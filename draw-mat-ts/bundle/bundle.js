/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__webpack_require__(/*! ./style.css */ \"./style.css\"); // Import stylesheets\r\nconst flo_mat_1 = __webpack_require__(/*! flo-mat */ \"./node_modules/flo-mat/node/index.js\");\r\nconst NS = 'http://www.w3.org/2000/svg'; // Svg namespace\r\n/**\r\n * Creates and returns an SVG DOM element.\r\n * @param id The dom id to assign to the SVG element, e.g. 1 -> 'svg-1'\r\n */\r\nfunction createSvg(id) {\r\n    let $e = document.createElementNS(NS, 'svg');\r\n    $e.setAttributeNS(null, 'id', 'svg' + id);\r\n    $e.setAttributeNS(null, 'style', 'width: 100%; display: inline-block');\r\n    $e.setAttributeNS(null, 'viewBox', '75 4 557 502');\r\n    return $e;\r\n}\r\n/**\r\n * Returns an SVG path string of a line.\r\n * @param ps The line endpoints.\r\n */\r\nfunction getLinePathStr(ps) {\r\n    let [[x0, y0], [x1, y1]] = ps;\r\n    return `M${x0} ${y0} L${x1} ${y1}`;\r\n}\r\n/**\r\n * Returns an SVG path string of a quadratic bezier curve.\r\n * @param ps The quadratic bezier control points.\r\n */\r\nfunction getQuadBezierPathStr(ps) {\r\n    let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    return `M${x0} ${y0} Q${x1} ${y1} ${x2} ${y2}`;\r\n}\r\n/**\r\n * Returns an SVG path string of a cubic bezier curve.\r\n * @param ps The cubic bezier control points.\r\n */\r\nfunction getCubicBezierPathStr(ps) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    return `M${x0} ${y0} C${x1} ${y1} ${x2} ${y2} ${x3} ${y3}`;\r\n}\r\n/**\r\n * Returns a function that draws an array of MAT curves on an SVG element.\r\n * @param mats An array of MATs to draw.\r\n * @param svg The SVG element on which to draw.\r\n * @param type The type of MAT to draw. This simply affects the class on the\r\n * path element.\r\n  */\r\nfunction drawMats(mats, svg, type) {\r\n    mats.forEach(f);\r\n    /**\r\n     * Draws a MAT curve on an SVG element.\r\n     */\r\n    function f(mat) {\r\n        let cpNode = mat.cpNode;\r\n        if (!cpNode) {\r\n            return;\r\n        }\r\n        let fs = [, , getLinePathStr, getQuadBezierPathStr, getCubicBezierPathStr];\r\n        flo_mat_1.traverseEdges(cpNode, function (cpNode) {\r\n            if (cpNode.isTerminating()) {\r\n                return;\r\n            }\r\n            let bezier = flo_mat_1.getCurveToNext(cpNode);\r\n            if (!bezier) {\r\n                return;\r\n            }\r\n            let $path = document.createElementNS(NS, 'path');\r\n            $path.setAttributeNS(null, \"d\", fs[bezier.length](bezier));\r\n            $path.setAttributeNS(null, \"class\", type);\r\n            svg.appendChild($path);\r\n        });\r\n    }\r\n}\r\n/**\r\n * The SVG path string representing our shape.\r\n */\r\nconst svgPathStr = `\r\n        M 144 251\r\n        C 145 169 110 82 227 59 \r\n        C 344 36 429 -46 505 96 \r\n        C 581 238 696 407 554 435 \r\n        C 412 463 191 532 197 442 \r\n        C 203 352 213 363 276 346 \r\n        C 339 329 563 318 437 242 \r\n        C 311 166 302 181 297 314 \r\n        C 292 447 160 585 151 419 \r\n        C 142 253 87.12 312.78 86 314 \r\n        C 87.16 312.74 142.8632 252.2348 144 251 \r\n        z\r\n`;\r\n/**\r\n * Adds a path to the given SVG element and give it a shape-path class.\r\n */\r\nfunction setSvgShapePath($svg, pathStr) {\r\n    let $path = document.createElementNS(NS, 'path'); // Create SVG path elem.\r\n    $path.setAttribute('class', 'shape-path');\r\n    $svg.appendChild($path); // Add the path element to the SVG.\r\n    document.body.appendChild($svg); // Add the SVG to the document body.\r\n    $path.setAttribute('d', svgPathStr);\r\n}\r\nfunction main() {\r\n    // Create and add and SVG element to our HTML page.\r\n    let $svg = createSvg(1); // Create SVG element.\r\n    setSvgShapePath($svg, svgPathStr);\r\n    // Get loops (representing the shape) from some SVG path.\r\n    let bezierLoops = flo_mat_1.getPathsFromStr(svgPathStr);\r\n    // We could also just give an array of linear, quadratic or cubic beziers as \r\n    // below (all lines in this case). Note that in the below case there is only\r\n    // one array of beziers (forming a single loop shape).\r\n    /*\r\n    bezierLoops = [\r\n        [\r\n            [[50.000, 95.000],[92.797, 63.905]],\r\n            [[92.797, 63.905],[76.450, 13.594]],\r\n            [[76.450, 13.594],[23.549, 13.594]],\r\n            [[23.549, 13.594],[7.202,  63.90]],\r\n            [[7.202,  63.900],[50.000, 95.000]]\r\n        ]\r\n    ];\r\n    */\r\n    // Get MATs from the loops.\r\n    let mats = flo_mat_1.findMats(bezierLoops, 3);\r\n    // Draw the MATs.\r\n    drawMats(mats, $svg, 'mat');\r\n    let sats = mats.map(mat => flo_mat_1.toScaleAxis(mat, 1.5));\r\n    // Get the SAT (at scale 1.5) of the MATs (of which there is only 1)\r\n    drawMats(sats, $svg, 'sat');\r\n}\r\nmain();\r\n\n\n//# sourceURL=webpack:///./index.ts?");

/***/ }),

/***/ "./node_modules/css-loader/index.js!./style.css":
/*!*********************************************!*\
  !*** ./node_modules/css-loader!./style.css ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ./node_modules/css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.i, \"\\r\\n.shape-path {\\r\\n    fill: lightgray;\\r\\n    stroke: darkgray;\\r\\n    stroke-width: 0.1%;\\r\\n}\\r\\n\\r\\n.mat {\\r\\n    fill: none;\\r\\n    stroke: deeppink;\\r\\n    stroke-width: 0.2%;\\r\\n}\\r\\n\\r\\n.sat {\\r\\n    fill: none;\\r\\n    stroke: blue;\\r\\n    stroke-width: 0.2%;\\r\\n}\", \"\"]);\n\n// exports\n\n\n//# sourceURL=webpack:///./style.css?./node_modules/css-loader");

/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n\n\n//# sourceURL=webpack:///./node_modules/css-loader/lib/css-base.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/are-beziers-in-same-k-family.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/are-beziers-in-same-k-family.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst evaluate_1 = __webpack_require__(/*! ./evaluate/evaluate */ \"./node_modules/flo-bezier3/node/evaluate/evaluate.js\");\r\nconst is_point_on_bezier_extension_1 = __webpack_require__(/*! ./is-point-on-bezier-extension */ \"./node_modules/flo-bezier3/node/is-point-on-bezier-extension.js\");\r\n/**\r\n * Returns true if two beziers are in the same K-family, i.e. when their infinte\r\n * extensions turn them into the same curve. This algorithm is robust if the\r\n * preconditions are met.\r\n *\r\n * It would not be hard to change the algorithm to relax\r\n * the preconditions to allow any two bezier curves with double-float coordinates\r\n * but this would slow it down since its run-time complexity is based on the\r\n * bit-length of the coordinates.\r\n *\r\n * Preconditions:\r\n * * Bezier control points must be grid-aligned\r\n * * The max bit-length of each bezier's control points PLUS 3 (due to power\r\n * basis conversion that can add 3 bits) PLUS 1 (due to testing of t values at\r\n * 1, 2, 4, 8, ...) must be < 53, therefore the max bitlength === 49.\r\n *\r\n * @param ps1 A bezier curve\r\n * @param ps2 Another bezier curve\r\n */\r\nfunction areBeziersInSameKFamily(ps1, ps2) {\r\n    // TODO - Use fast filters - this is very slow without filters, especially\r\n    // if the matrix used in isPointOnBezierExtension is ill-conditioned.\r\n    // Get ten points on the first bezier or its extension. Ten, since there is\r\n    // max 9 intersections between two cubic bezier curves; \r\n    // cubic x cubic -> 3 x 3 according to Bezout's Theorem. Also, make each\r\n    // parametric t-value an integer power of two to keep the bitlength a \r\n    // minimum (1 in this case). Don't use 1 either since it could be likely\r\n    // two beziers share an endpoint by design causing the algorithm to do an\r\n    // additional check and run slower.\r\n    let evaluate_ = evaluate_1.evaluate(ps1);\r\n    let ps = [0.03125, 0.0625, 0.125, 0.25, 0.5, 2, 4, 8, 16, 32].map(evaluate_);\r\n    //let isSamkeKFamily = ps.every(p => isPointOnBezierExtension(ps2, p));\r\n    for (let p of ps) {\r\n        if (!is_point_on_bezier_extension_1.isPointOnBezierExtension(ps2, p)) {\r\n            return false;\r\n        }\r\n    }\r\n    //console.log('isSamkeKFamily', ps1, ps2);\r\n    return true;\r\n}\r\nexports.areBeziersInSameKFamily = areBeziersInSameKFamily;\r\n//# sourceMappingURL=are-beziers-in-same-k-family.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/are-beziers-in-same-k-family.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/bezier3-intersection-sylvester/bezier3-intersection-sylvester_.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/bezier3-intersection-sylvester/bezier3-intersection-sylvester_.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst get_x_1 = __webpack_require__(/*! ../get-x */ \"./node_modules/flo-bezier3/node/get-x.js\");\r\nconst get_y_1 = __webpack_require__(/*! ../get-y */ \"./node_modules/flo-bezier3/node/get-y.js\");\r\nlet DELTA = 10 - 6;\r\n/**\r\n * TODO - unfinished\r\n * Returns the intersection points between two cubic beziers. This function is\r\n * not numerically stable. Use for experimentation and comparison only. The\r\n * algorithm may be enhanced to use exact arithmetic in degenerate cases.\r\n * T-value pairs at intersection of the first and second beziers respectively.\r\n * @param ps1 - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @param ps2 - Another cubic bezier\r\n * See http://mat.polsl.pl/sjpam/zeszyty/z6/Silesian_J_Pure_Appl_Math_v6_i1_str_155-176.pdf\r\n */\r\nfunction bezier3IntersectionSylvester(ps1, ps2) {\r\n    let [x1, y1] = ps1[0];\r\n    let [x2, y2] = ps2[0];\r\n    // Rotate by θ so that Δx ≡ d_0x - c_0x === 0 (as suggested by the paper)\r\n    let rotatedPs1;\r\n    let rotatedPs2;\r\n    if (Math.abs(x1 - x2) > 1e-12) {\r\n        let tanθ = (x1 - x2) / (y1 - y2);\r\n        let tanθ2 = tanθ * tanθ;\r\n        let sinθ = (tanθ2) / (1 + tanθ2); // Trig. identity\r\n        let cosθ = sinθ / tanθ;\r\n        let rotatedPs1_ = flo_vector2d_1.rotatePs(sinθ, cosθ, ps1);\r\n        let rotatedPs2_ = flo_vector2d_1.rotatePs(sinθ, cosθ, ps2);\r\n        rotatedPs1 = rotatedPs1_;\r\n        rotatedPs2 = rotatedPs2_;\r\n    }\r\n    else {\r\n        rotatedPs1 = ps1;\r\n        rotatedPs2 = ps2;\r\n    }\r\n    // Cache\r\n    let [c_3x, c_2x, c_1x, c_0x] = get_x_1.getX(rotatedPs1);\r\n    let [c_3y, c_2y, c_1y, c_0y] = get_y_1.getY(rotatedPs1);\r\n    let [d_3x, d_2x, d_1x, d_0x] = get_x_1.getX(rotatedPs2);\r\n    let [d_3y, d_2y, d_1y, d_0y] = get_y_1.getY(rotatedPs2);\r\n    let [a, b, c, d, e, f] = [d_3x, c_3x, d_2x, c_2x, d_1x, c_1x];\r\n    //let Δx = d_0x - c_0x; // === 0 after rotation\r\n    let [m, n, p, q, r, s] = [d_3y, c_3y, d_2y, c_2y, d_1y, c_1y];\r\n    let Δy = d_0y - c_0y;\r\n    let a2 = a * a;\r\n    let b2 = b * b;\r\n    let c2 = c * c;\r\n    let d2 = d * d;\r\n    let e2 = e * e;\r\n    let f2 = f * f;\r\n    let m2 = m * m;\r\n    let n2 = n * n;\r\n    let p2 = p * p;\r\n    let q2 = q * q;\r\n    let r2 = r * r;\r\n    let s2 = s * s;\r\n    let Δy2 = Δy * Δy;\r\n    let a3 = a2 * a;\r\n    let b3 = b2 * b;\r\n    let c3 = c2 * c;\r\n    let d3 = d2 * d;\r\n    let e3 = e2 * e;\r\n    let f3 = f2 * f;\r\n    let Δy3 = Δy2 * Δy;\r\n    let dΔy = d * Δy;\r\n    let dΔy2 = d * Δy2;\r\n    let bdΔy = b * dΔy;\r\n    let bdΔy2 = b * dΔy2;\r\n    let cΔy = c * Δy;\r\n    let cΔy2 = c * Δy2;\r\n    let bΔy = b * Δy;\r\n    let bΔy2 = b * Δy2;\r\n    let bΔy3 = b * Δy3;\r\n    let k9 = -b2 * Δy * f * s2 + bdΔy * f * q * s + 2 * bΔy * f2 * n * s - d2 * Δy * f * n * s -\r\n        b2 * dΔy2 * s - bΔy * f2 * q2 + dΔy * f2 * n * q - 2 * b2 * Δy2 * f * q +\r\n        d2 * bΔy2 * q - Δy * f3 * n2 + 3 * bdΔy2 * f * n - d3 * Δy2 * n - b3 * Δy3;\r\n    let k8 = b2 * Δy * e * s2 + 2 * b2 * Δy * f * r * s - bdΔy * e * q * s - 4 * bΔy * e * f * n * s +\r\n        d2 * Δy * e * n * s - bdΔy * f * q * r - 2 * bΔy * f2 * n * r + d2 * Δy * f * n * r +\r\n        b2 * dΔy2 * r + 2 * bΔy * e * f * q2 - 2 * dΔy * e * f * n * q + 2 * b2 * Δy2 * e * q +\r\n        3 * Δy * e * f2 * n2 - 3 * bdΔy2 * e * n;\r\n    let k7 = -2 * b2 * Δy * e * r * s - b * cΔy * f * q * s - bdΔy * f * p * s + 2 * c * dΔy * f * n * s +\r\n        2 * bΔy * e2 * n * s + b2 * cΔy2 * s - b2 * Δy * f * r2 + bdΔy * e * q * r +\r\n        4 * bΔy * e * f * n * r - d2 * Δy * e * n * r - bΔy * e2 * q2 + 2 * bΔy * f2 * p * q -\r\n        cΔy * f2 * n * q + dΔy * e2 * n * q - 2 * b * c * dΔy2 * q - dΔy * f2 * n * p +\r\n        2 * b2 * Δy2 * f * p - b * d2 * Δy2 * p - 3 * Δy * e2 * f * n2 - 3 * b * cΔy2 * f * n +\r\n        3 * c * d2 * Δy2 * n;\r\n    let k6 = 2 * a * bΔy * f * s2 - a * dΔy * f * q * s + b * cΔy * e * q * s + bdΔy * e * p * s -\r\n        2 * a * Δy * f2 * n * s - 2 * c * dΔy * e * n * s - 2 * bΔy * f2 * m * s + d2 * Δy * f * m * s +\r\n        2 * a * bdΔy2 * s + b2 * Δy * e * r2 + b * cΔy * f * q * r + bdΔy * f * p * r -\r\n        2 * c * dΔy * f * n * r - 2 * bΔy * e2 * n * r - b2 * cΔy2 * r + a * Δy * f2 * q2 -\r\n        4 * bΔy * e * f * p * q + 2 * cΔy * e * f * n * q - dΔy * f2 * m * q + 4 * a * bΔy2 * f * q -\r\n        a * d2 * Δy2 * q + 2 * dΔy * e * f * n * p - 2 * b2 * Δy2 * e * p + Δy * e3 * n2 +\r\n        2 * Δy * f3 * m * n - 3 * a * dΔy2 * f * n + 3 * b * cΔy2 * e * n - 3 * bdΔy2 * f * m +\r\n        d3 * Δy2 * m + 3 * a * b2 * Δy3;\r\n    let k5 = -2 * a * bΔy * e * s2 - 4 * a * bΔy * f * r * s + a * dΔy * e * q * s + b * cΔy * f * p * s +\r\n        4 * a * Δy * e * f * n * s - c2 * Δy * f * n * s + 4 * bΔy * e * f * m * s - d2 * Δy * e * m * s +\r\n        a * dΔy * f * q * r - b * cΔy * e * q * r - bdΔy * e * p * r + 2 * a * Δy * f2 * n * r +\r\n        2 * c * dΔy * e * n * r + 2 * bΔy * f2 * m * r - d2 * Δy * f * m * r - 2 * a * bdΔy2 * r -\r\n        2 * a * Δy * e * f * q2 + 2 * bΔy * e2 * p * q - cΔy * e2 * n * q + 2 * dΔy * e * f * m * q -\r\n        4 * a * bΔy2 * e * q + b * c2 * Δy2 * q - bΔy * f2 * p2 + cΔy * f2 * n * p -\r\n        dΔy * e2 * n * p + 2 * b * c * dΔy2 * p - 6 * Δy * e * f2 * m * n + 3 * a * dΔy2 * e * n -\r\n        3 * c2 * dΔy2 * n + 3 * bdΔy2 * e * m;\r\n    let k4 = 4 * a * bΔy * e * r * s + a * cΔy * f * q * s + a * dΔy * f * p * s - b * cΔy * e * p * s -\r\n        2 * a * Δy * e2 * n * s + c2 * Δy * e * n * s - 2 * c * dΔy * f * m * s - 2 * bΔy * e2 * m * s -\r\n        2 * a * b * cΔy2 * s + 2 * a * bΔy * f * r2 - a * dΔy * e * q * r - b * cΔy * f * p * r -\r\n        4 * a * Δy * e * f * n * r + c2 * Δy * f * n * r - 4 * bΔy * e * f * m * r + d2 * Δy * e * m * r +\r\n        a * Δy * e2 * q2 - 2 * a * Δy * f2 * p * q + cΔy * f2 * m * q - dΔy * e2 * m * q +\r\n        2 * a * c * dΔy2 * q + 2 * bΔy * e * f * p2 - 2 * cΔy * e * f * n * p + dΔy * f2 * m * p -\r\n        4 * a * bΔy2 * f * p + a * d2 * Δy2 * p + 6 * Δy * e2 * f * m * n + 3 * a * cΔy2 * f * n +\r\n        3 * b * cΔy2 * f * m - 3 * c * d2 * Δy2 * m;\r\n    let k3 = -a2 * Δy * f * s2 - a * cΔy * e * q * s - a * dΔy * e * p * s + 2 * a * Δy * f2 * m * s +\r\n        2 * c * dΔy * e * m * s - a2 * dΔy2 * s - 2 * a * bΔy * e * r2 - a * cΔy * f * q * r -\r\n        a * dΔy * f * p * r + b * cΔy * e * p * r + 2 * a * Δy * e2 * n * r - c2 * Δy * e * n * r +\r\n        2 * c * dΔy * f * m * r + 2 * bΔy * e2 * m * r + 2 * a * b * cΔy2 * r +\r\n        4 * a * Δy * e * f * p * q - 2 * cΔy * e * f * m * q - 2 * a2 * Δy2 * f * q - bΔy * e2 * p2 +\r\n        cΔy * e2 * n * p - 2 * dΔy * e * f * m * p + 4 * a * bΔy2 * e * p - b * c2 * Δy2 * p -\r\n        2 * Δy * e3 * m * n - 3 * a * cΔy2 * e * n + c3 * Δy2 * n - Δy * f3 * m2 +\r\n        3 * a * dΔy2 * f * m - 3 * b * cΔy2 * e * m - 3 * a2 * bΔy3;\r\n    let k2 = a2 * Δy * e * s2 + 2 * a2 * Δy * f * r * s - a * cΔy * f * p * s - 4 * a * Δy * e * f * m * s +\r\n        c2 * Δy * f * m * s + a * cΔy * e * q * r + a * dΔy * e * p * r - 2 * a * Δy * f2 * m * r -\r\n        2 * c * dΔy * e * m * r + a2 * dΔy2 * r - 2 * a * Δy * e2 * p * q + cΔy * e2 * m * q +\r\n        2 * a2 * Δy2 * e * q - a * c2 * Δy2 * q + a * Δy * f2 * p2 - cΔy * f2 * m * p +\r\n        dΔy * e2 * m * p - 2 * a * c * dΔy2 * p + 3 * Δy * e * f2 * m2 - 3 * a * dΔy2 * e * m +\r\n        3 * c2 * dΔy2 * m;\r\n    let k1 = -2 * a2 * Δy * e * r * s + a * cΔy * e * p * s + 2 * a * Δy * e2 * m * s - c2 * Δy * e * m * s +\r\n        a2 * cΔy2 * s - a2 * Δy * f * r2 + a * cΔy * f * p * r + 4 * a * Δy * e * f * m * r -\r\n        c2 * Δy * f * m * r - 2 * a * Δy * e * f * p2 + 2 * cΔy * e * f * m * p + 2 * a2 * Δy2 * f * p -\r\n        3 * Δy * e2 * f * m2 - 3 * a * cΔy2 * f * m;\r\n    let k0 = a2 * Δy * e * r2 - a * cΔy * e * p * r - 2 * a * Δy * e2 * m * r + c2 * Δy * e * m * r -\r\n        a2 * cΔy2 * r + a * Δy * e2 * p2 - cΔy * e2 * m * p - 2 * a2 * Δy2 * e * p +\r\n        a * c2 * Δy2 * p + Δy * e3 * m2 + 3 * a * cΔy2 * e * m - c3 * Δy2 * m + a3 * Δy3;\r\n    let poly = [k9, k8, k7, k6, k5, k4, k3, k2, k1, k0];\r\n    let roots = flo_poly_1.allRoots(poly, 0);\r\n    let tPairs = [];\r\n    for (let i = 0; i < roots.length; i++) {\r\n        let k = roots[i];\r\n        let k2 = k * k;\r\n        let k3 = k2 * k;\r\n        let ps1k = {\r\n            x: [c_3x * k3, c_2x * k2, c_1x * k, c_0x],\r\n            y: [c_3y * k3, c_2y * k2, c_1y * k, c_0y]\r\n        };\r\n        let ps2k = {\r\n            x: [d_3x * k3, d_2x * k2, d_1x * k, d_0x],\r\n            y: [d_3y * k3, d_2y * k2, d_1y * k, d_0y]\r\n        };\r\n        let xx = flo_poly_1.subtract(get_x_1.getX(rotatedPs2), ps1k.x);\r\n        let yy = flo_poly_1.subtract(get_y_1.getY(rotatedPs2), ps1k.y);\r\n        let rootsx = flo_poly_1.allRoots(xx, 0, 1);\r\n        let rootsy = flo_poly_1.allRoots(yy, 0, 1);\r\n        for (let j = 0; j < rootsx.length; j++) {\r\n            let rootx = rootsx[j];\r\n            for (let l = 0; l < rootsy.length; l++) {\r\n                let rooty = rootsy[l];\r\n                if (Math.abs(rootx - rooty) < DELTA) {\r\n                    let t = (rootx + rooty) / 2;\r\n                    let tk = t * k;\r\n                    if (t >= 0 && t <= 1 && tk >= 0 && tk <= 1) {\r\n                        tPairs.push([tk, t]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return tPairs;\r\n}\r\nexports.bezier3IntersectionSylvester = bezier3IntersectionSylvester;\r\n//# sourceMappingURL=bezier3-intersection-sylvester_.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/bezier3-intersection-sylvester/bezier3-intersection-sylvester_.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/bezier3-intersection/bezier3-intersection.js":
/*!************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/bezier3-intersection/bezier3-intersection.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst evaluate_1 = __webpack_require__(/*! ../evaluate/evaluate */ \"./node_modules/flo-bezier3/node/evaluate/evaluate.js\");\r\nconst check_intersection_in_ranges_1 = __webpack_require__(/*! ./check-intersection-in-ranges */ \"./node_modules/flo-bezier3/node/bezier3-intersection/check-intersection-in-ranges.js\");\r\nconst calc_other_t_1 = __webpack_require__(/*! ./calc-other-t */ \"./node_modules/flo-bezier3/node/bezier3-intersection/calc-other-t.js\");\r\n/**\r\n * Aaccurate, fast (cubically convergent) algorithm that returns the\r\n * intersections between two cubic beziers.\r\n *\r\n * At stretches where the two curves run extremely close to (or on top of) each\r\n * other and curve the same direction an interval is returned instead of a\r\n * point. This tolerance can be set by the Δ parameter.\r\n *\r\n * The algorithm is based on a paper at http://scholarsarchive.byu.edu/cgi/viewcontent.cgi?article=2206&context=etd\r\n * that finds the intersection of a fat line and a so-called geometric interval\r\n * making it faster than the standard fat-line intersection algorithm. The\r\n * algorithm has been modified to prevent run-away recursion by checking for\r\n * coincident pieces at subdivision steps.\r\n *\r\n * @param ps1 - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @param ps2 - Another cubic bezier\r\n * @param δ - An optional tolerance to within which the t parameter\r\n * should be calculated - defaults to the minimum value of 24*Number.EPSILON or\r\n * approximately 5e-15. Note that it might not make sense to set this to as\r\n * large as say 1e-5 since only a single iteration later the maximum accuracy\r\n * will be attained and not much speed will be gained anyway. Similarly if δ is\r\n * set to 1e-2 only two iterations will be saved. This is due to the algorithm\r\n * being cubically convergent (usually converging in about 4 to 8 iterations for\r\n * typical intersections).\r\n * @param Δ - A tolerance that indicates how closely a stretch of the\r\n * beziers can run together before being considered coincident. Defaults to the\r\n * minimum possible value of 1e-6 if not specified.\r\n * @returns An array that contains the t-value pairs at intersection\r\n * of the first and second beziers respectively. The array can also contain t\r\n * range pairs for coincident pieces that can be either used or ignored\r\n * depending on the application, e.g. the return value might be [[0.1,0.2],\r\n * [0.3,0.5],[[0.4,0.5],[0.6,0.7]]] that indicates intersection points at t\r\n * values of t1=0.1 and t2=0.2 for the first and second bezier respectively as\r\n * well as at t1=0.3 and t2=0.5 and finally indicates the curves to be nearly\r\n * coincident from t1=0.4 to t1=0.5 for the first bezier and t2=0.6 to t=0.7 for\r\n * the second bezier.\r\n */\r\nfunction bezier3Intersection(ps1, ps2, δ, Δ) {\r\n    // The minimum value Δ can be. If it is too small the algorithm may take too\r\n    // long in cases where the two curves run extremely close to each other for\r\n    // their entire length and curve the same direction.\r\n    const ΔMin = 1e-6;\r\n    // This is an estimate of the relative floating point error during clipping.\r\n    // A bound is given by |δP| = 2n*max_k(|b_k|)η, where n = 3 (cubic), b_k\r\n    // are the control points indexed by k=0,1,2,3 and η is machine epsilon, \r\n    // i.e. Number.EPSILON. We quadruple the bound to be sure.\r\n    const δMin = 6 * 4 * 8 * Number.EPSILON;\r\n    // Maximum error - limited to take rounding error into account.\r\n    if (δ === undefined) {\r\n        δ = 0;\r\n    }\r\n    δ = Math.max(δ, δMin);\r\n    if (Δ === undefined) {\r\n        Δ = ΔMin;\r\n    }\r\n    Δ = Math.max(Δ, ΔMin);\r\n    if (typeof _bez_debug_ !== 'undefined') {\r\n        _bez_debug_.generated.elems.beziers.push([ps1, ps2]);\r\n        _bez_debug_.generated.elems.fatLine.push({ l: [[0, 0], [1e-10, 1e-10]], minD: 0, maxD: 0 });\r\n    }\r\n    // Intersection t values for both beziers\r\n    let tss = [];\r\n    let iteration = {\r\n        ps1,\r\n        ps2,\r\n        tRange1: [0, 1],\r\n        tRange2: [0, 1],\r\n        idx: 1\r\n    };\r\n    let stack = [];\r\n    stack.push(iteration);\r\n    while (stack.length !== 0) {\r\n        let { ps1: ps1_, ps2: ps2_, tRange1, tRange2, idx } = stack.pop();\r\n        let { newIterations, t1 } = check_intersection_in_ranges_1.checkIntersectionInRanges(ps1_, ps2_, tRange1, tRange2, idx, δ);\r\n        stack.push(...newIterations);\r\n        if (t1) {\r\n            let pq = idx === 0 ? [ps1, ps2] : [ps2, ps1];\r\n            let t2 = calc_other_t_1.calcOtherT(t1, pq[0], pq[1]);\r\n            if (t2 === undefined) {\r\n                continue;\r\n            }\r\n            let ts = idx === 0 ? [t1, t2] : [t2, t1];\r\n            tss.push(ts);\r\n        }\r\n    }\r\n    if (typeof _bez_debug_ !== 'undefined') {\r\n        for (let ts of tss) {\r\n            _bez_debug_.generated.elems.intersection.push(evaluate_1.evaluate(ps1, ts[0]));\r\n        }\r\n    }\r\n    return tss;\r\n}\r\nexports.bezier3Intersection = bezier3Intersection;\r\n//# sourceMappingURL=bezier3-intersection.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/bezier3-intersection/bezier3-intersection.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/bezier3-intersection/calc-other-t.js":
/*!****************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/bezier3-intersection/calc-other-t.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst evaluate_1 = __webpack_require__(/*! ../evaluate/evaluate */ \"./node_modules/flo-bezier3/node/evaluate/evaluate.js\");\r\nconst closest_point_on_bezier_1 = __webpack_require__(/*! ../closest-point-on-bezier */ \"./node_modules/flo-bezier3/node/closest-point-on-bezier.js\");\r\n/**\r\n * Calculates the t-value of the closest point on Q to P(t).\r\n * @param δ\r\n * @param t\r\n * @param P\r\n * @param Q\r\n */ /*\r\nfunction calcOtherT(t: number, P: number[][], Q: number[][]) {\r\n\r\n   // Get some length measure on P and Q\r\n   // Get some length measure on P and Q\r\n   let max = Math.max(\r\n       Math.abs(P[0][0]),\r\n       Math.abs(P[0][1]),\r\n       Math.abs(P[1][0]),\r\n       Math.abs(P[1][1]),\r\n       Math.abs(P[2][0]),\r\n       Math.abs(P[2][1]),\r\n       Math.abs(P[3][0]),\r\n       Math.abs(P[3][1]),\r\n       Math.abs(Q[0][0]),\r\n       Math.abs(Q[0][1]),\r\n       Math.abs(Q[1][0]),\r\n       Math.abs(Q[1][1]),\r\n       Math.abs(Q[2][0]),\r\n       Math.abs(Q[2][1]),\r\n       Math.abs(Q[3][0]),\r\n       Math.abs(Q[3][1])\r\n   );\r\n\r\n   let pp = evaluate(P)(t);\r\n   let [x,y] = pp;\r\n\r\n   let tqsh = tsAtY(Q,y);\r\n   let tqsv = tsAtX(Q,x);\r\n   if (!tqsh.length && !tqsv.length) { return undefined; }\r\n\r\n   let tqs = [...tqsh, ...tqsv];\r\n\r\n   let bestT: number = undefined;\r\n   let bestD = Number.POSITIVE_INFINITY;\r\n   for (let tq of tqs) {\r\n       let pq = evaluate(Q)(tq);\r\n       let d = squaredDistanceBetween(pp,pq);\r\n       if (d < bestD) {\r\n           bestD = d;\r\n           bestT = tq;\r\n       }\r\n   }\r\n\r\n   // If the best distance > the max allowed tolerance then no intersection\r\n   // occured - this happens only in special cases where clipping occured at\r\n   // the endpoint of a curve.\r\n   let maxTolerance = 256 * 24*Number.EPSILON * max;\r\n   if (bestD > maxTolerance*maxTolerance) {\r\n       return undefined;\r\n   }\r\n\r\n   return bestT;\r\n}*/\r\nfunction calcOtherT(t, P, Q) {\r\n    // Get some length measure on P and Q\r\n    let max = 0;\r\n    for (let p of P) {\r\n        if (max < Math.abs(p[0])) {\r\n            max = Math.abs(p[0]);\r\n        }\r\n        if (max < Math.abs(p[1])) {\r\n            max = Math.abs(p[1]);\r\n        }\r\n    }\r\n    for (let p of Q) {\r\n        if (max < Math.abs(p[0])) {\r\n            max = Math.abs(p[0]);\r\n        }\r\n        if (max < Math.abs(p[1])) {\r\n            max = Math.abs(p[1]);\r\n        }\r\n    }\r\n    let p = evaluate_1.evaluate(P)(t);\r\n    let p_ = closest_point_on_bezier_1.closestPointOnBezier(Q, p);\r\n    let d = flo_vector2d_1.squaredDistanceBetween(p, p_.p);\r\n    let maxTolerance = 4 * 16 * 24 * Number.EPSILON * max;\r\n    //console.log(Math.sqrt(d), maxTolerance);\r\n    if (d > maxTolerance * maxTolerance) {\r\n        return undefined;\r\n    }\r\n    return p_.t;\r\n}\r\nexports.calcOtherT = calcOtherT;\r\n//# sourceMappingURL=calc-other-t.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/bezier3-intersection/calc-other-t.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/bezier3-intersection/center.js":
/*!**********************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/bezier3-intersection/center.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\n/**\r\n * Return the given two beziers but translated such that the shorter (by\r\n * some length measure) is closer to the origin.\r\n * @private\r\n * @param P\r\n * @param Q\r\n */\r\n/*\r\nfunction center(P: number[][], Q: number[][]) {\r\n    let lengthP = 0;\r\n    for (let i=1; i<P.length; i++) {\r\n        lengthP += sdst(P[i-1], P[i]);\r\n    }\r\n\r\n    let lengthQ = 0;\r\n    for (let i=1; i<Q.length; i++) {\r\n        lengthQ += sdst(Q[i-1], Q[i]);\r\n    }\r\n\r\n    let moveX: number;\r\n    let moveY: number;\r\n    if (lengthQ < lengthP) {\r\n        moveX = Q.reduce((prev, p) => prev + p[0], 0) / 4;\r\n        moveY = Q.reduce((prev, p) => prev + p[1], 0) / 4;\r\n    } else {\r\n        moveX = P.reduce((prev, p) => prev + p[0], 0) / 4;\r\n        moveY = P.reduce((prev, p) => prev + p[1], 0) / 4;\r\n    }\r\n    P = P.map(x => [x[0]-moveX, x[1]-moveY]);\r\n    Q = Q.map(x => [x[0]-moveX, x[1]-moveY]);\r\n\r\n    return [P, Q];\r\n}\r\n*/\r\nfunction center(P, Q) {\r\n    // TODO - improve - we shouldn't center, we should remove high order bits -\r\n    // almost the same thing\r\n    let lengthP = 0;\r\n    for (let i = 1; i < P.length; i++) {\r\n        lengthP += flo_vector2d_1.squaredDistanceBetween(P[i - 1], P[i]);\r\n    }\r\n    let lengthQ = 0;\r\n    for (let i = 1; i < Q.length; i++) {\r\n        lengthQ += flo_vector2d_1.squaredDistanceBetween(Q[i - 1], Q[i]);\r\n    }\r\n    let moveX;\r\n    let moveY;\r\n    if (lengthQ < lengthP) {\r\n        moveX = Q.reduce((prev, p) => prev + p[0], 0) / Q.length;\r\n        moveY = Q.reduce((prev, p) => prev + p[1], 0) / Q.length;\r\n    }\r\n    else {\r\n        moveX = P.reduce((prev, p) => prev + p[0], 0) / P.length;\r\n        moveY = P.reduce((prev, p) => prev + p[1], 0) / P.length;\r\n    }\r\n    P = P.map(x => [x[0] - moveX, x[1] - moveY]);\r\n    Q = Q.map(x => [x[0] - moveX, x[1] - moveY]);\r\n    return [P, Q];\r\n}\r\nexports.center = center;\r\n//# sourceMappingURL=center.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/bezier3-intersection/center.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/bezier3-intersection/check-intersection-in-ranges.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/bezier3-intersection/check-intersection-in-ranges.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst center_1 = __webpack_require__(/*! ./center */ \"./node_modules/flo-bezier3/node/bezier3-intersection/center.js\");\r\nconst get_distance_to_line_function_1 = __webpack_require__(/*! ./get-distance-to-line-function */ \"./node_modules/flo-bezier3/node/bezier3-intersection/get-distance-to-line-function.js\");\r\nconst geo_clip_1 = __webpack_require__(/*! ./clip/geo-clip */ \"./node_modules/flo-bezier3/node/bezier3-intersection/clip/geo-clip.js\");\r\nconst coincident_1 = __webpack_require__(/*! ../coincident */ \"./node_modules/flo-bezier3/node/coincident.js\");\r\nconst from_to_1 = __webpack_require__(/*! ../from-to */ \"./node_modules/flo-bezier3/node/from-to.js\");\r\nconst vector2d = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst split_at_1 = __webpack_require__(/*! ../split-at */ \"./node_modules/flo-bezier3/node/split-at.js\");\r\n// Helper function\r\nfunction checkIntersectionInRanges(Q_, P_, qRange, pRange, idx, δ) {\r\n    let cidx = idx === 0 ? 1 : 0; // Counter flip-flop index\r\n    // Move intersection toward the origin to prevent floating point issues\r\n    // that are introduced specifically by the getLineEquation function. \r\n    // This allows us to get a relative error in the final result usually in \r\n    // the 10 ULPS or less range.\r\n    [P_, Q_] = center_1.center(P_, Q_);\r\n    //console.log(P_.toString());\r\n    //console.log(Q_.toString());\r\n    let Q0 = Q_[0];\r\n    let QE = Q_[Q_.length - 1];\r\n    // Get the implict line equation for the line defined by the first and \r\n    // last control point of Q. This equation gives the distance between any \r\n    // point and the line.\r\n    let dQ = get_distance_to_line_function_1.getDistanceToLineFunction([Q0, QE]);\r\n    // Calculate the distance from the control points of Q to the line \r\n    let dMin = 0;\r\n    let dMax = 0;\r\n    if (Q_.length === 4) {\r\n        // Cubic\r\n        let dQ1 = dQ(Q_[1]);\r\n        let dQ2 = dQ(Q_[2]);\r\n        // Calculate the fat line of Q.\r\n        let C = (dQ1 * dQ2 > 0) ? 3 / 4 : 4 / 9;\r\n        dMin = C * Math.min(0, dQ1, dQ2);\r\n        dMax = C * Math.max(0, dQ1, dQ2);\r\n    }\r\n    else if (Q_.length === 3) {\r\n        // Quadratic\r\n        let dQ1 = dQ(Q_[1]);\r\n        dMin = 0.5 * Math.min(0, dQ1);\r\n        dMax = 0.5 * Math.max(0, dQ1);\r\n    }\r\n    else if (Q_.length === 2) {\r\n        // Line\r\n        dMin = dMax = 0;\r\n    }\r\n    if (typeof _bez_debug_ !== 'undefined') {\r\n        _bez_debug_.generated.elems.beziers.push([P_, Q_]);\r\n        _bez_debug_.generated.elems.fatLine.push({ l: [Q_[0], Q_[Q_.length - 1]], minD: dMin, maxD: dMax });\r\n    }\r\n    let { tMin, tMax } = geo_clip_1.geoClip(P_, dQ, dMin, dMax);\r\n    if (tMin === Number.POSITIVE_INFINITY) {\r\n        // No intersection\r\n        return { newIterations: [], t1: undefined };\r\n    }\r\n    if (tMax - tMin > 0.7) {\r\n        // First try a fatline perpendicular to the line Q0 - Q3\r\n        // Move [Q0, Q3] to the origin\r\n        let vQ = vector2d.fromTo(Q0, QE);\r\n        // Rotate vector by -90 degrees\r\n        let vQr = [-vQ[1], vQ[0]];\r\n        let l = (vector2d.len(vQ) / 2) * 2;\r\n        // Move back to middle of Q0 and Q3\r\n        let vQrm0 = [(Q0[0] + QE[0]) / 2, (Q0[1] + QE[1]) / 2];\r\n        let vQrm3 = vector2d.translate(vQr, vQrm0);\r\n        let dQ_ = get_distance_to_line_function_1.getDistanceToLineFunction([vQrm0, vQrm3]);\r\n        if (typeof _bez_debug_ !== 'undefined') {\r\n            _bez_debug_.generated.elems.beziers.push([P_, Q_]);\r\n            _bez_debug_.generated.elems.fatLine.push({ l: [vQrm0, vQrm3], minD: -l, maxD: +l });\r\n        }\r\n        let { tMin: tMin_, tMax: tMax_ } = geo_clip_1.geoClip(P_, dQ_, -l, +l);\r\n        if (tMin === Number.POSITIVE_INFINITY) {\r\n            // No intersection\r\n            return { newIterations: [], t1: undefined };\r\n        }\r\n        tMax = Math.min(tMax, tMax_);\r\n        tMin = Math.max(tMin, tMin_);\r\n    }\r\n    // The paper calls for a heuristic that if less than 30% will be\r\n    // clipped, rather split the longest curve and find intersections in the\r\n    // two halfs seperately.\r\n    if (tMax - tMin > 0.7) {\r\n        // Some length measure\r\n        let pSpan = pRange[1] - pRange[0];\r\n        let qSpan = qRange[1] - qRange[0];\r\n        let pq = coincident_1.coincident(P_, Q_);\r\n        if (pq !== undefined) {\r\n            return { newIterations: [], t1: undefined };\r\n        }\r\n        // Split the curve in half\r\n        if (pSpan <= qSpan) {\r\n            cidx = idx;\r\n            [P_, Q_] = [Q_, P_];\r\n            [pRange, qRange] = [qRange, pRange];\r\n        }\r\n        // Update t range.\r\n        let span = pRange[1] - pRange[0];\r\n        // 1st half\r\n        let tMinA = pRange[0];\r\n        let tMaxA = tMinA + span / 2;\r\n        // 2nd half\r\n        let tMinB = tMaxA;\r\n        let tMaxB = pRange[1];\r\n        let [A, B] = split_at_1.splitAtPrecise(P_, 0.5);\r\n        return {\r\n            newIterations: [{\r\n                    ps1: A,\r\n                    ps2: Q_,\r\n                    tRange1: [tMinA, tMaxA],\r\n                    tRange2: qRange,\r\n                    idx: cidx\r\n                }, {\r\n                    ps1: B,\r\n                    ps2: Q_,\r\n                    tRange1: [tMinB, tMaxB],\r\n                    tRange2: qRange,\r\n                    idx: cidx\r\n                }],\r\n            t1: undefined\r\n        };\r\n    }\r\n    // Update t range.\r\n    let span = pRange[1] - pRange[0];\r\n    let tMin_ = (tMin * span + pRange[0]);\r\n    let tMax_ = (tMax * span + pRange[0]);\r\n    if (Math.abs((tMax - tMin) * span) < δ) {\r\n        // Accurate enough solution found\r\n        let t1 = (((tMax + tMin) * span) / 2) + pRange[0];\r\n        return { newIterations: [], t1 };\r\n    }\r\n    // Clip\r\n    P_ = from_to_1.fromToPrecise(P_)(tMin, tMax);\r\n    // Swap Q and P and iterate.\r\n    return {\r\n        newIterations: [{\r\n                ps1: P_,\r\n                ps2: Q_,\r\n                tRange1: [tMin_, tMax_],\r\n                tRange2: qRange,\r\n                idx: cidx\r\n            }],\r\n        t1: undefined\r\n    };\r\n}\r\nexports.checkIntersectionInRanges = checkIntersectionInRanges;\r\n//# sourceMappingURL=check-intersection-in-ranges.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/bezier3-intersection/check-intersection-in-ranges.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/bezier3-intersection/clip/geo-clip.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/bezier3-intersection/clip/geo-clip.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst to_hybrid_quadratic_1 = __webpack_require__(/*! ./to-hybrid-quadratic */ \"./node_modules/flo-bezier3/node/bezier3-intersection/clip/to-hybrid-quadratic.js\");\r\n/**\r\n * @param P\r\n * @param dQ Distance to fat line's zero line\r\n * @param dMin\r\n * @param dMax\r\n */\r\nfunction geoClip(P, dQ, dMin, dMax) {\r\n    let hq = to_hybrid_quadratic_1.toHybridQuadratic(P);\r\n    let dH0 = dQ(hq[0]);\r\n    let dH2 = dQ(hq[2]);\r\n    let dH10 = dQ(hq[1][0]);\r\n    let dH11 = dQ(hq[1][1]);\r\n    let dHmin = Math.min(dH10, dH11);\r\n    let dHmax = Math.max(dH10, dH11);\r\n    let DyMin = [\r\n        dH0 - 2 * dHmin + dH2,\r\n        -2 * dH0 + 2 * dHmin,\r\n        dH0\r\n    ];\r\n    let DyMax = [\r\n        dH0 - 2 * dHmax + dH2,\r\n        -2 * dH0 + 2 * dHmax,\r\n        dH0\r\n    ];\r\n    let errorBound = 2 * Math.max(flo_poly_1.hornerErrorBound(DyMin, 1), flo_poly_1.hornerErrorBound(DyMax, 1));\r\n    dMin = dMin - errorBound;\r\n    dMax = dMax + errorBound;\r\n    let DyMinMin = DyMin.slice();\r\n    DyMinMin[2] = DyMinMin[2] - dMin;\r\n    let DyMinMax = DyMin.slice();\r\n    DyMinMax[2] = DyMinMax[2] - dMax;\r\n    let DyMaxMin = DyMax.slice();\r\n    DyMaxMin[2] = DyMaxMin[2] - dMin;\r\n    let DyMaxMax = DyMax.slice();\r\n    DyMaxMax[2] = DyMaxMax[2] - dMax;\r\n    let tMin = Number.POSITIVE_INFINITY;\r\n    let tMax = Number.NEGATIVE_INFINITY;\r\n    let rootsMinMin = flo_poly_1.allRoots(DyMinMin, 0, 1);\r\n    let rootsMinMax = flo_poly_1.allRoots(DyMinMax, 0, 1);\r\n    let rootsMaxMin = flo_poly_1.allRoots(DyMaxMin, 0, 1);\r\n    let rootsMaxMax = flo_poly_1.allRoots(DyMaxMax, 0, 1);\r\n    tMin = Math.min(...rootsMinMin, ...rootsMinMax, ...rootsMaxMin, ...rootsMaxMax);\r\n    tMax = Math.max(...rootsMinMin, ...rootsMinMax, ...rootsMaxMin, ...rootsMaxMax);\r\n    if (dH0 >= dMin && dH0 <= dMax) {\r\n        tMin = 0;\r\n    }\r\n    if (dH2 >= dMin && dH2 <= dMax) {\r\n        tMax = 1;\r\n    }\r\n    if (tMin < 0) {\r\n        tMin = 0;\r\n    }\r\n    if (tMax > 1) {\r\n        tMax = 1;\r\n    }\r\n    return { tMin, tMax };\r\n}\r\nexports.geoClip = geoClip;\r\n//# sourceMappingURL=geo-clip.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/bezier3-intersection/clip/geo-clip.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/bezier3-intersection/clip/to-hybrid-quadratic.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/bezier3-intersection/clip/to-hybrid-quadratic.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the hybrid quadratic version of the given cubic bezier. For a\r\n * definition of hybrid quadratic bezier curves see <a href=\"http://scholarsarchive.byu.edu/cgi/viewcontent.cgi?article=2206&context=etd\">\r\n * this paper</a>.\r\n * @param ps - A cubic bezier curve.\r\n * @returns An array of three quadratic bezier points where the\r\n * middle point is a 'hybrid' point represented as a line (itself represented\r\n * by two points (a linear bezier curve)) which can be evaluated at a different\r\n * t value (call it th). If evaluated at the same t value the result is the same\r\n * as evaluating the original cubic bezier at t. The set generated by evaluating\r\n * the hybrid quadratic curve for all (t,th) value pairs forms a geometric area\r\n * bound around the orginal cubic bezier curve. The length of the linear bezier\r\n * curve mentioned above is a measure of how closely the cubic can be\r\n * represented as a quadratic bezier curve.\r\n */\r\nfunction toHybridQuadratic(ps) {\r\n    if (ps.length === 4) {\r\n        let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        return [\r\n            [x0, y0],\r\n            [\r\n                [(3 * x1 - x0) / 2, (3 * y1 - y0) / 2],\r\n                [(3 * x2 - x3) / 2, (3 * y2 - y3) / 2] // evaluated at t\r\n            ],\r\n            [x3, y3] // evaluated at t\r\n        ];\r\n    }\r\n    else if (ps.length === 3) {\r\n        let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n        return [\r\n            [x0, y0],\r\n            [[x1, y1],\r\n                [x1, y1]],\r\n            [x2, y2] // evaluated at t\r\n        ];\r\n    }\r\n    else if (ps.length === 2) {\r\n        let [[x0, y0], [x1, y1]] = ps;\r\n        return [\r\n            [x0, y0],\r\n            [[(x1 + x0) / 2, (y1 + y0) / 2],\r\n                [(x1 + x0) / 2, (y1 + y0) / 2]],\r\n            [x1, y1] // evaluated at t\r\n        ];\r\n    }\r\n}\r\nexports.toHybridQuadratic = toHybridQuadratic;\r\n//# sourceMappingURL=to-hybrid-quadratic.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/bezier3-intersection/clip/to-hybrid-quadratic.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/bezier3-intersection/get-distance-to-line-function.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/bezier3-intersection/get-distance-to-line-function.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * @private\r\n * @param l\r\n */\r\nfunction getDistanceToLineFunction(l) {\r\n    let [a, b, c] = getLineEquation(l);\r\n    return function (p) {\r\n        return a * p[0] + b * p[1] + c;\r\n    };\r\n}\r\nexports.getDistanceToLineFunction = getDistanceToLineFunction;\r\n/**\r\n * Get the implicit line equation from two 2d points in the form f(x,y) := ax + by + c = 0\r\n * returned as the array [a,b,c].\r\n * @param l A line given by two points, e.g. [[2,0],[3,3]]\r\n */\r\nfunction getLineEquation(l) {\r\n    let [[x1, y1], [x2, y2]] = l;\r\n    let a = y1 - y2;\r\n    let b = x2 - x1;\r\n    let c = x1 * y2 - x2 * y1;\r\n    let d = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\r\n    return [a / d, b / d, c / d];\r\n}\r\n//# sourceMappingURL=get-distance-to-line-function.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/bezier3-intersection/get-distance-to-line-function.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/closest-point-on-bezier.js":
/*!******************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/closest-point-on-bezier.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_tangent_poly_from_point_1 = __webpack_require__(/*! ./get-tangent-poly-from-point */ \"./node_modules/flo-bezier3/node/get-tangent-poly-from-point.js\");\r\nconst evaluate_1 = __webpack_require__(/*! ./evaluate/evaluate */ \"./node_modules/flo-bezier3/node/evaluate/evaluate.js\");\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nfunction closestPointOnBezier(ps, p) {\r\n    let poly = get_tangent_poly_from_point_1.getTangentPolyFromPoint(ps, p);\r\n    let ts = flo_poly_1.allRoots(poly, 0, 1);\r\n    ts.push(0);\r\n    ts.push(1);\r\n    let ev = evaluate_1.evaluate(ps);\r\n    let ps_ = ts.map(t => ({ p: ev(t), t }));\r\n    // Get point with minimum distance\r\n    let minD = Number.POSITIVE_INFINITY;\r\n    let minP = undefined;\r\n    ps_.forEach(p_ => {\r\n        let d = flo_vector2d_1.squaredDistanceBetween(p_.p, p);\r\n        if (d < minD) {\r\n            minD = d;\r\n            minP = p_;\r\n        }\r\n    });\r\n    return minP;\r\n}\r\nexports.closestPointOnBezier = closestPointOnBezier;\r\n//# sourceMappingURL=closest-point-on-bezier.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/closest-point-on-bezier.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/coincident.js":
/*!*****************************************************!*\
  !*** ./node_modules/flo-bezier3/node/coincident.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Vector = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst evaluate_1 = __webpack_require__(/*! ./evaluate/evaluate */ \"./node_modules/flo-bezier3/node/evaluate/evaluate.js\");\r\nconst line_intersection_1 = __webpack_require__(/*! ./line-intersection */ \"./node_modules/flo-bezier3/node/line-intersection.js\");\r\nconst normal_1 = __webpack_require__(/*! ./normal */ \"./node_modules/flo-bezier3/node/normal.js\");\r\n/**\r\n * Check if the two given cubic beziers are nearly coincident everywhere along\r\n * a finite stretch and returns the coincident stretch (if any), otherwise\r\n * returns undefined.\r\n * @param P - A cubic bezier curve.\r\n * @param Q - Another cubic bezier curve.\r\n * @param δ - An indication of how closely the curves should stay to\r\n * each other before considered coincident.\r\n */\r\nfunction coincident(P, Q, δ = 1e-6) {\r\n    let PtoQs = [0.01, 0.99].map(i => calcPointAndNeighbor(P, Q, i));\r\n    let QtoPs = [0.01, 0.99].map(i => calcPointAndNeighbor(Q, P, i));\r\n    // Check if start and end points are coincident.\r\n    let tStartQ = 0.01;\r\n    let tEndQ = 0.99;\r\n    let tStartP = 0.01;\r\n    let tEndP = 0.99;\r\n    if (PtoQs[0].d <= δ) {\r\n        tStartQ = PtoQs[0].t;\r\n    }\r\n    if (PtoQs[1].d <= δ) {\r\n        tEndQ = PtoQs[1].t;\r\n    }\r\n    if (QtoPs[0].d <= δ) {\r\n        tStartP = QtoPs[0].t;\r\n    }\r\n    if (QtoPs[1].d <= δ) {\r\n        tEndP = QtoPs[1].t;\r\n    }\r\n    if (tStartP > tEndP) {\r\n        [tStartP, tEndP] = [tEndP, tStartP];\r\n    }\r\n    if (tStartQ > tEndQ) {\r\n        [tStartQ, tEndQ] = [tEndQ, tStartQ];\r\n    }\r\n    let tSpanP = tEndP - tStartP;\r\n    let tSpanQ = tEndQ - tStartQ;\r\n    // We must check at least 10 points to ensure entire curve is coincident, \r\n    // otherwise we may simply have found intersection points. We cannot simply \r\n    // check the control points for closeness since well seperated control \r\n    // points does not necessarily translate into well seperated curves.\r\n    // If the overlapping part is smaller than 1/10 (a heuristical value) then\r\n    // do not consider pieces overlapping.\r\n    if (tSpanP < 0.1 && tSpanQ < 0.1) {\r\n        return undefined;\r\n    }\r\n    let res = true;\r\n    for (let i = 0; i < 10; i++) {\r\n        let t = tStartP + tSpanP * (i / 10);\r\n        let { d } = calcPointAndNeighbor(P, Q, t);\r\n        if (d > δ) {\r\n            return undefined;\r\n        }\r\n    }\r\n    return { p: [tStartP, tEndP], q: [tStartQ, tEndQ] };\r\n}\r\nexports.coincident = coincident;\r\nfunction calcPointAndNeighbor(P, Q, t) {\r\n    // TODO - must also check crossing of normals - for if two curves open\r\n    // at endpoints and stop essentially at same point.\r\n    let pp1 = evaluate_1.evaluate(P)(t);\r\n    let normalVector = normal_1.normal(P)(t);\r\n    let pp2 = Vector.translate(pp1, normalVector);\r\n    let ts = line_intersection_1.lineIntersection(Q, [pp1, pp2]);\r\n    let bestT = undefined;\r\n    let bestQ = undefined;\r\n    let bestD = Number.POSITIVE_INFINITY;\r\n    for (let t of ts) {\r\n        let q = evaluate_1.evaluate(Q)(t);\r\n        let d = Vector.distanceBetween(q, pp1);\r\n        if (d < bestD) {\r\n            bestT = t;\r\n            bestQ = q;\r\n            bestD = d;\r\n        }\r\n    }\r\n    return { t: bestT, p: bestQ, d: bestD };\r\n}\r\n//# sourceMappingURL=coincident.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/coincident.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/curvature.js":
/*!****************************************************!*\
  !*** ./node_modules/flo-bezier3/node/curvature.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst evaluate_dx_1 = __webpack_require__(/*! ./evaluate-dx */ \"./node_modules/flo-bezier3/node/evaluate-dx.js\");\r\nconst evaluate_dy_1 = __webpack_require__(/*! ./evaluate-dy */ \"./node_modules/flo-bezier3/node/evaluate-dy.js\");\r\nconst evaluate_ddx_1 = __webpack_require__(/*! ./evaluate-ddx */ \"./node_modules/flo-bezier3/node/evaluate-ddx.js\");\r\nconst evaluate_ddy_1 = __webpack_require__(/*! ./evaluate-ddy */ \"./node_modules/flo-bezier3/node/evaluate-ddy.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst get_dxy_at_0_1 = __webpack_require__(/*! ./get-dxy-at-0 */ \"./node_modules/flo-bezier3/node/get-dxy-at-0.js\");\r\nconst get_ddxy_at_0_1 = __webpack_require__(/*! ./get-ddxy-at-0 */ \"./node_modules/flo-bezier3/node/get-ddxy-at-0.js\");\r\nconst get_dddxy_1 = __webpack_require__(/*! ./get-dddxy */ \"./node_modules/flo-bezier3/node/get-dddxy.js\");\r\nfunction κ(ps, t) {\r\n    let evDx = evaluate_dx_1.evaluateDx(ps);\r\n    let evDy = evaluate_dy_1.evaluateDy(ps);\r\n    let evDdx = evaluate_ddx_1.evaluateDdx(ps);\r\n    let evDdy = evaluate_ddy_1.evaluateDdy(ps);\r\n    function f(t) {\r\n        let dx = evDx(t);\r\n        let dy = evDy(t);\r\n        let ddx = evDdx(t);\r\n        let ddy = evDdy(t);\r\n        let a = dx * ddy - dy * ddx;\r\n        let b = Math.sqrt(Math.pow((dx * dx + dy * dy), 3));\r\n        return a / b;\r\n    }\r\n    // Curry\r\n    return t === undefined ? f : f(t);\r\n}\r\nexports.κ = κ;\r\n/**\r\n * Compare the curvature, κ, between two curves at t === 0.\r\n *\r\n * Returns a positive number if κ for psI > κ for psO, negative if κ for psI < κ\r\n * for psO or zero if the curve extensions are identical (i.e. in same K-family).\r\n *\r\n * Precondition: The point psI evaluated at zero must === the point psO\r\n * evaluated at zero.\r\n *\r\n * Exact: Returns the exact result if the bithlength of all\r\n * coordinates <= 53 - 5 === 48 and are bit-aligned.\r\n *\r\n * @param psI An order 1, 2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * representing the incoming curve\r\n * @param psO Another bezier representing the outgoing curve\r\n */\r\nfunction compareCurvaturesAtInterface(psI, psO) {\r\n    // Get x' and y' for incoming curve evaluated at 0\r\n    let [dxI, dyI] = get_dxy_at_0_1.getDxyAt0(psI); // max bitlength increase / max shift === 3\r\n    // Get x'' and y'' for incoming curve evaluated at 0\r\n    let [ddxI, ddyI] = get_ddxy_at_0_1.getDdxyAt0(psI); // max bitlength increase / max shift === 5\r\n    // Get x' and y' for outgoing curve evaluated at 0\r\n    let [dxO, dyO] = get_dxy_at_0_1.getDxyAt0(psO); // max bitlength increase / max shift === 3\r\n    // Get x'' and y'' for outgoing curve evaluated at 0\r\n    let [ddxO, ddyO] = get_ddxy_at_0_1.getDdxyAt0(psO); // max bitlength increase / max shift === 5\r\n    //console.log('κI: ', κ(psI, 0));\r\n    //console.log('κO: ', κ(psO, 0));\r\n    // Remember the formula for the signed curvature of a parametric curve:\r\n    // κ = x′y′′ - y′x′′ / sqrt(x′² + y′²)³\r\n    // κ² = (x′y′′ - y′x′′)² / (x′² + y′²)³\r\n    // This allows us to do an exact comparison of curvatures\r\n    // Simplifying the above gives (denoting the incoming curve with a subscript\r\n    // of 1 and the outgoing with a 2):\r\n    //      κIncoming > κOutgoing\r\n    // <=>  (x₁′y₁′′ - y₁′x₁′′)²(x₂′² + y₂′²)³ > (x₂′y₂′′ - y₂′x₂′′)²(x₁′² + y₁′²)³\r\n    // <=>  a²b³ > c²d³\r\n    // Note b³ > 0 and d³ > 0\r\n    // max aggregate bitlength increase (let original bitlength === p):\r\n    // a -> 2 x ((p+3)+(p+5) + 1) === 4p + 18 -> max p in double precision === 8 -> too low\r\n    //let a = (dxI*ddyI - dyI*ddxI)**2;\r\n    // b -> 3 x ((p+3) + 1) === 3p + 12\r\n    //let b = (dxO*dxO  + dyO*dyO )**3;\r\n    // c -> 2 x ((p+3)+(p+5) + 1) === 4p + 18\r\n    //let c = (dxO*ddyO - dyO*ddxO)**2;\r\n    // d -> 3 x ((p+3) + 1) === 3p + 12\r\n    //let d = (dxI*dxI  + dyI*dyI )**3;\r\n    // We need to resort to exact floating point arithmetic at this point\r\n    let a = flo_numerical_1.expansionDiff(flo_numerical_1.twoProduct(dxI, ddyI), flo_numerical_1.twoProduct(dyI, ddxI));\r\n    let c = flo_numerical_1.expansionDiff(flo_numerical_1.twoProduct(dxO, ddyO), flo_numerical_1.twoProduct(dyO, ddxO));\r\n    let signA = flo_numerical_1.sign(a);\r\n    let signC = flo_numerical_1.sign(c);\r\n    if (signA !== signC) {\r\n        //console.log('branch 3');\r\n        return signA - signC;\r\n    }\r\n    let b = flo_numerical_1.fastExpansionSum(flo_numerical_1.twoProduct(dxO, dxO), flo_numerical_1.twoProduct(dyO, dyO));\r\n    let d = flo_numerical_1.fastExpansionSum(flo_numerical_1.twoProduct(dxI, dxI), flo_numerical_1.twoProduct(dyI, dyI));\r\n    let b2 = flo_numerical_1.expansionProduct(b, b);\r\n    let b3 = flo_numerical_1.expansionProduct(b2, b);\r\n    let d2 = flo_numerical_1.expansionProduct(d, d);\r\n    let d3 = flo_numerical_1.expansionProduct(d2, d);\r\n    if (signA !== 0 || signC !== 0) {\r\n        //console.log('branch 4');\r\n        let a2 = flo_numerical_1.expansionProduct(a, a);\r\n        let c2 = flo_numerical_1.expansionProduct(c, c);\r\n        // max aggregate bitlength increase (let original bitlength === p):\r\n        // κ -> (2 x ((p+3)+(p+5) + 1)) + (3 x ((p+3) + 1)) === 7p + 30\r\n        // e.g. for bit-aligned input bitlength p of 10 we get output bitlength \r\n        // of 100, or for p === 3 (the max exact bitlength allowed to have exact\r\n        // results without resorting to infinite precision) we get 51 bits.\r\n        let κI = flo_numerical_1.expansionProduct(a2, b3);\r\n        let κO = flo_numerical_1.expansionProduct(c2, d3);\r\n        let δκ = flo_numerical_1.sign(flo_numerical_1.expansionDiff(κI, κO));\r\n        if (δκ !== 0) {\r\n            //console.log('branch 5');\r\n            // At this point signA === signC, both +tive or -tive\r\n            return signA > 0 ? δκ : -δκ;\r\n        }\r\n    }\r\n    // At this point signA === signC, both +tive or -tive or 0\r\n    // Now we have to look at the change of curvature w.r.t. the parameter t,\r\n    // i.e. \r\n    // κ′ = [(x′²+y′²)(x′y′′′-y′x′′′) - 3(x′y′′-y′x′′)(x′x′′+y′y′′)] / (x′²+y′²)^(5/2)\r\n    // Therefore: (denoting the incoming curve with a subscript of 1 and the outgoing with a 2)\r\n    // κ′Incoming > κ′Outgoing\r\n    // <=> [(x₁′²+y₁′²)(x₁′y₁′′′-y₁′x₁′′′) - 3(x₁′y₁′′-y₁′x₁′′)(x₁′x₁′′+y₁′y₁′′)]²(x₂′²+y₂′²)⁵ >\r\n    //     [(x₂′²+y₂′²)(x₂′y₂′′′-y₂′x₂′′′) - 3(x₂′y₂′′-y₂′x₂′′)(x₂′x₂′′+y₂′y₂′′)]²(x₁′²+y₁′²)⁵\r\n    // <=> (de - 3af)²b⁵ > (bg - 3ch)²d⁵\r\n    // <=> i²b⁵ > j²d⁵\r\n    // Get x′′′ and y′′′ for incoming curve evaluated at 1\r\n    let [dddxI, dddyI] = get_dddxy_1.getDddxy(psI); // max bitlength increase === max shift === 6\r\n    let [dddxO, dddyO] = get_dddxy_1.getDddxy(psO); // max bitlength increase === max shift === 6\r\n    let e = flo_numerical_1.expansionDiff(flo_numerical_1.twoProduct(dxI, dddyI), flo_numerical_1.twoProduct(dyI, dddxI));\r\n    let f = flo_numerical_1.fastExpansionSum(flo_numerical_1.twoProduct(dxI, ddxI), flo_numerical_1.twoProduct(dyI, ddyI));\r\n    let g = flo_numerical_1.expansionDiff(flo_numerical_1.twoProduct(dxO, dddyO), flo_numerical_1.twoProduct(dyO, dddxO));\r\n    let h = flo_numerical_1.fastExpansionSum(flo_numerical_1.twoProduct(dxO, ddxO), flo_numerical_1.twoProduct(dyO, ddyO));\r\n    // (de - 3af)²b⁵ > (bg - 3ch)²d⁵\r\n    // i²b⁵ > j²d⁵\r\n    let i = flo_numerical_1.expansionDiff(flo_numerical_1.expansionProduct(d, e), flo_numerical_1.scaleExpansion(flo_numerical_1.expansionProduct(a, f), 3));\r\n    let j = flo_numerical_1.expansionDiff(flo_numerical_1.expansionProduct(b, g), flo_numerical_1.scaleExpansion(flo_numerical_1.expansionProduct(c, h), 3));\r\n    let signI = flo_numerical_1.sign(i);\r\n    let signJ = flo_numerical_1.sign(j);\r\n    if (signA !== signC) {\r\n        return signI - signJ;\r\n    }\r\n    if (signI === 0 && signJ === 0) {\r\n        // Both curve extensions are identical, i.e. in the same K-family\r\n        return 0;\r\n    }\r\n    let i2 = flo_numerical_1.expansionProduct(i, i);\r\n    let b5 = flo_numerical_1.expansionProduct(b2, b3);\r\n    let j2 = flo_numerical_1.expansionProduct(j, j);\r\n    let d5 = flo_numerical_1.expansionProduct(d2, d3);\r\n    let dκI = flo_numerical_1.expansionProduct(i2, b5);\r\n    let dκO = flo_numerical_1.expansionProduct(j2, d5);\r\n    let sgn = flo_numerical_1.sign(flo_numerical_1.expansionDiff(dκI, dκO));\r\n    return signI > 0 ? sgn : -sgn;\r\n    // If the above returned value is still zero then the two curve extensions \r\n    // are identical, i.e. in the same K-family\r\n}\r\nexports.compareCurvaturesAtInterface = compareCurvaturesAtInterface;\r\n//# sourceMappingURL=curvature.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/curvature.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/debug/debug.js":
/*!******************************************************!*\
  !*** ./node_modules/flo-bezier3/node/debug/debug.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst draw_elem_1 = __webpack_require__(/*! ./draw-elem/draw-elem */ \"./node_modules/flo-bezier3/node/debug/draw-elem/draw-elem.js\");\r\nclass BezDebug {\r\n    /**\r\n     * @param config - configuration settings.\r\n     * @param fs - some useful functions.\r\n     * @private\r\n     */\r\n    constructor(g) {\r\n        //(this as any).Bezier3 = Bezier3; // Included only for quick debugging from console\r\n        //(this as any).Vector2d = Vector; // ...\r\n        this.g = g;\r\n        //-----------------------------------------------\r\n        // Generated by debug object for later inspection\r\n        //-----------------------------------------------\r\n        this.generated = {\r\n            elems: {\r\n                beziers: [],\r\n                fatLine: [],\r\n                looseBoundingBox: [],\r\n                tightBoundingBox: [],\r\n                extreme: [],\r\n                boundingHull: [],\r\n                intersection: [],\r\n            }\r\n        };\r\n        this.fs = {\r\n            drawElem: draw_elem_1.drawElemFunctions,\r\n        };\r\n    }\r\n}\r\nexports.BezDebug = BezDebug;\r\n//# sourceMappingURL=debug.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/debug/debug.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/debug/draw-elem/draw-elem.js":
/*!********************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/debug/draw-elem/draw-elem.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst flo_draw_1 = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\r\nfunction fatLine(g, fatLine) {\r\n    let { l, minD, maxD } = fatLine;\r\n    let [lp1, lp2] = l;\r\n    const E = 1024;\r\n    let lv = flo_vector2d_1.fromTo(lp1, lp2);\r\n    let lvTimes10 = [+E * lv[0], +E * lv[1]];\r\n    let reverseLvTimes10 = [-E * lv[0], -E * lv[1]];\r\n    let normal = [-lv[1], lv[0]]; // Rotate by -90 degrees\r\n    let normMin = flo_vector2d_1.toLength(normal, minD);\r\n    let normMax = flo_vector2d_1.toLength(normal, maxD);\r\n    let extLp1 = flo_vector2d_1.translate(lp1, reverseLvTimes10);\r\n    let extLp2 = flo_vector2d_1.translate(lp2, lvTimes10);\r\n    let nl11 = flo_vector2d_1.translate(extLp1, normMin);\r\n    let nl12 = flo_vector2d_1.translate(extLp2, normMin);\r\n    let nl21 = flo_vector2d_1.translate(extLp1, normMax);\r\n    let nl22 = flo_vector2d_1.translate(extLp2, normMax);\r\n    let nl1 = [nl11, nl12];\r\n    let nl2 = [nl21, nl22];\r\n    let $line1 = flo_draw_1.drawFs.line(g, nl1);\r\n    let $line2 = flo_draw_1.drawFs.line(g, nl2);\r\n    return [...$line1, ...$line2];\r\n}\r\nfunction beziers(g, beziers) {\r\n    let $bezier1 = flo_draw_1.drawFs.bezier(g, beziers[0], 'blue thin5 nofill');\r\n    let $bezier2 = flo_draw_1.drawFs.bezier(g, beziers[1], 'green thin5 nofill');\r\n    let size = getSize([...beziers[0], ...beziers[1]]) / 400;\r\n    let $dots = [];\r\n    for (let i = 0; i < beziers.length; i++) {\r\n        let bezier = beziers[i];\r\n        for (let j = 0; j < bezier.length; j++) {\r\n            let p = bezier[j];\r\n            $dots.push(...flo_draw_1.drawFs.dot(g, p, size, i === 0 ? 'blue' : 'green'));\r\n        }\r\n    }\r\n    /*\r\n    let $dots = [\r\n        ...drawFs.dot(g, beziers[0][0], size, 'blue'),\r\n        ...drawFs.dot(g, beziers[0][1], size, 'blue'),\r\n        ...drawFs.dot(g, beziers[0][2], size, 'blue'),\r\n        ...drawFs.dot(g, beziers[0][3], size, 'blue'),\r\n        ...drawFs.dot(g, beziers[1][0], size, 'green'),\r\n        ...drawFs.dot(g, beziers[1][1], size, 'green'),\r\n        ...drawFs.dot(g, beziers[1][2], size, 'green'),\r\n        ...drawFs.dot(g, beziers[1][3], size, 'green'),\r\n    ]\r\n    */\r\n    return [...$bezier1, ...$bezier2, ...$dots];\r\n}\r\nfunction getSize(ps) {\r\n    let minX = Number.POSITIVE_INFINITY;\r\n    let minY = Number.POSITIVE_INFINITY;\r\n    let maxX = Number.NEGATIVE_INFINITY;\r\n    let maxY = Number.NEGATIVE_INFINITY;\r\n    for (let p of ps) {\r\n        if (p[0] < minX) {\r\n            minX = p[0];\r\n        }\r\n        if (p[1] < minY) {\r\n            minY = p[1];\r\n        }\r\n        if (p[0] > maxX) {\r\n            maxX = p[0];\r\n        }\r\n        if (p[1] > maxY) {\r\n            maxY = p[1];\r\n        }\r\n    }\r\n    let width = maxX - minX;\r\n    let height = maxY - minY;\r\n    return Math.max(width, height);\r\n}\r\nfunction intersection(g, p) {\r\n    let $elems = flo_draw_1.drawFs.crossHair(g, p, 'red thin5 nofill', 0.5);\r\n    return $elems;\r\n}\r\nfunction extreme(g, extreme) {\r\n    let $elems = flo_draw_1.drawFs.crossHair(g, extreme.p, 'red thin10 nofill', 0.05);\r\n    return $elems;\r\n}\r\nfunction boundingHull(g, hull) {\r\n    let $polygon = flo_draw_1.drawFs.polygon(g, hull, 'thin5 black nofill');\r\n    return $polygon;\r\n}\r\nfunction looseBoundingBox(g, box) {\r\n    let $box = flo_draw_1.drawFs.rect(g, box, 'thin5 brown nofill');\r\n    return $box;\r\n}\r\nfunction tightBoundingBox(g, box) {\r\n    let $box = flo_draw_1.drawFs.polygon(g, box, 'thin5 black nofill');\r\n    return $box;\r\n}\r\nlet drawElemFunctions = {\r\n    beziers,\r\n    intersection,\r\n    extreme,\r\n    boundingHull,\r\n    looseBoundingBox,\r\n    tightBoundingBox,\r\n    fatLine\r\n};\r\nexports.drawElemFunctions = drawElemFunctions;\r\n//# sourceMappingURL=draw-elem.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/debug/draw-elem/draw-elem.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/evaluate-ddx.js":
/*!*******************************************************!*\
  !*** ./node_modules/flo-bezier3/node/evaluate-ddx.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_ddx_1 = __webpack_require__(/*! ./get-ddx */ \"./node_modules/flo-bezier3/node/get-ddx.js\");\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nfunction evaluateDdx(ps, t) {\r\n    const ddPs = get_ddx_1.getDdx(ps); // Speed optimizing cache\r\n    const f = flo_poly_1.evaluate(ddPs);\r\n    return t === undefined ? f : f(t); // Curry\r\n}\r\nexports.evaluateDdx = evaluateDdx;\r\n//# sourceMappingURL=evaluate-ddx.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/evaluate-ddx.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/evaluate-ddy.js":
/*!*******************************************************!*\
  !*** ./node_modules/flo-bezier3/node/evaluate-ddy.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_ddy_1 = __webpack_require__(/*! ./get-ddy */ \"./node_modules/flo-bezier3/node/get-ddy.js\");\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nfunction evaluateDdy(ps, t) {\r\n    const ddPs = get_ddy_1.getDdy(ps); // Speed optimizing cache\r\n    const f = flo_poly_1.evaluate(ddPs);\r\n    return t === undefined ? f : f(t); // Curry\r\n}\r\nexports.evaluateDdy = evaluateDdy;\r\n//# sourceMappingURL=evaluate-ddy.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/evaluate-ddy.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/evaluate-dx.js":
/*!******************************************************!*\
  !*** ./node_modules/flo-bezier3/node/evaluate-dx.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst get_dx_1 = __webpack_require__(/*! ./get-dx */ \"./node_modules/flo-bezier3/node/get-dx.js\");\r\nfunction evaluateDx(ps, t) {\r\n    const dPs = get_dx_1.getDx(ps); // Speed optimizing cache\r\n    const f = flo_poly_1.evaluate(dPs);\r\n    return t === undefined ? f : f(t); // Curry\r\n}\r\nexports.evaluateDx = evaluateDx;\r\n//# sourceMappingURL=evaluate-dx.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/evaluate-dx.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/evaluate-dy.js":
/*!******************************************************!*\
  !*** ./node_modules/flo-bezier3/node/evaluate-dy.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst get_dy_1 = __webpack_require__(/*! ./get-dy */ \"./node_modules/flo-bezier3/node/get-dy.js\");\r\nfunction evaluateDy(ps, t) {\r\n    const dPs = get_dy_1.getDy(ps); // Speed optimizing cache\r\n    const f = flo_poly_1.evaluate(dPs);\r\n    return t === undefined ? f : f(t); // Curry\r\n}\r\nexports.evaluateDy = evaluateDy;\r\n//# sourceMappingURL=evaluate-dy.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/evaluate-dy.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/evaluate-x/evaluate-x.js":
/*!****************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/evaluate-x/evaluate-x.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst get_x_1 = __webpack_require__(/*! ../get-x */ \"./node_modules/flo-bezier3/node/get-x.js\");\r\nfunction evaluateX(ps, t) {\r\n    const xPs = get_x_1.getX(ps); // Speed optimizing cache\r\n    const evPs = flo_poly_1.evaluate(xPs);\r\n    const len = ps.length;\r\n    function f(t) {\r\n        if (t === 0) {\r\n            return ps[0][0];\r\n        }\r\n        if (t === 1) {\r\n            return ps[len - 1][0];\r\n        }\r\n        return evPs(t);\r\n    }\r\n    return t === undefined ? f : f(t); // Curry\r\n}\r\nexports.evaluateX = evaluateX;\r\n//# sourceMappingURL=evaluate-x.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/evaluate-x/evaluate-x.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/evaluate-y/evaluate-y.js":
/*!****************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/evaluate-y/evaluate-y.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst get_y_1 = __webpack_require__(/*! ../get-y */ \"./node_modules/flo-bezier3/node/get-y.js\");\r\nfunction evaluateY(ps, t) {\r\n    const yPs = get_y_1.getY(ps); // Speed optimizing cache\r\n    const evPs = flo_poly_1.evaluate(yPs);\r\n    const len = ps.length;\r\n    function f(t) {\r\n        if (t === 0) {\r\n            return ps[0][1];\r\n        }\r\n        if (t === 1) {\r\n            return ps[len - 1][1];\r\n        }\r\n        return evPs(t);\r\n    }\r\n    return t === undefined ? f : f(t); // Curry\r\n}\r\nexports.evaluateY = evaluateY;\r\n//# sourceMappingURL=evaluate-y.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/evaluate-y/evaluate-y.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/evaluate/evaluate.js":
/*!************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/evaluate/evaluate.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction evaluate(ps, t) {\r\n    //const evX = evaluateX(ps);\r\n    //const evY = evaluateY(ps);\r\n    const len = ps.length;\r\n    return t === undefined ? f : f(t);\r\n    function f(t) {\r\n        if (t === 0) {\r\n            return ps[0];\r\n        }\r\n        else if (t === 1) {\r\n            return ps[len - 1];\r\n        }\r\n        let s = 1 - t;\r\n        if (ps.length === 4) {\r\n            // cubic\r\n            let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n            let x = x0 * Math.pow(s, 3) + 3 * x1 * Math.pow(s, 2) * t + 3 * x2 * s * Math.pow(t, 2) + x3 * Math.pow(t, 3);\r\n            let y = y0 * Math.pow(s, 3) + 3 * y1 * Math.pow(s, 2) * t + 3 * y2 * s * Math.pow(t, 2) + y3 * Math.pow(t, 3);\r\n            return [x, y];\r\n        }\r\n        if (ps.length === 3) {\r\n            // quadratic\r\n            let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n            let x = x0 * Math.pow(s, 2) + 2 * x1 * s * t + x2 * Math.pow(t, 2);\r\n            let y = y0 * Math.pow(s, 2) + 2 * y1 * s * t + y2 * Math.pow(t, 2);\r\n            return [x, y];\r\n        }\r\n        if (ps.length === 2) {\r\n            // line\r\n            let [[x0, y0], [x1, y1]] = ps;\r\n            let x = x0 * s + x1 * t;\r\n            let y = y0 * s + y1 * t;\r\n            return [x, y];\r\n        }\r\n        //return [evX(t), evY(t)];\t\t\r\n    }\r\n}\r\nexports.evaluate = evaluate;\r\n//# sourceMappingURL=evaluate.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/evaluate/evaluate.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/flatness.js":
/*!***************************************************!*\
  !*** ./node_modules/flo-bezier3/node/flatness.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst length_upper_bound_1 = __webpack_require__(/*! ./length-upper-bound */ \"./node_modules/flo-bezier3/node/length-upper-bound.js\");\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\n/**\r\n * Returns a flatness measure of the given curve - calculated as the total\r\n * distance between consecutive control points divided by the distance between\r\n * the endpoints.\r\n * @param ps An order 1,2 or 3 bezier curve.\r\n */\r\nfunction flatness(ps) {\r\n    return length_upper_bound_1.lengthUpperBound(ps) / flo_vector2d_1.distanceBetween(ps[0], ps[ps.length - 1]);\r\n}\r\nexports.flatness = flatness;\r\n//# sourceMappingURL=flatness.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/flatness.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/from-0-to-T.js":
/*!******************************************************!*\
  !*** ./node_modules/flo-bezier3/node/from-0-to-T.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst split_at_1 = __webpack_require__(/*! ./split-at */ \"./node_modules/flo-bezier3/node/split-at.js\");\r\n/**\r\n * Returns an order 1, 2 or 3 bezier curve that starts at the given curve's t=0\r\n * and ends at the given t parameter.\r\n *\r\n * A loose bound on the accuracy of the resultant points is given by:\r\n * |δP| = 2n*max(|b_k|)η, where n = 3 (cubic), b_k are the control points\r\n * and η is Number.EPSILON.\r\n * @param ps - A cubic bezier curve\r\n * @param t - The t parameter where the resultant bezier should end\r\n */\r\nfunction from0ToT(ps, t) {\r\n    return split_at_1.splitAt(ps, t)[0];\r\n}\r\nexports.from0ToT = from0ToT;\r\n//# sourceMappingURL=from-0-to-T.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/from-0-to-T.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/from-T-to-1.js":
/*!******************************************************!*\
  !*** ./node_modules/flo-bezier3/node/from-T-to-1.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst split_at_1 = __webpack_require__(/*! ./split-at */ \"./node_modules/flo-bezier3/node/split-at.js\");\r\n/**\r\n * Returns an order 1, 2 or 3 bezier curve that starts at the given t parameter\r\n * and ends at t=1.\r\n *\r\n * A loose bound on the accuracy of the resultant points is given by:\r\n * |δP| = 2n*max_k(|b_k|)η, where n = 3 (cubic), b_k are the control points\r\n * abd η is Number.EPSILON.\r\n * @param ps - A cubic bezier curve\r\n * @param t - The t parameter where the resultant bezier should start\r\n */\r\nfunction fromTTo1(ps, t) {\r\n    return split_at_1.splitAt(ps, t)[1];\r\n}\r\nexports.fromTTo1 = fromTTo1;\r\n//# sourceMappingURL=from-T-to-1.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/from-T-to-1.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/from-to.js":
/*!**************************************************!*\
  !*** ./node_modules/flo-bezier3/node/from-to.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst evaluate_1 = __webpack_require__(/*! ./evaluate/evaluate */ \"./node_modules/flo-bezier3/node/evaluate/evaluate.js\");\r\nconst split_at_1 = __webpack_require__(/*! ./split-at */ \"./node_modules/flo-bezier3/node/split-at.js\");\r\n/**\r\n * Returns a bezier curve that starts at the given curve and ends at the\r\n * given t parameter. Uses de Casteljau's algorithm.\r\n *\r\n * A loose bound on the accuracy of the resultant points is given by:\r\n * |δP| = 2*2n*max_k(|b_k|)η, where n = 3 (for a cubic), b_k are the control\r\n * points and η is Number.EPSILON.\r\n * @param ps - A cubic bezier curve\r\n * @param t1 - The t parameter where the resultant bezier should start\r\n * @param t2 - The t parameter where the resultant bezier should end\r\n */\r\nfunction fromTo(ps) {\r\n    return function (t1, t2) {\r\n        let reverse = t1 > t2;\r\n        if (t1 > t2) {\r\n            [t1, t2] = [t2, t1];\r\n        }\r\n        let ps_;\r\n        if (t1 === 0 && t2 === 1) {\r\n            ps_ = ps;\r\n        }\r\n        else if (t1 === 0) {\r\n            ps_ = split_at_1.splitAt(ps, t2)[0];\r\n        }\r\n        else if (t2 === 1) {\r\n            ps_ = split_at_1.splitAt(ps, t1)[1];\r\n        }\r\n        else if (t1 === t2) {\r\n            // Degenerate case\r\n            let p = evaluate_1.evaluate(ps, t1);\r\n            if (ps.length === 2) {\r\n                return [p, p];\r\n            }\r\n            if (ps.length === 3) {\r\n                return [p, p, p];\r\n            }\r\n            if (ps.length === 4) {\r\n                return [p, p, p, p];\r\n            }\r\n        }\r\n        else {\r\n            ps_ = split_at_1.splitAt(split_at_1.splitAt(ps, t1)[1], (t2 - t1) / (1 - t1))[0];\r\n        }\r\n        return reverse ? ps_.slice().reverse() : ps_;\r\n    };\r\n}\r\nexports.fromTo = fromTo;\r\n/**\r\n * Returns a bezier curve that starts at the given curve and ends at the\r\n * given t parameter. Uses de Casteljau's algorithm.\r\n *\r\n * A loose bound on the accuracy of the resultant points is given by:\r\n * |δP| = 2*2n*max_k(|b_k|)η, where n = 3 (for a cubic), b_k are the control\r\n * points and η is Number.EPSILON.\r\n * @param ps - A cubic bezier curve\r\n * @param t1 - The t parameter where the resultant bezier should start\r\n * @param t2 - The t parameter where the resultant bezier should end\r\n */\r\nfunction fromToPrecise(ps) {\r\n    return function (t1, t2) {\r\n        let reverse = t1 > t2;\r\n        if (t1 > t2) {\r\n            [t1, t2] = [t2, t1];\r\n        }\r\n        let ps_;\r\n        if (t1 === 0 && t2 === 1) {\r\n            ps_ = ps;\r\n        }\r\n        else if (t1 === 0) {\r\n            ps_ = split_at_1.splitAtPrecise(ps, t2)[0];\r\n        }\r\n        else if (t2 === 1) {\r\n            ps_ = split_at_1.splitAtPrecise(ps, t1)[1];\r\n        }\r\n        else if (t1 === t2) {\r\n            // Degenerate case\r\n            let p = evaluate_1.evaluate(ps, t1);\r\n            if (ps.length === 2) {\r\n                return [p, p];\r\n            }\r\n            if (ps.length === 3) {\r\n                return [p, p, p];\r\n            }\r\n            if (ps.length === 4) {\r\n                return [p, p, p, p];\r\n            }\r\n        }\r\n        else {\r\n            ps_ = split_at_1.splitAtPrecise(split_at_1.splitAtPrecise(ps, t1)[1], (t2 - t1) / (1 - t1))[0];\r\n        }\r\n        return reverse ? ps_.slice().reverse() : ps_;\r\n    };\r\n}\r\nexports.fromToPrecise = fromToPrecise;\r\n//# sourceMappingURL=from-to.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/from-to.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/get-bounding-box-tight.js":
/*!*****************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/get-bounding-box-tight.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst get_bounding_box_1 = __webpack_require__(/*! ./get-bounding-box */ \"./node_modules/flo-bezier3/node/get-bounding-box.js\");\r\n/**\r\n * Returns the tight bounding box of the given cubic bezier.\r\n * @returns The tight bounding box of the bezier as four ordered\r\n * points of a rotated rectangle.\r\n * TODO - test case of baseLength === 0\r\n */\r\nlet getBoundingBoxTight = flo_memoize_1.memoize(function (ps) {\r\n    let [x0, y0] = ps[0];\r\n    let [xE, yE] = ps[ps.length - 1];\r\n    let baseLength = Math.sqrt((xE - x0) * (xE - x0) + (yE - y0) * (yE - y0));\r\n    let sinθ = (yE - y0) / baseLength;\r\n    let cosθ = (xE - x0) / baseLength;\r\n    let box = getNormalizedBoundingBox(ps, sinθ, cosθ);\r\n    let [[p0x, p0y], [p1x, p1y]] = box;\r\n    let axisAlignedBox = [\r\n        box[0], [p1x, p0y],\r\n        box[1], [p0x, p1y]\r\n    ];\r\n    return flo_vector2d_1.rotateThenTranslatePs(sinθ, cosθ, ps[0], axisAlignedBox);\r\n});\r\nexports.getBoundingBoxTight = getBoundingBoxTight;\r\n/**\r\n * Helper function. Returns the bounding box of the normalized (i.e. first point\r\n * moved to origin and rotated so that last point lies on x-axis) given cubic\r\n * bezier.\r\n * @ignore\r\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @param sinθ - Sine of angle made by line from first bezier point to\r\n * last with x-axis.\r\n * @param cosθ - Cosine of angle made by line from first bezier point\r\n * to last with x-axis.\r\n * @returns Bounding box in the form [[minX, minY], [maxX,maxY]\r\n */\r\nfunction getNormalizedBoundingBox(ps, sinθ, cosθ) {\r\n    let vectorToOrigin = ps[0].map(x => -x);\r\n    let boundingPs = flo_vector2d_1.translateThenRotatePs(vectorToOrigin, -sinθ, cosθ, ps);\r\n    return get_bounding_box_1.getBoundingBox(boundingPs);\r\n}\r\n//# sourceMappingURL=get-bounding-box-tight.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/get-bounding-box-tight.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/get-bounding-box.js":
/*!***********************************************************!*\
  !*** ./node_modules/flo-bezier3/node/get-bounding-box.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\r\nconst get_bounds_1 = __webpack_require__(/*! ./get-bounds */ \"./node_modules/flo-bezier3/node/get-bounds.js\");\r\n/**\r\n * Returns the axis-aligned bounding box of a given bezier.\r\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @returns the axis-aligned bounding box in the form\r\n * [[minx, miny], [maxx,maxy]\r\n */\r\nlet getBoundingBox = flo_memoize_1.memoize(function (ps) {\r\n    return get_bounds_1.getBounds(ps).box;\r\n});\r\nexports.getBoundingBox = getBoundingBox;\r\n//# sourceMappingURL=get-bounding-box.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/get-bounding-box.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/get-bounds.js":
/*!*****************************************************!*\
  !*** ./node_modules/flo-bezier3/node/get-bounds.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\r\nconst get_dx_1 = __webpack_require__(/*! ./get-dx */ \"./node_modules/flo-bezier3/node/get-dx.js\");\r\nconst get_dy_1 = __webpack_require__(/*! ./get-dy */ \"./node_modules/flo-bezier3/node/get-dy.js\");\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst evaluate_x_1 = __webpack_require__(/*! ./evaluate-x/evaluate-x */ \"./node_modules/flo-bezier3/node/evaluate-x/evaluate-x.js\");\r\nconst evaluate_y_1 = __webpack_require__(/*! ./evaluate-y/evaluate-y */ \"./node_modules/flo-bezier3/node/evaluate-y/evaluate-y.js\");\r\n/**\r\n * Calculates and returns general bezier bounds.\r\n * @returns The axis-aligned bounding box together with the t values\r\n * where the bounds on the bezier are reached.\r\n */\r\nlet getBounds = flo_memoize_1.memoize(function (ps) {\r\n    // TODO - handle special cases of line / quadratic\r\n    // Roots of derivative\r\n    let roots = [get_dx_1.getDx(ps), get_dy_1.getDy(ps)]\r\n        .map(poly => flo_poly_1.allRoots(poly, 0, 1));\r\n    // Endpoints\r\n    roots[0].push(0, 1);\r\n    roots[1].push(0, 1);\r\n    let minX = Number.POSITIVE_INFINITY;\r\n    let maxX = Number.NEGATIVE_INFINITY;\r\n    let minY = Number.POSITIVE_INFINITY;\r\n    let maxY = Number.NEGATIVE_INFINITY;\r\n    let tMinX = undefined;\r\n    let tMinY = undefined;\r\n    let tMaxX = undefined;\r\n    let tMaxY = undefined;\r\n    // Test points\r\n    for (let i = 0; i < roots[0].length; i++) {\r\n        let t = roots[0][i];\r\n        let x = evaluate_x_1.evaluateX(ps, t);\r\n        if (x < minX) {\r\n            minX = x;\r\n            tMinX = t;\r\n        }\r\n        if (x > maxX) {\r\n            maxX = x;\r\n            tMaxX = t;\r\n        }\r\n    }\r\n    for (let i = 0; i < roots[1].length; i++) {\r\n        let t = roots[1][i];\r\n        let y = evaluate_y_1.evaluateY(ps, t);\r\n        if (y < minY) {\r\n            minY = y;\r\n            tMinY = t;\r\n        }\r\n        if (y > maxY) {\r\n            maxY = y;\r\n            tMaxY = t;\r\n        }\r\n    }\r\n    let ts = [[tMinX, tMinY], [tMaxX, tMaxY]];\r\n    let box = [[minX, minY], [maxX, maxY]];\r\n    return { ts, box };\r\n});\r\nexports.getBounds = getBounds;\r\n//# sourceMappingURL=get-bounds.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/get-bounds.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/get-curvature-extrema/get-curvature-extrema-brackets.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/get-curvature-extrema/get-curvature-extrema-brackets.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst DELTA = 1e-6;\r\n/**\r\n * Calculates the curvature extrema brackets of the given cubic bezier.\r\n * See the paper at http://ac.els-cdn.com/S037704270000529X/1-s2.0-S037704270000529X-main.pdf?_tid=0b25a2cc-ad35-11e5-a728-00000aacb362&acdnat=1451288083_86359fc83af9dec3232c90a6d2e71031\r\n * Note that naming conventions is roughly as in the paper above.\r\n * @param ps\r\n */\r\nfunction getCurvatureExtremaBrackets(ps) {\r\n    let none = { brackets: [], inflections: [] };\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    // Bezier points translated to origin;\r\n    let P_1x = x1 - x0;\r\n    let P_1y = y1 - y0;\r\n    let P_2x = x2 - x0;\r\n    let P_2y = y2 - y0;\r\n    let P_3x = x3 - x0;\r\n    let P_3y = y3 - y0;\r\n    // Distance to consecutive points\r\n    let W_0x = P_1x;\r\n    let W_1x = P_2x - P_1x;\r\n    let W_2x = P_3x - P_2x;\r\n    let W_0y = P_1y;\r\n    let W_1y = P_2y - P_1y;\r\n    let W_2y = P_3y - P_2y;\r\n    // Check for degenerate case in which cubic curve becomes quadratic. \r\n    if ((Math.abs(W_0x - 2 * W_1x + W_2x) < DELTA) &&\r\n        (Math.abs(W_0y - 2 * W_1y + W_2y) < DELTA)) {\r\n        // TODO - This case is simpler due to being quadratic - still needs to\r\n        // be implemented!. \r\n    }\r\n    // See http://ac.els-cdn.com/S037704270000529X/1-s2.0-S037704270000529X-main.pdf?_tid=0b25a2cc-ad35-11e5-a728-00000aacb362&acdnat=1451288083_86359fc83af9dec3232c90a6d2e71031\r\n    // Rotate curve so that W0 - 2W1 + W2 = (0, (1/3)a), a != 0\r\n    let atan_numer = P_3x - 3 * P_2x + 3 * P_1x;\r\n    let atan_denom = P_3y - 3 * P_2y + 3 * P_1y;\r\n    let atan_numer_squared = atan_numer * atan_numer;\r\n    let atan_denom_squared = atan_denom * atan_denom;\r\n    let rad = Math.sqrt((atan_numer_squared / atan_denom_squared) + 1);\r\n    let cos_theta = 1 / rad;\r\n    let sin_theta;\r\n    if (cos_theta === 0) { // edge case\r\n        sin_theta = 1;\r\n    }\r\n    else {\r\n        sin_theta = atan_numer / (atan_denom * rad);\r\n    }\r\n    // Here we skip expensive trig evaluations\r\n    let R_1x = P_1x * cos_theta - P_1y * sin_theta;\r\n    let R_1y = P_1x * sin_theta + P_1y * cos_theta;\r\n    let R_2x = P_2x * cos_theta - P_2y * sin_theta;\r\n    let R_2y = P_2x * sin_theta + P_2y * cos_theta;\r\n    let R_3x = P_3x * cos_theta - P_3y * sin_theta;\r\n    let R_3y = P_3x * sin_theta + P_3y * cos_theta;\r\n    // Modify W_0x, etc. to be correct for new rotated curve \r\n    W_0x = R_1x;\r\n    W_1x = R_2x - R_1x;\r\n    W_2x = R_3x - R_2x;\r\n    W_0y = R_1y;\r\n    W_1y = R_2y - R_1y;\r\n    W_2y = R_3y - R_2y;\r\n    let a = 3 * (W_0y - 2 * W_1y + W_2y);\r\n    let dif = W_1x - W_0x; // === R_2x - 2*R_1x;\r\n    if (dif === 0) {\r\n        // Case 1 (special) - W_1x - W_0x === 0\r\n        // Degenerate to a cubic function (as opposed to parametric cubic)\r\n        if (W_0x === 0) {\r\n            // We have a straight line x=0!\r\n            return none;\r\n        }\r\n        if (W_0x < 0) {\r\n            // Reflect curve accross y-axis to make dif > 0\r\n            R_1x = -R_1x;\r\n            R_2x = -R_2x;\r\n            R_3x = -R_3x;\r\n            // Modify W_0x, etc. to be correct for new reflected \r\n            W_0x = -W_0x;\r\n            W_1x = -W_1x;\r\n            W_2x = -W_2x;\r\n        }\r\n        // TODO - finish\r\n        return none; // WRONG!\r\n    }\r\n    else {\r\n        // Case 2 (usual) - W_1x - W_0x !== 0\r\n        if (dif < 0) {\r\n            // Reflect curve accross y-axis to make dif > 0\r\n            R_1x = -R_1x;\r\n            R_2x = -R_2x;\r\n            R_3x = -R_3x;\r\n            // Modify W_0x, etc. to be correct for new reflected \r\n            W_0x = -W_0x;\r\n            W_1x = -W_1x;\r\n            W_2x = -W_2x;\r\n            dif = -dif;\r\n        }\r\n        // From the paper:\r\n        // ---------------\r\n        // All curves has exactly one of 4 cases:\r\n        //\r\n        // 1. It has a single inflection point and exactly 2 curvature maxima \r\n        //    (symmetrically positioned about inflection point). This is the \r\n        //    case if dif === 0 in above code.\r\n        // 2. TODO - It has a single cusp - ignored for now!\r\n        // 3. It has a point of self-intersection - occurs if d < 0 in paper.\r\n        // 4. It has 2 inflection points, no cusps, no self-intersections.\r\n        //    It can have either 3 or 5 curvature extrema\r\n        //    a. The case of 5 curvature extrema is ignored for now - in the \r\n        //       paper it is mentioned to even find such a curve is difficult \r\n        //       and it seems such curves have very sharp curvature at one point \r\n        //       which does not usually occur in an SVG shape. But this case \r\n        //       should later be included or we'll miss some points.\r\n        //    b. There are 3 curvature extrema:\r\n        //       Extrema occur in the range (-inf, -sqrt(d)), \r\n        //       (-sqrt(d), sqrt(d)), (sqrt(d), inf). \r\n        //       Since we dont know how to select -inf and inf we will just \r\n        //       choose them to be -10 and 11 (remember bezier runs from t=0 to \r\n        //       t=1). If Brent's method runs out of the (0,1) interval we stop \r\n        //       and use 0 or 1 as the extremum? Remember extrema can also occur \r\n        //       at t=0 and t=1!\r\n        //\r\n        // TODO - At the moment we only test for case 1 and 4b, but in future \r\n        // we must test and eliminate the other cases.\r\n        let μ = 6 * dif;\r\n        let λ = (3 * a * W_0x) / (μ * μ);\r\n        let γ1 = (3 * a * W_0y) / (μ * μ);\r\n        let γ2 = (3 * (W_1y - W_0y)) / (μ);\r\n        let d = λ * λ - 2 * γ2 * λ + γ1;\r\n        let b = 2 * (γ2 - λ);\r\n        let deParamBoundary = deParameterizeBoundary(λ, μ, a);\r\n        let deParam = deParameterize(λ, μ, a);\r\n        if (d > 0) {\r\n            let ssigd_ = Math.sqrt(d);\r\n            // de-reparametize\r\n            // Note: the sda and sdb here are the inflection points forcase iv! \r\n            // there are easier ways to calculate these\r\n            let sda = -ssigd_;\r\n            let sdb = ssigd_;\r\n            let brackets = [\r\n                [Number.NEGATIVE_INFINITY, sda],\r\n                [sda, sdb],\r\n                [sdb, Number.POSITIVE_INFINITY]\r\n            ]\r\n                .map(deParamBoundary)\r\n                .map(clipBoundary);\r\n            let inflections = [deParam(sda), deParam(sdb)].filter(v => v > 0 && v < 1);\r\n            //console.log(inflections)\r\n            return { brackets, inflections };\r\n        }\r\n        else if (d < 0) {\r\n            // It is a loop \r\n            // Note: The loop intersection may be outside t=[0,1] but curvature \r\n            // maxima may still occur inside t=[0,1] of course.\r\n            // There can be 1 or 3 maxima of curvature.\r\n            let ξ1_ = 2 * b * b - 8 * d - 3;\r\n            if (ξ1_ < 0) {\r\n                let brackets = [[0, Math.sqrt(-3 * d)]]\r\n                    .map(deParamBoundary)\r\n                    .map(clipBoundary);\r\n                return { brackets, inflections: [] };\r\n            }\r\n            else {\r\n                let ξ2_ = Math.sqrt(5 * ξ1_);\r\n                let ξ1 = (-5 * b - ξ2_) / 10;\r\n                let ξ2 = (-5 * b + ξ2_) / 10;\r\n                let brackets = [\r\n                    [Number.NEGATIVE_INFINITY, ξ1],\r\n                    [ξ1, Math.min(0, ξ2)],\r\n                    [Math.max(0, ξ2), Math.sqrt(-3 * d)]\r\n                ]\r\n                    .map(deParamBoundary)\r\n                    .map(clipBoundary);\r\n                return { brackets, inflections: [] };\r\n            }\r\n        }\r\n        else if (d === 0) {\r\n            // TODO - It is a cusp - still to implement!\r\n            return none;\r\n        }\r\n        else {\r\n            return none; // NaN\r\n        }\r\n    }\r\n}\r\nexports.getCurvatureExtremaBrackets = getCurvatureExtremaBrackets;\r\n/**\r\n * Clips to [0,1] or returns undefined if not within [0,1].\r\n * @param range\r\n */\r\nfunction clipBoundary(range) {\r\n    let [a, b] = range;\r\n    if ((a < 0 && b < 0) || (a > 1 && b > 1)) {\r\n        return undefined;\r\n    }\r\n    if (a < 0) {\r\n        a = 0;\r\n    }\r\n    if (a > 1) {\r\n        a = 1;\r\n    }\r\n    if (b < 0) {\r\n        b = 0;\r\n    }\r\n    if (b > 1) {\r\n        b = 1;\r\n    }\r\n    return [a, b];\r\n}\r\n/**\r\n *\r\n * @param λ\r\n * @param μ\r\n * @param a\r\n */\r\nfunction deParameterize(λ, μ, a) {\r\n    return (σ) => (σ - λ) * (μ / a);\r\n}\r\n/**\r\n *\r\n * @param λ\r\n * @param μ\r\n * @param a\r\n */\r\nfunction deParameterizeBoundary(λ, μ, a) {\r\n    return (boundary) => boundary.map(deParameterize(λ, μ, a));\r\n}\r\n//# sourceMappingURL=get-curvature-extrema-brackets.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/get-curvature-extrema/get-curvature-extrema-brackets.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/get-curvature-extrema/get-curvature-extrema.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/get-curvature-extrema/get-curvature-extrema.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst get_curvature_extrema_brackets_1 = __webpack_require__(/*! ./get-curvature-extrema-brackets */ \"./node_modules/flo-bezier3/node/get-curvature-extrema/get-curvature-extrema-brackets.js\");\r\nconst curvature_1 = __webpack_require__(/*! ../curvature */ \"./node_modules/flo-bezier3/node/curvature.js\");\r\nconst index_1 = __webpack_require__(/*! ../index */ \"./node_modules/flo-bezier3/node/index.js\");\r\n/**\r\n * Finds the osculating circles and inflection points for the given bezier.\r\n * @param ps\r\n */\r\nfunction getCurvatureExtrema(ps) {\r\n    if (ps.length === 2) {\r\n        return { maxCurvatureTs: [], maxNegativeCurvatureTs: [] };\r\n    }\r\n    else if (ps.length === 3) {\r\n        // See e.g. https://math.stackexchange.com/a/2971112\r\n        // TODO\r\n        return { maxCurvatureTs: [], maxNegativeCurvatureTs: [] };\r\n    }\r\n    let maxCurvatureTs = [];\r\n    let maxNegativeCurvatureTs = [];\r\n    let brackets = get_curvature_extrema_brackets_1.getCurvatureExtremaBrackets(ps).brackets;\r\n    let κPs = curvature_1.κ(ps); // The curvature function\r\n    let lenb = brackets.length;\r\n    for (let k = 0; k < lenb; k++) {\r\n        let bracket = brackets[k];\r\n        if (!bracket) {\r\n            continue;\r\n        }\r\n        let root = lookForRoot(ps, bracket);\r\n        if (!root) {\r\n            continue;\r\n        }\r\n        let κ_ = -κPs(root);\r\n        // Check if local extrema is a maximum or minimum.\r\n        let κAtMinsd = -κPs(bracket[0]);\r\n        let κAtMaxsd = -κPs(bracket[1]);\r\n        if (κ_ > κAtMinsd && κ_ > κAtMaxsd) {\r\n            // maximum\r\n            if (κ_ > 0) {\r\n                maxCurvatureTs.push(root);\r\n            }\r\n        }\r\n        else if (κ_ <= κAtMinsd && κ_ <= κAtMaxsd) {\r\n            // minimum\r\n            if (κ_ < 0) {\r\n                maxNegativeCurvatureTs.push(root);\r\n            }\r\n        }\r\n    }\r\n    return { maxCurvatureTs, maxNegativeCurvatureTs };\r\n}\r\nexports.getCurvatureExtrema = getCurvatureExtrema;\r\nfunction lookForRoot(ps, [minsd, maxsd]) {\r\n    // At this point there can be exactly 0 or 1 roots within \r\n    // [minsd, maxsd]\r\n    let dκMod_ = index_1.dκMod(ps);\r\n    let c0 = dκMod_(minsd);\r\n    let c1 = dκMod_(maxsd);\r\n    if (c0 * c1 >= 0) {\r\n        return;\r\n    }\r\n    // There is exactly one root in the interval.\r\n    let root = flo_poly_1.brent(dκMod_, minsd, maxsd);\r\n    return root;\r\n}\r\n//# sourceMappingURL=get-curvature-extrema.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/get-curvature-extrema/get-curvature-extrema.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/get-dddxy.js":
/*!****************************************************!*\
  !*** ./node_modules/flo-bezier3/node/get-dddxy.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the 3rd derivative of the power basis representation of a line,\r\n * quadratic or cubic bezier's x and y-coordinates.\r\n *\r\n * Note: this is a constant value and the same for all t-values and, in\r\n * particular, zero for a line or quadratic.\r\n *\r\n * @param ps An order 1,2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n *\r\n * Bitlength: If the coordinates of the control points are bit-aligned then\r\n * * max bitlength increase === max shift === 6 (for cubics)\r\n * * max bitlength increase === max shift === 0 (for quadratics)\r\n * * max bitlength increase === max shift === 0 (for lines)\r\n *\r\n * @param ps An order 1,2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n */\r\nfunction getDddxy(ps) {\r\n    if (ps.length === 4) {\r\n        let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        return [\r\n            6 * x3 - 18 * x2 + 18 * x1 - 6 * x0,\r\n            6 * y3 - 18 * y2 + 18 * y1 - 6 * y0\r\n        ]; // max bitlength increase 6\r\n    }\r\n    else if (ps.length === 3 || ps.length === 2) {\r\n        return [0, 0];\r\n    }\r\n}\r\nexports.getDddxy = getDddxy;\r\n//# sourceMappingURL=get-dddxy.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/get-dddxy.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/get-ddx.js":
/*!**************************************************!*\
  !*** ./node_modules/flo-bezier3/node/get-ddx.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the 2nd derivative of the power basis representation of a line,\r\n * quadratic or cubic bezier's x-coordinates.\r\n *\r\n * Bitlength: If the coordinates of the control points are grid-aligned then\r\n * max bitlength increase === max shift === 6 (for cubics)\r\n * max bitlength increase === max shift === 3 (for quadratics)\r\n * max bitlength increase === max shift === 0 (for lines)\r\n *\r\n * @param ps An order 1,2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n */\r\nfunction getDdx(ps) {\r\n    if (ps.length === 4) {\r\n        let [[x0,], [x1,], [x2,], [x3,]] = ps;\r\n        return [\r\n            6 * x3 - 18 * x2 + 18 * x1 - 6 * x0,\r\n            6 * x2 - 12 * x1 + 6 * x0 // t^0 - max bitlength increase 5\r\n        ];\r\n    }\r\n    else if (ps.length === 3) {\r\n        let [[x0,], [x1,], [x2,]] = ps;\r\n        return [\r\n            2 * x2 - 4 * x1 + 2 * x0 // t^0 - max bitlength increase 3\r\n        ];\r\n    }\r\n    else if (ps.length === 2) {\r\n        return [0];\r\n    }\r\n}\r\nexports.getDdx = getDdx;\r\n//# sourceMappingURL=get-ddx.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/get-ddx.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/get-ddxy-at-0.js":
/*!********************************************************!*\
  !*** ./node_modules/flo-bezier3/node/get-ddxy-at-0.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the 2nd derivative of the power basis representation of a line,\r\n * quadratic or cubic bezier's x and y-coordinates when evaluated at t === 0.\r\n *\r\n * Bitlength: If the coordinates of the control points are bit-aligned then\r\n * * max bitlength increase === max shift === 5 (for cubics)\r\n * * max bitlength increase === max shift === 3 (for quadratics)\r\n * * max bitlength increase === max shift === 0 (for lines)\r\n *\r\n * @param ps An order 1,2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n */\r\nfunction getDdxyAt0(ps) {\r\n    if (ps.length === 4) {\r\n        let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n        return [\r\n            6 * x2 - 12 * x1 + 6 * x0,\r\n            6 * y2 - 12 * y1 + 6 * y0\r\n        ]; // max bitlength increase 5\r\n    }\r\n    else if (ps.length === 3) {\r\n        let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n        return [\r\n            2 * x2 - 4 * x1 + 2 * x0,\r\n            2 * y2 - 4 * y1 + 2 * y0\r\n        ]; // max bitlength increase 3\r\n    }\r\n    else if (ps.length === 2) {\r\n        return [0, 0];\r\n    }\r\n}\r\nexports.getDdxyAt0 = getDdxyAt0;\r\n//# sourceMappingURL=get-ddxy-at-0.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/get-ddxy-at-0.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/get-ddxy-at-1.js":
/*!********************************************************!*\
  !*** ./node_modules/flo-bezier3/node/get-ddxy-at-1.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the 2nd derivative of the power basis representation of a line,\r\n * quadratic or cubic bezier's x and y-coordinates when evaluated at 1.\r\n *\r\n * This is a seperate function because it allows us to make stronger bitlength\r\n * guarantees.\r\n *\r\n * Bitlength: If the coordinates of the control points are grid-aligned then\r\n * * max bitlength increase === max shift === 5 (for cubics)\r\n * * max bitlength increase === max shift === 3 (for quadratics)\r\n * * max bitlength increase === max shift === 0 (for lines)\r\n *\r\n * @param ps An order 1,2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n */\r\nfunction getDdxyAt1(ps) {\r\n    if (ps.length === 4) {\r\n        let [, [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        return [\r\n            6 * x3 - 12 * x2 + 6 * x1,\r\n            6 * y3 - 12 * y2 + 6 * y1,\r\n        ]; // max bitlength increase 5\r\n    }\r\n    else if (ps.length === 3) {\r\n        let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n        return [\r\n            2 * x2 - 4 * x1 + 2 * x0,\r\n            2 * y2 - 4 * y1 + 2 * y0,\r\n        ]; // max bitlength increase 3\r\n    }\r\n    else if (ps.length === 2) {\r\n        return [0, 0]; // max bitlength increase 0\r\n    }\r\n}\r\nexports.getDdxyAt1 = getDdxyAt1;\r\n//# sourceMappingURL=get-ddxy-at-1.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/get-ddxy-at-1.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/get-ddy.js":
/*!**************************************************!*\
  !*** ./node_modules/flo-bezier3/node/get-ddy.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the 2nd derivative of the power basis representation of a line,\r\n * quadratic or cubic bezier's y-coordinates.\r\n *\r\n * This function is memoized on its points parameter by object reference.\r\n *\r\n * Bitlength: If the coordinates of the control points are grid-aligned then\r\n * max bitlength increase === max shift === 6 (for cubics)\r\n * max bitlength increase === max shift === 3 (for quadratics)\r\n * max bitlength increase === max shift === 0 (for lines)\r\n *\r\n * @param ps An order 1,2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n */\r\nfunction getDdy(ps) {\r\n    if (ps.length === 4) {\r\n        let [[, y0], [, y1], [, y2], [, y3]] = ps;\r\n        return [\r\n            6 * y3 - 18 * y2 + 18 * y1 - 6 * y0,\r\n            6 * y2 - 12 * y1 + 6 * y0 // t^0 - max bitlength increase 5\r\n        ];\r\n    }\r\n    else if (ps.length === 3) {\r\n        let [[, y0], [, y1], [, y2]] = ps;\r\n        return [\r\n            2 * y2 - 4 * y1 + 2 * y0 // t^0 - max bitlength increase 3\r\n        ];\r\n    }\r\n    else if (ps.length === 2) {\r\n        return [0];\r\n    }\r\n}\r\nexports.getDdy = getDdy;\r\n//# sourceMappingURL=get-ddy.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/get-ddy.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/get-dx.js":
/*!*************************************************!*\
  !*** ./node_modules/flo-bezier3/node/get-dx.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the derivative of the power basis representation of a line, quadratic\r\n * or cubic bezier's x-coordinates. This function is memoized on its points\r\n * parameter by object reference.\r\n * @param ps An order 1,2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n */\r\n//let getDx = /*memoize*/((ps: number[][]) => differentiate(getX(ps)));\r\n/**\r\n * Returns the derivative of the power basis representation of a line, quadratic\r\n * or cubic bezier's x-coordinates.\r\n *\r\n * Bitlength: If the coordinates of the control points are grid-aligned then\r\n * max bitlength increase === max shift === 5 (for cubics)\r\n * max bitlength increase === max shift === 3 (for quadratics)\r\n * max bitlength increase === max shift === 1 (for lines)\r\n *\r\n * @param ps An order 1,2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n */\r\nfunction getDx(ps) {\r\n    if (ps.length === 4) {\r\n        let [[x0,], [x1,], [x2,], [x3,]] = ps;\r\n        return [\r\n            3 * x3 - 9 * x2 + 9 * x1 - 3 * x0,\r\n            6 * x2 - 12 * x1 + 6 * x0,\r\n            3 * x1 - 3 * x0 // t^0 - max bitlength increase 3\r\n        ];\r\n    }\r\n    else if (ps.length === 3) {\r\n        let [[x0,], [x1,], [x2,]] = ps;\r\n        return [\r\n            2 * x2 - 4 * x1 + 2 * x0,\r\n            2 * x1 - 2 * x0,\r\n        ];\r\n    }\r\n    else if (ps.length === 2) {\r\n        let [[x0,], [x1,]] = ps;\r\n        return [\r\n            x1 - x0,\r\n        ];\r\n    }\r\n    return [];\r\n}\r\nexports.getDx = getDx;\r\n//# sourceMappingURL=get-dx.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/get-dx.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/get-dxy-at-0.js":
/*!*******************************************************!*\
  !*** ./node_modules/flo-bezier3/node/get-dxy-at-0.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the derivative of the power basis representation of a line, quadratic\r\n * or cubic bezier's x and y-coordinates when evaluated at t === 0.\r\n *\r\n * Bitlength: If the coordinates of the control points are grid-aligned then\r\n * * max bitlength increase === max shift === 3 (for cubics)\r\n * * max bitlength increase === max shift === 2 (for quadratics)\r\n * * max bitlength increase === max shift === 1 (for lines)\r\n *\r\n * @param ps An order 1,2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n */\r\nfunction getDxyAt0(ps) {\r\n    if (ps.length === 4) {\r\n        let [[x0, y0], [x1, y1]] = ps;\r\n        return [\r\n            3 * x1 - 3 * x0,\r\n            3 * y1 - 3 * y0\r\n        ]; // max bitlength increase 3\r\n    }\r\n    else if (ps.length === 3) {\r\n        let [[x0, y0], [x1, y1]] = ps;\r\n        return [\r\n            2 * x1 - 2 * x0,\r\n            2 * y1 - 2 * y0,\r\n        ]; // max bitlength increase 2\r\n    }\r\n    else if (ps.length === 2) {\r\n        let [[x0, y0], [x1, y1]] = ps;\r\n        return [\r\n            x1 - x0,\r\n            y1 - y0,\r\n        ]; // max bitlength increase 1\r\n    }\r\n}\r\nexports.getDxyAt0 = getDxyAt0;\r\n//# sourceMappingURL=get-dxy-at-0.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/get-dxy-at-0.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/get-dxy-at-1.js":
/*!*******************************************************!*\
  !*** ./node_modules/flo-bezier3/node/get-dxy-at-1.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the derivative of the power basis representation of a line, quadratic\r\n * or cubic bezier's x and y-coordinates when evaluated at 1.\r\n *\r\n * This is a seperate function because it allows us to make stronger bitlength\r\n * guarantees.\r\n *\r\n * Bitlength: If the coordinates of the control points are grid-aligned then\r\n * * max bitlength increase === max shift === 3 (for cubics)\r\n * * max bitlength increase === max shift === 2 (for quadratics)\r\n * * max bitlength increase === max shift === 1 (for lines)\r\n *\r\n * @param ps An order 1,2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n */\r\nfunction getDxyAt1(ps) {\r\n    if (ps.length === 4) {\r\n        let [, , [x2, y2], [x3, y3]] = ps;\r\n        return [\r\n            3 * x3 - 3 * x2,\r\n            3 * y3 - 3 * y2,\r\n        ]; // max bitlength increase 3\r\n    }\r\n    else if (ps.length === 3) {\r\n        let [, [x1, y1], [x2, y2]] = ps;\r\n        return [\r\n            2 * x2 - 2 * x1,\r\n            2 * y2 - 2 * y1,\r\n        ]; // max bitlength increase 2\r\n    }\r\n    else if (ps.length === 2) {\r\n        let [[x0, y0], [x1, y1]] = ps;\r\n        return [\r\n            x1 - x0,\r\n            y1 - y0\r\n        ]; // max bitlength increase 1\r\n    }\r\n}\r\nexports.getDxyAt1 = getDxyAt1;\r\n//# sourceMappingURL=get-dxy-at-1.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/get-dxy-at-1.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/get-dy.js":
/*!*************************************************!*\
  !*** ./node_modules/flo-bezier3/node/get-dy.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the derivative of the power basis representation of a line, quadratic\r\n * or cubic bezier y-coordinates. This function is memoized on its points\r\n * parameter by object reference.\r\n * Returns differentiated power basis polynomial from highest\r\n * power to lowest, e.g. at^2 + bt + c is returned as [a,b,c].\r\n * @param ps An order 1,2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n */\r\n//let getDy = /*memoize*/((ps: number[][]) => differentiate(getY(ps)));\r\n/**\r\n * Returns the derivative of the power basis representation of a line, quadratic\r\n * or cubic bezier's y-coordinates.\r\n *\r\n * Bitlength: If the coordinates of the control points are grid-aligned then\r\n * max bitlength increase === max shift === 5 (for cubics)\r\n * max bitlength increase === max shift === 3 (for quadratics)\r\n * max bitlength increase === max shift === 1 (for lines)\r\n *\r\n * @param ps An order 1,2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n */\r\nfunction getDy(ps) {\r\n    if (ps.length === 4) {\r\n        let [[, y0], [, y1], [, y2], [, y3]] = ps;\r\n        return [\r\n            3 * y3 - 9 * y2 + 9 * y1 - 3 * y0,\r\n            6 * y2 - 12 * y1 + 6 * y0,\r\n            3 * y1 - 3 * y0 // t^0 - max bitlength increase 3\r\n        ];\r\n    }\r\n    else if (ps.length === 3) {\r\n        let [[, y0], [, y1], [, y2]] = ps;\r\n        return [\r\n            2 * y2 - 4 * y1 + 2 * y0,\r\n            2 * y1 - 2 * y0,\r\n        ];\r\n    }\r\n    else if (ps.length === 2) {\r\n        let [[, y0], [, y1]] = ps;\r\n        return [\r\n            y1 - y0,\r\n        ];\r\n    }\r\n}\r\nexports.getDy = getDy;\r\n//# sourceMappingURL=get-dy.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/get-dy.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/get-inflections.js":
/*!**********************************************************!*\
  !*** ./node_modules/flo-bezier3/node/get-inflections.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_curvature_extrema_brackets_1 = __webpack_require__(/*! ./get-curvature-extrema/get-curvature-extrema-brackets */ \"./node_modules/flo-bezier3/node/get-curvature-extrema/get-curvature-extrema-brackets.js\");\r\nfunction getInflections(ps) {\r\n    return get_curvature_extrema_brackets_1.getCurvatureExtremaBrackets(ps).inflections;\r\n}\r\nexports.getInflections = getInflections;\r\n//# sourceMappingURL=get-inflections.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/get-inflections.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/get-interface-ccw.js":
/*!************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/get-interface-ccw.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst curvature_1 = __webpack_require__(/*! ./curvature */ \"./node_modules/flo-bezier3/node/curvature.js\");\r\n/**\r\n * Angle in degrees to radians.\r\n * @hidden\r\n */\r\nconst DEGREES = {\r\n    //'0'    : 0.0000,\r\n    0.25: 0.0050,\r\n    1: 0.0167,\r\n    4: 0.0698,\r\n    16: 0.2756,\r\n};\r\n/** @hidden */\r\n//const DEGREE_LIMIT = DEGREES[1];\r\nconst DEGREE_LIMIT = DEGREES[1];\r\n/**\r\n * Returns a positive value if the second bezier (of order 1, 2 or 3) curves\r\n * anti-clockwise with respect to the first at the point where the first bezier\r\n * ends and the second one starts. Returns a negative number if the turn is\r\n * clockwise. Returns 0 otherwise.\r\n *\r\n * The algorithm is a generalization of ccw, a.k.a orient2d.\r\n *\r\n * The above obviously necessitates that their endpoints coincide as described.\r\n *\r\n * Preconditions (for robustness):\r\n * * The beziers has control points with max bit-length of 25 and bit-aligned.\r\n * * The bezier does not have infinite curvature at either endpoint\r\n *\r\n * This is so the vectors between control points can be\r\n * calculated exactly without resorting to adaptive infinite precision floating\r\n * point operations. Note: aligned to 'grid' here means if you bitwise-and all\r\n * values together the resulting bitlength === the max bithlength of any value.\r\n *\r\n * @param psI The incoming bezier that ends at the interface\r\n * @param psO The outgoing bezier that starts at the interface\r\n */\r\nfunction getInterfaceCcw(psI, psO) {\r\n    let lenI = psI.length;\r\n    // second last control point of incoming curve\r\n    let p0 = psI[lenI - 2];\r\n    // last control point of incoming curve / first control point of outgoing\r\n    let p1 = psO[0];\r\n    // second control point of outgoing curve\r\n    let p2 = psO[1];\r\n    /*\r\n    if (typeof _bez_debug_ !== 'undefined') {\r\n        let maxBitLength = 25;\r\n\r\n        let p1_ = psI[lenI-1];\r\n\r\n        // ---- precondition: does endpoints coincide\r\n        if (p1_[0] !== p1[0] || p1_[1] !== p1[1]) {\r\n            throw new Error('Curve endpoints must coincide.');\r\n        }\r\n\r\n        // ---- precondition: are coordinates grid-aligned\r\n\r\n        // Get all coordinate values into an array\r\n        let xs: number[] = [];\r\n        [psI, psO].forEach(ps => ps.forEach(p => p.forEach(x => {\r\n            xs.push(x);\r\n        })));\r\n        \r\n        let msb = xs.reduce((prevX, x) => Math.max(prevX, msbExponent(x)), Number.NEGATIVE_INFINITY);\r\n        let lsb = xs.reduce((prevX, x) => Math.min(prevX, lsbExponent(x)), Number.POSITIVE_INFINITY);\r\n\r\n        let bitlengthAll = msb - lsb + 1;\r\n        if (bitlengthAll > maxBitLength) {\r\n            throw new Error(\r\n                `Curve control point coordinates must be bit-aligned and <= ${maxBitLength}. bitlength === ${bitlengthAll}, coordinates: ${xs}`\r\n            );\r\n        }\r\n    }\r\n    */\r\n    // Max one bit can be added in the calculations below due to bit-alignment\r\n    let xE = p1[0] - p0[0]; // tangent x-coordinate\r\n    let yE = p1[1] - p0[1]; // tangent y-coordinate\r\n    let xS = p2[0] - p1[0]; // tangent x-coordinate\r\n    let yS = p2[1] - p1[1]; // tangent y-coordinate\r\n    // If the tangent is to be found at t === 0 or t === 1 then using a basic \r\n    // property of bezier curves we can find the tangents easily as below\r\n    // (non-normalized) tangent of incoming curve at t === 1\r\n    let tangentAtEnd = [xE, yE];\r\n    // (non-normalized) tangent of outgoing curve at t === 0\r\n    let tangentAtStart = [xS, yS];\r\n    // The cross calculated below will have a max bitlength of \r\n    // (2*(maxBitLength+1))+1 === e.g. (2*(25+1)) + 1 === 53\r\n    // If the preconditions are met it is exact\r\n    //let crossTangents = cross(tangentAtEnd, tangentAtStart);\r\n    // The cross below is exact by adaptive infinite precision\r\n    let crossTangents = flo_numerical_1.orient2d(p0, p1, p2);\r\n    if (crossTangents !== 0) {\r\n        return crossTangents;\r\n    }\r\n    // The dot calculated below will have a max bitlength of \r\n    // (2*(maxBitLength+1))+1 === e.g. (2*(25+1)) + 1 === 53\r\n    // If the preconditions are met it is exact\r\n    let dotTangents = flo_vector2d_1.dot(tangentAtEnd, tangentAtStart);\r\n    if (dotTangents > 0) {\r\n        // Curves go in same direction at interface - neither clock or \r\n        // anti-clockwise.\r\n        // Note: The above comment is not strictly true but as this case is not\r\n        // important for the algorithm we return 0\r\n        return 0;\r\n    }\r\n    // Curves go in opposite directions at interface starting off with the exact\r\n    // same tangent - look now at curvature to see which has the largest \r\n    // curvature so we can base the clock or anti-clockwise result on that\r\n    // Look at curvature\r\n    return curvature_1.compareCurvaturesAtInterface(psI.slice().reverse(), psO);\r\n}\r\nexports.getInterfaceCcw = getInterfaceCcw;\r\n//# sourceMappingURL=get-interface-ccw.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/get-interface-ccw.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/get-tangent-poly-from-point.js":
/*!**********************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/get-tangent-poly-from-point.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the polynomial whose roots are all the t values on the given bezier\r\n * curve such that the line from the given point to the point on the bezier\r\n * evaluated at t is tangent to the bezier at t.\r\n * @param ps An order 1, 2 or 3 bezier curve given by its control points.\r\n * @param p\r\n */\r\nfunction getTangentPolyFromPoint(ps, p) {\r\n    if (ps.length === 4) {\r\n        return getPolyForCubic(ps, p);\r\n    }\r\n    else if (ps.length === 3) {\r\n        return getPolyForQuadratic(ps, p);\r\n    }\r\n    else if (ps.length === 2) {\r\n        return getPolyForLine(ps, p);\r\n    }\r\n}\r\nexports.getTangentPolyFromPoint = getTangentPolyFromPoint;\r\nfunction getPolyForCubic(ps, p) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    let [xp, yp] = p;\r\n    let xx0 = x0 - xp;\r\n    let xx1 = x1 - xp;\r\n    let xx2 = x2 - xp;\r\n    let xx3 = x3 - xp;\r\n    let yy0 = y0 - yp;\r\n    let yy1 = y1 - yp;\r\n    let yy2 = y2 - yp;\r\n    let yy3 = y3 - yp;\r\n    let x00 = xx0 * xx0;\r\n    let x01 = 6 * xx0 * xx1;\r\n    let x02 = 6 * xx0 * xx2;\r\n    let x03 = 2 * xx0 * xx3;\r\n    let x11 = 9 * xx1 * xx1;\r\n    let x12 = 18 * xx1 * xx2;\r\n    let x13 = 6 * xx1 * xx3;\r\n    let x22 = 9 * xx2 * xx2;\r\n    let x23 = 6 * xx2 * xx3;\r\n    let x33 = xx3 * xx3;\r\n    let y00 = yy0 * yy0;\r\n    let y01 = 6 * yy0 * yy1;\r\n    let y02 = 6 * yy0 * yy2;\r\n    let y03 = 2 * yy0 * yy3;\r\n    let y11 = 9 * yy1 * yy1;\r\n    let y12 = 18 * yy1 * yy2;\r\n    let y13 = 6 * yy1 * yy3;\r\n    let y22 = 9 * yy2 * yy2;\r\n    let y23 = 6 * yy2 * yy3;\r\n    let y33 = yy3 * yy3;\r\n    let t5 = 6 * ((x33 - x23 + x13 - x03 + x22 - x12 + x02 + x11 - x01 + x00) +\r\n        (y33 - y23 + y13 - y03 + y22 - y12 + y02 + y11 - y01 + y00));\r\n    let t4 = 5 * ((x23 - 2 * x13 + 3 * x03 - 2 * x22 + 3 * x12 - 4 * x02 - 4 * x11 + 5 * x01 - 6 * x00) +\r\n        (y23 - 2 * y13 + 3 * y03 - 2 * y22 + 3 * y12 - 4 * y02 - 4 * y11 + 5 * y01 - 6 * y00));\r\n    let t3 = 4 * ((x13 - 3 * x03 + x22 - 3 * x12 + 6 * x02 + 6 * x11 - 10 * x01 + 15 * x00) +\r\n        (y13 - 3 * y03 + y22 - 3 * y12 + 6 * y02 + 6 * y11 - 10 * y01 + 15 * y00));\r\n    let t2 = 3 * ((x03 + x12 - 4 * x02 - 4 * x11 + 10 * x01 - 20 * x00) +\r\n        (y03 + y12 - 4 * y02 - 4 * y11 + 10 * y01 - 20 * y00));\r\n    let t1 = 2 * ((x02 + x11 - 5 * x01 + 15 * x00) +\r\n        (y02 + y11 - 5 * y01 + 15 * y00));\r\n    let t0 = ((x01 - 6 * x00) +\r\n        (y01 - 6 * y00));\r\n    return [t5, t4, t3, t2, t1, t0];\r\n}\r\nfunction getPolyForQuadratic(ps, p) {\r\n    let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    let [xp, yp] = p;\r\n    let xx0 = x0 - xp;\r\n    let xx1 = x1 - xp;\r\n    let xx2 = x2 - xp;\r\n    let yy0 = y0 - yp;\r\n    let yy1 = y1 - yp;\r\n    let yy2 = y2 - yp;\r\n    let x00 = 1 * xx0 * xx0;\r\n    let x01 = 1 * xx0 * xx1;\r\n    let x02 = 1 * xx0 * xx2;\r\n    let x11 = 1 * xx1 * xx1;\r\n    let x12 = 1 * xx1 * xx2;\r\n    let x22 = 1 * xx2 * xx2;\r\n    let y00 = 1 * yy0 * yy0;\r\n    let y01 = 1 * yy0 * yy1;\r\n    let y02 = 1 * yy0 * yy2;\r\n    let y11 = 1 * yy1 * yy1;\r\n    let y12 = 1 * yy1 * yy2;\r\n    let y22 = 1 * yy2 * yy2;\r\n    let t3 = 4 * (y22 + 2 * y02 - 4 * y12 + 4 * y11 - 4 * y01 + y00 +\r\n        x22 + 2 * x02 - 4 * x12 + 4 * x11 - 4 * x01 + x00);\r\n    let t2 = 12 * (y12 - y02 - 2 * y11 + 3 * y01 - y00 +\r\n        x12 - x02 - 2 * x11 + 3 * x01 - x00);\r\n    let t1 = 4 * (y02 + 2 * y11 - 6 * y01 + 3 * y00 +\r\n        x02 + 2 * x11 - 6 * x01 + 3 * x00);\r\n    let t0 = 4 * (y01 - y00 +\r\n        x01 - x00);\r\n    return [t3, t2, t1, t0];\r\n}\r\nfunction getPolyForLine(ps, p) {\r\n    let [[x0, y0], [x1, y1]] = ps;\r\n    let [xp, yp] = p;\r\n    let xx0 = x0 - xp;\r\n    let xx1 = x1 - xp;\r\n    let yy0 = y0 - yp;\r\n    let yy1 = y1 - yp;\r\n    let x00 = 1 * xx0 * xx0;\r\n    let x01 = 1 * xx0 * xx1;\r\n    let x11 = 1 * xx1 * xx1;\r\n    let y00 = 1 * yy0 * yy0;\r\n    let y01 = 1 * yy0 * yy1;\r\n    let y11 = 1 * yy1 * yy1;\r\n    let t1 = 2 * (y11 - 2 * y01 + y00 + x11 - 2 * x01 + x00);\r\n    let t0 = 2 * (y01 - y00 + x01 - x00);\r\n    return [t1, t0];\r\n}\r\n//# sourceMappingURL=get-tangent-poly-from-point.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/get-tangent-poly-from-point.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/get-x.js":
/*!************************************************!*\
  !*** ./node_modules/flo-bezier3/node/get-x.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the approximate power basis representation of a line, quadratic or\r\n * cubic bezier's x-coordinates.\r\n *\r\n * If certain preconditions are met (see below) it returns the exact result.\r\n *\r\n * This function is memoized on its points parameter by object reference.\r\n *\r\n * Returns the power basis polynomial from highest power to lowest,\r\n * e.g. at^3 + bt^2 + ct + d is returned as [a,b,c,d]\r\n *\r\n * Bitlength: If the coordinates of the control points are grid-aligned then\r\n * max bitlength increase === max shift === 4 (for cubics)\r\n * (due to 'multiplication' by 9 (3x 6x 3x)\r\n * max bitlength increase === max shift === 2 (for quadratics)\r\n * (due to 'multiplication' by 4 (1x 2x 1x)\r\n * max bitlength increase === max shift === 1 (for lines)\r\n * (due to 'multiplication' by 4 (1x 1x)\r\n *\r\n * @param ps An order 1, 2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n */\r\nfunction getX(ps) {\r\n    if (ps.length === 4) {\r\n        let [[x0,], [x1,], [x2,], [x3,]] = ps;\r\n        return [\r\n            x3 - 3 * x2 + 3 * x1 - x0,\r\n            3 * x2 - 6 * x1 + 3 * x0,\r\n            3 * x1 - 3 * x0,\r\n            x0,\r\n        ];\r\n    }\r\n    else if (ps.length === 3) {\r\n        let [[x0,], [x1,], [x2,]] = ps;\r\n        return [\r\n            x2 - 2 * x1 + x0,\r\n            2 * x1 - 2 * x0,\r\n            x0,\r\n        ];\r\n    }\r\n    else if (ps.length === 2) {\r\n        let [[x0,], [x1,]] = ps;\r\n        return [\r\n            x1 - x0,\r\n            x0,\r\n        ];\r\n    }\r\n}\r\nexports.getX = getX;\r\n//# sourceMappingURL=get-x.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/get-x.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/get-y.js":
/*!************************************************!*\
  !*** ./node_modules/flo-bezier3/node/get-y.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the approximate power basis representation of a line, quadratic or\r\n * cubic bezier's y-coordinates.\r\n *\r\n * If certain preconditions are met (see below) it returns the exact result.\r\n *\r\n * This function is memoized on its points parameter by object reference.\r\n *\r\n * Returns the power basis polynomial from highest power to lowest,\r\n * e.g. at^3 + bt^2 + ct + d is returned as [a,b,c,d]\r\n *\r\n * Bitlength: If the coordinates of the control points are grid-aligned then\r\n * max bitlength increase === max shift === 4 (for cubics)\r\n * (due to 'multiplication' by 9 (3x 6x 3x)\r\n * max bitlength increase === max shift === 2 (for quadratics)\r\n * (due to 'multiplication' by 4 (1x 2x 1x)\r\n * max bitlength increase === max shift === 1 (for lines)\r\n * (due to 'multiplication' by 4 (1x 1x)\r\n *\r\n * @param ps An order 1, 2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n */\r\nlet getY = /*memoize*/ (function (ps) {\r\n    if (ps.length === 4) {\r\n        let [[, y0], [, y1], [, y2], [, y3]] = ps;\r\n        return [\r\n            y3 - 3 * y2 + 3 * y1 - y0,\r\n            3 * y2 - 6 * y1 + 3 * y0,\r\n            3 * y1 - 3 * y0,\r\n            y0,\r\n        ];\r\n    }\r\n    else if (ps.length === 3) {\r\n        let [[, y0], [, y1], [, y2]] = ps;\r\n        return [\r\n            y2 - 2 * y1 + y0,\r\n            2 * y1 - 2 * y0,\r\n            y0,\r\n        ];\r\n    }\r\n    else if (ps.length === 2) {\r\n        let [[, y0], [, y1]] = ps;\r\n        return [\r\n            y1 - y0,\r\n            y0,\r\n        ];\r\n    }\r\n});\r\nexports.getY = getY;\r\n//# sourceMappingURL=get-y.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/get-y.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/hausdorff-distance.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/hausdorff-distance.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst Vector = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst get_x_1 = __webpack_require__(/*! ./get-x */ \"./node_modules/flo-bezier3/node/get-x.js\");\r\nconst get_y_1 = __webpack_require__(/*! ./get-y */ \"./node_modules/flo-bezier3/node/get-y.js\");\r\nconst evaluate_1 = __webpack_require__(/*! ./evaluate/evaluate */ \"./node_modules/flo-bezier3/node/evaluate/evaluate.js\");\r\nconst closest_point_on_bezier_1 = __webpack_require__(/*! ./closest-point-on-bezier */ \"./node_modules/flo-bezier3/node/closest-point-on-bezier.js\");\r\nconst split_by_max_curve_length_1 = __webpack_require__(/*! ./split-by-max-curve-length */ \"./node_modules/flo-bezier3/node/split-by-max-curve-length.js\");\r\nfunction hausdorffDistanceCandidates(ps1, ps2, maxLength) {\r\n    let ts = split_by_max_curve_length_1.splitByMaxCurveLength(ps1, maxLength);\r\n    let candidates = [];\r\n    for (let i = 0; i < ts.length; i++) {\r\n        let t = ts[i];\r\n        let p = evaluate_1.evaluate(ps1, t);\r\n        let v = closest_point_on_bezier_1.closestPointOnBezier(ps2, p);\r\n        candidates.push({\r\n            p1: p,\r\n            p2: v.p,\r\n            d: Vector.distanceBetween(p, v.p)\r\n        });\r\n    }\r\n    return candidates;\r\n}\r\nexports.hausdorffDistanceCandidates = hausdorffDistanceCandidates;\r\n/**\r\n * Calculates and returns an approximation to the one-sided Hausdorff distance\r\n * from ps1 to ps2 between two bezier curves.\r\n * @param ps1\r\n * @param ps2\r\n * @param maxLength The first curve (ps1) will be split into pieces such that\r\n * each piece is shorter than maxLength. All endpoints of the smaller curves\r\n * are then used to check the distance to the other curve. The max of these\r\n * are given as an estimate of the Hausdorff distance.\r\n */\r\nfunction hausdorffDistance(ps1, ps2, maxLength) {\r\n    let candidates = hausdorffDistanceCandidates(ps1, ps2, maxLength);\r\n    let maxD = Number.NEGATIVE_INFINITY;\r\n    for (let candidate of candidates) {\r\n        if (candidate.d > maxD) {\r\n            maxD = candidate.d;\r\n        }\r\n    }\r\n    return maxD;\r\n}\r\nexports.hausdorffDistance = hausdorffDistance;\r\n/**\r\n * TODO: incomplete - but exact (bar numerical imprecision) calculation\r\n * @param ps1\r\n * @param ps2\r\n */\r\nfunction hausdorffDistance_(ps1, ps2) {\r\n    let candidates = hausdorffDistanceCandidates_(ps1, ps2);\r\n    let maxD = Number.NEGATIVE_INFINITY;\r\n    for (let candidate of candidates) {\r\n        if (candidate.d > maxD) {\r\n            maxD = candidate.d;\r\n        }\r\n    }\r\n    return maxD;\r\n}\r\n/**\r\n * TODO - incomplete\r\n * See https://pdfs.semanticscholar.org/dca1/1890c5377ec0bc3b4e252c1d2f438ffa92a2.pdf\r\n * Calculates and returns the one-sided Hausdorff distance from ps1 to ps2\r\n * between two bezier curves. The result is given as an array of a pair of\r\n * candidate points.\r\n */\r\nfunction hausdorffDistanceCandidates_(ps1, ps2) {\r\n    let len1 = ps1.length;\r\n    let ps1s = ps1[0];\r\n    let ps1e = ps1[len1 - 1];\r\n    let len2 = ps2.length;\r\n    let ps2s = ps2[0];\r\n    let ps2e = ps2[len2 - 1];\r\n    let candidates = [];\r\n    // Endpoints\r\n    {\r\n        let { p, t } = closest_point_on_bezier_1.closestPointOnBezier(ps2, ps1s);\r\n        candidates.push({\r\n            p1: ps1s,\r\n            p2: p,\r\n            d: Vector.distanceBetween(ps1s, p)\r\n        });\r\n    }\r\n    {\r\n        let { p, t } = closest_point_on_bezier_1.closestPointOnBezier(ps2, ps1e);\r\n        candidates.push({\r\n            p1: ps1e,\r\n            p2: p,\r\n            d: Vector.distanceBetween(ps1e, p)\r\n        });\r\n    }\r\n    // 3.3.1 Intersection with a point-point bisector\r\n    {\r\n        let x_t = get_x_1.getX(ps1);\r\n        let y_t = get_y_1.getY(ps1);\r\n        let u = ps2s[0];\r\n        let v = ps2s[1];\r\n        let w = ps2e[0];\r\n        let z = ps2e[1];\r\n        let A = flo_poly_1.subtract(x_t, [u]);\r\n        let B = flo_poly_1.subtract(y_t, [v]);\r\n        let C = flo_poly_1.subtract(x_t, [w]);\r\n        let D = flo_poly_1.subtract(y_t, [z]);\r\n        let E = flo_poly_1.add(flo_poly_1.multiply(A, A), flo_poly_1.multiply(B, B));\r\n        let F = flo_poly_1.add(flo_poly_1.multiply(C, C), flo_poly_1.multiply(D, D));\r\n        let G = flo_poly_1.subtract(E, F);\r\n        candidates.push(...flo_poly_1.allRoots(G, 0, 1).map(t => {\r\n            let p1 = evaluate_1.evaluate(ps1, t);\r\n            let p2 = ps2s;\r\n            return { p1, p2, d: Vector.distanceBetween(p1, p2) };\r\n        }));\r\n    }\r\n    // 3.3.2 Intersection with a point-curve bisector - start endpoint\r\n    {\r\n        let xa_t = get_x_1.getX(ps1);\r\n        let ya_t = get_y_1.getY(ps1);\r\n        let xb_s = get_x_1.getX(ps2);\r\n        let yb_s = get_y_1.getY(ps2);\r\n        // FAIL - we need to solve systems of polynomial equations - too hard\r\n        // But in future use Sylvester matrix, etc. to solve - even for systems\r\n        // with 3 or more equations there exist algorithms\r\n        // Alternatively, in case of quad beziers, use the actual self-bisector \r\n        // to intersect - it is just a line\r\n    }\r\n    return candidates;\r\n}\r\n//# sourceMappingURL=hausdorff-distance.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/hausdorff-distance.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/index.js":
/*!************************************************!*\
  !*** ./node_modules/flo-bezier3/node/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nexports.rotate = flo_vector2d_1.rotatePs;\r\nexports.translate = flo_vector2d_1.translatePs;\r\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\r\nconst flo_gauss_quadrature_1 = __webpack_require__(/*! flo-gauss-quadrature */ \"./node_modules/flo-gauss-quadrature/node/index.js\");\r\nconst flo_graham_scan_1 = __webpack_require__(/*! flo-graham-scan */ \"./node_modules/flo-graham-scan/node/index.js\");\r\nconst get_x_1 = __webpack_require__(/*! ./get-x */ \"./node_modules/flo-bezier3/node/get-x.js\");\r\nexports.getX = get_x_1.getX;\r\nconst get_y_1 = __webpack_require__(/*! ./get-y */ \"./node_modules/flo-bezier3/node/get-y.js\");\r\nexports.getY = get_y_1.getY;\r\nconst get_dx_1 = __webpack_require__(/*! ./get-dx */ \"./node_modules/flo-bezier3/node/get-dx.js\");\r\nexports.getDx = get_dx_1.getDx;\r\nconst get_dy_1 = __webpack_require__(/*! ./get-dy */ \"./node_modules/flo-bezier3/node/get-dy.js\");\r\nexports.getDy = get_dy_1.getDy;\r\nconst get_ddx_1 = __webpack_require__(/*! ./get-ddx */ \"./node_modules/flo-bezier3/node/get-ddx.js\");\r\nexports.getDdx = get_ddx_1.getDdx;\r\nconst get_ddy_1 = __webpack_require__(/*! ./get-ddy */ \"./node_modules/flo-bezier3/node/get-ddy.js\");\r\nexports.getDdy = get_ddy_1.getDdy;\r\nconst get_dxy_at_1_1 = __webpack_require__(/*! ./get-dxy-at-1 */ \"./node_modules/flo-bezier3/node/get-dxy-at-1.js\");\r\nexports.getDxyAt1 = get_dxy_at_1_1.getDxyAt1;\r\nconst get_ddxy_at_1_1 = __webpack_require__(/*! ./get-ddxy-at-1 */ \"./node_modules/flo-bezier3/node/get-ddxy-at-1.js\");\r\nexports.getDdxyAt1 = get_ddxy_at_1_1.getDdxyAt1;\r\nconst get_dxy_at_0_1 = __webpack_require__(/*! ./get-dxy-at-0 */ \"./node_modules/flo-bezier3/node/get-dxy-at-0.js\");\r\nexports.getDxyAt0 = get_dxy_at_0_1.getDxyAt0;\r\nconst get_ddxy_at_0_1 = __webpack_require__(/*! ./get-ddxy-at-0 */ \"./node_modules/flo-bezier3/node/get-ddxy-at-0.js\");\r\nexports.getDdxyAt0 = get_ddxy_at_0_1.getDdxyAt0;\r\nconst get_dddxy_1 = __webpack_require__(/*! ./get-dddxy */ \"./node_modules/flo-bezier3/node/get-dddxy.js\");\r\nexports.getDddxy = get_dddxy_1.getDddxy;\r\nconst evaluate_x_1 = __webpack_require__(/*! ./evaluate-x/evaluate-x */ \"./node_modules/flo-bezier3/node/evaluate-x/evaluate-x.js\");\r\nexports.evaluateX = evaluate_x_1.evaluateX;\r\nconst evaluate_y_1 = __webpack_require__(/*! ./evaluate-y/evaluate-y */ \"./node_modules/flo-bezier3/node/evaluate-y/evaluate-y.js\");\r\nexports.evaluateY = evaluate_y_1.evaluateY;\r\nconst evaluate_1 = __webpack_require__(/*! ./evaluate/evaluate */ \"./node_modules/flo-bezier3/node/evaluate/evaluate.js\");\r\nexports.evaluate = evaluate_1.evaluate;\r\nconst evaluate_dx_1 = __webpack_require__(/*! ./evaluate-dx */ \"./node_modules/flo-bezier3/node/evaluate-dx.js\");\r\nexports.evaluateDx = evaluate_dx_1.evaluateDx;\r\nconst evaluate_ddx_1 = __webpack_require__(/*! ./evaluate-ddx */ \"./node_modules/flo-bezier3/node/evaluate-ddx.js\");\r\nexports.evaluateDdx = evaluate_ddx_1.evaluateDdx;\r\nconst evaluate_dy_1 = __webpack_require__(/*! ./evaluate-dy */ \"./node_modules/flo-bezier3/node/evaluate-dy.js\");\r\nexports.evaluateDy = evaluate_dy_1.evaluateDy;\r\nconst evaluate_ddy_1 = __webpack_require__(/*! ./evaluate-ddy */ \"./node_modules/flo-bezier3/node/evaluate-ddy.js\");\r\nexports.evaluateDdy = evaluate_ddy_1.evaluateDdy;\r\nconst tangent_1 = __webpack_require__(/*! ./tangent */ \"./node_modules/flo-bezier3/node/tangent.js\");\r\nexports.tangent = tangent_1.tangent;\r\nconst normal_1 = __webpack_require__(/*! ./normal */ \"./node_modules/flo-bezier3/node/normal.js\");\r\nexports.normal = normal_1.normal;\r\nconst from_0_to_T_1 = __webpack_require__(/*! ./from-0-to-T */ \"./node_modules/flo-bezier3/node/from-0-to-T.js\");\r\nexports.from0ToT = from_0_to_T_1.from0ToT;\r\nconst from_T_to_1_1 = __webpack_require__(/*! ./from-T-to-1 */ \"./node_modules/flo-bezier3/node/from-T-to-1.js\");\r\nexports.fromTTo1 = from_T_to_1_1.fromTTo1;\r\nconst from_to_1 = __webpack_require__(/*! ./from-to */ \"./node_modules/flo-bezier3/node/from-to.js\");\r\nexports.fromTo = from_to_1.fromTo;\r\nexports.fromToPrecise = from_to_1.fromToPrecise;\r\nconst coincident_1 = __webpack_require__(/*! ./coincident */ \"./node_modules/flo-bezier3/node/coincident.js\");\r\nexports.coincident = coincident_1.coincident;\r\nconst line_intersection_1 = __webpack_require__(/*! ./line-intersection */ \"./node_modules/flo-bezier3/node/line-intersection.js\");\r\nexports.lineIntersection = line_intersection_1.lineIntersection;\r\nconst bezier3_intersection_1 = __webpack_require__(/*! ./bezier3-intersection/bezier3-intersection */ \"./node_modules/flo-bezier3/node/bezier3-intersection/bezier3-intersection.js\");\r\nexports.bezier3Intersection = bezier3_intersection_1.bezier3Intersection;\r\nconst bezier3_intersection_sylvester_1 = __webpack_require__(/*! ./bezier3-intersection-sylvester/bezier3-intersection-sylvester_ */ \"./node_modules/flo-bezier3/node/bezier3-intersection-sylvester/bezier3-intersection-sylvester_.js\");\r\nexports.bezier3IntersectionSylvester = bezier3_intersection_sylvester_1.bezier3IntersectionSylvester;\r\nconst ts_at_x_1 = __webpack_require__(/*! ./ts-at-x */ \"./node_modules/flo-bezier3/node/ts-at-x.js\");\r\nexports.tsAtX = ts_at_x_1.tsAtX;\r\nconst ts_at_y_1 = __webpack_require__(/*! ./ts-at-y */ \"./node_modules/flo-bezier3/node/ts-at-y.js\");\r\nexports.tsAtY = ts_at_y_1.tsAtY;\r\nconst debug_1 = __webpack_require__(/*! ./debug/debug */ \"./node_modules/flo-bezier3/node/debug/debug.js\");\r\nexports.BezDebug = debug_1.BezDebug;\r\nconst curvature_1 = __webpack_require__(/*! ./curvature */ \"./node_modules/flo-bezier3/node/curvature.js\");\r\nexports.κ = curvature_1.κ;\r\nconst quad_to_polyline_1 = __webpack_require__(/*! ./quad-to-polyline */ \"./node_modules/flo-bezier3/node/quad-to-polyline.js\");\r\nexports.quadToPolyline = quad_to_polyline_1.quadToPolyline;\r\nconst is_quad_obtuse_1 = __webpack_require__(/*! ./is-quad-obtuse */ \"./node_modules/flo-bezier3/node/is-quad-obtuse.js\");\r\nexports.isQuadObtuse = is_quad_obtuse_1.isQuadObtuse;\r\nconst split_at_1 = __webpack_require__(/*! ./split-at */ \"./node_modules/flo-bezier3/node/split-at.js\");\r\nexports.splitAt = split_at_1.splitAt;\r\nexports.splitAtPrecise = split_at_1.splitAtPrecise;\r\nconst closest_point_on_bezier_1 = __webpack_require__(/*! ./closest-point-on-bezier */ \"./node_modules/flo-bezier3/node/closest-point-on-bezier.js\");\r\nexports.closestPointOnBezier = closest_point_on_bezier_1.closestPointOnBezier;\r\nconst hausdorff_distance_1 = __webpack_require__(/*! ./hausdorff-distance */ \"./node_modules/flo-bezier3/node/hausdorff-distance.js\");\r\nexports.hausdorffDistance = hausdorff_distance_1.hausdorffDistance;\r\nexports.hausdorffDistanceCandidates = hausdorff_distance_1.hausdorffDistanceCandidates;\r\nconst length_upper_bound_1 = __webpack_require__(/*! ./length-upper-bound */ \"./node_modules/flo-bezier3/node/length-upper-bound.js\");\r\nexports.lengthUpperBound = length_upper_bound_1.lengthUpperBound;\r\nconst length_squared_upper_bound_1 = __webpack_require__(/*! ./length-squared-upper-bound */ \"./node_modules/flo-bezier3/node/length-squared-upper-bound.js\");\r\nexports.lengthSquaredUpperBound = length_squared_upper_bound_1.lengthSquaredUpperBound;\r\nconst split_by_max_curve_length_1 = __webpack_require__(/*! ./split-by-max-curve-length */ \"./node_modules/flo-bezier3/node/split-by-max-curve-length.js\");\r\nexports.splitByMaxCurveLength = split_by_max_curve_length_1.splitByMaxCurveLength;\r\nconst get_curvature_extrema_1 = __webpack_require__(/*! ./get-curvature-extrema/get-curvature-extrema */ \"./node_modules/flo-bezier3/node/get-curvature-extrema/get-curvature-extrema.js\");\r\nexports.getCurvatureExtrema = get_curvature_extrema_1.getCurvatureExtrema;\r\nconst get_inflections_1 = __webpack_require__(/*! ./get-inflections */ \"./node_modules/flo-bezier3/node/get-inflections.js\");\r\nexports.getInflections = get_inflections_1.getInflections;\r\nconst flatness_1 = __webpack_require__(/*! ./flatness */ \"./node_modules/flo-bezier3/node/flatness.js\");\r\nexports.flatness = flatness_1.flatness;\r\nconst split_by_max_curvature_1 = __webpack_require__(/*! ./split-by-max-curvature */ \"./node_modules/flo-bezier3/node/split-by-max-curvature.js\");\r\nexports.splitByMaxCurvature = split_by_max_curvature_1.splitByMaxCurvature;\r\nconst split_by_curvature_and_length_1 = __webpack_require__(/*! ./split-by-curvature-and-length */ \"./node_modules/flo-bezier3/node/split-by-curvature-and-length.js\");\r\nexports.splitByCurvatureAndLength = split_by_curvature_and_length_1.splitByCurvatureAndLength;\r\nconst is_point_on_bezier_extension_1 = __webpack_require__(/*! ./is-point-on-bezier-extension */ \"./node_modules/flo-bezier3/node/is-point-on-bezier-extension.js\");\r\nexports.isPointOnBezierExtension = is_point_on_bezier_extension_1.isPointOnBezierExtension;\r\nconst are_beziers_in_same_k_family_1 = __webpack_require__(/*! ./are-beziers-in-same-k-family */ \"./node_modules/flo-bezier3/node/are-beziers-in-same-k-family.js\");\r\nexports.areBeziersInSameKFamily = are_beziers_in_same_k_family_1.areBeziersInSameKFamily;\r\nconst get_interface_ccw_1 = __webpack_require__(/*! ./get-interface-ccw */ \"./node_modules/flo-bezier3/node/get-interface-ccw.js\");\r\nexports.getInterfaceCcw = get_interface_ccw_1.getInterfaceCcw;\r\nconst is_line_1 = __webpack_require__(/*! ./is-line */ \"./node_modules/flo-bezier3/node/is-line.js\");\r\nexports.isLine = is_line_1.isLine;\r\nexports.isHorizontalLine = is_line_1.isHorizontalLine;\r\nexports.isVerticalLine = is_line_1.isVerticalLine;\r\nconst is_self_overlapping_1 = __webpack_require__(/*! ./is-self-overlapping */ \"./node_modules/flo-bezier3/node/is-self-overlapping.js\");\r\nexports.isSelfOverlapping = is_self_overlapping_1.isSelfOverlapping;\r\nconst get_tangent_poly_from_point_1 = __webpack_require__(/*! ./get-tangent-poly-from-point */ \"./node_modules/flo-bezier3/node/get-tangent-poly-from-point.js\");\r\nexports.getTangentPolyFromPoint = get_tangent_poly_from_point_1.getTangentPolyFromPoint;\r\nconst get_bounds_1 = __webpack_require__(/*! ./get-bounds */ \"./node_modules/flo-bezier3/node/get-bounds.js\");\r\nexports.getBounds = get_bounds_1.getBounds;\r\nconst get_bounding_box_tight_1 = __webpack_require__(/*! ./get-bounding-box-tight */ \"./node_modules/flo-bezier3/node/get-bounding-box-tight.js\");\r\nexports.getBoundingBoxTight = get_bounding_box_tight_1.getBoundingBoxTight;\r\nconst get_bounding_box_1 = __webpack_require__(/*! ./get-bounding-box */ \"./node_modules/flo-bezier3/node/get-bounding-box.js\");\r\nexports.getBoundingBox = get_bounding_box_1.getBoundingBox;\r\n/**\r\n * Returns the convex hull of a bezier's control points. This hull bounds the\r\n * bezier curve. This function is memoized.\r\n *\r\n * The tolerance at which the cross product of two nearly collinear lines of the\r\n * hull are considered collinear is 1e-12.\r\n * @param ps - A bezier curve, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @returns An ordered array of convex hull points.\r\n */\r\nlet getBoundingHull = flo_memoize_1.memoize(flo_graham_scan_1.grahamScan);\r\nexports.getBoundingHull = getBoundingHull;\r\n/**\r\n * Returns a cubic bezier from the given line with evenly spaced control points.\r\n * @param l a 2d line represented by two points\r\n * @returns Control points of the cubic bezier.\r\n */\r\nfunction fromLine(l) {\r\n    let [[x0, y0], [x1, y1]] = l;\r\n    let xInterval = (x1 - x0) / 3;\r\n    let yInterval = (y1 - y0) / 3;\r\n    return [\r\n        [x0, y0],\r\n        [x0 + xInterval, y0 + yInterval],\r\n        [x0 + xInterval * 2, y0 + yInterval * 2],\r\n        [x1, y1]\r\n    ];\r\n}\r\nexports.fromLine = fromLine;\r\n/**\r\n * Returns the given bezier's inflection points.\r\n **/\r\nfunction findInflectionPoints(ps) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    // From http://www.caffeineowl.com/graphics/2d/vectorial/cubic-inflexion.html eq. 4\r\n    let ax = x1 - x0;\r\n    let ay = y1 - y0;\r\n    let bx = x2 - x1 - ax;\r\n    let by = y2 - y1 - ay;\r\n    let cx = x3 - x2 - ax - (2 * bx);\r\n    let cy = y3 - y2 - ay - (2 * by);\r\n    // From http://www.caffeineowl.com/graphics/2d/vectorial/cubic-inflexion.html eq. 6:\r\n    //   infl(t) := ax*by - ay*bx + t*(ax*cy - ay*cx) + t^2*(bx*cy - by*cx);\r\n    // We find the roots of the quadratic - a,b,c are the quadratic coefficients\r\n    let a = bx * cy - by * cx;\r\n    let b = ax * cy - ay * cx;\r\n    let c = ax * by - ay * bx;\r\n    let inflectionTs = flo_poly_1.allRoots([a, b, c], 0, 1);\r\n    const evPs = evaluate_1.evaluate(ps);\r\n    return inflectionTs.map(evPs);\r\n}\r\n/**\r\n * Alias of κ.\r\n */\r\nlet curvature = curvature_1.κ;\r\nexports.curvature = curvature;\r\nfunction κds(ps, t) {\r\n    const evDx = evaluate_dx_1.evaluateDx(ps);\r\n    const evDy = evaluate_dy_1.evaluateDy(ps);\r\n    const evDdx = evaluate_ddx_1.evaluateDdx(ps);\r\n    const evDdy = evaluate_ddy_1.evaluateDdy(ps);\r\n    function f(t) {\r\n        let dx = evDx(t);\r\n        let dy = evDy(t);\r\n        let ddx = evDdx(t);\r\n        let ddy = evDdy(t);\r\n        let a = dx * ddy - dy * ddx;\r\n        let b = dx * dx + dy * dy;\r\n        return a / b;\r\n    }\r\n    // Curry\r\n    return t === undefined ? f : f(t);\r\n}\r\nfunction dκMod(ps, t) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    function f(t) {\r\n        let ts = t * t;\r\n        let omt = 1 - t;\r\n        let a = ts * x3;\r\n        let b = ts * y3;\r\n        let c = 2 * t - 3 * ts;\r\n        let d = (3 * t - 1) * omt;\r\n        let e = omt * omt;\r\n        let f = 3 * (a + c * x2 - d * x1 - e * x0);\r\n        let g = 3 * (b + c * y2 - d * y1 - e * y0);\r\n        let h = 6 * (t * y3 - (3 * t - 1) * y2 + (3 * t - 2) * y1 + omt * y0);\r\n        let i = 6 * (t * x3 - (3 * t - 1) * x2 + (3 * t - 2) * x1 + omt * x0);\r\n        let j = Math.sqrt(f * f + g * g);\r\n        return 4 * (f * (y3 - 3 * y2 + 3 * y1 - y0) -\r\n            g * (x3 - 3 * x2 + 3 * x1 - x0)) * Math.pow(j, 3) -\r\n            (f * h - i * g) * (2 * h * g + 2 * i * f) * j;\r\n    }\r\n    return t === undefined ? f : f(t);\r\n}\r\nexports.dκMod = dκMod;\r\n/**\r\n * Categorizes the given cubic bezier curve according to whether it has a loop,\r\n * a cusp, or zero, one or two inflection points all of which are mutually\r\n * exclusive.\r\n *\r\n * See <a href=\"http://graphics.pixar.com/people/derose/publications/CubicClassification/paper.pdf\">\r\n * this</a> paper.\r\n * @param ps A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @returns A value of 'L', 'C', '0', '1', or '2' depending on whether\r\n * the curve has a loop, a cusp, or zero, one or two inflection points.\r\n */\r\nfunction categorize(ps) {\r\n    // TODO - finish\r\n}\r\nfunction totalCurvature(ps, interval) {\r\n    const tanPs = tangent_1.tangent(ps);\r\n    function f(interval) {\r\n        return flo_gauss_quadrature_1.gaussQuadrature(κds(ps), interval);\r\n        // TODO\r\n        /*\r\n        let [a,b] = interval;\r\n        let tangentA = tanPs(a);\r\n        let tangentB = tanPs(b);\r\n        let sinθ = Vector.cross(tanA, tanB)\r\n        */\r\n    }\r\n    // Curry\r\n    return interval === undefined ? f : f(interval);\r\n}\r\nexports.totalCurvature = totalCurvature;\r\nfunction totalAbsoluteCurvature(ps, interval) {\r\n    function f(interval = [0, 1]) {\r\n        // Numerically integrate the absolute curvature\r\n        let result = flo_gauss_quadrature_1.gaussQuadrature(t => Math.abs(κds(ps)(t)), interval);\r\n        return result;\r\n    }\r\n    // Curry\r\n    return interval === undefined ? f : f(interval);\r\n}\r\nexports.totalAbsoluteCurvature = totalAbsoluteCurvature;\r\nfunction length(interval, ps) {\r\n    let fs = [, , length1, length2, length3];\r\n    function f(ps) {\r\n        return fs[ps.length](interval, ps);\r\n    }\r\n    // Curry\r\n    return ps === undefined ? f : f(ps);\r\n}\r\nexports.length = length;\r\n/**\r\n * Returns the curve length in the specified interval. This function is curried.\r\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @param interval - The paramter interval over which the length is\r\n * to be calculated (often === [0,1]).\r\n */\r\nfunction length3(interval, ps) {\r\n    if (interval[0] === interval[1]) {\r\n        return 0;\r\n    }\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    // Keep line below to ensure zero length curve returns zero!\r\n    if (x0 === x1 && x1 === x2 && x2 === x3 &&\r\n        y0 === y1 && y1 === y2 && y2 === y3) {\r\n        return 0;\r\n    }\r\n    const evDs = ds(ps);\r\n    return flo_gauss_quadrature_1.gaussQuadrature(evDs, interval);\r\n}\r\n/**\r\n * Returns the curve length in the specified interval. This function is curried.\r\n * Unused because it is not numerically stable in its current form.\r\n * See https://gist.github.com/tunght13488/6744e77c242cc7a94859\r\n * @param ps - A quadratic bezier, e.g. [[0,0],[1,1],[2,1]]\r\n * @param interval - The paramter interval over which the length is\r\n * to be calculated (often === [0,1]).\r\n */\r\n/*\r\nfunction length2(interval: number[], ps: number[][]) {\r\n    if (interval[0] === interval[1]) { return 0; }\r\n\r\n    let [[x0_, y0_], [x1_, y1_], [x2_, y2_]] = ps;\r\n    // Keep line below to ensure zero length curve returns zero!\r\n    if (x0_ === x1_ && x1_ === x2_ && y0_ === y1_ && y1_ === y2_) {\r\n        return 0;\r\n    }\r\n\r\n    let [[x0, y0], [x1, y1], [x2, y2]] =\r\n            fromTo(ps)(interval[0], interval[1]);\r\n\r\n    let ax = x0 - 2*x1 + x2;\r\n    let ay = y0 - 2*y1 + y2;\r\n    let bx = 2*x1 - 2*x0;\r\n    let by = 2*y1 - 2*y0;\r\n\r\n    let A = 4 * (ax*ax + ay*ay);\r\n    let B = 4 * (ax*bx + ay*by);\r\n    let C = bx*bx + by*by;\r\n\r\n    let Sabc = 2*Math.sqrt(A+B+C);\r\n    let A_2 = Math.sqrt(A);\r\n    let A_32 = 2*A*A_2;\r\n    let C_2 = 2*Math.sqrt(C);\r\n    let BA = B/A_2;\r\n\r\n    return (\r\n        A_32*Sabc + A_2*B*(Sabc - C_2) +\r\n        (4*C*A - B*B)*Math.log((2*A_2 + BA + Sabc) / (BA + C_2))\r\n    ) / (4*A_32);\r\n}\r\n*/\r\n/**\r\n * Returns the curve length in the specified interval. This function is curried.\r\n * @param ps A quadratic bezier, e.g. [[0,0],[1,1],[2,1]]\r\n * @param interval The paramter interval over which the length is\r\n * to be calculated (often === [0,1]).\r\n */\r\nfunction length2(interval, ps) {\r\n    if (interval[0] === interval[1]) {\r\n        return 0;\r\n    }\r\n    let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    // Ensure zero length curve returns zero!\r\n    if (x0 === x1 && x1 === x2 && y0 === y1 && y1 === y2) {\r\n        return 0;\r\n    }\r\n    const evDs = ds(ps);\r\n    return flo_gauss_quadrature_1.gaussQuadrature(evDs, interval);\r\n}\r\nfunction length1(interval, ps) {\r\n    let [t1, t2] = interval;\r\n    if (t1 === t2) {\r\n        return 0;\r\n    }\r\n    let [[x0, y0], [x1, y1]] = ps;\r\n    // Keep line below to ensure zero length curve returns zero!\r\n    if (x0 === x1 && y0 === y1) {\r\n        return 0;\r\n    }\r\n    let p1 = [x0 + t1 * (x1 - x0), y0 + t1 * (y1 - y0)];\r\n    let p2 = [x0 + t2 * (x1 - x0), y0 + t2 * (y1 - y0)];\r\n    return flo_vector2d_1.distanceBetween(p1, p2);\r\n}\r\nfunction getTAtLength(ps, s) {\r\n    let ps_ = toCubic(ps);\r\n    const lenAtT = (t) => length([0, t], ps_);\r\n    function f(s) {\r\n        return flo_poly_1.brent(t => (lenAtT(t) - s), -0.1, 1.1);\r\n    }\r\n    // Curry\r\n    return s === undefined ? f : f(s);\r\n}\r\nexports.getTAtLength = getTAtLength;\r\nfunction ds(ps, t) {\r\n    const evDx = evaluate_dx_1.evaluateDx(ps);\r\n    const evDy = evaluate_dy_1.evaluateDy(ps);\r\n    function f(t) {\r\n        let dx = evDx(t);\r\n        let dy = evDy(t);\r\n        return Math.sqrt(dx * dx + dy * dy);\r\n    }\r\n    // Curry\r\n    return t === undefined ? f : f(t);\r\n}\r\nexports.ds = ds;\r\n/**\r\n * Returns a new bezier from the given bezier by limiting its t range.\r\n *\r\n * Uses de Casteljau's algorithm.\r\n *\r\n * @param ps A bezier\r\n * @param tRange A t range\r\n */\r\nfunction bezierFromBezierPiece(ps, tRange) {\r\n    // If tRange = [0,1] then return original bezier.\r\n    if (tRange[0] === 0 && tRange[1] === 1) {\r\n        return ps;\r\n    }\r\n    // If tRange[0] === tRange[1] then return a single point degenerated bezier.\r\n    if (tRange[0] === tRange[1]) {\r\n        let p = evaluate_1.evaluate(ps)(tRange[0]);\r\n        return [p, p, p, p];\r\n    }\r\n    if (tRange[0] === 0) {\r\n        return from_0_to_T_1.from0ToT(ps, tRange[1]);\r\n    }\r\n    if (tRange[1] === 1) {\r\n        return from_T_to_1_1.fromTTo1(ps, tRange[0]);\r\n    }\r\n    // At this stage we know the t range is not degenerate and tRange[0] !== 0 \r\n    // and tRange[1] !== 1\r\n    return from_0_to_T_1.from0ToT(from_T_to_1_1.fromTTo1(ps, tRange[0]), (tRange[1] - tRange[0]) / (1 - tRange[0]));\r\n}\r\nexports.bezierFromBezierPiece = bezierFromBezierPiece;\r\n/**\r\n * Returns a human readable string representation of the given bezier.\r\n * @param ps - A bezier curve\r\n */\r\nfunction toString(ps) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    return `[[${x0},${y0}],[${x1},${y1}],[${x2},${y2}],[${x3},${y3}]]`;\r\n}\r\nexports.toString = toString;\r\n/**\r\n * Scales all control points of the given bezier by the given factor.\r\n * @param ps - A bezier curve\r\n * @param c - The scale factor\r\n */\r\nfunction scale(ps, c) {\r\n    return ps.map(x => [x[0] * c, x[1] * c]);\r\n}\r\nexports.scale = scale;\r\n/**\r\n * Returns the best least squares quadratic bezier approximation to the given\r\n * cubic bezier. Note that the two bezier endpoints differ in general.\r\n * @param ps - A cubic bezier curve.\r\n */\r\nfunction toQuadratic(ps) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    return [\r\n        [(19 / 20) * x0 + (3 / 20) * x1 + (-3 / 20) * x2 + (1 / 20) * x3,\r\n            (19 / 20) * y0 + (3 / 20) * y1 + (-3 / 20) * y2 + (1 / 20) * y3],\r\n        [(-1 / 4) * x0 + (3 / 4) * x1 + (3 / 4) * x2 + (-1 / 4) * x3,\r\n            (-1 / 4) * y0 + (3 / 4) * y1 + (3 / 4) * y2 + (-1 / 4) * y3],\r\n        [(1 / 20) * x0 + (-3 / 20) * x1 + (3 / 20) * x2 + (19 / 20) * x3,\r\n            (1 / 20) * y0 + (-3 / 20) * y1 + (3 / 20) * y2 + (19 / 20) * y3]\r\n    ];\r\n}\r\nexports.toQuadratic = toQuadratic;\r\n/**\r\n * Evaluates the given hybrid quadratic at the given t and th parameters. (see\r\n * toHybridQuadratic for details).\r\n * @param hq - A hybrid quadratic\r\n * @param t - The bezier parameter value\r\n * @param th - The parameter value for the hybrid quadratic point.\r\n */\r\nfunction evaluateHybridQuadratic(\r\n//hq: (number[] | number[][])[],\r\nhq, t, th) {\r\n    let P0 = hq[0];\r\n    let P1 = evaluate_1.evaluate(hq[1], th);\r\n    let P2 = hq[2];\r\n    //let P1 = evaluateLinear(<number[][]>hq[1], th);\r\n    //\tlet P1 = evaluate(hq[1], th);\r\n    //return evaluateQuadratic([P0, P1, P2], t);\r\n    return evaluate_1.evaluate([P0, P1, P2], t);\r\n}\r\nexports.evaluateHybridQuadratic = evaluateHybridQuadratic;\r\n/**\r\n * Evaluates the given linear bezier (line) at a specific t value.\r\n * @param ps - A linear bezier curve.\r\n * @param t - The value where the bezier should be evaluated\r\n */ /*\r\nfunction evaluateLinear(ps: number[][], t: number) {\r\n   let [[x0,y0],[x1,y1]] = ps;\r\n\r\n   let x = x0*(1-t) + x1*t;\r\n   let y = y0*(1-t) + y1*t;\r\n\r\n   return [x,y];\r\n}*/\r\n/**\r\n * Returns a clone of the given cubic bezier (with a different reference).\r\n * @param ps A cubic bezier given by its array of control points\r\n */\r\nfunction clone(ps) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    return [[x0, y0], [x1, y1], [x2, y2], [x3, y3]];\r\n}\r\nexports.clone = clone;\r\n/**\r\n * Evaluates the given quadratic bezier at a specific t value.\r\n * @param ps - A quadratic bezier curve.\r\n * @param t - The value where the bezier should be evaluated\r\n */ /*\r\nfunction evaluateQuadratic(ps: number[][], t: number) {\r\n   let [[x0,y0],[x1,y1],[x2,y2]] = ps;\r\n\r\n   let x = x0*(1-t)**2 + x1*2*(1-t)*t + x2*t**2;\r\n   let y = y0*(1-t)**2 + y1*2*(1-t)*t + y2*t**2;\r\n\r\n   return [x,y];\r\n}\r\n*/\r\n/**\r\n * Returns the cubic version of the given quadratic bezier curve. Quadratic\r\n * bezier curves can always be represented by cubics - the converse is false.\r\n * @param ps - A quadratic bezier curve.\r\n */\r\nfunction quadraticToCubic(ps) {\r\n    let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    return [\r\n        [x0, y0],\r\n        [(1 / 3) * x0 + (2 / 3) * x1, (1 / 3) * y0 + (2 / 3) * y1],\r\n        [(2 / 3) * x1 + (1 / 3) * x2, (2 / 3) * y1 + (1 / 3) * y2],\r\n        [x2, y2]\r\n    ];\r\n}\r\nexports.quadraticToCubic = quadraticToCubic;\r\nfunction linearToCubic(ps) {\r\n    let [[x0, y0], [x1, y1]] = ps;\r\n    let xInterval = (x1 - x0) / 3;\r\n    let yInterval = (y1 - y0) / 3;\r\n    return [\r\n        [x0, y0],\r\n        [x0 + xInterval * 1, y0 + yInterval * 1],\r\n        [x0 + xInterval * 2, y0 + yInterval * 2],\r\n        [x1, y1]\r\n    ];\r\n}\r\nexports.linearToCubic = linearToCubic;\r\n/**\r\n * Returns a cubic bezier curve that is equivalent to the given linear or\r\n * quadratic bezier curve. Cubics are just returned unaltered.\r\n * @param ps An order 1, 2 or 3 bezier curve\r\n */\r\nfunction toCubic(ps) {\r\n    if (ps.length === 2) { // Linear\r\n        return linearToCubic(ps);\r\n    }\r\n    else if (ps.length === 3) { // Quadratic\r\n        return quadraticToCubic(ps);\r\n    }\r\n    else if (ps.length === 4) { // Cubic\r\n        return ps;\r\n    }\r\n}\r\nexports.toCubic = toCubic;\r\n/**\r\n * Returns the given points (e.g. bezier) in reverse order.\r\n * @param ps\r\n */\r\nfunction reverse(ps) {\r\n    return ps.slice().reverse();\r\n}\r\nexports.reverse = reverse;\r\nfunction equal(psA, psB) {\r\n    let [[ax0, ay0], [ax1, ay1], [ax2, ay2], [ax3, ay3]] = psA;\r\n    let [[bx0, by0], [bx1, by1], [bx2, by2], [bx3, by3]] = psB;\r\n    return (ax0 === bx0 && ax1 === bx1 && ax2 === bx2 && ax3 === bx3 &&\r\n        ay0 === by0 && ay1 === by1 && ay2 === by2 && ay3 === by3);\r\n}\r\nexports.equal = equal;\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/index.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/is-line.js":
/*!**************************************************!*\
  !*** ./node_modules/flo-bezier3/node/is-line.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\n/**\r\n * Returns true if the given bezier is a line or a line in diguise, i.e. if all\r\n * control points are collinear.\r\n *\r\n * Robust: Robust for any bitlength of the given coordinates.\r\n * @param ps An order 1, 2 or 3 bezier curve.\r\n */\r\nfunction isLine(ps) {\r\n    if (ps.length === 2) {\r\n        // Line\r\n        return true;\r\n    }\r\n    if (ps.length === 3) {\r\n        // Quadratic bezier\r\n        return flo_numerical_1.orient2d(ps[0], ps[1], ps[2]) === 0;\r\n    }\r\n    if (ps.length === 4) {\r\n        // Cubic bezier\r\n        return (flo_numerical_1.orient2d(ps[0], ps[1], ps[2]) === 0 &&\r\n            flo_numerical_1.orient2d(ps[1], ps[2], ps[3]) === 0 &&\r\n            // The below check is necessary for if ps[1] === ps[2]\r\n            flo_numerical_1.orient2d(ps[0], ps[2], ps[3]) === 0);\r\n    }\r\n}\r\nexports.isLine = isLine;\r\n/**\r\n * Returns true if the given bezier degenerates to a horizontal line (possibly\r\n * self-overlapping)\r\n * @param ps An order 1, 2 or 3 bezier curve.\r\n */\r\nfunction isHorizontalLine(ps) {\r\n    let y = ps[0][1];\r\n    for (let i = 1; i < ps.length; i++) {\r\n        if (ps[i][1] !== y) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexports.isHorizontalLine = isHorizontalLine;\r\n/**\r\n * Returns true if the given bezier degenerates to a vertical line (possibly\r\n * self-overlapping)\r\n * @param ps An order 1, 2 or 3 bezier curve.\r\n */\r\nfunction isVerticalLine(ps) {\r\n    let x = ps[0][0];\r\n    for (let i = 1; i < ps.length; i++) {\r\n        if (ps[i][0] !== x) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexports.isVerticalLine = isVerticalLine;\r\n//# sourceMappingURL=is-line.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/is-line.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/is-point-on-bezier-extension.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/is-point-on-bezier-extension.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_x_1 = __webpack_require__(/*! ./get-x */ \"./node_modules/flo-bezier3/node/get-x.js\");\r\nconst get_y_1 = __webpack_require__(/*! ./get-y */ \"./node_modules/flo-bezier3/node/get-y.js\");\r\nconst det_naive_1 = __webpack_require__(/*! ./matrix/det-naive */ \"./node_modules/flo-bezier3/node/matrix/det-naive.js\");\r\n/**\r\n * Returns true if the given point is on the given bezier curve where the\r\n * parameter t is allowed to extend to +-infinity, i.e. t is an element of\r\n * [-inf, +inf], false otherwise.\r\n *\r\n * Exact: This algorithm uses exact floating point arithmetic and thus not\r\n * susceptible to round-off error.\r\n *\r\n * Precondition: ps and p must be grid-aligned and have a maximum bitlength\r\n * of 50.\r\n * (note: it is relatively easy to extend the algorithm to relax this condition\r\n * but would then run much slower)\r\n * (note: 53 - 3 = 50 bits due to the power representation calculation that\r\n * multiplies the coordinates by 1,2,3, or 6. When multiplied by 6 a coordinate\r\n * can move 3 bits off the grid (to the left of course)\r\n */\r\nfunction isPointOnBezierExtension(ps, p) {\r\n    let ps_ = ps.slice();\r\n    if (typeof _bez_debug_ !== 'undefined') {\r\n        // Check precondition\r\n        for (let p of ps_) {\r\n            //if (bitLength())\r\n        }\r\n    }\r\n    // Get power basis\r\n    let x = get_x_1.getX(ps_);\r\n    let y = get_y_1.getY(ps_);\r\n    // Move to origin\r\n    x[x.length - 1] -= p[0];\r\n    y[y.length - 1] -= p[1];\r\n    let a = 0;\r\n    let b = 0;\r\n    let c = 0;\r\n    let d = 0;\r\n    let e = 0;\r\n    let f = 0;\r\n    let g = 0;\r\n    let h = 0;\r\n    if (x.length === 4) {\r\n        [a, b, c, d] = x;\r\n    }\r\n    else if (x.length === 3) {\r\n        [b, c, d] = x;\r\n    }\r\n    else if (x.length === 2) {\r\n        [c, d] = x;\r\n    }\r\n    if (y.length === 4) {\r\n        [e, f, g, h] = y;\r\n    }\r\n    else if (y.length === 3) {\r\n        [f, g, h] = y;\r\n    }\r\n    else if (y.length === 2) {\r\n        [g, h] = y;\r\n    }\r\n    // first non-zero x power\r\n    let fnzX = a !== 0 ? 3 :\r\n        b !== 0 ? 2 :\r\n            c !== 0 ? 1 :\r\n                d !== 0 ? 0 : -1;\r\n    // first non-zero y power\r\n    let fnzY = e !== 0 ? 3 :\r\n        f !== 0 ? 2 :\r\n            g !== 0 ? 1 :\r\n                h !== 0 ? 0 : -1;\r\n    // Swap if necessary\r\n    if (fnzX < fnzY) {\r\n        [fnzX, fnzY] = [fnzY, fnzX];\r\n        [a, e] = [e, a];\r\n        [b, f] = [f, b];\r\n        [c, g] = [g, c];\r\n        [d, h] = [h, d];\r\n    }\r\n    // The sylvester matrix\r\n    let S;\r\n    if (fnzX === 3 && fnzY === 3) {\r\n        S = [\r\n            [a, b, c, d, 0, 0],\r\n            [0, a, b, c, d, 0],\r\n            [0, 0, a, b, c, d],\r\n            [e, f, g, h, 0, 0],\r\n            [0, e, f, g, h, 0],\r\n            [0, 0, e, f, g, h]\r\n        ];\r\n    }\r\n    else if (fnzX === 3 && fnzY === 2) {\r\n        S = [\r\n            [a, b, c, d, 0],\r\n            [0, a, b, c, d],\r\n            [f, g, h, 0, 0],\r\n            [0, f, g, h, 0],\r\n            [0, 0, f, g, h]\r\n        ];\r\n    }\r\n    else if (fnzX === 3 && fnzY === 1) {\r\n        S = [\r\n            [a, b, c, d],\r\n            [g, h, 0, 0],\r\n            [0, g, h, 0],\r\n            [0, 0, g, h]\r\n        ];\r\n    }\r\n    else if (fnzX === 3 && fnzY === 0) {\r\n        // of course we can take a shortcut here - left for symmetry\r\n        return false;\r\n        /*\r\n        S = [\r\n            [h,0,0],\r\n            [0,h,0],\r\n            [0,0,h]\r\n        ];\r\n        */\r\n    }\r\n    else if (fnzX === 3 && fnzY === -1) {\r\n        // This is a cubic curve that 'loops' back on itself - it degenrates into\r\n        // a self-overlapping line. The point is on the curve.\r\n        return true;\r\n    }\r\n    else if (fnzX === 2 && fnzY === 2) {\r\n        S = [\r\n            [b, c, d, 0],\r\n            [0, b, c, d],\r\n            [f, g, h, 0],\r\n            [0, f, g, h]\r\n        ];\r\n    }\r\n    else if (fnzX === 2 && fnzY === 1) {\r\n        S = [\r\n            [b, c, d],\r\n            [g, h, 0],\r\n            [0, g, h]\r\n        ];\r\n    }\r\n    else if (fnzX === 2 && fnzY === 0) {\r\n        return false;\r\n        // Below just kept for the sake of symmetry\r\n        /*\r\n        S = [\r\n            [h,0],\r\n            [0,h]\r\n        ];\r\n        */\r\n    }\r\n    else if (fnzX === 2 && fnzY === -1) {\r\n        // This is a cubic curve that 'loops' back on itself - it degenrates into\r\n        // a self-overlapping line. The point may be on the curve?.\r\n        return true;\r\n    }\r\n    else if (fnzX === 1 && fnzY === 1) {\r\n        // x(t) is a line, y(t) is also a line\r\n        S = [\r\n            [c, d],\r\n            [g, h]\r\n        ];\r\n    }\r\n    else if (fnzX === 1 && fnzY === 0) {\r\n        // x(t) is a line, y(t) === d\r\n        // This degenerates into the line y(x) === d\r\n        return false;\r\n        //S = [[h]];\r\n    }\r\n    else if (fnzX === 1 && fnzY === -1) {\r\n        // x(t) is a line, y(t) === 0\r\n        // This is a line y(x) === 0. The point is on the curve.\r\n        return true;\r\n    }\r\n    else if (fnzX === 0 && fnzY === 0) {\r\n        // x(t) is a constant !== 0, y(t) is a constant !== 0\r\n        // This is a bezier degenerated into a point\r\n        return false;\r\n    }\r\n    else if (fnzX === 0 && fnzY === -1) {\r\n        // x(t) is a constant !== 0, y(t) === 0\r\n        // This is also a bezier degenerated into a point\r\n        return false;\r\n    }\r\n    else if (fnzX === -1 && fnzY === -1) {\r\n        // x(t) === 0, y(t) === 0\r\n        // This is also a bezier degenerated into a point, but the point is\r\n        // identical to the input point!\r\n        return true;\r\n    }\r\n    let detS = det_naive_1.detSlowExact(S.map(row => row.map(x => [x])));\r\n    return detS[detS.length - 1] === 0;\r\n}\r\nexports.isPointOnBezierExtension = isPointOnBezierExtension;\r\n//# sourceMappingURL=is-point-on-bezier-extension.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/is-point-on-bezier-extension.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/is-quad-flat.js":
/*!*******************************************************!*\
  !*** ./node_modules/flo-bezier3/node/is-quad-flat.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vector = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst is_quad_obtuse_1 = __webpack_require__(/*! ./is-quad-obtuse */ \"./node_modules/flo-bezier3/node/is-quad-obtuse.js\");\r\nconst evaluate_1 = __webpack_require__(/*! ./evaluate/evaluate */ \"./node_modules/flo-bezier3/node/evaluate/evaluate.js\");\r\n/**\r\n * Returns true if the given quadratic bezier curve is acute (see isQuadObtuse)\r\n * and can be approximated with a line segment with maximum Hausdorff distance\r\n * <= the given tolerance.\r\n * @param ps A quadratic bezier curve.\r\n */\r\nfunction isQuadFlat(ps, tolerance) {\r\n    if (is_quad_obtuse_1.isQuadObtuse(ps)) {\r\n        return false;\r\n    }\r\n    let [[x1, y1], , [x2, y2]] = ps;\r\n    if (x1 === x2 && y1 === y2) {\r\n        return true;\r\n    }\r\n    let [x0, y0] = evaluate_1.evaluate(ps, 0.5);\r\n    let numerator = Math.pow(((y2 - y1) * x0 - (x2 - x1) * y0 + x2 * y1 - y2 * x1), 2);\r\n    let denominator = vector.squaredDistanceBetween(ps[0], ps[2]);\r\n    let dSquared = Math.abs(numerator / denominator);\r\n    return dSquared < Math.pow(tolerance, 2);\r\n}\r\nexports.isQuadFlat = isQuadFlat;\r\n//# sourceMappingURL=is-quad-flat.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/is-quad-flat.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/is-quad-obtuse.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-bezier3/node/is-quad-obtuse.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\n/**\r\n * Returns true if the given quadratic bezier is obtuse, false otherwise (i.e.\r\n * false if acute).\r\n * Obtuse here is defined as follows: Let the quad form a triangle through its\r\n * control points P0, P1, P2 where P0 and P2 are the endpoints. If both interior\r\n * angles ∠P0 and ∠P2 are <= 90 degrees then the quad is considered acute,\r\n * otherwise it is considered obtuse.\r\n */\r\nfunction isQuadObtuse(ps) {\r\n    let v0 = flo_vector2d_1.fromTo(ps[0], ps[1]);\r\n    let v1 = flo_vector2d_1.fromTo(ps[1], ps[2]);\r\n    let v2 = flo_vector2d_1.fromTo(ps[2], ps[0]);\r\n    let angleP0Obtuse = flo_vector2d_1.dot(v2, v0) > 0;\r\n    let angleP2Obtuse = flo_vector2d_1.dot(v1, v2) > 0;\r\n    return angleP0Obtuse || angleP2Obtuse;\r\n}\r\nexports.isQuadObtuse = isQuadObtuse;\r\n//# sourceMappingURL=is-quad-obtuse.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/is-quad-obtuse.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/is-self-overlapping.js":
/*!**************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/is-self-overlapping.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst is_line_1 = __webpack_require__(/*! ./is-line */ \"./node_modules/flo-bezier3/node/is-line.js\");\r\n/**\r\n * Returns true if the given bezier is a line and self-overlapping, i.e. if it\r\n * intersects itself at an infinite number of points.\r\n *\r\n * Note: A bezier curve can only intersect itself at an infinite number of\r\n * points if is a self-overlapping line.\r\n *\r\n * Robust: This function is robust via adaptive infinite precision floating\r\n * point arithmetic.\r\n * @param ps An order 1, 2 or 3 bezier curve\r\n */\r\nfunction isSelfOverlapping(ps) {\r\n    if (!is_line_1.isLine(ps)) {\r\n        return false;\r\n    }\r\n    // Check if control points are non-strict monotone\r\n    let xs = ps.map(p => p[0]);\r\n    let ys = ps.map(p => p[1]);\r\n    return !(isMonotone(xs) && isMonotone(ys));\r\n}\r\nexports.isSelfOverlapping = isSelfOverlapping;\r\n/**\r\n * Returns true if the given array of numbers are non-strict monotone increasing.\r\n * @param xs An array of numbers\r\n */\r\nfunction isMonotoneIncreasing(xs) {\r\n    for (let i = 1; i < xs.length; i++) {\r\n        if (xs[i - 1] > xs[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Returns true if the given array of numbers are non-strict monotone decreasing.\r\n * @param xs An array of numbers\r\n */\r\nfunction isMonotoneDecreasing(xs) {\r\n    for (let i = 1; i < xs.length; i++) {\r\n        if (xs[i - 1] < xs[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction isMonotone(xs) {\r\n    return isMonotoneIncreasing(xs) || isMonotoneDecreasing(xs);\r\n}\r\n//# sourceMappingURL=is-self-overlapping.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/is-self-overlapping.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/length-squared-upper-bound.js":
/*!*********************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/length-squared-upper-bound.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\n/**\r\n * Returns an upper bound for the length of the given order 1, 2 or 3 bezier\r\n * curve.\r\n *\r\n * The curve has lenhth 0 iff this bound is zero.\r\n *\r\n * This bound is a bit loose as it uses the sum of the straight-line distances\r\n * between control points as a measure.\r\n * @param ps\r\n */\r\nfunction lengthSquaredUpperBound(ps) {\r\n    let totalLength = 0;\r\n    for (let i = 0; i < ps.length - 1; i++) {\r\n        totalLength += flo_vector2d_1.squaredDistanceBetween(ps[i], ps[i + 1]);\r\n    }\r\n    return totalLength;\r\n}\r\nexports.lengthSquaredUpperBound = lengthSquaredUpperBound;\r\n//# sourceMappingURL=length-squared-upper-bound.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/length-squared-upper-bound.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/length-upper-bound.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/length-upper-bound.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\n/**\r\n * Returns an upper bound for the length of the given bezier curve - this bound\r\n * is not very strict as it uses the sum of the straight-line distances between\r\n * control points as a measure.\r\n * @param ps\r\n */\r\nfunction lengthUpperBound(ps) {\r\n    let totalLength = 0;\r\n    for (let i = 0; i < ps.length - 1; i++) {\r\n        totalLength += flo_vector2d_1.distanceBetween(ps[i], ps[i + 1]);\r\n    }\r\n    return totalLength;\r\n}\r\nexports.lengthUpperBound = lengthUpperBound;\r\n//# sourceMappingURL=length-upper-bound.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/length-upper-bound.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/line-intersection.js":
/*!************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/line-intersection.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst get_y_1 = __webpack_require__(/*! ./get-y */ \"./node_modules/flo-bezier3/node/get-y.js\");\r\n/**\r\n * Returns the bezier t values of the intersection between the given cubic\r\n * bezier and the given line.\r\n * @param ps - The bezier curve\r\n * @param l - The line given as a start and end point\r\n */\r\nfunction lineIntersection(ps, l) {\r\n    let [[x0, y0], [x1, y1]] = l;\r\n    let [x, y] = [x1 - x0, y1 - y0];\r\n    if (x === 0 && y === 0) {\r\n        return [];\r\n    } // It is not a line, it's a point. \r\n    // Move the line and the bezier together so the line's first point is on the\r\n    // origin.\r\n    ps = flo_vector2d_1.translatePs([-x0, -y0], ps);\r\n    // Rotate the bezier and line together so the line is y=0.\r\n    let len = Math.sqrt(x * x + y * y);\r\n    let sinθ = y / len;\r\n    let cosθ = x / len;\r\n    ps = flo_vector2d_1.rotatePs(-sinθ, cosθ, ps);\r\n    // Find the intersection t values\r\n    return flo_poly_1.allRoots(get_y_1.getY(ps), 0, 1);\r\n}\r\nexports.lineIntersection = lineIntersection;\r\n//# sourceMappingURL=line-intersection.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/line-intersection.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/matrix/det-naive.js":
/*!***********************************************************!*\
  !*** ./node_modules/flo-bezier3/node/matrix/det-naive.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\n// TODO - from https://raw.githubusercontent.com/divyanthj/determinant/master/src/scripts/services/calculate.js\r\nfunction detNaive(A) {\r\n    let det = 0;\r\n    if (A.length === 1) {\r\n        return A[0][0];\r\n    }\r\n    if (A.length == 2) {\r\n        det = A[0][0] * A[1][1] - A[1][0] * A[0][1];\r\n        return det;\r\n    }\r\n    //Recursion begins here\r\n    //Instantiate smaller matrix\r\n    for (let i = 0; i < A.length; i++) {\r\n        let smaller = [];\r\n        for (let newvar = 0; newvar < A.length - 1; newvar++) {\r\n            let array = [];\r\n            for (let m = 0; m < A.length - 1; m++) {\r\n                array.push(0);\r\n            }\r\n            smaller.push(array);\r\n        }\r\n        //Populate smaller matrix with the appropriate values.\r\n        for (var a = 1; a < A.length; a++) {\r\n            for (var b = 0; b < A.length; b++) {\r\n                if (b < i) {\r\n                    smaller[a - 1][b] = A[a][b];\r\n                }\r\n                else if (b > i) {\r\n                    smaller[a - 1][b - 1] = A[a][b];\r\n                }\r\n            }\r\n        }\r\n        //calculate determinant of smaller matrix\r\n        //multiply determinant of smaller matrix with current element\r\n        //add to \"det\"\r\n        let s = i % 2 === 0 ? 1 : -1;\r\n        det += s * A[0][i] * detNaive(smaller);\r\n    }\r\n    return det;\r\n}\r\nexports.detNaive = detNaive;\r\nfunction detSlowExact(A) {\r\n    var det = [0];\r\n    if (A.length === 1) {\r\n        return A[0][0];\r\n    }\r\n    if (A.length == 2) {\r\n        //det = A[0][0] * A[1][1] - A[1][0] * A [0][1];\r\n        let a = flo_numerical_1.expansionProduct(A[0][0], A[1][1]);\r\n        let b = flo_numerical_1.negativeOf(flo_numerical_1.expansionProduct(A[1][0], A[0][1]));\r\n        return flo_numerical_1.fastExpansionSum(a, b);\r\n    }\r\n    //Instantiate smaller matrix\r\n    for (let i = 0; i < A.length; i++) {\r\n        let smaller = [];\r\n        for (let newvar = 0; newvar < A.length - 1; newvar++) {\r\n            var array = [];\r\n            for (var m = 0; m < A.length - 1; m++) {\r\n                array.push([0]);\r\n            }\r\n            smaller.push(array);\r\n        }\r\n        //Populate smaller matrix with the appropriate values.\r\n        for (let a = 1; a < A.length; a++) {\r\n            for (let b = 0; b < A.length; b++) {\r\n                if (b < i) {\r\n                    smaller[a - 1][b] = A[a][b];\r\n                }\r\n                else if (b > i) {\r\n                    smaller[a - 1][b - 1] = A[a][b];\r\n                }\r\n            }\r\n        }\r\n        //calculate determinant of smaller matrix\r\n        //multiply determinant of smaller matrix with current element\r\n        //add to \"det\"\r\n        let s = i % 2 === 0 ? 1 : -1;\r\n        //det += s * A[0][i] * detSlowExact(smaller);\r\n        let a = flo_numerical_1.expansionProduct(A[0][i], detSlowExact(smaller));\r\n        if (i % 2 !== 0) {\r\n            a = flo_numerical_1.negativeOf(a);\r\n        }\r\n        det = flo_numerical_1.fastExpansionSum(det, a);\r\n    }\r\n    return det;\r\n}\r\nexports.detSlowExact = detSlowExact;\r\n//# sourceMappingURL=det-naive.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/matrix/det-naive.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/normal.js":
/*!*************************************************!*\
  !*** ./node_modules/flo-bezier3/node/normal.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst tangent_1 = __webpack_require__(/*! ./tangent */ \"./node_modules/flo-bezier3/node/tangent.js\");\r\nfunction normal(ps, t) {\r\n    const tanPs = tangent_1.tangent(ps);\r\n    function f(t) {\r\n        let v = tanPs(t);\r\n        return [v[1], -v[0]];\r\n    }\r\n    // Curry\r\n    return t === undefined ? f : f(t);\r\n}\r\nexports.normal = normal;\r\n//# sourceMappingURL=normal.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/normal.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/quad-to-polyline.js":
/*!***********************************************************!*\
  !*** ./node_modules/flo-bezier3/node/quad-to-polyline.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst is_quad_flat_1 = __webpack_require__(/*! ./is-quad-flat */ \"./node_modules/flo-bezier3/node/is-quad-flat.js\");\r\nconst split_at_1 = __webpack_require__(/*! ./split-at */ \"./node_modules/flo-bezier3/node/split-at.js\");\r\n/**\r\n * Transforms the given quadratic bezier into a polyline approximation to within\r\n * a given tolerance.\r\n * @param ps A quadratic bezier curve given as an array of points.\r\n */\r\nfunction quadToPolyline(ps, tolerance) {\r\n    // A quad bezier has the following useful properties (Let the control\r\n    // points be labeled P0, P1 and P2 respectively and let the point at t = 0.5\r\n    // be labeled M1):\r\n    // -------------------------------------------------------------------------\r\n    // * At t = 0.5 P1 has its maximum influence of 0.5 and P0 and P2 each an \r\n    // influence of 0.25.\r\n    // * The tangent at t = 0.5 is given by P2 - P0.\r\n    // * The line implied by the tangent at t = 0.5 cuts the line segments P0-P1\r\n    // and P2-P1 in half. Lets call these points M0 and M2.\r\n    // * The polygon P0-M0-M2-P2 bounds the curve.\r\n    // * The curve can be cut into two quad bezier curves. \r\n    // * If it is cut at t = 0.5, i.e. at M1 so that we have two quad beziers \r\n    // defined by the triangles Q1 = P0-M0-M1 and Q2 = M0-M2-P2 then both \r\n    // the interior angles at P0 and P2 are < 90 degrees (acute). Lets call such\r\n    // a quad acute, otherwise obtuse.\r\n    // * If we split an obtuse quad at t = 0.5 then the resulting quads are both\r\n    // acute.\r\n    // * Acute quads is such that the point at t = 0.5, i.e. at M1) is the \r\n    // furthest away from the line P0-P2.\r\n    // Note: In our algorithm the above property can be used to measure the \r\n    // flatness of the quad reliably.\r\n    // The algorithm: q: quad => lines[] such that the Hausdorff distance \r\n    // between the polyline and the quad < tolerance.\r\n    // Strategy: Use linked list for polyline - makes splitting easier\r\n    // -------------------------------------------------------------------------\r\n    // quad obtuse ? \r\n    //   no  : Push the quad onto the stack\r\n    //   yes : Split the quad at t = 0.5 and push both halves onto the stack\r\n    // Loop while stack not empty\r\n    //   pop from stack => q\r\n    //   d <= calculate distance from t = 0.5 to line p0-p2\r\n    //   tolerance < tol ?\r\n    //     yes : do nothing\r\n    //     no  : split quad at t = 0.5 and push both halves onto the stack\r\n    // Loop end\r\n    // Stack with nodes still to be checked\r\n    let stack = [];\r\n    // Polyline linked list\r\n    let head = {\r\n        ps,\r\n        prev: undefined,\r\n        next: undefined\r\n    };\r\n    stack.push(head);\r\n    while (stack.length) {\r\n        let node = stack.pop();\r\n        if (is_quad_flat_1.isQuadFlat(node.ps, tolerance)) {\r\n            continue;\r\n        }\r\n        let quads = split_at_1.splitAt(node.ps, 0.5);\r\n        let prev = node.prev;\r\n        let next = node.next;\r\n        let node1 = {\r\n            ps: quads[0],\r\n            prev,\r\n            next: undefined // to be set below\r\n        };\r\n        let node2 = {\r\n            ps: quads[1],\r\n            prev: undefined,\r\n            next\r\n        };\r\n        node1.next = node2;\r\n        node2.prev = node1;\r\n        if (prev) {\r\n            prev.next = node1;\r\n        }\r\n        if (next) {\r\n            next.prev = node2;\r\n        }\r\n        if (head === node) {\r\n            head = node1;\r\n        }\r\n        stack.push(node1);\r\n        stack.push(node2);\r\n    }\r\n    let linePs = [];\r\n    let node = head;\r\n    linePs.push(head.ps[0]);\r\n    while (node) {\r\n        linePs.push(node.ps[2]);\r\n        node = node.next;\r\n    }\r\n    return linePs;\r\n}\r\nexports.quadToPolyline = quadToPolyline;\r\n//# sourceMappingURL=quad-to-polyline.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/quad-to-polyline.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/split-at.js":
/*!***************************************************!*\
  !*** ./node_modules/flo-bezier3/node/split-at.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\n/**\r\n * Returns 2 new beziers split at the given t parameter, i.e. for the ranges\r\n * [0,t] and [t,1].\r\n * @param ps An order 1, 2 or 3 bezier curve\r\n * @param t The curve parameter\r\n */\r\nfunction splitAt(ps, t) {\r\n    if (ps.length === 2) {\r\n        return splitLineAt(ps, t);\r\n    }\r\n    else if (ps.length === 3) {\r\n        return splitQuadAt(ps, t);\r\n    }\r\n    else if (ps.length === 4) {\r\n        return splitCubicAt(ps, t);\r\n    }\r\n    return [];\r\n}\r\nexports.splitAt = splitAt;\r\n/**\r\n * Returns 2 new beziers split at the given t parameter, i.e. for the ranges\r\n * [0,t] and [t,1].\r\n *\r\n * The result is precise, i.e. each returned coordinate is rounded to the\r\n * nearest ulp (unit in the last place)\r\n *\r\n * @param ps An order 1, 2 or 3 bezier curve\r\n * @param t The curve parameter\r\n */\r\nfunction splitAtPrecise(ps, t) {\r\n    if (ps.length === 2) {\r\n        return splitLineAtPrecise(ps, t);\r\n    }\r\n    else if (ps.length === 3) {\r\n        return splitQuadAtPrecise(ps, t);\r\n    }\r\n    else if (ps.length === 4) {\r\n        return splitCubicAtPrecise(ps, t);\r\n    }\r\n    return [];\r\n}\r\nexports.splitAtPrecise = splitAtPrecise;\r\n/**\r\n * Returns 2 new cubic beziers split at the given t parameter, i.e. for the ranges\r\n * [0,t] and [t,1]. Uses de Casteljau's algorithm.\r\n *\r\n * A loose bound on the accuracy of the resultant points is given by:\r\n * |δP| = 2n*max_k(|b_k|)η, where n = 3 (cubic), b_k are the control points\r\n * and η is Number.EPSILON.\r\n * @param ps A cubic bezier curve\r\n * @param t The t parameter where the curve should be split\r\n */\r\nfunction splitCubicAt(ps, t) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    let s = 1 - t;\r\n    /** The split point */\r\n    let p = [\r\n        x3 * Math.pow(t, 3) + 3 * x2 * s * Math.pow(t, 2) + 3 * x1 * Math.pow(s, 2) * t + x0 * Math.pow(s, 3),\r\n        y3 * Math.pow(t, 3) + 3 * y2 * s * Math.pow(t, 2) + 3 * y1 * Math.pow(s, 2) * t + y0 * Math.pow(s, 3)\r\n    ];\r\n    let ps1 = [\r\n        [x0, y0],\r\n        [x1 * t + x0 * s,\r\n            y1 * t + y0 * s],\r\n        [x2 * Math.pow(t, 2) + 2 * x1 * s * t + x0 * Math.pow(s, 2),\r\n            y2 * Math.pow(t, 2) + 2 * y1 * s * t + y0 * Math.pow(s, 2)],\r\n        p\r\n    ];\r\n    let ps2 = [\r\n        p,\r\n        [x3 * Math.pow(t, 2) + 2 * x2 * t * s + x1 * Math.pow(s, 2),\r\n            y3 * Math.pow(t, 2) + 2 * y2 * t * s + y1 * Math.pow(s, 2)],\r\n        [x3 * t + x2 * s,\r\n            y3 * t + y2 * s],\r\n        [x3, y3]\r\n    ];\r\n    return [ps1, ps2];\r\n}\r\n/**\r\n * Returns 2 new cubic beziers split at the given t parameter, i.e. for the ranges\r\n * [0,t] and [t,1]. Uses de Casteljau's algorithm.\r\n *\r\n * The result is precise, i.e. each returned coordinate is rounded to the\r\n * nearest ulp (unit in the last place)\r\n * @param ps A cubic bezier curve\r\n * @param t The t parameter where the curve should be split\r\n */\r\nfunction splitCubicAtPrecise(ps, t) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    let s = 1 - t;\r\n    let s2 = flo_numerical_1.twoProduct(s, s);\r\n    let s3 = flo_numerical_1.scaleExpansion(s2, s);\r\n    let t2 = flo_numerical_1.twoProduct(t, t);\r\n    let t3 = flo_numerical_1.scaleExpansion(t2, t);\r\n    let st = flo_numerical_1.twoProduct(s, t);\r\n    let st2 = flo_numerical_1.scaleExpansion(t2, s);\r\n    let s2t = flo_numerical_1.scaleExpansion(s2, t);\r\n    /** The split point */\r\n    let p = [\r\n        //x3*t**3 + 3*x2*s*t**2 + 3*x1*s**2*t + x0*s**3,\r\n        //y3*t**3 + 3*y2*s*t**2 + 3*y1*s**2*t + y0*s**3\r\n        flo_numerical_1.estimate(flo_numerical_1.calculateSum([\r\n            flo_numerical_1.scaleExpansion(t3, x3),\r\n            flo_numerical_1.scaleExpansion(st2, 3 * x2),\r\n            flo_numerical_1.scaleExpansion(s2t, 3 * x1),\r\n            flo_numerical_1.scaleExpansion(s3, x0)\r\n        ])),\r\n        flo_numerical_1.estimate(flo_numerical_1.calculateSum([\r\n            flo_numerical_1.scaleExpansion(t3, y3),\r\n            flo_numerical_1.scaleExpansion(st2, 3 * y2),\r\n            flo_numerical_1.scaleExpansion(s2t, 3 * y1),\r\n            flo_numerical_1.scaleExpansion(s3, y0)\r\n        ]))\r\n    ];\r\n    let ps1 = [\r\n        [x0, y0],\r\n        [\r\n            //x1*t + x0*s,\r\n            //y1*t + y0*s\r\n            flo_numerical_1.estimate(flo_numerical_1.fastExpansionSum(flo_numerical_1.twoProduct(x1, t), flo_numerical_1.twoProduct(x0, s))),\r\n            flo_numerical_1.estimate(flo_numerical_1.fastExpansionSum(flo_numerical_1.twoProduct(y1, t), flo_numerical_1.twoProduct(y0, s)))\r\n        ],\r\n        [\r\n            //x2*t**2 + 2*x1*s*t + x0*s**2, \r\n            //y2*t**2 + 2*y1*s*t + y0*s**2\r\n            flo_numerical_1.estimate(flo_numerical_1.calculateSum([\r\n                flo_numerical_1.scaleExpansion(t2, x2),\r\n                flo_numerical_1.scaleExpansion(st, 2 * x1),\r\n                flo_numerical_1.scaleExpansion(s2, x0)\r\n            ])),\r\n            flo_numerical_1.estimate(flo_numerical_1.calculateSum([\r\n                flo_numerical_1.scaleExpansion(t2, y2),\r\n                flo_numerical_1.scaleExpansion(st, 2 * y1),\r\n                flo_numerical_1.scaleExpansion(s2, y0)\r\n            ]))\r\n        ],\r\n        p\r\n    ];\r\n    let ps2 = [\r\n        p,\r\n        [\r\n            //x3*t**2 + 2*x2*t*s + x1*s**2, \r\n            //y3*t**2 + 2*y2*t*s + y1*s**2\r\n            flo_numerical_1.estimate(flo_numerical_1.calculateSum([\r\n                flo_numerical_1.scaleExpansion(t2, x3),\r\n                flo_numerical_1.scaleExpansion(st, 2 * x2),\r\n                flo_numerical_1.scaleExpansion(s2, x1)\r\n            ])),\r\n            flo_numerical_1.estimate(flo_numerical_1.calculateSum([\r\n                flo_numerical_1.scaleExpansion(t2, y3),\r\n                flo_numerical_1.scaleExpansion(st, 2 * y2),\r\n                flo_numerical_1.scaleExpansion(s2, y1)\r\n            ]))\r\n        ],\r\n        [\r\n            //x3*t + x2*s, \r\n            //y3*t + y2*s\r\n            flo_numerical_1.estimate(flo_numerical_1.fastExpansionSum(flo_numerical_1.twoProduct(x3, t), flo_numerical_1.twoProduct(x2, s))),\r\n            flo_numerical_1.estimate(flo_numerical_1.fastExpansionSum(flo_numerical_1.twoProduct(y3, t), flo_numerical_1.twoProduct(y2, s))),\r\n        ],\r\n        [x3, y3]\r\n    ];\r\n    return [ps1, ps2];\r\n}\r\nfunction splitQuadAt(ps, t) {\r\n    let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    let s = 1 - t;\r\n    /** The split point */\r\n    let p = [\r\n        x0 * Math.pow(s, 2) + 2 * x1 * s * t + x2 * Math.pow(t, 2),\r\n        y0 * Math.pow(s, 2) + 2 * y1 * s * t + y2 * Math.pow(t, 2)\r\n    ];\r\n    let ps1 = [\r\n        [x0, y0],\r\n        [x0 * s + x1 * t,\r\n            y0 * s + y1 * t],\r\n        p\r\n    ];\r\n    let ps2 = [\r\n        p,\r\n        [x1 * s + x2 * t,\r\n            y1 * s + y2 * t],\r\n        [x2, y2]\r\n    ];\r\n    return [ps1, ps2];\r\n}\r\n/**\r\n *\r\n * @param ps\r\n * @param t\r\n */\r\nfunction splitQuadAtPrecise(ps, t) {\r\n    let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    let s = 1 - t;\r\n    let t2 = flo_numerical_1.twoProduct(t, t);\r\n    let s2 = flo_numerical_1.twoProduct(s, s);\r\n    let st = flo_numerical_1.twoProduct(s, t);\r\n    /** The split point */\r\n    let p = [\r\n        //x0*s**2 + 2*x1*s*t + x2*t**2,\r\n        //y0*s**2 + 2*y1*s*t + y2*t**2\r\n        flo_numerical_1.estimate(flo_numerical_1.calculateSum([\r\n            flo_numerical_1.scaleExpansion(s2, x0),\r\n            flo_numerical_1.scaleExpansion(st, 2 * x1),\r\n            flo_numerical_1.scaleExpansion(t2, x2)\r\n        ])),\r\n        flo_numerical_1.estimate(flo_numerical_1.calculateSum([\r\n            flo_numerical_1.scaleExpansion(s2, y0),\r\n            flo_numerical_1.scaleExpansion(st, 2 * y1),\r\n            flo_numerical_1.scaleExpansion(t2, y2)\r\n        ]))\r\n    ];\r\n    let ps1 = [\r\n        [x0, y0],\r\n        [\r\n            //x0*s + x1*t, \r\n            //y0*s + y1*t\r\n            flo_numerical_1.estimate(flo_numerical_1.fastExpansionSum(flo_numerical_1.twoProduct(x0, s), flo_numerical_1.twoProduct(x1, t))),\r\n            flo_numerical_1.estimate(flo_numerical_1.fastExpansionSum(flo_numerical_1.twoProduct(y0, s), flo_numerical_1.twoProduct(y1, t))),\r\n        ],\r\n        p\r\n    ];\r\n    let ps2 = [\r\n        p,\r\n        [\r\n            //x1*s + x2*t, \r\n            //y1*s + y2*t\r\n            flo_numerical_1.estimate(flo_numerical_1.fastExpansionSum(flo_numerical_1.twoProduct(x1, s), flo_numerical_1.twoProduct(x2, t))),\r\n            flo_numerical_1.estimate(flo_numerical_1.fastExpansionSum(flo_numerical_1.twoProduct(y1, s), flo_numerical_1.twoProduct(y2, t))),\r\n        ],\r\n        [x2, y2]\r\n    ];\r\n    return [ps1, ps2];\r\n}\r\nfunction splitLineAt(ps, t) {\r\n    let [[x0, y0], [x1, y1]] = ps;\r\n    let s = 1 - t;\r\n    /** The split point */\r\n    let p = [\r\n        s * x0 + t * x1,\r\n        s * y0 + t * y1\r\n    ];\r\n    let ps1 = [\r\n        [x0, y0],\r\n        p\r\n    ];\r\n    let ps2 = [\r\n        p,\r\n        [x1, y1]\r\n    ];\r\n    return [ps1, ps2];\r\n}\r\n/**\r\n *\r\n * @param ps\r\n * @param t\r\n */\r\nfunction splitLineAtPrecise(ps, t) {\r\n    let [[x0, y0], [x1, y1]] = ps;\r\n    let s = 1 - t;\r\n    /** The split point */\r\n    let p = [\r\n        //s*x0 + t*x1,\r\n        //s*y0 + t*y1\r\n        flo_numerical_1.estimate(flo_numerical_1.fastExpansionSum(flo_numerical_1.twoProduct(s, x0), flo_numerical_1.twoProduct(t, x1))),\r\n        flo_numerical_1.estimate(flo_numerical_1.fastExpansionSum(flo_numerical_1.twoProduct(s, y0), flo_numerical_1.twoProduct(t, y1)))\r\n    ];\r\n    let ps1 = [\r\n        [x0, y0],\r\n        p\r\n    ];\r\n    let ps2 = [\r\n        p,\r\n        [x1, y1]\r\n    ];\r\n    return [ps1, ps2];\r\n}\r\n//# sourceMappingURL=split-at.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/split-at.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/split-by-curvature-and-length.js":
/*!************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/split-by-curvature-and-length.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst from_to_1 = __webpack_require__(/*! ./from-to */ \"./node_modules/flo-bezier3/node/from-to.js\");\r\nconst length_upper_bound_1 = __webpack_require__(/*! ./length-upper-bound */ \"./node_modules/flo-bezier3/node/length-upper-bound.js\");\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\n/**\r\n * Split the order 1, 2 or 3 bezier into pieces (given as an array of parameter\r\n * (t) values) such that each piece is flat within a given tolerance given by\r\n * maxFlatness and maxLength.\r\n * @param ps\r\n * @param maxFlatness\r\n * @param maxLength\r\n */\r\nfunction splitByCurvatureAndLength(ps, maxFlatness = 1.01, maxLength = 100) {\r\n    let ts = [0, 1]; // include endpoints\r\n    let tStack = [[0, 1]];\r\n    let fromTo_ = from_to_1.fromTo(ps);\r\n    while (tStack.length) {\r\n        let ts_ = tStack.pop();\r\n        let ps_ = fromTo_(ts_[0], ts_[1]);\r\n        let l1 = length_upper_bound_1.lengthUpperBound(ps_);\r\n        let l2 = flo_vector2d_1.distanceBetween(ps_[0], ps_[ps_.length - 1]);\r\n        //let flatness_ = ((l1 / l2)**1280) * l1;\r\n        let flatness_ = 1 + (l1 / l2 - 1) * (l1 / maxLength);\r\n        if (flatness_ > maxFlatness) {\r\n            let t = (ts_[0] + ts_[1]) / 2;\r\n            tStack.push([ts_[0], t]);\r\n            tStack.push([t, ts_[1]]);\r\n            ts.push(t);\r\n        }\r\n    }\r\n    ts.sort((a, b) => a - b);\r\n    return ts;\r\n}\r\nexports.splitByCurvatureAndLength = splitByCurvatureAndLength;\r\n//# sourceMappingURL=split-by-curvature-and-length.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/split-by-curvature-and-length.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/split-by-max-curvature.js":
/*!*****************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/split-by-max-curvature.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst from_to_1 = __webpack_require__(/*! ./from-to */ \"./node_modules/flo-bezier3/node/from-to.js\");\r\nconst flatness_1 = __webpack_require__(/*! ./flatness */ \"./node_modules/flo-bezier3/node/flatness.js\");\r\n/**\r\n * Split the order 1, 2 or 3 bezier into pieces (given as an array of parameter\r\n * (t) values) such that each piece is flat within a given tolerance given by\r\n * the flatness function.\r\n * @param ps\r\n * @param tolerance Maximum tolerance (must be > 1) for flatness measure.\r\n */\r\nfunction splitByMaxCurvature(ps, tolerance = 1.1) {\r\n    let ts = [0, 1]; // include endpoints\r\n    let tStack = [[0, 1]];\r\n    let fromTo_ = from_to_1.fromTo(ps);\r\n    while (tStack.length) {\r\n        let ts_ = tStack.pop();\r\n        let ps_ = fromTo_(ts_[0], ts_[1]);\r\n        //lengthUpperBound(ps) / distanceBetween(ps[0], ps[ps.length-1])\r\n        if (flatness_1.flatness(ps_) > tolerance) {\r\n            let t = (ts_[0] + ts_[1]) / 2;\r\n            tStack.push([ts_[0], t]);\r\n            tStack.push([t, ts_[1]]);\r\n            ts.push(t);\r\n        }\r\n    }\r\n    ts.sort((a, b) => a - b);\r\n    return ts;\r\n}\r\nexports.splitByMaxCurvature = splitByMaxCurvature;\r\n//# sourceMappingURL=split-by-max-curvature.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/split-by-max-curvature.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/split-by-max-curve-length.js":
/*!********************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/split-by-max-curve-length.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst length_upper_bound_1 = __webpack_require__(/*! ./length-upper-bound */ \"./node_modules/flo-bezier3/node/length-upper-bound.js\");\r\nconst from_to_1 = __webpack_require__(/*! ./from-to */ \"./node_modules/flo-bezier3/node/from-to.js\");\r\n/**\r\n * Split the order 1, 2 or 3 bezier into pieces (given as an array of parameter\r\n * (t) values) such that the longest curve length is guaranteed to be lower than\r\n * the given max length.\r\n * @param ps\r\n * @param maxLength\r\n */\r\nfunction splitByMaxCurveLength(ps, maxLength) {\r\n    let ts = [0, 1]; // include endpoints\r\n    let tStack = [[0, 1]];\r\n    let fromTo_ = from_to_1.fromTo(ps);\r\n    while (tStack.length) {\r\n        let ts_ = tStack.pop();\r\n        let ps_ = fromTo_(ts_[0], ts_[1]);\r\n        if (length_upper_bound_1.lengthUpperBound(ps_) > maxLength) {\r\n            let t = (ts_[0] + ts_[1]) / 2;\r\n            tStack.push([ts_[0], t]);\r\n            tStack.push([t, ts_[1]]);\r\n            ts.push(t);\r\n        }\r\n    }\r\n    ts.sort((a, b) => a - b);\r\n    return ts;\r\n}\r\nexports.splitByMaxCurveLength = splitByMaxCurveLength;\r\n//# sourceMappingURL=split-by-max-curve-length.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/split-by-max-curve-length.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/tangent.js":
/*!**************************************************!*\
  !*** ./node_modules/flo-bezier3/node/tangent.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst evaluate_dx_1 = __webpack_require__(/*! ./evaluate-dx */ \"./node_modules/flo-bezier3/node/evaluate-dx.js\");\r\nconst evaluate_dy_1 = __webpack_require__(/*! ./evaluate-dy */ \"./node_modules/flo-bezier3/node/evaluate-dy.js\");\r\nfunction tangent(ps, t) {\r\n    const evDx = evaluate_dx_1.evaluateDx(ps);\r\n    const evDy = evaluate_dy_1.evaluateDy(ps);\r\n    function f(t) {\r\n        let dx = evDx(t);\r\n        let dy = evDy(t);\r\n        let d = Math.sqrt(dx * dx + dy * dy);\r\n        return [dx / d, dy / d];\r\n    }\r\n    // Curry\r\n    return t === undefined ? f : f(t);\r\n}\r\nexports.tangent = tangent;\r\n//# sourceMappingURL=tangent.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/tangent.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/ts-at-x.js":
/*!**************************************************!*\
  !*** ./node_modules/flo-bezier3/node/ts-at-x.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst get_x_1 = __webpack_require__(/*! ./get-x */ \"./node_modules/flo-bezier3/node/get-x.js\");\r\n/**\r\n * Returns the bezier t values of the intersection between the given cubic\r\n * bezier and the given vertical line.\r\n * @param ps - The bezier curve\r\n * @param y - The y value of the horizontal line\r\n */\r\nfunction tsAtX(ps, x) {\r\n    // Translate ps so that x = 0.\r\n    ps = ps.map(p => [p[0] - x, p[1]]);\r\n    // Find the intersection t values\r\n    return flo_poly_1.allRoots(get_x_1.getX(ps), 0, 1);\r\n}\r\nexports.tsAtX = tsAtX;\r\n//# sourceMappingURL=ts-at-x.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/ts-at-x.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/ts-at-y.js":
/*!**************************************************!*\
  !*** ./node_modules/flo-bezier3/node/ts-at-y.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst get_y_1 = __webpack_require__(/*! ./get-y */ \"./node_modules/flo-bezier3/node/get-y.js\");\r\n/**\r\n * Returns the bezier t values of the intersection between the given cubic\r\n * bezier and the given horizontal line.\r\n * @param ps - The bezier curve\r\n * @param y - The y value of the horizontal line\r\n */\r\nfunction tsAtY(ps, y) {\r\n    // Translate ps so that y = 0.\r\n    ps = ps.map(p => [p[0], p[1] - y]);\r\n    // Find the intersection t values\r\n    return flo_poly_1.allRoots(get_y_1.getY(ps), 0, 1);\r\n}\r\nexports.tsAtY = tsAtY;\r\n//# sourceMappingURL=ts-at-y.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/ts-at-y.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/bezier-from-bezier-piece.js":
/*!*********************************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/bezier-from-bezier-piece.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst evaluate_bezier_1 = __webpack_require__(/*! ./evaluate-bezier */ \"./node_modules/flo-draw/node/draw/evaluate-bezier.js\");\r\nconst split_at_1 = __webpack_require__(/*! ./split-at */ \"./node_modules/flo-draw/node/draw/split-at.js\");\r\n/**\r\n * Returns a new bezier from the given bezier by limiting its t range.\r\n *\r\n * Duplicated here so we don't circularly depend on flo-bezier.\r\n *\r\n * Uses de Casteljau's algorithm.\r\n *\r\n * @param ps A bezier\r\n * @param tRange A t range\r\n */\r\nfunction bezierFromBezierPiece(ps, tRange) {\r\n    // If tRange = [0,1] then return original bezier.\r\n    if (tRange[0] === 0 && tRange[1] === 1) {\r\n        return ps;\r\n    }\r\n    // If tRange[0] === tRange[1] then return a single point degenerated bezier.\r\n    if (tRange[0] === tRange[1]) {\r\n        let p = evaluate_bezier_1.evaluateBezier(ps, tRange[0]);\r\n        return [p, p, p, p];\r\n    }\r\n    if (tRange[0] === 0) {\r\n        return split_at_1.splitAt(ps, tRange[1])[0];\r\n    }\r\n    if (tRange[1] === 1) {\r\n        return split_at_1.splitAt(ps, tRange[0])[1];\r\n    }\r\n    // At this stage we know the t range is not degenerate and tRange[0] !== 0 \r\n    // and tRange[1] !== 1\r\n    return split_at_1.splitAt(split_at_1.splitAt(ps, tRange[0])[1], (tRange[1] - tRange[0]) / (1 - tRange[0]))[0];\r\n}\r\nexports.bezierFromBezierPiece = bezierFromBezierPiece;\r\n//# sourceMappingURL=bezier-from-bezier-piece.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-draw/node/draw/bezier-from-bezier-piece.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/bezier-piece.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/bezier-piece.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst default_class_1 = __webpack_require__(/*! ./default-class */ \"./node_modules/flo-draw/node/draw/default-class.js\");\r\nconst cross_hair_1 = __webpack_require__(/*! ./cross-hair */ \"./node_modules/flo-draw/node/draw/cross-hair.js\");\r\nconst bezier_1 = __webpack_require__(/*! ./bezier */ \"./node_modules/flo-draw/node/draw/bezier.js\");\r\nconst evaluate_bezier_1 = __webpack_require__(/*! ./evaluate-bezier */ \"./node_modules/flo-draw/node/draw/evaluate-bezier.js\");\r\nconst bezier_from_bezier_piece_1 = __webpack_require__(/*! ./bezier-from-bezier-piece */ \"./node_modules/flo-draw/node/draw/bezier-from-bezier-piece.js\");\r\n/**\r\n * Draws a bezier piece, i.e. a bezier within a specified t range.\r\n * @param snap\r\n * @param bezierPiece\r\n * @param class\r\n * @param delay\r\n */\r\nfunction bezierPiece(g, ps_, tRange, class_ = default_class_1.DEFAULT_CLASS, delay) {\r\n    let $elems = [];\r\n    // Draw crosshair if t range bounds are equal.\r\n    if (tRange[0] === tRange[1]) {\r\n        let p = evaluate_bezier_1.evaluateBezier(ps_, tRange[0]);\r\n        $elems = cross_hair_1.crossHair(g, p, class_, 1.5);\r\n    }\r\n    else {\r\n        let ps = bezier_from_bezier_piece_1.bezierFromBezierPiece(ps_, tRange);\r\n        $elems = bezier_1.bezier(g, ps, class_);\r\n    }\r\n    if (delay) {\r\n        setTimeout(() => $elems.forEach(e => e.remove()), delay);\r\n    }\r\n    return $elems;\r\n}\r\nexports.bezierPiece = bezierPiece;\r\n//# sourceMappingURL=bezier-piece.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-draw/node/draw/bezier-piece.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/bezier.js":
/*!***************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/bezier.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst default_class_1 = __webpack_require__(/*! ./default-class */ \"./node_modules/flo-draw/node/draw/default-class.js\");\r\nconst line_1 = __webpack_require__(/*! ./line */ \"./node_modules/flo-draw/node/draw/line.js\");\r\nconst quad_bezier_1 = __webpack_require__(/*! ./quad-bezier */ \"./node_modules/flo-draw/node/draw/quad-bezier.js\");\r\nconst cubic_bezier_1 = __webpack_require__(/*! ./cubic-bezier */ \"./node_modules/flo-draw/node/draw/cubic-bezier.js\");\r\nfunction bezier(g, bezier, class_ = default_class_1.DEFAULT_CLASS, delay) {\r\n    if (bezier.length === 2) {\r\n        return line_1.line(g, bezier, class_, delay);\r\n    }\r\n    else if (bezier.length === 3) {\r\n        return quad_bezier_1.quadBezier(g, bezier, class_, delay);\r\n    }\r\n    else if (bezier.length === 4) {\r\n        return cubic_bezier_1.cubicBezier(g, bezier, class_, delay);\r\n    }\r\n    return [];\r\n}\r\nexports.bezier = bezier;\r\n//# sourceMappingURL=bezier.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-draw/node/draw/bezier.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/beziers.js":
/*!****************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/beziers.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst bezier_1 = __webpack_require__(/*! ./bezier */ \"./node_modules/flo-draw/node/draw/bezier.js\");\r\nconst COLORS = ['red', 'green', 'cyan', 'blue'];\r\n/**\r\n * Draws beziers.\r\n * @param snap\r\n * @param beziers\r\n * @param delay\r\n */\r\nfunction beziers(g, beziers, classes, delay) {\r\n    let alternateColors = classes === undefined;\r\n    let $beziers = [];\r\n    for (let i = 0; i < beziers.length; i++) {\r\n        let ps = beziers[i];\r\n        let color = COLORS[i % COLORS.length];\r\n        let class_ = alternateColors\r\n            ? 'thin5 nofill ' + color\r\n            : classes;\r\n        $beziers.push(...bezier_1.bezier(g, ps, class_));\r\n    }\r\n    if (delay) {\r\n        setTimeout(() => $beziers.forEach(e => e.remove()), delay);\r\n    }\r\n    return $beziers;\r\n}\r\nexports.beziers = beziers;\r\n//# sourceMappingURL=beziers.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-draw/node/draw/beziers.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/circle.js":
/*!***************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/circle.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst default_class_1 = __webpack_require__(/*! ./default-class */ \"./node_modules/flo-draw/node/draw/default-class.js\");\r\nconst xmlns_1 = __webpack_require__(/*! ./xmlns */ \"./node_modules/flo-draw/node/draw/xmlns.js\");\r\n/**\r\n * Draws a circle\r\n * @param g An SVG group element wherein to draw the circle.\r\n * @param circle\r\n * @param classes\r\n * @param delay\r\n */\r\nfunction circle(g, circle, classes = default_class_1.DEFAULT_CLASS, delay) {\r\n    let c = circle.center;\r\n    let r = circle.radius;\r\n    let $circle = document.createElementNS(xmlns_1.XMLNS, 'circle');\r\n    $circle.setAttributeNS(null, \"cx\", c[0].toString());\r\n    $circle.setAttributeNS(null, \"cy\", c[1].toString());\r\n    $circle.setAttributeNS(null, \"r\", r.toString());\r\n    $circle.setAttributeNS(null, \"class\", classes);\r\n    g.appendChild($circle);\r\n    if (delay) {\r\n        setTimeout(() => $circle.remove(), delay);\r\n    }\r\n    return [$circle];\r\n}\r\nexports.circle = circle;\r\n//# sourceMappingURL=circle.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-draw/node/draw/circle.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/cross-hair.js":
/*!*******************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/cross-hair.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst default_class_1 = __webpack_require__(/*! ./default-class */ \"./node_modules/flo-draw/node/draw/default-class.js\");\r\nconst circle_1 = __webpack_require__(/*! ./circle */ \"./node_modules/flo-draw/node/draw/circle.js\");\r\nconst line_1 = __webpack_require__(/*! ./line */ \"./node_modules/flo-draw/node/draw/line.js\");\r\n/**\r\n * Draws a crosshair.\r\n */\r\nfunction crossHair(g, p, classes = default_class_1.DEFAULT_CLASS, r = 3, delay) {\r\n    let circle_ = { center: p, radius: r };\r\n    let $circle = circle_1.circle(g, circle_, classes);\r\n    let l1 = [[p[0] - r, p[1]], [p[0] + r, p[1]]];\r\n    let l2 = [[p[0], p[1] - r], [p[0], p[1] + r]];\r\n    let $l1 = line_1.line(g, l1, classes);\r\n    let $l2 = line_1.line(g, l2, classes);\r\n    if (delay) {\r\n        setTimeout(() => {\r\n            $circle.forEach(e => e.remove());\r\n            $l1.forEach(e => e.remove());\r\n            $l2.forEach(e => e.remove());\r\n        }, delay);\r\n    }\r\n    return [...$circle, ...$l1, ...$l2];\r\n}\r\nexports.crossHair = crossHair;\r\n//# sourceMappingURL=cross-hair.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-draw/node/draw/cross-hair.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/cubic-bezier.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/cubic-bezier.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst default_class_1 = __webpack_require__(/*! ./default-class */ \"./node_modules/flo-draw/node/draw/default-class.js\");\r\nconst xmlns_1 = __webpack_require__(/*! ./xmlns */ \"./node_modules/flo-draw/node/draw/xmlns.js\");\r\nconst cross_hair_1 = __webpack_require__(/*! ./cross-hair */ \"./node_modules/flo-draw/node/draw/cross-hair.js\");\r\nfunction cubicBezier(g, bezier, class_ = default_class_1.DEFAULT_CLASS, delay) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = bezier;\r\n    if (x0 === x3 && y0 === y3) {\r\n        return cross_hair_1.crossHair(g, [x0, y0], class_, 0.2, delay);\r\n    }\r\n    let $path = document.createElementNS(xmlns_1.XMLNS, 'path');\r\n    $path.setAttributeNS(null, \"d\", `M${x0} ${y0} C${x1} ${y1} ${x2} ${y2} ${x3} ${y3}`);\r\n    $path.setAttributeNS(null, \"class\", class_);\r\n    g.appendChild($path);\r\n    if (delay) {\r\n        setTimeout(() => $path.remove(), delay);\r\n    }\r\n    return [$path];\r\n}\r\nexports.cubicBezier = cubicBezier;\r\n//# sourceMappingURL=cubic-bezier.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-draw/node/draw/cubic-bezier.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/default-class.js":
/*!**********************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/default-class.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst DEFAULT_CLASS = 'red thin10 nofill ';\r\nexports.DEFAULT_CLASS = DEFAULT_CLASS;\r\n//# sourceMappingURL=default-class.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-draw/node/draw/default-class.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/dot.js":
/*!************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/dot.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst circle_1 = __webpack_require__(/*! ./circle */ \"./node_modules/flo-draw/node/draw/circle.js\");\r\n/**\r\n * Draws a dot.\r\n */\r\nfunction dot(g, p, r = 3, color = 'red', delay) {\r\n    let $dot = circle_1.circle(g, { center: p, radius: r }, 'dot ' + color, delay);\r\n    if (delay) {\r\n        setTimeout(() => $dot.forEach(e => e.remove(), delay));\r\n    }\r\n    return [...$dot];\r\n}\r\nexports.dot = dot;\r\n//# sourceMappingURL=dot.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-draw/node/draw/dot.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/evaluate-bezier.js":
/*!************************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/evaluate-bezier.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns an estimate of evaluating the given bezier at the given t value.\r\n * @param ps An order 1, 2 or bezier\r\n * @param t The parameter ∈ [0,1]\r\n */\r\nfunction evaluateBezier(ps, t) {\r\n    let s = 1 - t;\r\n    if (ps.length === 4) {\r\n        // cubic\r\n        let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        let x = x0 * Math.pow(s, 3) + 3 * x1 * Math.pow(s, 2) * t + 3 * x2 * s * Math.pow(t, 2) + x3 * Math.pow(t, 3);\r\n        let y = y0 * Math.pow(s, 3) + 3 * y1 * Math.pow(s, 2) * t + 3 * y2 * s * Math.pow(t, 2) + y3 * Math.pow(t, 3);\r\n        return [x, y];\r\n    }\r\n    if (ps.length === 3) {\r\n        // quadratic\r\n        let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n        let x = x0 * Math.pow(s, 2) + 2 * x1 * s * t + x2 * Math.pow(t, 2);\r\n        let y = y0 * Math.pow(s, 2) + 2 * y1 * s * t + y2 * Math.pow(t, 2);\r\n        return [x, y];\r\n    }\r\n    if (ps.length === 2) {\r\n        // line\r\n        let [[x0, y0], [x1, y1]] = ps;\r\n        let x = x0 * s + x1 * t;\r\n        let y = y0 * s + y1 * t;\r\n        return [x, y];\r\n    }\r\n    return [NaN, NaN];\r\n}\r\nexports.evaluateBezier = evaluateBezier;\r\n//# sourceMappingURL=evaluate-bezier.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-draw/node/draw/evaluate-bezier.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/line.js":
/*!*************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/line.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst default_class_1 = __webpack_require__(/*! ./default-class */ \"./node_modules/flo-draw/node/draw/default-class.js\");\r\nconst xmlns_1 = __webpack_require__(/*! ./xmlns */ \"./node_modules/flo-draw/node/draw/xmlns.js\");\r\n/**\r\n *\r\n * @param snap\r\n * @param l\r\n * @param classes\r\n */\r\nfunction line(g, l, classes = default_class_1.DEFAULT_CLASS, delay) {\r\n    let $line = document.createElementNS(xmlns_1.XMLNS, 'line');\r\n    $line.setAttributeNS(null, \"x1\", l[0][0].toString());\r\n    $line.setAttributeNS(null, \"y1\", l[0][1].toString());\r\n    $line.setAttributeNS(null, \"x2\", l[1][0].toString());\r\n    $line.setAttributeNS(null, \"y2\", l[1][1].toString());\r\n    $line.setAttributeNS(null, \"class\", classes);\r\n    g.appendChild($line);\r\n    if (delay) {\r\n        setTimeout(() => $line.remove(), delay);\r\n    }\r\n    return [$line];\r\n}\r\nexports.line = line;\r\n//# sourceMappingURL=line.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-draw/node/draw/line.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/loop.js":
/*!*************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/loop.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst default_class_1 = __webpack_require__(/*! ./default-class */ \"./node_modules/flo-draw/node/draw/default-class.js\");\r\nconst xmlns_1 = __webpack_require__(/*! ./xmlns */ \"./node_modules/flo-draw/node/draw/xmlns.js\");\r\nfunction loop(g, curves, class_ = default_class_1.DEFAULT_CLASS, delay) {\r\n    if (!curves.length) {\r\n        return [];\r\n    }\r\n    let $path = document.createElementNS(xmlns_1.XMLNS, 'path');\r\n    let d = `M${curves[0][0][0]} ${curves[0][0][1]} `;\r\n    for (let i = 0; i < curves.length; i++) {\r\n        let curve = curves[i];\r\n        d += `${getType(curve.length)} `;\r\n        for (let j = 1; j < curve.length; j++) {\r\n            d += `${curve[j][0]} ${curve[j][1]} `;\r\n        }\r\n    }\r\n    d += ' z';\r\n    $path.setAttributeNS(null, \"d\", d);\r\n    if (class_) {\r\n        $path.setAttributeNS(null, \"class\", class_);\r\n    }\r\n    g.appendChild($path);\r\n    if (delay) {\r\n        setTimeout(() => $path.remove(), delay);\r\n    }\r\n    return [$path];\r\n}\r\nexports.loop = loop;\r\nfunction getType(len) {\r\n    if (len === 2) {\r\n        return 'L';\r\n    }\r\n    if (len === 3) {\r\n        return 'Q';\r\n    }\r\n    if (len === 4) {\r\n        return 'C';\r\n    }\r\n}\r\n//# sourceMappingURL=loop.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-draw/node/draw/loop.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/polygon.js":
/*!****************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/polygon.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst default_class_1 = __webpack_require__(/*! ./default-class */ \"./node_modules/flo-draw/node/draw/default-class.js\");\r\nconst xmlns_1 = __webpack_require__(/*! ./xmlns */ \"./node_modules/flo-draw/node/draw/xmlns.js\");\r\nfunction polygon(g, poly, class_ = default_class_1.DEFAULT_CLASS, delay) {\r\n    let $path = document.createElementNS(xmlns_1.XMLNS, 'path');\r\n    let d = `M${poly[0][0]} ${poly[0][1]} L`;\r\n    for (let i = 0; i < poly.length; i++) {\r\n        d += `${poly[i][0]} ${poly[i][1]} `;\r\n    }\r\n    d += ' z';\r\n    $path.setAttributeNS(null, \"d\", d);\r\n    if (class_) {\r\n        $path.setAttributeNS(null, \"class\", class_);\r\n    }\r\n    g.appendChild($path);\r\n    if (delay) {\r\n        setTimeout(() => $path.remove(), delay);\r\n    }\r\n    return [$path];\r\n}\r\nexports.polygon = polygon;\r\n//# sourceMappingURL=polygon.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-draw/node/draw/polygon.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/polyline.js":
/*!*****************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/polyline.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst default_class_1 = __webpack_require__(/*! ./default-class */ \"./node_modules/flo-draw/node/draw/default-class.js\");\r\nconst xmlns_1 = __webpack_require__(/*! ./xmlns */ \"./node_modules/flo-draw/node/draw/xmlns.js\");\r\nfunction polyline(g, poly, class_ = default_class_1.DEFAULT_CLASS, delay) {\r\n    if (poly.length < 2) {\r\n        return [];\r\n    }\r\n    let $path = document.createElementNS(xmlns_1.XMLNS, 'path');\r\n    let d = `M${poly[0][0]} ${poly[0][1]} L`;\r\n    for (let i = 0; i < poly.length; i++) {\r\n        d += `${poly[i][0]} ${poly[i][1]} `;\r\n    }\r\n    $path.setAttributeNS(null, \"d\", d);\r\n    if (class_) {\r\n        $path.setAttributeNS(null, \"class\", class_);\r\n    }\r\n    g.appendChild($path);\r\n    if (delay) {\r\n        setTimeout(() => $path.remove(), delay);\r\n    }\r\n    return [$path];\r\n}\r\nexports.polyline = polyline;\r\n//# sourceMappingURL=polyline.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-draw/node/draw/polyline.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/quad-bezier.js":
/*!********************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/quad-bezier.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst default_class_1 = __webpack_require__(/*! ./default-class */ \"./node_modules/flo-draw/node/draw/default-class.js\");\r\nconst xmlns_1 = __webpack_require__(/*! ./xmlns */ \"./node_modules/flo-draw/node/draw/xmlns.js\");\r\nfunction quadBezier(g, ps, class_ = default_class_1.DEFAULT_CLASS, delay) {\r\n    let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    let $path = document.createElementNS(xmlns_1.XMLNS, 'path');\r\n    $path.setAttributeNS(null, \"d\", `M${x0} ${y0} Q${x1} ${y1} ${x2} ${y2}`);\r\n    if (class_) {\r\n        $path.setAttributeNS(null, \"class\", class_);\r\n    }\r\n    g.appendChild($path);\r\n    if (delay) {\r\n        setTimeout(() => $path.remove(), delay);\r\n    }\r\n    return [$path];\r\n}\r\nexports.quadBezier = quadBezier;\r\n//# sourceMappingURL=quad-bezier.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-draw/node/draw/quad-bezier.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/rect.js":
/*!*************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/rect.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst default_class_1 = __webpack_require__(/*! ./default-class */ \"./node_modules/flo-draw/node/draw/default-class.js\");\r\nconst xmlns_1 = __webpack_require__(/*! ./xmlns */ \"./node_modules/flo-draw/node/draw/xmlns.js\");\r\nfunction rect(g, rect, classes = default_class_1.DEFAULT_CLASS, delay) {\r\n    let $rect = document.createElementNS(xmlns_1.XMLNS, 'rect');\r\n    $rect.setAttributeNS(null, \"x\", rect[0][0].toString());\r\n    $rect.setAttributeNS(null, \"y\", rect[0][1].toString());\r\n    $rect.setAttributeNS(null, \"width\", (rect[1][0] - rect[0][0]).toString());\r\n    $rect.setAttributeNS(null, \"height\", (rect[1][1] - rect[0][1]).toString());\r\n    if (classes) {\r\n        $rect.setAttributeNS(null, \"class\", classes);\r\n    }\r\n    g.appendChild($rect);\r\n    if (delay) {\r\n        setTimeout(() => $rect.remove(), delay);\r\n    }\r\n    return [$rect];\r\n}\r\nexports.rect = rect;\r\n//# sourceMappingURL=rect.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-draw/node/draw/rect.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/split-at.js":
/*!*****************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/split-at.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns 2 new beziers split at the given t parameter, i.e. for the ranges\r\n * [0,t] and [t,1].\r\n * @param ps\r\n * @param t\r\n */\r\nfunction splitAt(ps, t) {\r\n    if (ps.length === 2) {\r\n        return splitLineAt(ps, t);\r\n    }\r\n    else if (ps.length === 3) {\r\n        return splitQuadAt(ps, t);\r\n    }\r\n    else if (ps.length === 4) {\r\n        return splitCubicAt(ps, t);\r\n    }\r\n    return [];\r\n}\r\nexports.splitAt = splitAt;\r\n/**\r\n * Returns 2 new cubic beziers split at the given t parameter, i.e. for the ranges\r\n * [0,t] and [t,1]. Uses de Casteljau's algorithm.\r\n *\r\n * A loose bound on the accuracy of the resultant points is given by:\r\n * |δP| = 2n*max_k(|b_k|)η, where n = 3 (cubic), b_k are the control points\r\n * abd η is Number.EPSILON.\r\n * @param ps A cubic bezier curve\r\n * @param t The t parameter where the curve should be split\r\n */\r\nfunction splitCubicAt(ps, t) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    let s = 1 - t;\r\n    let t2 = t * t;\r\n    let t3 = t2 * t;\r\n    let s2 = s * s;\r\n    let s3 = s2 * s;\r\n    /** The split point */\r\n    let p = [\r\n        t3 * x3 + 3 * s * t2 * x2 + 3 * s2 * t * x1 + s3 * x0,\r\n        t3 * y3 + 3 * s * t2 * y2 + 3 * s2 * t * y1 + s3 * y0\r\n    ];\r\n    let ps1 = [\r\n        [x0, y0],\r\n        [t * x1 + s * x0,\r\n            t * y1 + s * y0],\r\n        [t2 * x2 + 2 * s * t * x1 + s2 * x0,\r\n            t2 * y2 + 2 * s * t * y1 + s2 * y0],\r\n        p\r\n    ];\r\n    let ps2 = [\r\n        p,\r\n        [t2 * x3 + 2 * t * s * x2 + s2 * x1,\r\n            t2 * y3 + 2 * t * s * y2 + s2 * y1],\r\n        [t * x3 + s * x2,\r\n            t * y3 + s * y2],\r\n        [x3, y3]\r\n    ];\r\n    return [ps1, ps2];\r\n}\r\nfunction splitQuadAt(ps, t) {\r\n    let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    let s = 1 - t;\r\n    /** The split point */\r\n    let p = [\r\n        s * s * x0 + 2 * s * t * x1 + t * t * x2,\r\n        s * s * y0 + 2 * s * t * y1 + t * t * y2\r\n    ];\r\n    let ps1 = [\r\n        [x0, y0],\r\n        [s * x0 + t * x1,\r\n            s * y0 + t * y1],\r\n        p\r\n    ];\r\n    let ps2 = [\r\n        p,\r\n        [s * x1 + t * x2,\r\n            s * y1 + t * y2],\r\n        [x2, y2]\r\n    ];\r\n    return [ps1, ps2];\r\n}\r\nfunction splitLineAt(ps, t) {\r\n    let [[x0, y0], [x1, y1]] = ps;\r\n    let s = 1 - t;\r\n    /** The split point */\r\n    let p = [\r\n        s * x0 + t * x1,\r\n        s * y0 + t * y1\r\n    ];\r\n    let ps1 = [\r\n        [x0, y0],\r\n        p\r\n    ];\r\n    let ps2 = [\r\n        p,\r\n        [x1, y1]\r\n    ];\r\n    return [ps1, ps2];\r\n}\r\n//# sourceMappingURL=split-at.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-draw/node/draw/split-at.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/xmlns.js":
/*!**************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/xmlns.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst XMLNS = 'http://www.w3.org/2000/svg';\r\nexports.XMLNS = XMLNS;\r\n//# sourceMappingURL=xmlns.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-draw/node/draw/xmlns.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/index.js":
/*!*********************************************!*\
  !*** ./node_modules/flo-draw/node/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst circle_1 = __webpack_require__(/*! ./draw/circle */ \"./node_modules/flo-draw/node/draw/circle.js\");\r\nconst cross_hair_1 = __webpack_require__(/*! ./draw/cross-hair */ \"./node_modules/flo-draw/node/draw/cross-hair.js\");\r\nconst dot_1 = __webpack_require__(/*! ./draw/dot */ \"./node_modules/flo-draw/node/draw/dot.js\");\r\nconst line_1 = __webpack_require__(/*! ./draw/line */ \"./node_modules/flo-draw/node/draw/line.js\");\r\nconst rect_1 = __webpack_require__(/*! ./draw/rect */ \"./node_modules/flo-draw/node/draw/rect.js\");\r\nconst polygon_1 = __webpack_require__(/*! ./draw/polygon */ \"./node_modules/flo-draw/node/draw/polygon.js\");\r\nconst loop_1 = __webpack_require__(/*! ./draw/loop */ \"./node_modules/flo-draw/node/draw/loop.js\");\r\nconst polyline_1 = __webpack_require__(/*! ./draw/polyline */ \"./node_modules/flo-draw/node/draw/polyline.js\");\r\nconst beziers_1 = __webpack_require__(/*! ./draw/beziers */ \"./node_modules/flo-draw/node/draw/beziers.js\");\r\nconst cubic_bezier_1 = __webpack_require__(/*! ./draw/cubic-bezier */ \"./node_modules/flo-draw/node/draw/cubic-bezier.js\");\r\nconst bezier_1 = __webpack_require__(/*! ./draw/bezier */ \"./node_modules/flo-draw/node/draw/bezier.js\");\r\nconst bezier_piece_1 = __webpack_require__(/*! ./draw/bezier-piece */ \"./node_modules/flo-draw/node/draw/bezier-piece.js\");\r\nconst quad_bezier_1 = __webpack_require__(/*! ./draw/quad-bezier */ \"./node_modules/flo-draw/node/draw/quad-bezier.js\");\r\nlet drawFs = {\r\n    circle: circle_1.circle,\r\n    crossHair: cross_hair_1.crossHair,\r\n    dot: dot_1.dot,\r\n    line: line_1.line,\r\n    rect: rect_1.rect,\r\n    beziers: beziers_1.beziers,\r\n    bezier: bezier_1.bezier,\r\n    bezierPiece: bezier_piece_1.bezierPiece,\r\n    quadBezier: quad_bezier_1.quadBezier,\r\n    cubicBezier: cubic_bezier_1.cubicBezier,\r\n    polygon: polygon_1.polygon,\r\n    loop: loop_1.loop,\r\n    polyline: polyline_1.polyline\r\n};\r\nexports.drawFs = drawFs;\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-draw/node/index.js?");

/***/ }),

/***/ "./node_modules/flo-gauss-quadrature/node/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-gauss-quadrature/node/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n// TODO A future improvement can be to use the Gauss–Kronrod rules\r\n// to estimate the error and thus choose a number of constants based\r\n// on the error.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// TODO In future, the constants can be calculated and cached so we can\r\n// choose any value for the order.\r\n/**\r\n * Numerically integrates the given function using the Gaussian Quadrature\r\n * method.\r\n *\r\n * See https://en.wikipedia.org/wiki/Gaussian_quadrature\r\n * See http://pomax.github.io/bezierinfo/#arclength\r\n * @param f The univariate function to be integrated\r\n * @param interval The integration interval\r\n * @param order Can be 2, 4, 8, or 16. Higher values give more accurate results\r\n * but is slower - defaults to 16.\r\n */\r\nfunction gaussQuadrature(f, interval, order = 16) {\r\n    if (interval[0] === interval[1]) {\r\n        return 0;\r\n    }\r\n    let { weights, abscissas } = GAUSS_CONSTANTS[order];\r\n    let [a, b] = interval;\r\n    let result = 0;\r\n    let m1 = (b - a) / 2;\r\n    let m2 = (b + a) / 2;\r\n    for (let i = 0; i <= order - 1; i++) {\r\n        result += weights[i] * f(m1 * abscissas[i] + m2);\r\n    }\r\n    return m1 * result;\r\n}\r\nexports.gaussQuadrature = gaussQuadrature;\r\n// The Gaussian Legendre Quadrature method constants. \r\nconst GAUSS_CONSTANTS = {\r\n    2: {\r\n        weights: [1, 1],\r\n        abscissas: [-0.5773502691896257, 0.5773502691896257]\r\n    },\r\n    4: {\r\n        weights: [0.6521451548625461, 0.6521451548625461,\r\n            0.3478548451374538, 0.3478548451374538],\r\n        abscissas: [-0.3399810435848563, 0.3399810435848563,\r\n            -0.8611363115940526, 0.8611363115940526]\r\n    },\r\n    8: {\r\n        weights: [0.3626837833783620, 0.3626837833783620,\r\n            0.3137066458778873, 0.3137066458778873,\r\n            0.2223810344533745, 0.2223810344533745,\r\n            0.1012285362903763, 0.1012285362903763],\r\n        abscissas: [-0.1834346424956498, 0.1834346424956498,\r\n            -0.5255324099163290, 0.5255324099163290,\r\n            -0.7966664774136267, 0.7966664774136267,\r\n            -0.9602898564975363, 0.9602898564975363]\r\n    },\r\n    // Taken from http://keisan.casio.com/exec/system/1330940731\r\n    16: {\r\n        abscissas: [-0.989400934991649932596,\r\n            -0.944575023073232576078,\r\n            -0.86563120238783174388,\r\n            -0.7554044083550030338951,\r\n            -0.6178762444026437484467,\r\n            -0.4580167776572273863424,\r\n            -0.28160355077925891323,\r\n            -0.0950125098376374401853,\r\n            0.0950125098376374401853,\r\n            0.28160355077925891323,\r\n            0.4580167776572273863424,\r\n            0.617876244402643748447,\r\n            0.755404408355003033895,\r\n            0.8656312023878317438805,\r\n            0.944575023073232576078,\r\n            0.989400934991649932596\r\n        ],\r\n        weights: [\r\n            0.0271524594117540948518,\r\n            0.062253523938647892863,\r\n            0.0951585116824927848099,\r\n            0.1246289712555338720525,\r\n            0.1495959888165767320815,\r\n            0.169156519395002538189,\r\n            0.182603415044923588867,\r\n            0.189450610455068496285,\r\n            0.1894506104550684962854,\r\n            0.182603415044923588867,\r\n            0.1691565193950025381893,\r\n            0.149595988816576732081,\r\n            0.124628971255533872053,\r\n            0.095158511682492784809,\r\n            0.062253523938647892863,\r\n            0.027152459411754094852\r\n        ]\r\n    }\r\n};\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-gauss-quadrature/node/index.js?");

/***/ }),

/***/ "./node_modules/flo-graham-scan/node/get-smallest-indx-y-then-x.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-graham-scan/node/get-smallest-indx-y-then-x.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * @private\r\n */\r\nfunction getSmallestIndxYThenX(ps) {\r\n    let smallest = [\r\n        Number.POSITIVE_INFINITY,\r\n        Number.POSITIVE_INFINITY\r\n    ];\r\n    let smallestI = undefined;\r\n    for (let i = 0; i < ps.length; i++) {\r\n        let y = ps[i][1];\r\n        if ((y < smallest[1]) ||\r\n            (y === smallest[1] && ps[i][0] < smallest[0])) {\r\n            smallestI = i;\r\n            smallest = ps[i];\r\n        }\r\n    }\r\n    return smallestI;\r\n}\r\nexports.getSmallestIndxYThenX = getSmallestIndxYThenX;\r\n//# sourceMappingURL=get-smallest-indx-y-then-x.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-graham-scan/node/get-smallest-indx-y-then-x.js?");

/***/ }),

/***/ "./node_modules/flo-graham-scan/node/index.js":
/*!****************************************************!*\
  !*** ./node_modules/flo-graham-scan/node/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst get_smallest_indx_y_then_x_1 = __webpack_require__(/*! ./get-smallest-indx-y-then-x */ \"./node_modules/flo-graham-scan/node/get-smallest-indx-y-then-x.js\");\r\nconst swap_1 = __webpack_require__(/*! ./swap */ \"./node_modules/flo-graham-scan/node/swap.js\");\r\n/**\r\n * Finds the convex hull of the given set of 2d points using the\r\n * Graham Scan algorithm and returns the hull as an array of points.\r\n * See https://en.wikipedia.org/wiki/Graham_scan\r\n *\r\n * Robust: This algorithm is robust via adaptive infinite precision floating\r\n * point arithmetic.\r\n * @param ps A set of points\r\n * @param includeAllBoundaryPoints Set this to true to if all boundary points\r\n * should be returned, even redundant ones - defaults to false\r\n */\r\nfunction grahamScan(ps, includeAllBoundaryPoints = false) {\r\n    if (!ps.length) {\r\n        return undefined;\r\n    }\r\n    function fail(p1, p2, p3) {\r\n        let res = flo_numerical_1.orient2d(p1, p2, p3);\r\n        return includeAllBoundaryPoints\r\n            ? res < 0\r\n            : res <= 0;\r\n    }\r\n    let ps_ = ps.slice();\r\n    let n = ps_.length;\r\n    let idx = get_smallest_indx_y_then_x_1.getSmallestIndxYThenX(ps_);\r\n    let [p] = ps_.splice(idx, 1);\r\n    ps_.sort((a, b) => {\r\n        let res = -flo_numerical_1.orient2d(p, a, b);\r\n        if (res !== 0) {\r\n            return res;\r\n        }\r\n        res = a[1] - b[1];\r\n        if (res !== 0) {\r\n            return res;\r\n        }\r\n        return a[0] - b[0];\r\n    });\r\n    ps_.unshift(p);\r\n    let m = 1;\r\n    for (let i = 2; i < n; i++) {\r\n        while (fail(ps_[m - 1], ps_[m], ps_[i])) {\r\n            if (m > 1) {\r\n                m -= 1;\r\n                continue;\r\n            }\r\n            else if (i === n - 1) {\r\n                m -= 1;\r\n                break;\r\n            }\r\n            else {\r\n                i += 1;\r\n            }\r\n        }\r\n        m += 1;\r\n        swap_1.swap(ps_, m, i);\r\n    }\r\n    return ps_.slice(0, m + 1);\r\n}\r\nexports.grahamScan = grahamScan;\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-graham-scan/node/index.js?");

/***/ }),

/***/ "./node_modules/flo-graham-scan/node/swap.js":
/*!***************************************************!*\
  !*** ./node_modules/flo-graham-scan/node/swap.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * In-place swap two elements in the given array.\r\n * @ignore\r\n */\r\nfunction swap(arr, a, b) {\r\n    if (a === b) {\r\n        return;\r\n    }\r\n    let temp = arr[a];\r\n    arr[a] = arr[b];\r\n    arr[b] = temp;\r\n}\r\nexports.swap = swap;\r\n//# sourceMappingURL=swap.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-graham-scan/node/swap.js?");

/***/ }),

/***/ "./node_modules/flo-ll-rb-tree/node/index.js":
/*!***************************************************!*\
  !*** ./node_modules/flo-ll-rb-tree/node/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Concise, Destructive, Left Leaning Red Black Tree implementation.\n * See: https://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf\n * See: https://en.wikipedia.org/wiki/Left-leaning_red%E2%80%93black_tree\n * See: http://www.teachsolaisgames.com/articles/balanced_left_leaning.html\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tree_node_1 = __webpack_require__(/*! ./src/tree-node */ \"./node_modules/flo-ll-rb-tree/node/src/tree-node.js\");\nconst tree_node_color_1 = __webpack_require__(/*! ./src/tree-node-color */ \"./node_modules/flo-ll-rb-tree/node/src/tree-node-color.js\");\nconst tree_node_direction_1 = __webpack_require__(/*! ./src/tree-node-direction */ \"./node_modules/flo-ll-rb-tree/node/src/tree-node-direction.js\");\nfunction isRed(node) {\n    return node && node.color === tree_node_color_1.default.RED;\n}\n/**\n * @param compare\n * @param datas\n * @param replaceDups - If true then if a duplicate is\n * inserted (as per the equivalence relation induced by the compare)\n * then replace it. If false then keep an array of values at the relevant\n * node.\n */\nclass LlRbTree {\n    constructor(compare, datas, replaceDups) {\n        this.getMinNode = this.getMinOrMaxNode(tree_node_direction_1.default.LEFT);\n        this.getMaxNode = this.getMinOrMaxNode(tree_node_direction_1.default.RIGHT);\n        const tree = this;\n        tree.setComparator(compare, replaceDups);\n        tree.replaceDups = replaceDups;\n        tree.root = null;\n        if (!datas) {\n            return;\n        }\n        for (let data of datas) {\n            tree.insert(data);\n        }\n    }\n    /**\n     * Destructively sets the tree compare. This function can be used for for e.g.\n     * the Bentley Ottmann algorithm.\n     */\n    setComparator(compare, replaceDups) {\n        if (replaceDups) {\n            this.compare = compare;\n        }\n        else {\n            this.compare = (a, b) => compare(a, b[0]);\n        }\n    }\n    isEmpty() { return !this.root; }\n    /**\n     * Find the node in the tree with the given data using the tree compare\n     * function.\n     * @returns {Node} node or null if not found.\n     */\n    find(data) {\n        const tree = this;\n        let node = this.root;\n        while (node) {\n            let c = tree.compare(data, node.data);\n            if (c === 0) {\n                return node;\n            }\n            else {\n                node = node[c > 0 ? tree_node_direction_1.default.RIGHT : tree_node_direction_1.default.LEFT];\n            }\n        }\n        return null;\n    }\n    /**\n     * .\n     */\n    toArrayInOrder() {\n        let nodes = [];\n        f(this.root);\n        function f(node) {\n            if (!node) {\n                return;\n            }\n            f(node[tree_node_direction_1.default.LEFT]);\n            nodes.push(node);\n            f(node[tree_node_direction_1.default.RIGHT]);\n        }\n        return nodes;\n    }\n    /**\n     * Inserts a node with the given data into the tree.\n     */\n    insert(data) {\n        const tree = this;\n        tree.root = f(tree.root, data);\n        tree.root.color = tree_node_color_1.default.BLACK;\n        tree.root.parent = undefined;\n        function f(h, data) {\n            if (!h) {\n                return new tree_node_1.default(data, !tree.replaceDups);\n            }\n            let c = tree.compare(data, h.data);\n            if (c === 0) {\n                if (tree.replaceDups) {\n                    h.data = data;\n                }\n                else {\n                    h.data.push(data);\n                }\n            }\n            else {\n                let dir = c > 0 ? tree_node_direction_1.default.RIGHT : tree_node_direction_1.default.LEFT;\n                h[dir] = f(h[dir], data);\n                h[dir].parent = h;\n            }\n            if (isRed(h[tree_node_direction_1.default.RIGHT]) &&\n                !isRed(h[tree_node_direction_1.default.LEFT])) {\n                h = rotate(tree_node_direction_1.default.LEFT, h);\n            }\n            if (isRed(h[tree_node_direction_1.default.LEFT]) &&\n                isRed(h[tree_node_direction_1.default.LEFT][tree_node_direction_1.default.LEFT])) {\n                h = rotate(tree_node_direction_1.default.RIGHT, h);\n            }\n            if (isRed(h[tree_node_direction_1.default.LEFT]) &&\n                isRed(h[tree_node_direction_1.default.RIGHT])) {\n                flipColors(h);\n            }\n            return h;\n        }\n    }\n    /**\n     * Removes an item from the tree based on the given data.\n     * @param {LlRbTree} tree\n     * @param {*} data\n     * @param {boolean} all - If the data is an array, remove all.\n     */\n    remove(data, all) {\n        const tree = this;\n        tree.root = f(tree.root, data);\n        if (tree.root) {\n            tree.root.color = tree_node_color_1.default.BLACK;\n            tree.root.parent = undefined;\n        }\n        function f(h, data) {\n            //let h = h_;\n            let c = tree.compare(data, h.data);\n            if (!tree.replaceDups && c === 0 && !all && h.data.length > 1) {\n                removeFromArray(data, h.data);\n                return h;\n            }\n            if (c < 0 && !h[tree_node_direction_1.default.LEFT] || c > 0 && !h[tree_node_direction_1.default.RIGHT]) {\n                return h;\n            }\n            if (c < 0) {\n                if (!isRed(h[tree_node_direction_1.default.LEFT]) &&\n                    !isRed(h[tree_node_direction_1.default.LEFT][tree_node_direction_1.default.LEFT])) {\n                    h = moveRedLeft(h);\n                }\n                h[tree_node_direction_1.default.LEFT] = f(h[tree_node_direction_1.default.LEFT], data);\n                if (h[tree_node_direction_1.default.LEFT]) {\n                    h[tree_node_direction_1.default.LEFT].parent = h;\n                }\n                return fixUp(h);\n            }\n            if (isRed(h[tree_node_direction_1.default.LEFT])) {\n                h = rotate(tree_node_direction_1.default.RIGHT, h);\n                c = tree.compare(data, h.data);\n                if (!tree.replaceDups && c === 0 && !all && h.data.length > 1) {\n                    removeFromArray(data, h.data);\n                    return h;\n                }\n            }\n            if (c === 0 && !h[tree_node_direction_1.default.RIGHT]) {\n                return null;\n            }\n            if (!isRed(h[tree_node_direction_1.default.RIGHT]) &&\n                !isRed(h[tree_node_direction_1.default.RIGHT][tree_node_direction_1.default.LEFT])) {\n                h = moveRedRight(h);\n                c = tree.compare(data, h.data);\n                if (!tree.replaceDups && c === 0 && !all && h.data.length > 1) {\n                    removeFromArray(data, h.data);\n                    return h;\n                }\n            }\n            if (c === 0) {\n                h.data = tree.min(h[tree_node_direction_1.default.RIGHT]);\n                h[tree_node_direction_1.default.RIGHT] = removeMin(h[tree_node_direction_1.default.RIGHT]);\n            }\n            else {\n                h[tree_node_direction_1.default.RIGHT] = f(h[tree_node_direction_1.default.RIGHT], data);\n            }\n            if (h[tree_node_direction_1.default.RIGHT]) {\n                h[tree_node_direction_1.default.RIGHT].parent = h;\n            }\n            return fixUp(h);\n        }\n    }\n    /**\n     * Returns the two ordered nodes bounding the data. If the\n     * data falls on a node, that node and the next (to the right) is\n     * returned.\n     * @returns {Node[]}\n     */\n    findBounds(data) {\n        const tree = this;\n        let node = tree.root;\n        let bounds = [undefined, undefined];\n        if (node === null) {\n            return bounds;\n        }\n        while (node) {\n            const c = tree.compare(data, node.data);\n            if (c >= 0) {\n                bounds[0] = node;\n            }\n            else {\n                bounds[1] = node;\n            }\n            node = node[c >= 0 ? tree_node_direction_1.default.RIGHT : tree_node_direction_1.default.LEFT];\n        }\n        return bounds;\n    }\n    /**\n     * @param {LlRbTree} tree\n     * @param {*} data\n     * @returns {Node[]} The two ordered nodes bounding the data. If the\n     * data falls on a node, returns the nodes before and after this one.\n     */\n    findBoundsExcl(data) {\n        const tree = this;\n        let node = tree.root;\n        let bounds = [undefined, undefined];\n        if (node === null) {\n            return bounds;\n        }\n        f(node);\n        function f(node) {\n            while (node) {\n                let c = tree.compare(data, node.data);\n                if (c === 0) {\n                    // Search on both sides\n                    f(node[tree_node_direction_1.default.LEFT]);\n                    f(node[tree_node_direction_1.default.RIGHT]);\n                    return;\n                }\n                if (c > 0) {\n                    bounds[0] = node;\n                }\n                else if (c < 0) {\n                    bounds[1] = node;\n                }\n                node = node[c > 0 ? tree_node_direction_1.default.RIGHT : tree_node_direction_1.default.LEFT];\n            }\n        }\n        return bounds;\n    }\n    /**\n     *\n     */\n    findAllInOrder(data) {\n        const tree = this;\n        let nodes = [];\n        f(tree.root);\n        function f(node) {\n            while (node) {\n                let c = tree.compare(data, node.data);\n                if (c === 0) {\n                    f(node[tree_node_direction_1.default.LEFT]);\n                    nodes.push(node);\n                    f(node[tree_node_direction_1.default.RIGHT]);\n                    return;\n                }\n                node = node[c > 0 ? tree_node_direction_1.default.RIGHT : tree_node_direction_1.default.LEFT];\n            }\n        }\n        return nodes;\n    }\n    getMinOrMaxNode(dir) {\n        return function (node) {\n            if (!node) {\n                return undefined;\n            }\n            while (node[dir]) {\n                node = node[dir];\n            }\n            return node;\n        };\n    }\n    min(node) {\n        return this.getMinNode(node).data;\n    }\n    max(node) {\n        return this.getMaxNode(node).data;\n    }\n}\n/**\n * Removes the data from the tuple using ===.\n * Note this function uses === and not the compare function!\n */\nfunction removeFromArray(elem, arr) {\n    let index = arr.indexOf(elem);\n    if (index !== -1) {\n        arr.splice(index, 1);\n    }\n}\n/**\n * Destructively rotates the given node, say h, in the\n * given direction as far as tree rotations go.\n * @param {boolean} dir true -> right, false -> left\n * @param {Node} h\n * @returns The node that is at the top after the rotation.\n */\nfunction rotate(dir, h) {\n    const otherDir = dir ? tree_node_direction_1.default.LEFT : tree_node_direction_1.default.RIGHT;\n    const x = h[otherDir];\n    h[otherDir] = x[dir];\n    if (x[dir]) {\n        x[dir].parent = h;\n    }\n    x[dir] = h;\n    h.parent = x;\n    x.color = h.color;\n    h.color = tree_node_color_1.default.RED;\n    return x;\n}\nfunction removeMin(h) {\n    if (!h[tree_node_direction_1.default.LEFT]) {\n        return null;\n    }\n    if (!isRed(h[tree_node_direction_1.default.LEFT]) &&\n        !isRed(h[tree_node_direction_1.default.LEFT][tree_node_direction_1.default.LEFT])) {\n        h = moveRedLeft(h);\n    }\n    h[tree_node_direction_1.default.LEFT] = removeMin(h[tree_node_direction_1.default.LEFT]);\n    if (h[tree_node_direction_1.default.LEFT]) {\n        h[tree_node_direction_1.default.LEFT].parent = h;\n    }\n    return fixUp(h);\n}\nfunction flipColor(color) {\n    return color === tree_node_color_1.default.RED ? tree_node_color_1.default.BLACK : tree_node_color_1.default.RED;\n}\n/**\n * Destructively flips the color of the given node and both\n * it's childrens' colors.\n * @param {Node} h\n */\nfunction flipColors(h) {\n    h.color = flipColor(h.color);\n    h[tree_node_direction_1.default.LEFT].color = flipColor(h[tree_node_direction_1.default.LEFT].color);\n    h[tree_node_direction_1.default.RIGHT].color = flipColor(h[tree_node_direction_1.default.RIGHT].color);\n}\n/**\n * @description\n * @param h\n * @returns The node that is at the top after the move.\n */\nfunction moveRedLeft(h) {\n    flipColors(h);\n    if (isRed(h[tree_node_direction_1.default.RIGHT][tree_node_direction_1.default.LEFT])) {\n        let a = rotate(tree_node_direction_1.default.RIGHT, h[tree_node_direction_1.default.RIGHT]);\n        h[tree_node_direction_1.default.RIGHT] = a;\n        a.parent = h;\n        h = rotate(tree_node_direction_1.default.LEFT, h);\n        flipColors(h);\n    }\n    return h;\n}\n/**\n * @description\n * @param h\n * @returns The node that is at the top after the move.\n */\nfunction moveRedRight(h) {\n    flipColors(h);\n    if (isRed(h[tree_node_direction_1.default.LEFT][tree_node_direction_1.default.LEFT])) {\n        h = rotate(tree_node_direction_1.default.RIGHT, h);\n        flipColors(h);\n    }\n    return h;\n}\n/**\n * @description Fix right-leaning red nodes.\n * @returns The node that is at the top after the fix.\n */\nfunction fixUp(h) {\n    if (isRed(h[tree_node_direction_1.default.RIGHT])) {\n        h = rotate(tree_node_direction_1.default.LEFT, h);\n    }\n    if (isRed(h[tree_node_direction_1.default.LEFT]) &&\n        isRed(h[tree_node_direction_1.default.LEFT][tree_node_direction_1.default.LEFT])) {\n        h = rotate(tree_node_direction_1.default.RIGHT, h);\n    }\n    // Split 4-nodes.\n    if (isRed(h[tree_node_direction_1.default.LEFT]) &&\n        isRed(h[tree_node_direction_1.default.RIGHT])) {\n        flipColors(h);\n    }\n    return h;\n}\nexports.default = LlRbTree;\n\n\n//# sourceURL=webpack:///./node_modules/flo-ll-rb-tree/node/index.js?");

/***/ }),

/***/ "./node_modules/flo-ll-rb-tree/node/src/tree-node-color.js":
/*!*****************************************************************!*\
  !*** ./node_modules/flo-ll-rb-tree/node/src/tree-node-color.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar TreeNodeColor;\n(function (TreeNodeColor) {\n    TreeNodeColor[TreeNodeColor[\"BLACK\"] = 0] = \"BLACK\";\n    TreeNodeColor[TreeNodeColor[\"RED\"] = 1] = \"RED\";\n})(TreeNodeColor || (TreeNodeColor = {}));\nexports.default = TreeNodeColor;\n\n\n//# sourceURL=webpack:///./node_modules/flo-ll-rb-tree/node/src/tree-node-color.js?");

/***/ }),

/***/ "./node_modules/flo-ll-rb-tree/node/src/tree-node-direction.js":
/*!*********************************************************************!*\
  !*** ./node_modules/flo-ll-rb-tree/node/src/tree-node-direction.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar TreeNodeDirection;\n(function (TreeNodeDirection) {\n    TreeNodeDirection[TreeNodeDirection[\"LEFT\"] = 0] = \"LEFT\";\n    TreeNodeDirection[TreeNodeDirection[\"RIGHT\"] = 1] = \"RIGHT\";\n})(TreeNodeDirection || (TreeNodeDirection = {}));\nexports.default = TreeNodeDirection;\n\n\n//# sourceURL=webpack:///./node_modules/flo-ll-rb-tree/node/src/tree-node-direction.js?");

/***/ }),

/***/ "./node_modules/flo-ll-rb-tree/node/src/tree-node.js":
/*!***********************************************************!*\
  !*** ./node_modules/flo-ll-rb-tree/node/src/tree-node.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tree_node_color_1 = __webpack_require__(/*! ./tree-node-color */ \"./node_modules/flo-ll-rb-tree/node/src/tree-node-color.js\");\n/**\n * Red Black Tree node.\n * @constructor\n * @param {*} data\n */\nclass TreeNode {\n    constructor(data, asArray) {\n        if (asArray) {\n            this.data = [data];\n        }\n        else {\n            this.data = data;\n        }\n        this.color = tree_node_color_1.default.RED;\n    }\n}\nexports.default = TreeNode;\n\n\n//# sourceURL=webpack:///./node_modules/flo-ll-rb-tree/node/src/tree-node.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/bezier-piece.js":
/*!***************************************************!*\
  !*** ./node_modules/flo-mat/node/bezier-piece.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Represents a part of a bezier within the shape boundary.\r\n */\r\nclass BezierPiece {\r\n    /**\r\n     * @param curve A bezier curve within the shape boundary.\r\n     * @param ts The start and end t parameter values of the bezier curve.\r\n     */\r\n    constructor(curve, ts) {\r\n        this.curve = curve;\r\n        this.ts = ts;\r\n    }\r\n}\r\nexports.BezierPiece = BezierPiece;\r\n//# sourceMappingURL=bezier-piece.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/bezier-piece.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/beziers-to-svg-path-str.js":
/*!**************************************************************!*\
  !*** ./node_modules/flo-mat/node/beziers-to-svg-path-str.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns an SVG path string representation of the given cubic bezier loop.\r\n * @param beziers An array of cubic bezier curves each given as an array of\r\n * control points.\r\n * @param decimalPlaces The number of decimal places in the returned path\r\n * string.\r\n */\r\nfunction beziersToSvgPathStr(beziers, decimalPlaces = 10) {\r\n    const D = decimalPlaces;\r\n    let str = '';\r\n    for (let i = 0; i < beziers.length; i++) {\r\n        let ps = beziers[i];\r\n        if (i === 0) {\r\n            str = 'M ' +\r\n                ps[0][0].toFixed(D) + ' ' +\r\n                ps[0][1].toFixed(D) + '\\n';\r\n        }\r\n        str += 'C ' +\r\n            ps[1][0].toFixed(D) + ' ' +\r\n            ps[1][1].toFixed(D) + ' ' +\r\n            ps[2][0].toFixed(D) + ' ' +\r\n            ps[2][1].toFixed(D) + ' ' +\r\n            ps[3][0].toFixed(D) + ' ' +\r\n            ps[3][1].toFixed(D) + ' ' + '\\n';\r\n    }\r\n    return str + ' z' + '\\n';\r\n}\r\nexports.beziersToSvgPathStr = beziersToSvgPathStr;\r\n//# sourceMappingURL=beziers-to-svg-path-str.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/beziers-to-svg-path-str.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/circle.js":
/*!*********************************************!*\
  !*** ./node_modules/flo-mat/node/circle.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\n/**\r\n * Canonical circle representation.\r\n */\r\nclass Circle {\r\n    /**\r\n     * @param center The center.\r\n     * @param radius The radius.\r\n     */\r\n    constructor(center, radius) {\r\n        this.center = center;\r\n        this.radius = radius;\r\n    }\r\n    /**\r\n     * Returns a scaled version of the given circle without changing its center.\r\n     * @param circle\r\n     * @param s multiplier\r\n     */\r\n    static scale(circle, s) {\r\n        return new Circle(circle.center, circle.radius * s);\r\n    }\r\n    /**\r\n     * Returns true if the first circle engulfs the second.\r\n     * @param c1\r\n     * @param c2\r\n     */\r\n    static engulfsCircle(c1, c2) {\r\n        if (c1.radius <= c2.radius) {\r\n            return false;\r\n        }\r\n        let d = flo_vector2d_1.squaredDistanceBetween(c1.center, c2.center);\r\n        let dr = c1.radius - c2.radius;\r\n        let δ = dr * dr;\r\n        return δ > d;\r\n    }\r\n    /**\r\n     * Returns a human-readable string description of the given circle.\r\n     * @param circle\r\n     */\r\n    static toString(circle) {\r\n        return 'c: ' + circle.center + ' r: ' + circle.radius;\r\n    }\r\n}\r\nexports.Circle = Circle;\r\n//# sourceMappingURL=circle.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/circle.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/contact-point.js":
/*!****************************************************!*\
  !*** ./node_modules/flo-mat/node/contact-point.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst point_on_shape_1 = __webpack_require__(/*! ./point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\n/**\r\n * Represents a point on the shape boundary for which MAT data has been\r\n * calculated.\r\n */\r\nclass ContactPoint {\r\n    /**\r\n     * @param pointOnShape Identifies the point on the shape boundary.\r\n     * @param circle The maximal disk circle touching this point.\r\n     * @param order Internally used to order two points lying at the same planar\r\n     * point.\r\n     * @param order2\r\n     * Internally used to order two points lying at the same planar\r\n     * point.\r\n     */\r\n    constructor(pointOnShape, circle, order, order2) {\r\n        this.pointOnShape = pointOnShape;\r\n        this.circle = circle;\r\n        this.order = order;\r\n        this.order2 = order2;\r\n    }\r\n    /**\r\n     * Primarily for internal use.\r\n     *\r\n     * Compares the two contact points according to their order along the shape\r\n     * boundary. Returns > 0 if a > b, < 0 if a < b or 0 if a === b.\r\n     * @param a The first contact point.\r\n     * @param b The second contact point.\r\n     */\r\n    static compare(a, b) {\r\n        let res = point_on_shape_1.PointOnShape.compare(a.pointOnShape, b.pointOnShape);\r\n        if (res === undefined) {\r\n            return undefined;\r\n        }\r\n        if (res !== 0) {\r\n            return res;\r\n        }\r\n        res = a.order - b.order;\r\n        if (res !== 0) {\r\n            return res;\r\n        }\r\n        return a.order2 - b.order2;\r\n    }\r\n}\r\nexports.ContactPoint = ContactPoint;\r\n//# sourceMappingURL=contact-point.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/contact-point.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/corner.js":
/*!*********************************************!*\
  !*** ./node_modules/flo-mat/node/corner.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Represents a corner on the shape boundary, i.e. a point where two bezier\r\n * curves meet. This class is typically used internally only.\r\n */\r\nclass Corner {\r\n    /**\r\n     * @param tangents The unit tangents at the points t === 1 of the\r\n     * first curve and at t === 0 of the second respectively.\r\n     * @param crossTangents The cross of the unit tangents.\r\n     * @param isSharp True if the corner is sharp, i.e. > 0 radians as one goes\r\n     * in a positive direction around the shape boundary.\r\n     * @param isDull True if the corner is dull, i.e. < 0 radians as one goes\r\n     * in a positive direction around the shape boundary.\r\n     * @param isQuiteSharp True if the corner is quite sharp, i.e. > δ radians\r\n     * as one goes in a positive direction around the shape boundary where δ is\r\n     * some pre-determined parameter.\r\n     * @param isQuiteDull True if the corner is quite dull, i.e. < δ radians\r\n     * as one goes in a positive direction around the shape boundary where δ is\r\n     * some pre-determined parameter.\r\n     */\r\n    constructor(tangents, crossTangents, isSharp, isDull, isQuiteSharp, isQuiteDull) {\r\n        this.tangents = tangents;\r\n        this.crossTangents = crossTangents;\r\n        this.isSharp = isSharp;\r\n        this.isDull = isDull;\r\n        this.isQuiteSharp = isQuiteSharp;\r\n        this.isQuiteDull = isQuiteDull;\r\n    }\r\n}\r\nexports.Corner = Corner;\r\n//# sourceMappingURL=corner.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/corner.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/cp-node/clone.js":
/*!****************************************************!*\
  !*** ./node_modules/flo-mat/node/cp-node/clone.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst cp_node_1 = __webpack_require__(/*! ./cp-node */ \"./node_modules/flo-mat/node/cp-node/cp-node.js\");\r\n/** @hidden */\r\nconst EDGES = ['prev', 'next', 'prevOnCircle', 'nextOnCircle'];\r\n/**\r\n * Returns a deep clone of this [[CpNode]]. Can be used to copy the MAT\r\n * since cloning a single [[CpNode]] necessarily implies cloning all\r\n * [[CpNode]]s on the same MAT tree.\r\n */\r\nfunction clone(cpNode) {\r\n    // Don't change this function to be recursive, the call stack may \r\n    // overflow if there are too many CpNodes.\r\n    let nodeMap = new Map();\r\n    let newCpNode = new cp_node_1.CpNode(cpNode.cp, cpNode.isHoleClosing, cpNode.isIntersection);\r\n    //newCpNode.matCurveToNextVertex = cpNode.matCurveToNextVertex;\r\n    nodeMap.set(cpNode, newCpNode);\r\n    let cpStack = [{ cpNode, newCpNode }];\r\n    while (cpStack.length) {\r\n        let { cpNode, newCpNode } = cpStack.pop();\r\n        for (let edge of EDGES) {\r\n            let node = cpNode[edge];\r\n            let newNode = nodeMap.get(node);\r\n            if (!newNode) {\r\n                newNode = new cp_node_1.CpNode(node.cp, node.isHoleClosing, node.isIntersection);\r\n                //newNode.matCurveToNextVertex = node.matCurveToNextVertex;\r\n                nodeMap.set(node, newNode);\r\n                cpStack.push({ cpNode: node, newCpNode: newNode });\r\n            }\r\n            newCpNode[edge] = newNode;\r\n        }\r\n    }\r\n    return newCpNode;\r\n}\r\nexports.clone = clone;\r\n//# sourceMappingURL=clone.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/cp-node/clone.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/cp-node/cp-node.js":
/*!******************************************************!*\
  !*** ./node_modules/flo-mat/node/cp-node/cp-node.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst contact_point_1 = __webpack_require__(/*! ../contact-point */ \"./node_modules/flo-mat/node/contact-point.js\");\r\nconst cp_node_for_debugging_1 = __webpack_require__(/*! ../debug/cp-node-for-debugging */ \"./node_modules/flo-mat/node/debug/cp-node-for-debugging.js\");\r\nconst remove_1 = __webpack_require__(/*! ./remove */ \"./node_modules/flo-mat/node/cp-node/remove.js\");\r\n/**\r\n * The primary class of the library.\r\n *\r\n * Since the MAT is a full representation of the shape boundary an instance of\r\n * this class contains both the information of a boundary point and a medial\r\n * axis point (and edge to the next point(s)). It also contains edges to other\r\n * [[CpNode]]s which allows for traversal of the MAT and thus implictly\r\n * represents the entire MAT.\r\n *\r\n * To get the maximal disk circle (of which the center is on the medial axis)\r\n * use [[cp]].circle.\r\n *\r\n * To get the boundary point, use [[cp]].pointOnShape.\r\n *\r\n * The edge, [[next]] (resp. [[prev]]) allows one to move anti-clockwise (resp.\r\n * clockwise) on the shape boundary to the next [[CpNode]]. This also imposes a\r\n * direction of traversal of the MAT edges and vertices.\r\n *\r\n * The edge [[nextOnCircle]] (resp. [[prevOnCircle]]) allows one to go\r\n * anti-clockwise (resp. clockwise) around the maximal disks implied by\r\n * the CpNode to the next maximal disk contact point. This is equivalent to\r\n * following other branches on the MAT.\r\n *\r\n * Each [[CpNode]] has a property, [[matCurveToNextVertex]], which is a bezier\r\n * curve from the maximal disk of this [[CpNode]] to the next [[CpNode]]'s\r\n * maximal disk and thus directly represents a piece of the medial axis.\r\n *\r\n * The getter, [[children]], returns the children of this [[CpNode]] when\r\n * seen as a MAT edge. Only children in a 'forward' direction are returned. These\r\n * include all edges except the 'backward' edge given by [[prevOnCircle]]. For\r\n * [[CpNode]]s having a maximal disk with 2 contact points (a 2-prong, the usual\r\n * case) the children will be the single edge [[next]]. For a 3-prong this will\r\n * be the edgese [[next]] and [[nextOnCircle]], etc. [[children]] allows one to\r\n * easily traverse the MAT tree - see e.g. the implementation of\r\n * [[traverseEdges]].\r\n *\r\n * [[vertexChildren]] is similar to [[children]] but returns the child nodes of\r\n * the tree when [[CpNode]] is seen as a MAT vertex point (as opposed to edge).\r\n * In this way the dual graph of the tree can easily be traversed - see e.g.\r\n * [[traverseVertices]]. Generally, however, traversing the edges is preferred\r\n * as it returns the entire Medial Axis (by utilizing [[matCurveToNextVertex]]\r\n * on each returned edge).\r\n *\r\n * It may be worth mentioning that by traversing from the CpNode by following\r\n * [[next]] repeatedly until one is back at the same CpNode allows one\r\n * to 'go around' the shape and at the same time traverse the MAT twice in\r\n * different directions.\r\n */\r\nclass CpNode {\r\n    /**\r\n     * Primarily for internal use.\r\n     * @param cp The shape boundary contact point, i.e. a [[CpNode]] without its\r\n     * edges.\r\n     * @param prev The previous (going clockwise around the boundary) contact\r\n     * point ([[CpNode]]).\r\n     * @param next The next (going ant-clockwise around the boundary)\r\n     * contact ([[CpNode]]).\r\n     * @param prevOnCircle The previous [[CpNode]] (going clockwise around\r\n     * the inscribed circle defined by the maximal disk).\r\n     * @param nextOnCircle The next [[CpNode]] (going anti-clockwise around\r\n     * the inscribed circle defined by the maximal disk).\r\n     * @param matCurveToNextVertex The actual medial axis curve from this\r\n     * [[CpNode]]'s maximal disk circle to the next [[CpNode]]'s circle. It is a\r\n     * bezier curve of order 1, 2 or 3.\r\n     * @param isHoleClosing If true, this [[CpNode]] belongs to a hole-closing\r\n     * maximal disk.\r\n     */\r\n    constructor(cp, isHoleClosing, isIntersection, prev = undefined, next = undefined, prevOnCircle = undefined, nextOnCircle = undefined /*,\r\n    public matCurveToNextVertex: number[][] = undefined*/) {\r\n        this.cp = cp;\r\n        this.isHoleClosing = isHoleClosing;\r\n        this.isIntersection = isIntersection;\r\n        this.prev = prev;\r\n        this.next = next;\r\n        this.prevOnCircle = prevOnCircle;\r\n        this.nextOnCircle = nextOnCircle;\r\n    }\r\n    /**\r\n     * Returns the children of this [[CpNode]] when seen as a MAT edge. Only\r\n     * children in a 'forward' direction are returned. These include all edges\r\n     * except the 'backward' edge given by [[prevOnCircle]], even terminating\r\n     * edges.\r\n     */\r\n    getChildren() {\r\n        let children = [];\r\n        let cp = this.next;\r\n        let cp_ = cp;\r\n        do {\r\n            children.push(cp_);\r\n            cp_ = cp_.nextOnCircle;\r\n        } while (cp_.nextOnCircle !== cp);\r\n        return children;\r\n    }\r\n    /**\r\n     * Similar to [[children]] but returns the child nodes of the tree when\r\n     * [[CpNode]] is seen as a MAT vertex point (as opposed to edge). In this\r\n     * way the dual graph of the tree can easily be traversed - see e.g.\r\n     * [[traverseVertices]]. Generally, however, traversing the edges is\r\n     * preferred as it returns the entire Medial Axis (by utilizing\r\n     * [[matCurveToNextVertex]] on each returned edge).\r\n     */\r\n    get vertexChildren() {\r\n        if (this.isTerminating()) {\r\n            return [];\r\n        }\r\n        let cp = this;\r\n        let children = [];\r\n        let cp_ = cp;\r\n        while (cp_ !== cp.prevOnCircle) {\r\n            if (!cp_.isTerminating()) {\r\n                children.push(cp_.next);\r\n            }\r\n            cp_ = cp_.nextOnCircle;\r\n        }\r\n        return children;\r\n    }\r\n    /**\r\n     * Returns all [[CpNode]]s on the MAT that this [[CpNode]] is part of\r\n     * starting from the current one and going anti-clockwise around the shape.\r\n     */\r\n    getAllOnLoop() {\r\n        let cpStart = this;\r\n        let cps = [cpStart];\r\n        let cp = this.next;\r\n        while (cp !== cpStart) {\r\n            cps.push(cp);\r\n            cp = cp.next;\r\n        }\r\n        return cps;\r\n    }\r\n    /**\r\n     * Primarily for internal use.\r\n     *\r\n     * Insert a [[CpNode]] into the MAT tree graph after the specified point\r\n     * and returns the freshly inserted [[CpNode]].\r\n     * @param isHoleClosing True if this is a hole closing contact point.\r\n     * @param isIntersection True if this is a contact point at a shape boundary\r\n     * intersection point.\r\n     * @param cpTree The tree graph holding the [[CpNodes]] of the MAT.\r\n     * @param cp - [[ContactPoint]] defining the [[CpNode]].\r\n     * @param prev_ - Inserts the new [[CpNode]] right after this item if the\r\n     * loop is not empty, else insert the new [[CpNode]] as the only item in the\r\n     * loop.\r\n     */\r\n    static insert(isHoleClosing, isIntersection, cpTree, cp, prev_) {\r\n        let cpNode = new CpNode(cp, isHoleClosing, isIntersection);\r\n        if (typeof _debug_ !== 'undefined') {\r\n            _debug_.generated.elems.cpNode.push(new cp_node_for_debugging_1.CpNodeForDebugging(_debug_.generated, cpNode));\r\n        }\r\n        let prev;\r\n        let next;\r\n        if (!prev_) {\r\n            prev = cpNode;\r\n            next = cpNode;\r\n        }\r\n        else {\r\n            prev = prev_;\r\n            next = prev.next;\r\n        }\r\n        next.prev = cpNode;\r\n        prev.next = cpNode;\r\n        cpNode.prev = prev;\r\n        cpNode.next = next;\r\n        cpTree.insert(cpNode);\r\n        return cpNode;\r\n    }\r\n    /**\r\n     * Return this (except if exclThis is truthy) and the the other CpNodes\r\n     * around the maximal disk vertex circle in an anti-clockwise order.\r\n     * @param exclThis If true the returned array does not include this\r\n     * [[CpNode]].\r\n     */\r\n    getCpNodesOnCircle(exclThis = false) {\r\n        let startCp = this;\r\n        let cp = startCp;\r\n        let cps = [];\r\n        do {\r\n            if (exclThis) {\r\n                exclThis = false;\r\n            }\r\n            else {\r\n                cps.push(cp);\r\n            }\r\n            cp = cp.nextOnCircle;\r\n        } while (cp !== startCp);\r\n        return cps;\r\n    }\r\n    /**\r\n     * Returns true if the 2 given [[CpNode]]s are on the same maximal disk\r\n     * circle.\r\n     * @param cpNode1 A [[CpNode]].\r\n     * @param cpNode2 Another [[CpNode]]\r\n     */\r\n    static isOnSameCircle(cpNode1, cpNode2) {\r\n        let cpNodes = cpNode1.getCpNodesOnCircle(true);\r\n        return cpNodes.indexOf(cpNode2) >= 0;\r\n    }\r\n    /**\r\n     * Returns true if this [[CpNode]] is terminating, i.e. implies a leaf MAT\r\n     * vertex.\r\n     *\r\n     * This is always the case for sharp corners and maximal disks with\r\n     * a single contact point. Note, however, that even in these cases there are\r\n     * two contact points stored (sitting 'on top' of each other) for the\r\n     * maximal disk. It can be seen as a limiting case of a two-prong where the\r\n     * distance between two of the contact points tend to zero. One point\r\n     * (represented by a [[CpNode]] of course) will be terminating with the\r\n     * other point being its [[next]], whereas the other point will *not* be\r\n     * terminating and 'points' back into the shape.\r\n     */\r\n    isTerminating() {\r\n        return this === this.next.prevOnCircle;\r\n    }\r\n    /**\r\n     * Like isTerminating() but only returns true if all cpNodes on the circle\r\n     * (except this.prevOnCircle) is terminating.\r\n     */\r\n    isFullyTerminating() {\r\n        let otherOnCircle = this.prevOnCircle.getCpNodesOnCircle(true);\r\n        let isFullyTerminating = otherOnCircle.every(cpNode => cpNode.isTerminating());\r\n        return isFullyTerminating;\r\n    }\r\n    /**\r\n     * Returns the first [[CpNode]] (from this one by successively applying\r\n     * .nextOnCircle) that exits the circle.\r\n     */\r\n    getFirstExit() {\r\n        let startNode = this;\r\n        let cpNode = startNode;\r\n        while (cpNode.next === cpNode.prevOnCircle) {\r\n            cpNode = cpNode.next;\r\n            if (cpNode === startNode) {\r\n                // The very special case the MAT is a single point.\r\n                return undefined;\r\n            }\r\n        }\r\n        return cpNode;\r\n    }\r\n    /**\r\n     * Returns true if this [[CpNode]] represents a sharp corner, i.e. the\r\n     * limiting case of a two-prong having zero radius.\r\n     *\r\n     * Note that two [[CpNode]]s are stored for each sharp corner, one being\r\n     * terminating and one not. See [[isTerminating]] for more details.\r\n     */\r\n    isSharp() {\r\n        return this.cp.circle.radius === 0;\r\n    }\r\n    /**\r\n     * Returns true if this [[CpNode]]'s maximal disk has only one contact point\r\n     * on the shape boundary (up to planar coordinates). These includes sharp\r\n     * corners.\r\n     *\r\n     * Note, however, that two [[CpNode]]s are stored for each such point to\r\n     * preserve symmetry - see [[isTerminating]] for more details.\r\n     */\r\n    isOneProng() {\r\n        let cp1 = this;\r\n        if (cp1.cp.circle.radius === 0) {\r\n            return true;\r\n        }\r\n        let cp2 = cp1.nextOnCircle;\r\n        let p1 = cp1.cp.pointOnShape.p;\r\n        let p2 = cp2.cp.pointOnShape.p;\r\n        return (p1[0] === p2[0] && p1[1] === p2[1]);\r\n    }\r\n    /**\r\n     * Returns the number of contact points on the maximal disk circle implied\r\n     * by this [[CpNode]].\r\n     *\r\n     * Note, however, that even one-prongs and sharp corners will return 2 (see\r\n     * [[isTerminating]] for more details); if this is not desired use\r\n     * [[getRealProngCount]] instead which will return 1 in these cases.\r\n     */\r\n    getProngCount() {\r\n        let startCp = this;\r\n        let cp = startCp;\r\n        let i = 0;\r\n        do {\r\n            i++;\r\n            cp = cp.nextOnCircle;\r\n        } while (cp !== startCp);\r\n        return i;\r\n    }\r\n    /**\r\n     * Returns the number of contact points (up to planar coordinates) on the\r\n     * maximal disk circle implied by this [[CpNode]].\r\n     *\r\n     * See also [[getProngCount]].\r\n     */\r\n    getRealProngCount() {\r\n        if (this.isOneProng()) {\r\n            return 1;\r\n        }\r\n        return this.getProngCount();\r\n    }\r\n}\r\nexports.CpNode = CpNode;\r\n/**\r\n * Primarily for internal use.\r\n *\r\n * Compares the order of two [[CpNode]]s. The order is cyclic and depends\r\n * on a [[CpNode]]'s relative position along the shape boundary.\r\n */\r\nCpNode.comparator = (a, b) => contact_point_1.ContactPoint.compare(a.cp, b.cp);\r\nCpNode.remove = remove_1.removeCpNode;\r\n//# sourceMappingURL=cp-node.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/cp-node/cp-node.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/cp-node/remove.js":
/*!*****************************************************!*\
  !*** ./node_modules/flo-mat/node/cp-node/remove.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * TODO: description very wrong\r\n * Removes a cpNode from the Mat. Returns true if successful, false if the\r\n * [[CpNode]] has contact point count !== 2. 3-prongs and above cannot be\r\n * removed since it would cause a change in MAT topology. Leaves are also not\r\n * removed. Even if there are >= 3 contact points and some are terminating such\r\n * that it is effectively a two-prong, it is not removed.\r\n *\r\n * @param cpTree The tree graph holding the [[CpNodes]] of the MAT.\r\n * @param cpNode The [[CpNode]] to remove.\r\n */\r\nfunction removeCpNode(cpNode, cpTree) {\r\n    /*\r\n    let isTerminating = cpNode.isTerminating();\r\n    let childCount = cpNode.getChildren().length;\r\n    if (isTerminating /*|| childCount !== 1*/ /*) {\r\n        return false;\r\n    }*/\r\n    let prev = cpNode.prev;\r\n    let next = cpNode.next;\r\n    prev.next = next;\r\n    next.prev = prev;\r\n    let nextOpposite = next.prevOnCircle;\r\n    let prevOpposite = prev.nextOnCircle;\r\n    nextOpposite.next = prevOpposite;\r\n    prevOpposite.prev = nextOpposite;\r\n    if (cpTree) {\r\n        cpTree.remove(cpNode, false);\r\n    }\r\n}\r\nexports.removeCpNode = removeCpNode;\r\n//# sourceMappingURL=remove.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/cp-node/remove.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/curve.js":
/*!********************************************!*\
  !*** ./node_modules/flo-mat/node/curve.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\r\n//import { κExactAt0, κExactAt1 } from 'flo-bezier3';\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst corner_1 = __webpack_require__(/*! ./corner */ \"./node_modules/flo-mat/node/corner.js\");\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\n/**\r\n * Represents a bezier curve on the shape boundary / loop.\r\n */\r\nclass Curve {\r\n    /**\r\n     * Primarily for internal use.\r\n     * @param loop The closed loop of bezier curves representing the shape\r\n     * boundary this curve belongs to.\r\n     * @param ps The bezier control points.\r\n     * @param prev The previous curve (when going in a negative direction around\r\n     * the shape boundary, i.e. clockwise for the outer shape and anti-clockwise\r\n     * for the holes (if any)).\r\n     * @param next The next curve (when going in a positive direction around\r\n     * the shape boundary, i.e. anti-clockwise for the outer shape and clockwise\r\n     * for the holes (if any)).\r\n     * @param idx The curve's ordered index in the loop. This imposes a cycling\r\n     * ordering of the curves in the loop.\r\n     */\r\n    constructor(loop, ps, prev, next, idx) {\r\n        this.loop = loop;\r\n        this.ps = ps;\r\n        this.prev = prev;\r\n        this.next = next;\r\n        this.idx = idx;\r\n    }\r\n    /**\r\n     * Returns information about the corner created at the end of this curve\r\n     * (at t === 1) and the start of the next curve (at t === 0).\r\n     * @param curve The relevant [[Curve]].\r\n     */\r\n    static getCornerAtEnd(curve) {\r\n        return getCornerAtEnd(curve);\r\n    }\r\n}\r\nexports.Curve = Curve;\r\n/**\r\n * Angle in degrees to radians.\r\n * @hidden\r\n */\r\nconst DEGREES = {\r\n    //'0'    : 0.0000,\r\n    0.25: 0.0050,\r\n    1: 0.0167,\r\n    4: 0.0698,\r\n    16: 0.2756,\r\n};\r\n/** @hidden */\r\n//const DEGREE_LIMIT = DEGREES[1];\r\n//const DEGREE_LIMIT = DEGREES[4]; \r\nconst DEGREE_LIMIT = DEGREES[16];\r\n/**\r\n * Returns a new corner with properties.\r\n *\r\n * PRECONDITION: The beziers has control points with max bit-length of 26 and\r\n * aligned to a 'grid' to have the same exponent. This is so the vectors between\r\n * control points can be calculated exactly without resorting to adaptive\r\n * infinite precision floating point operations.\r\n *\r\n * @param psI The incoming bezier that ends in the corner\r\n * @param psO The outgoing bezier that starts at the corner\r\n */\r\nfunction getCorner(psI, psO) {\r\n    // getInterfaceCcw must return a number !== 0 if psI and psO are not the\r\n    // same as seen as a curve extension with t ∈ [-∞,+∞]\r\n    let ccw = flo_bezier3_1.getInterfaceCcw(psI, psO);\r\n    let isSharp = ccw < 0;\r\n    let isDull = ccw > 0;\r\n    // Find (non-normalized) tangent of curve.ps at t === 1\r\n    let p0E = psI[psI.length - 2];\r\n    let p1E = psI[psI.length - 1];\r\n    let xE = p1E[0] - p0E[0];\r\n    let yE = p1E[1] - p0E[1];\r\n    let tangentAtEnd = [xE, yE];\r\n    // Find (non-normalized) tangent of curve.next.ps at t === 0\r\n    let p0S = psO[0];\r\n    let p1S = psO[1];\r\n    let xS = p1S[0] - p0S[0];\r\n    let yS = p1S[1] - p0S[1];\r\n    let tangentAtStart = [xS, yS];\r\n    // These use square root and are thus not exact\r\n    let tangents_ = [\r\n        flo_vector2d_1.toUnitVector(tangentAtEnd),\r\n        flo_vector2d_1.toUnitVector(tangentAtStart),\r\n    ];\r\n    // The cross calculated below should be exact due to beziers having been\r\n    // normalized!\r\n    let crossTangents = flo_vector2d_1.cross(tangents_[0], tangents_[1]);\r\n    let isQuiteSharp;\r\n    let isQuiteDull;\r\n    let dotTangents = flo_vector2d_1.dot(tangentAtEnd, tangentAtStart);\r\n    if (dotTangents > 0) {\r\n        // Curves go in same direction\r\n        isQuiteSharp = crossTangents < -DEGREE_LIMIT;\r\n        isQuiteDull = crossTangents > +DEGREE_LIMIT;\r\n    }\r\n    else {\r\n        isQuiteSharp = isSharp;\r\n        isQuiteDull = isDull;\r\n    }\r\n    return new corner_1.Corner(tangents_, crossTangents, isSharp, isDull, isQuiteSharp, isQuiteDull);\r\n}\r\nexports.getCorner = getCorner;\r\n/**\r\n * Returns information about the corner created at the end of this curve\r\n * (at t === 1) and the start of the next curve (at t === 0).\r\n * @hidden\r\n */\r\nlet getCornerAtEnd = flo_memoize_1.memoize(function (curve) {\r\n    let psE = curve.ps;\r\n    let psS = curve.next.ps;\r\n    return getCorner(psE, psS);\r\n});\r\n//# sourceMappingURL=curve.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/curve.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/cp-node-for-debugging.js":
/*!******************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/cp-node-for-debugging.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Class used for debugging only.\r\n */\r\nclass CpNodeForDebugging {\r\n    constructor(generated, cpNode) {\r\n        this.generated = generated;\r\n        this.cpNode = cpNode;\r\n    }\r\n}\r\nexports.CpNodeForDebugging = CpNodeForDebugging;\r\n//# sourceMappingURL=cp-node-for-debugging.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/cp-node-for-debugging.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/debug.js":
/*!**************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/debug.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n//import * as Vector from 'flo-vector2d';\r\n//import * as Bezier3 from 'flo-bezier3';\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst general_1 = __webpack_require__(/*! ./functions/general */ \"./node_modules/flo-mat/node/debug/functions/general.js\");\r\nconst two_prong_1 = __webpack_require__(/*! ./functions/two-prong */ \"./node_modules/flo-mat/node/debug/functions/two-prong.js\");\r\nconst three_prong_1 = __webpack_require__(/*! ./functions/three-prong */ \"./node_modules/flo-mat/node/debug/functions/three-prong.js\");\r\nconst draw_elem_1 = __webpack_require__(/*! ./functions/draw-elem/draw-elem */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/draw-elem.js\");\r\nconst flo_draw_1 = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\r\nclass Generated {\r\n    constructor(path, g) {\r\n        this.path = path;\r\n        this.g = g;\r\n        this.elems = {\r\n            twoProng_regular: [],\r\n            twoProng_failed: [],\r\n            twoProng_notAdded: [],\r\n            twoProng_deleted: [],\r\n            twoProng_holeClosing: [],\r\n            looseBoundingBox: [],\r\n            tightBoundingBox: [],\r\n            oneProng: [],\r\n            oneProngAtDullCorner: [],\r\n            sharpCorner: [],\r\n            dullCorner: [],\r\n            vertex: [],\r\n            minY: [],\r\n            threeProng: [],\r\n            boundingHull: [],\r\n            mat: [],\r\n            sat: [],\r\n            cpNode: [],\r\n            loop: [],\r\n            loops: [],\r\n            maxVertex: [],\r\n            leaves: [],\r\n            culls: [],\r\n            intersection: [],\r\n        };\r\n        this.timing = {\r\n            simplify: [0, 0],\r\n            holeClosers: [0, 0],\r\n            oneAnd2Prongs: [0, 0],\r\n            threeProngs: [0, 0],\r\n            mats: [0, 0],\r\n            sats: [0, 0]\r\n        };\r\n    }\r\n}\r\nexports.Generated = Generated;\r\nclass MatDebug {\r\n    /**\r\n     * @param fs - some useful functions.\r\n     */\r\n    constructor() {\r\n        // These are included only for quick debugging from console\r\n        //(this as any).Bezier3  = Bezier3;\r\n        //(this as any).Vector2d = Vector; \r\n        /* The current path for which MATs are being found */\r\n        this.generated = undefined;\r\n        this.directives = {\r\n            stopAfterHoleClosers: false,\r\n            stopAfterHoleClosersNum: undefined,\r\n            stopAfterTwoProngs: false,\r\n            stopAfterTwoProngsNum: undefined,\r\n            stopAfterThreeProngs: false,\r\n        };\r\n        /**\r\n         * These functions are meant to be used in the console, e.g. in the\r\n         * console try typing d.fs.twoProng.traceConvergence(0);\r\n         */\r\n        this.fs = Object.assign(Object.assign({ draw: flo_draw_1.drawFs }, general_1.generalDebugFunctions), { twoProng: two_prong_1.twoProngDebugFunctions, threeProng: three_prong_1.threeProngDebugFunctions, drawElem: draw_elem_1.drawElemFunctions });\r\n    }\r\n    createNewGenerated(\r\n    //bezierLoops: number[][][][],\r\n    path, g) {\r\n        this.generated = new Generated(path, g);\r\n        //this.generatedAll.set(bezierLoops, this.generated);\r\n    }\r\n}\r\nexports.MatDebug = MatDebug;\r\n//# sourceMappingURL=debug.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/debug.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/bounding-hull.js":
/*!******************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/bounding-hull.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_draw_1 = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\r\nfunction boundingHull(g, hull, style = 'thin5 black nofill') {\r\n    let $polygon = flo_draw_1.drawFs.polygon(g, hull, style);\r\n    return $polygon;\r\n}\r\nexports.boundingHull = boundingHull;\r\n//# sourceMappingURL=bounding-hull.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/bounding-hull.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/branch.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/branch.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_draw_1 = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\r\nconst smoothen_1 = __webpack_require__(/*! ../../../mat/smoothen/smoothen */ \"./node_modules/flo-mat/node/mat/smoothen/smoothen.js\");\r\nfunction drawBranch(g, branch, delay) {\r\n    let classes = 'thin5 purple nofill';\r\n    let $svgs = [];\r\n    let i = 0;\r\n    for (let cpNode of branch) {\r\n        if (cpNode.isTerminating()) {\r\n            continue;\r\n        }\r\n        //let bezier = cpNode.matCurveToNextVertex;\r\n        let bezier = smoothen_1.getCurveToNext(cpNode);\r\n        if (!bezier) {\r\n            continue;\r\n        }\r\n        i++;\r\n        $svgs.push(...flo_draw_1.drawFs.bezier(g, bezier, classes, delay));\r\n    }\r\n    return $svgs;\r\n}\r\nexports.drawBranch = drawBranch;\r\n//# sourceMappingURL=branch.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/branch.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/culls.js":
/*!**********************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/culls.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction culls(g, culls) {\r\n    let $elems = [];\r\n    for (let circle of culls) {\r\n        let p = circle.center;\r\n        $elems.push(drawCircle(g, p, 0.4, 'cyan thin5 nofill'));\r\n    }\r\n    return $elems;\r\n}\r\nexports.culls = culls;\r\nfunction drawCircle(g, center, radiusPercent, classes) {\r\n    const XMLNS = 'http://www.w3.org/2000/svg';\r\n    let $circle = document.createElementNS(XMLNS, 'circle');\r\n    $circle.setAttributeNS(null, \"cx\", center[0].toString());\r\n    $circle.setAttributeNS(null, \"cy\", center[1].toString());\r\n    $circle.setAttributeNS(null, \"r\", radiusPercent.toString() + '%');\r\n    $circle.setAttributeNS(null, \"class\", classes);\r\n    g.appendChild($circle);\r\n    return $circle;\r\n}\r\n//# sourceMappingURL=culls.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/culls.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/draw-circle-percent.js":
/*!************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/draw-circle-percent.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction drawCirclePercent(g, center, radiusPercent, classes) {\r\n    const XMLNS = 'http://www.w3.org/2000/svg';\r\n    let $circle = document.createElementNS(XMLNS, 'circle');\r\n    $circle.setAttributeNS(null, \"cx\", center[0].toString());\r\n    $circle.setAttributeNS(null, \"cy\", center[1].toString());\r\n    $circle.setAttributeNS(null, \"r\", radiusPercent.toString() + '%');\r\n    $circle.setAttributeNS(null, \"class\", classes);\r\n    g.appendChild($circle);\r\n    return $circle;\r\n}\r\nexports.drawCirclePercent = drawCirclePercent;\r\n//# sourceMappingURL=draw-circle-percent.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/draw-circle-percent.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/draw-elem.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/draw-elem.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst one_prong_1 = __webpack_require__(/*! ./one-prong */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/one-prong.js\");\r\nconst two_prong_1 = __webpack_require__(/*! ./two-prong */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/two-prong.js\");\r\nconst three_prong_1 = __webpack_require__(/*! ./three-prong */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/three-prong.js\");\r\nconst vertex_1 = __webpack_require__(/*! ./vertex */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/vertex.js\");\r\nconst min_y_1 = __webpack_require__(/*! ./min-y */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/min-y.js\");\r\nconst bounding_hull_1 = __webpack_require__(/*! ./bounding-hull */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/bounding-hull.js\");\r\nconst loose_bounding_box_1 = __webpack_require__(/*! ./loose-bounding-box */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/loose-bounding-box.js\");\r\nconst tight_bounding_box_1 = __webpack_require__(/*! ./tight-bounding-box */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/tight-bounding-box.js\");\r\nconst sharp_corner_1 = __webpack_require__(/*! ./sharp-corner */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/sharp-corner.js\");\r\nconst dull_corner_1 = __webpack_require__(/*! ./dull-corner */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/dull-corner.js\");\r\nconst mat_1 = __webpack_require__(/*! ./mat */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/mat.js\");\r\nconst loop_1 = __webpack_require__(/*! ./loop */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/loop.js\");\r\nconst loops_1 = __webpack_require__(/*! ./loops */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/loops.js\");\r\nconst max_vertex_1 = __webpack_require__(/*! ./max-vertex */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/max-vertex.js\");\r\nconst leaves_1 = __webpack_require__(/*! ./leaves */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/leaves.js\");\r\nconst culls_1 = __webpack_require__(/*! ./culls */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/culls.js\");\r\nconst intersection_1 = __webpack_require__(/*! ./intersection */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/intersection.js\");\r\nconst one_prong_at_dull_corner_1 = __webpack_require__(/*! ./one-prong-at-dull-corner */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/one-prong-at-dull-corner.js\");\r\nfunction notImplementedYet(g, elem) {\r\n    return []; // TODO - implement relevant drawing function\r\n}\r\nlet drawElemFunctions = {\r\n    oneProng: one_prong_1.drawOneProng,\r\n    oneProngAtDullCorner: one_prong_at_dull_corner_1.oneProngAtDullCorner,\r\n    twoProng_regular: two_prong_1.twoProng,\r\n    twoProng_failed: two_prong_1.twoProng,\r\n    twoProng_notAdded: two_prong_1.twoProng,\r\n    twoProng_deleted: two_prong_1.twoProng,\r\n    twoProng_holeClosing: two_prong_1.twoProng,\r\n    threeProng: three_prong_1.threeProng,\r\n    minY: min_y_1.minY,\r\n    boundingHull: bounding_hull_1.boundingHull,\r\n    looseBoundingBox: loose_bounding_box_1.looseBoundingBox,\r\n    tightBoundingBox: tight_bounding_box_1.tightBoundingBox,\r\n    sharpCorner: sharp_corner_1.sharpCorner,\r\n    dullCorner: dull_corner_1.dullCorner,\r\n    vertex: vertex_1.vertex,\r\n    mat: mat_1.drawMat('mat'),\r\n    sat: mat_1.drawMat('sat'),\r\n    loop: loop_1.loop,\r\n    loops: loops_1.loops,\r\n    maxVertex: max_vertex_1.maxVertex,\r\n    leaves: leaves_1.leaves,\r\n    culls: culls_1.culls,\r\n    intersection: intersection_1.intersection,\r\n    cpNode: notImplementedYet\r\n};\r\nexports.drawElemFunctions = drawElemFunctions;\r\n//# sourceMappingURL=draw-elem.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/draw-elem.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/dull-corner.js":
/*!****************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/dull-corner.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_draw_1 = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\r\nfunction dullCorner(g, curve) {\r\n    const scaleFactor = 1;\r\n    let p = curve.ps[3];\r\n    let $pos = flo_draw_1.drawFs.dot(g, p, 0.5 * scaleFactor, 'orange');\r\n    return $pos;\r\n}\r\nexports.dullCorner = dullCorner;\r\n//# sourceMappingURL=dull-corner.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/dull-corner.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/intersection.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/intersection.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst draw_circle_percent_1 = __webpack_require__(/*! ./draw-circle-percent */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/draw-circle-percent.js\");\r\nfunction intersection(g, x) {\r\n    return [draw_circle_percent_1.drawCirclePercent(g, x.pos.p, 0.7, 'purple thin2 nofill')];\r\n}\r\nexports.intersection = intersection;\r\n//# sourceMappingURL=intersection.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/intersection.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/leaves.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/leaves.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst draw_circle_percent_1 = __webpack_require__(/*! ./draw-circle-percent */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/draw-circle-percent.js\");\r\nfunction leaves(g, leaves) {\r\n    let $elems = [];\r\n    for (let cpNode of leaves) {\r\n        let cp = cpNode.cp;\r\n        let p = cp.circle.center;\r\n        $elems.push(draw_circle_percent_1.drawCirclePercent(g, p, 0.5, 'pinker thin5 nofill'));\r\n    }\r\n    return $elems;\r\n}\r\nexports.leaves = leaves;\r\n//# sourceMappingURL=leaves.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/leaves.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/loop.js":
/*!*********************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/loop.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// TODO - finish\r\nfunction loop(g, loop) {\r\n    /*\r\n    for (let curve of loop.curves) {\r\n        drawFs.bezier(g, curve.ps, undefined, 1000);\r\n    }\r\n    */\r\n    return [];\r\n}\r\nexports.loop = loop;\r\n//# sourceMappingURL=loop.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/loop.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/loops.js":
/*!**********************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/loops.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// TODO - finish\r\nfunction loops(g, loops) {\r\n    return [];\r\n}\r\nexports.loops = loops;\r\n//# sourceMappingURL=loops.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/loops.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/loose-bounding-box.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/loose-bounding-box.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_draw_1 = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\r\nfunction looseBoundingBox(g, box) {\r\n    let $box = flo_draw_1.drawFs.rect(g, box, 'thin5 brown nofill');\r\n    return $box;\r\n}\r\nexports.looseBoundingBox = looseBoundingBox;\r\n//# sourceMappingURL=loose-bounding-box.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/loose-bounding-box.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/mat.js":
/*!********************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/mat.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst traverse_edges_1 = __webpack_require__(/*! ../../../traverse-edges */ \"./node_modules/flo-mat/node/traverse-edges.js\");\r\nconst flo_draw_1 = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\r\nconst smoothen_1 = __webpack_require__(/*! ../../../mat/smoothen/smoothen */ \"./node_modules/flo-mat/node/mat/smoothen/smoothen.js\");\r\nfunction drawMat(type) {\r\n    let classes = type === 'mat'\r\n        ? 'thin5 purple nofill'\r\n        : 'thin10 red nofill';\r\n    return (g, mat) => {\r\n        let cpNode = mat.cpNode;\r\n        if (!cpNode) {\r\n            return undefined;\r\n        }\r\n        // TODO - remove - testing\r\n        /*while (!cpNode.isTerminating()) {\r\n            cpNode = cpNode.next;\r\n        }*/\r\n        /*\r\n        drawFs.dot(g, cpNode.cp.pointOnShape.p, 1)\r\n        drawFs.dot(g, cpNode.cp.circle.center, 2)\r\n        */\r\n        let $svgs = [];\r\n        let i = 0;\r\n        traverse_edges_1.traverseEdges(cpNode, cpNode => {\r\n            if (cpNode.isTerminating()) {\r\n                return;\r\n            }\r\n            //let bezier = cpNode.matCurveToNextVertex;\r\n            let bezier = smoothen_1.getCurveToNext(cpNode);\r\n            if (!bezier) {\r\n                return;\r\n            }\r\n            i++;\r\n            $svgs.push(...flo_draw_1.drawFs.bezier(g, bezier, classes /*, i*100*/));\r\n        });\r\n        return $svgs;\r\n    };\r\n}\r\nexports.drawMat = drawMat;\r\n//# sourceMappingURL=mat.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/mat.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/max-vertex.js":
/*!***************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/max-vertex.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_draw_1 = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\r\nfunction maxVertex(g, cpNode) {\r\n    let circle = cpNode.cp.circle;\r\n    let $elems = flo_draw_1.drawFs.circle(g, circle, 'brown thin10 nofill');\r\n    return $elems;\r\n}\r\nexports.maxVertex = maxVertex;\r\n//# sourceMappingURL=max-vertex.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/max-vertex.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/min-y.js":
/*!**********************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/min-y.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst flo_draw_1 = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\r\nfunction minY(g, pos) {\r\n    let p = flo_bezier3_1.evaluate(pos.curve.ps, pos.t);\r\n    let $elems = flo_draw_1.drawFs.crossHair(g, p, 'red thin10 nofill');\r\n    return $elems;\r\n}\r\nexports.minY = minY;\r\n//# sourceMappingURL=min-y.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/min-y.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/one-prong-at-dull-corner.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/one-prong-at-dull-corner.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nconst flo_draw_1 = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\r\nfunction oneProngAtDullCorner(g, pos) {\r\n    let oCircle = point_on_shape_1.PointOnShape.getOsculatingCircle(Number.POSITIVE_INFINITY, pos);\r\n    let $center = flo_draw_1.drawFs.dot(g, pos.p, 0.1, 'orange');\r\n    let $circle = flo_draw_1.drawFs.dot(g, oCircle.center, 0.25, 'orange');\r\n    let $pos = flo_draw_1.drawFs.circle(g, oCircle, 'orange thin10 nofill');\r\n    return [...$center, ...$circle, ...$pos];\r\n}\r\nexports.oneProngAtDullCorner = oneProngAtDullCorner;\r\n//# sourceMappingURL=one-prong-at-dull-corner.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/one-prong-at-dull-corner.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/one-prong.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/one-prong.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nconst circle_1 = __webpack_require__(/*! ../../../circle */ \"./node_modules/flo-mat/node/circle.js\");\r\nconst flo_draw_1 = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\r\nconst scaleFactor = 0.5;\r\nfunction drawOneProng(g, pos) {\r\n    let circle = circle_1.Circle.scale(point_on_shape_1.PointOnShape.getOsculatingCircle(Number.POSITIVE_INFINITY, pos), 1);\r\n    let $center = flo_draw_1.drawFs.dot(g, pos.p, 0.1 * scaleFactor, 'gray');\r\n    let $circle = flo_draw_1.drawFs.dot(g, circle.center, 0.25 * scaleFactor, 'gray');\r\n    let $pos = flo_draw_1.drawFs.circle(g, circle, 'gray thin10 nofill');\r\n    return [...$center, ...$circle, ...$pos];\r\n}\r\nexports.drawOneProng = drawOneProng;\r\n//# sourceMappingURL=one-prong.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/one-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/sharp-corner.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/sharp-corner.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_draw_1 = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\r\nfunction sharpCorner(g, curve) {\r\n    const scaleFactor = 1;\r\n    let p = curve.ps[curve.ps.length - 1];\r\n    let $pos = flo_draw_1.drawFs.dot(g, p, 0.6 * scaleFactor, 'green');\r\n    return $pos;\r\n}\r\nexports.sharpCorner = sharpCorner;\r\n//# sourceMappingURL=sharp-corner.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/sharp-corner.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/three-prong.js":
/*!****************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/three-prong.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst circle_1 = __webpack_require__(/*! ../../../circle */ \"./node_modules/flo-mat/node/circle.js\");\r\nconst flo_draw_1 = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\r\nconst scaleFactor = 0.3;\r\nfunction threeProng(g, threeProng) {\r\n    let circle = circle_1.Circle.scale(threeProng.circle, 1);\r\n    let poss = threeProng.poss;\r\n    let $cp1 = flo_draw_1.drawFs.dot(g, poss[0].p, 0.1 * 1 * scaleFactor, 'blue');\r\n    let $cp2 = flo_draw_1.drawFs.dot(g, poss[1].p, 0.1 * 2 * scaleFactor, 'blue');\r\n    let $cp3 = flo_draw_1.drawFs.dot(g, poss[2].p, 0.1 * 3 * scaleFactor, 'blue');\r\n    let $center = flo_draw_1.drawFs.dot(g, circle.center, 0.3 * scaleFactor, 'blue');\r\n    let $circle = flo_draw_1.drawFs.circle(g, circle, 'blue thin2 nofill');\r\n    return [...$center, ...$cp1, ...$cp2, ...$cp3, ...$circle];\r\n}\r\nexports.threeProng = threeProng;\r\n//# sourceMappingURL=three-prong.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/three-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/tight-bounding-box.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/tight-bounding-box.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_draw_1 = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\r\nfunction tightBoundingBox(g, box) {\r\n    let $box = flo_draw_1.drawFs.polygon(g, box, 'thin5 black nofill');\r\n    return $box;\r\n}\r\nexports.tightBoundingBox = tightBoundingBox;\r\n//# sourceMappingURL=tight-bounding-box.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/tight-bounding-box.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/two-prong.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/two-prong.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_two_prong_type_1 = __webpack_require__(/*! ../../../mat/get-two-prong-type */ \"./node_modules/flo-mat/node/mat/get-two-prong-type.js\");\r\nconst flo_draw_1 = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\r\nfunction twoProng(g, twoProng) {\r\n    //let scaleFactor = width/200;\t\t\r\n    let scaleFactor = 0.3;\r\n    let $failedDot = [];\r\n    let $center = [];\r\n    let $circle = [];\r\n    let $cp1 = [];\r\n    let $cp2 = [];\r\n    let color;\r\n    let thin;\r\n    switch (get_two_prong_type_1.getTwoProngType(twoProng)) {\r\n        case 'twoProng_regular': {\r\n            color = 'red ';\r\n            thin = '2';\r\n            break;\r\n        }\r\n        case 'twoProng_holeClosing': {\r\n            color = 'cyan ';\r\n            thin = '10';\r\n            break;\r\n        }\r\n    }\r\n    if (twoProng.failed) {\r\n        $failedDot = flo_draw_1.drawFs.dot(g, twoProng.pos.p, 1 * scaleFactor, 'black');\r\n    }\r\n    else if (!twoProng.failed) {\r\n        $center = flo_draw_1.drawFs.dot(g, twoProng.circle.center, 1 * scaleFactor, 'yellow');\r\n        $circle = flo_draw_1.drawFs.circle(g, twoProng.circle, color + 'thin' + thin + ' nofill');\r\n        $cp1 = flo_draw_1.drawFs.dot(g, twoProng.pos.p, 0.035 * scaleFactor, color);\r\n        $cp2 = flo_draw_1.drawFs.dot(g, twoProng.z, 0.07 * scaleFactor, color);\r\n    }\r\n    return [...$failedDot, ...$center, ...$circle, ...$cp1, ...$cp2];\r\n}\r\nexports.twoProng = twoProng;\r\n//# sourceMappingURL=two-prong.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/two-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/vertex.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/vertex.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_draw_1 = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\r\nfunction vertex(g, cpNode, visible = true, displayDelay) {\r\n    let visibleClass = visible ? '' : ' invisible';\r\n    let circle = cpNode.cp.circle;\r\n    const THIN = 'thin20';\r\n    let cps = cpNode.getCpNodesOnCircle();\r\n    console.log(cps);\r\n    let $svgs = [];\r\n    let $circle = flo_draw_1.drawFs.circle(g, circle, 'red ' + THIN + ' nofill ' + visibleClass, displayDelay);\r\n    let $crossHair = flo_draw_1.drawFs.crossHair(g, circle.center, 'red ' + THIN + ' nofill ' + visibleClass, 3, displayDelay);\r\n    $svgs = [...$circle, ...$crossHair];\r\n    for (let i = 0; i < cps.length; i++) {\r\n        let cp = cps[i];\r\n        let edgeCircle = cp.next.cp.circle;\r\n        let $circle = flo_draw_1.drawFs.circle(g, edgeCircle, 'pink ' + THIN + ' nofill ' + visibleClass, displayDelay);\r\n        let $crossHair = flo_draw_1.drawFs.crossHair(g, edgeCircle.center, 'pink ' + THIN + ' nofill ' + visibleClass, 3, displayDelay);\r\n        $svgs.push(...$circle, ...$crossHair);\r\n        let p1 = circle.center;\r\n        let p2 = edgeCircle.center;\r\n        let thin = i === 0 ? 'thin10' : (i === 1 ? 'thin20' : 'thin35');\r\n        let $line = flo_draw_1.drawFs.line(g, [p1, p2], 'yellow ' + thin + ' nofill ' + visibleClass, displayDelay);\r\n        $svgs.push(...$line);\r\n    }\r\n    return $svgs;\r\n}\r\nexports.vertex = vertex;\r\n//# sourceMappingURL=vertex.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/vertex.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/general.js":
/*!**************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/general.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nlet i = 0;\r\n/** Name the given object - for debugging purposes only */\r\nfunction nameObj(o, pre = '') {\r\n    o.name = '' + pre + i++;\r\n}\r\n/**\r\n * Transforms a boundary piece (δ) into a human readable string.\r\n * @param cpNodes A boundary piece given by two CpNodes.\r\n */\r\nfunction δToString(cpNodes) {\r\n    return cpNodes.map(cpNode => point_on_shape_1.PointOnShape.toHumanString(cpNode.cp.pointOnShape));\r\n}\r\n/**\r\n * Transforms an array of boundary pieces (δs) into a human readable string.\r\n * @param cpNodes An array of boundary pieces.\r\n */\r\nfunction δsToString(cpNodes) {\r\n    return cpNodes.map(δToString);\r\n}\r\n/**\r\n * Convert the given points into a human readable string.\r\n * @param ps\r\n */\r\nfunction pointsToStr(ps, decimalPlaces = 3) {\r\n    return ps.map(p => pointToStr(p, decimalPlaces));\r\n}\r\n/**\r\n * Converts the given point into a human readable string.\r\n * @param p - The point\r\n * @param decimalPlaces - number of decimal places\r\n */\r\nfunction pointToStr(p, decimalPlaces = 3) {\r\n    return p[0].toFixed(decimalPlaces) + ', ' + p[1].toFixed(decimalPlaces);\r\n}\r\nlet generalDebugFunctions = {\r\n    δToString,\r\n    δsToString,\r\n    pointToStr,\r\n    pointsToStr,\r\n    nameObj,\r\n};\r\nexports.generalDebugFunctions = generalDebugFunctions;\r\n//# sourceMappingURL=general.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/general.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/three-prong.js":
/*!******************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/three-prong.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst circle_1 = __webpack_require__(/*! ../../circle */ \"./node_modules/flo-mat/node/circle.js\");\r\n/**\r\n * Draws 3 lines from the given 3-prong center to its 3 contact points.\r\n * @param n - The 3-prong's zero-based index.\r\n */\r\nfunction drawSpokes(n) {\r\n    let threeProng = _debug_.generated.elems.threeProng[n];\r\n    let g = threeProng.generated.g;\r\n    let cc = threeProng.circle.center;\r\n    let poss = threeProng.poss;\r\n    _debug_.fs.draw.line(g, [poss[0].p, cc], 'thin5 red');\r\n    _debug_.fs.draw.line(g, [poss[1].p, cc], 'thin5 red');\r\n    _debug_.fs.draw.line(g, [poss[2].p, cc], 'thin5 red');\r\n}\r\n/**\r\n * Shows the circle for each boundary iteration.\r\n * @param n_ - The 3-prong's zero-based index. If ommitted, all will be shown.\r\n * @param idx - The specific boundary iteration index to view. If ommitted, all\r\n * will be shown.\r\n */\r\nfunction traceConvergence(n_, idx) {\r\n    let sIndx;\r\n    let eIndx;\r\n    if (n_ === undefined) {\r\n        sIndx = 0;\r\n        eIndx = _debug_.generated.elems.threeProng.length;\r\n    }\r\n    else {\r\n        sIndx = n_;\r\n        eIndx = n_ + 1;\r\n    }\r\n    for (let n = sIndx; n < eIndx; n++) {\r\n        let forDebugging = _debug_.generated.elems.threeProng[n];\r\n        let g = forDebugging.generated.g;\r\n        console.log(forDebugging);\r\n        let candidateThreeProngs = forDebugging.candidateThreeProngs;\r\n        //-----------------------------\r\n        //---- Get start and end index\r\n        //-----------------------------\r\n        let startIndx;\r\n        let endIndx;\r\n        if (n_ === undefined || idx === -1) {\r\n            startIndx = forDebugging.bestIndx;\r\n            endIndx = forDebugging.bestIndx + 1;\r\n        }\r\n        else {\r\n            if (idx === undefined) {\r\n                startIndx = 0;\r\n                endIndx = candidateThreeProngs.length;\r\n            }\r\n            else {\r\n                startIndx = idx;\r\n                endIndx = idx + 1;\r\n            }\r\n        }\r\n        //---------------------------------\r\n        //---- Draw candidate three-prongs\r\n        //---------------------------------\r\n        for (let i = startIndx; i < endIndx; i++) {\r\n            let circle = candidateThreeProngs[i].circle;\r\n            if (forDebugging.bestIndx === i) {\r\n                _debug_.fs.draw.dot(g, circle.center, 0.2, 'green');\r\n                _debug_.fs.draw.circle(g, circle, 'black thin10 nofill');\r\n            }\r\n            else {\r\n                _debug_.fs.draw.dot(g, circle.center, 0.2, 'cyan');\r\n                _debug_.fs.draw.circle(g, circle, 'cyan thin5 nofill');\r\n            }\r\n        }\r\n    }\r\n}\r\n/**\r\n * Shows the actual boundary for each iteration.\r\n * @param n The 3-prong's zero-based index.\r\n * @param idx The specific boundary iteration index to view. If ommitted will\r\n * show all.\r\n */\r\nfunction showBoundary(n, idx) {\r\n    let debugInfo = _debug_.generated.elems.threeProng[n];\r\n    let g = debugInfo.generated.g;\r\n    let candidateThreeProngs = debugInfo.candidateThreeProngs;\r\n    let startIndx = idx === undefined ? 0 : idx;\r\n    let endIndx = idx === undefined ? candidateThreeProngs.length : idx;\r\n    // Draw relevant δs\r\n    let cpss = debugInfo.cpss;\r\n    let j = 0;\r\n    // For each iteration of δ3s (indexed by j)\r\n    for (let idx = 1; idx < cpss.length - 1; idx++) {\r\n        if (!(j >= startIndx && j <= endIndx)) {\r\n            j++;\r\n            continue;\r\n        }\r\n        let δ3s = [\r\n            cpss[0],\r\n            cpss[idx],\r\n            cpss[cpss.length - 1]\r\n        ];\r\n        // For each of the 3 δs\r\n        for (let i = 0; i < 3; i++) {\r\n            let δ = δ3s[i];\r\n            let δS = δ[0]; // Delta Start\r\n            let δE = δ[1]; // Delta End\r\n            let posS = δS.cp.pointOnShape;\r\n            let posE = δE.cp.pointOnShape;\r\n            let pS = posS.p;\r\n            let pE = posE.p;\r\n            let r = 1 + (i * 0.5);\r\n            if (flo_vector2d_1.equal(pS, pE)) {\r\n                _debug_.fs.draw.crossHair(g, pS, 'red thin10 nofill', r);\r\n            }\r\n            else {\r\n                _debug_.fs.draw.crossHair(g, pS, 'green thin10 nofill', r);\r\n                _debug_.fs.draw.crossHair(g, pE, 'blue thin10 nofill', r);\r\n            }\r\n        }\r\n        j++;\r\n    }\r\n}\r\n/**\r\n * @param n The 3-prong's zero-based index.\r\n */\r\nfunction logδs(n) {\r\n    let threeProng = _debug_.generated.elems.threeProng[n];\r\n    console.log(threeProng.cpss);\r\n}\r\n/**\r\n *\r\n * @param p\r\n */\r\nfunction logNearest(showSpokes = true, showTrace = true, showBoundaries = true) {\r\n    return function (p, showDelay = 1000) {\r\n        //let closestPerLoops: ThreeProngForDebugging[] = [];\r\n        //_debug_.generatedAll.forEach(function(generated) {\r\n        let generated = _debug_.generated;\r\n        let threeProng = flo_vector2d_1.getObjClosestTo(p, generated.elems.threeProng, threeProng => threeProng.circle.center);\r\n        //closestPerLoops.push(threeProng)\r\n        //});\r\n        /*\r\n        let threeProng = getObjClosestTo<ThreeProngForDebugging>(\r\n            p,\r\n            closestPerLoops,\r\n            threeProng => threeProng.circle.center\r\n        );\r\n        */\r\n        let circle = threeProng.circle;\r\n        let g = threeProng.generated.g;\r\n        console.log(threeProng);\r\n        let circle2 = new circle_1.Circle(circle.center, circle.radius || 1);\r\n        let draw = _debug_.fs.draw;\r\n        draw.circle(g, circle2, 'blue thin10 nofill', showDelay);\r\n        draw.crossHair(g, circle.center, 'red thin2 nofill', 2, showDelay);\r\n        if (showSpokes) {\r\n            draw.line(g, [threeProng.poss[0].p, circle.center], 'blue thin5 nofill', showDelay);\r\n            draw.line(g, [threeProng.poss[1].p, circle.center], 'blue thin5 nofill', showDelay);\r\n            draw.line(g, [threeProng.poss[2].p, circle.center], 'blue thin5 nofill', showDelay);\r\n        }\r\n        if (showBoundaries) {\r\n            let boundaries = threeProng.boundaries;\r\n            let boundaryS = boundaries[0];\r\n            let boundaryE = boundaries[boundaries.length - 1];\r\n            draw.beziers(g, boundaryS, 'red thin20 nofill', showDelay);\r\n            for (let i = 1; i < boundaries.length - 1; i++) {\r\n                let boundary = boundaries[i];\r\n                draw.beziers(g, boundary, 'green thin20 nofill', showDelay);\r\n            }\r\n            draw.beziers(g, boundaryE, 'blue thin20 nofill', showDelay);\r\n        }\r\n        if (showTrace) {\r\n            let traces = threeProng.traces;\r\n            for (let trace of traces) {\r\n                draw.polyline(g, trace, 'red thin5 nofill', showDelay);\r\n            }\r\n        }\r\n    };\r\n}\r\nlet threeProngDebugFunctions = {\r\n    drawSpokes,\r\n    traceConvergence,\r\n    showBoundary,\r\n    logδs,\r\n    logNearest\r\n};\r\nexports.threeProngDebugFunctions = threeProngDebugFunctions;\r\n//# sourceMappingURL=three-prong.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/three-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/two-prong.js":
/*!****************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/two-prong.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst circle_1 = __webpack_require__(/*! ../../circle */ \"./node_modules/flo-mat/node/circle.js\");\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\n/**\r\n *\r\n */\r\nfunction logδ(n, type = 'twoProng_regular') {\r\n    let δ = _debug_.generated.elems[type][n].δ;\r\n    console.log(δ);\r\n}\r\n/**\r\n *\r\n */\r\nfunction log(n, type = 'twoProng_regular') {\r\n    let twoProng = _debug_.generated.elems[type][n];\r\n    console.log(twoProng);\r\n}\r\n/**\r\n *\r\n */\r\nfunction drawNormal(n, showDelay = 1000, type = 'twoProng_regular') {\r\n    let twoProngs = _debug_.generated.elems[type];\r\n    // If not specified which, draw all\r\n    if (n === undefined) {\r\n        for (let i = 0; i < twoProngs.length; i++) {\r\n            drawNormal(i);\r\n        }\r\n    }\r\n    let twoProng = twoProngs[n];\r\n    let g = twoProng.generated.g;\r\n    if (!twoProng) {\r\n        return;\r\n    }\r\n    _debug_.fs.draw.line(g, [twoProng.pos.p, twoProng.circle.center], 'thin10 blue', showDelay);\r\n}\r\n/**\r\n *\r\n */\r\nfunction logδBasic(n, type = 'twoProng_regular') {\r\n    let delta = _debug_.generated.elems[type][n].δ;\r\n    function f(x) {\r\n        let pos = x.cp.pointOnShape;\r\n        return {\r\n            bez: pos.curve.ps,\r\n            t: pos.t\r\n        };\r\n    }\r\n    console.log(f(delta[0]));\r\n    console.log(f(delta[1]));\r\n}\r\n/**\r\n *\r\n */\r\nfunction logNearest(p, showDelay = 1000, type = 'twoProng_regular') {\r\n    let closestPerLoops = [];\r\n    //_debug_.generatedAll.forEach(function(generated, loops) {\r\n    let generated = _debug_.generated;\r\n    let twoProng = flo_vector2d_1.getObjClosestTo(p, generated.elems[type], twoProng => twoProng.circle.center);\r\n    closestPerLoops.push(twoProng);\r\n    //});\r\n    /*\r\n    let twoProng = getObjClosestTo<TwoProngForDebugging>(\r\n        p,\r\n        closestPerLoops,\r\n        twoProng => twoProng.circle.center\r\n    );\r\n    */\r\n    console.log(twoProng);\r\n    let n;\r\n    for (let i = 0; i < _debug_.generated.elems[type].length; i++) {\r\n        let twoProng_ = _debug_.generated.elems[type][i];\r\n        if (twoProng_ === twoProng) {\r\n            n = i;\r\n            break;\r\n        }\r\n    }\r\n    if (n !== undefined) {\r\n        traceConvergence(n, true, showDelay);\r\n    }\r\n}\r\n/**\r\n *\r\n * @param n - The 2-prong's zero-based index.\r\n * @param range\r\n * cascade of convergence)\r\n */\r\nfunction traceConvergence(n, finalOnly, showDelay = 1000, range = undefined, type = 'twoProng_regular') {\r\n    if (n === undefined) {\r\n        return;\r\n    }\r\n    let twoProngInfo = _debug_.generated.elems[type][n];\r\n    let xs = twoProngInfo.xs;\r\n    let g = twoProngInfo.generated.g;\r\n    console.log(twoProngInfo);\r\n    console.log(twoProngInfo.xs.map(x => ({\r\n        x: x.x,\r\n        y: x.y,\r\n        z: x.z,\r\n        d: x.z ? flo_vector2d_1.squaredDistanceBetween(x.y.p, x.z.p) : 0,\r\n        t: x.t,\r\n    })));\r\n    for (let i = 0; i < xs.length; i++) {\r\n        if (range && (i < range[0] || i >= range[1])) {\r\n            continue;\r\n        }\r\n        if (finalOnly && i !== xs.length - 1) {\r\n            continue;\r\n        }\r\n        let x = twoProngInfo.xs[i];\r\n        let circle = new circle_1.Circle(x.x, flo_vector2d_1.distanceBetween(x.x, x.y.p));\r\n        _debug_.fs.draw.crossHair(g, x.x, 'red thin10 nofill', undefined, showDelay);\r\n        _debug_.fs.draw.circle(g, circle, 'blue thin10 nofill', showDelay);\r\n        if (x.z !== undefined) {\r\n            _debug_.fs.draw.crossHair(g, x.z.p, 'yellow thin10 nofill', 2, showDelay);\r\n        }\r\n    }\r\n    twoProngDebugFunctions.drawNormal(n, showDelay);\r\n}\r\nlet twoProngDebugFunctions = {\r\n    logδ,\r\n    log,\r\n    drawNormal,\r\n    logδBasic,\r\n    traceConvergence,\r\n    logNearest,\r\n};\r\nexports.twoProngDebugFunctions = twoProngDebugFunctions;\r\n//# sourceMappingURL=two-prong.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/two-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/three-prong-for-debugging.js":
/*!**********************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/three-prong-for-debugging.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst point_on_shape_1 = __webpack_require__(/*! ../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\n/**\r\n * Class used in debugging. A three-prong is a maximally inscribed circle that\r\n * touches the shape boundary (tangentially) at 3 points.\r\n */\r\nclass ThreeProngForDebugging {\r\n    /**\r\n     * @param circle The best fit circle found for the 3-prong.\r\n     * @param poss The best fit 3 points found for the 3-prong.\r\n     * @param cp3ss The 3 boundary pieces on which the three prong points were\r\n     * found.\r\n     * @param cpss The boundary pieces that were used to search the three prong\r\n     * on.\r\n     * @param bestIndx\r\n     * @param candidateThreeProngs An array of 3-prongs, each of which may be a\r\n     * best fit 3-prong.\r\n     */\r\n    constructor() { }\r\n    get cpsSimple() {\r\n        return this.cpss.map(δ => [point_on_shape_1.PointOnShape.toHumanString(δ[0].cp.pointOnShape),\r\n            point_on_shape_1.PointOnShape.toHumanString(δ[1].cp.pointOnShape)]);\r\n    }\r\n}\r\nexports.ThreeProngForDebugging = ThreeProngForDebugging;\r\n//# sourceMappingURL=three-prong-for-debugging.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/three-prong-for-debugging.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/two-prong-for-debugging.js":
/*!********************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/two-prong-for-debugging.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass TwoProngForDebugging {\r\n    constructor(generated, bezierPieces, pos, δ, z, circle, xs, failed, holeClosing, notAdded, deleted, cpNode = undefined) {\r\n        this.generated = generated;\r\n        this.bezierPieces = bezierPieces;\r\n        this.pos = pos;\r\n        this.δ = δ;\r\n        this.z = z;\r\n        this.circle = circle;\r\n        this.xs = xs;\r\n        this.failed = failed;\r\n        this.holeClosing = holeClosing;\r\n        this.notAdded = notAdded;\r\n        this.deleted = deleted;\r\n        this.cpNode = cpNode;\r\n    }\r\n}\r\nexports.TwoProngForDebugging = TwoProngForDebugging;\r\n//# sourceMappingURL=two-prong-for-debugging.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/two-prong-for-debugging.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/find-mats.js":
/*!************************************************!*\
  !*** ./node_modules/flo-mat/node/find-mats.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst mat_1 = __webpack_require__(/*! ./mat */ \"./node_modules/flo-mat/node/mat.js\");\r\nconst simplify_paths_1 = __webpack_require__(/*! ./svg/fs/simplify-paths/simplify-paths */ \"./node_modules/flo-mat/node/svg/fs/simplify-paths/simplify-paths.js\");\r\nconst get_extreme_1 = __webpack_require__(/*! ./svg/fs/get-extreme */ \"./node_modules/flo-mat/node/svg/fs/get-extreme.js\");\r\nconst find_and_add_3_prongs_1 = __webpack_require__(/*! ./mat/find-mat/find-and-add-3-prongs */ \"./node_modules/flo-mat/node/mat/find-mat/find-and-add-3-prongs.js\");\r\nconst create_initial_cp_graph_1 = __webpack_require__(/*! ./mat/find-mat/create-initial-cp-graph */ \"./node_modules/flo-mat/node/mat/find-mat/create-initial-cp-graph.js\");\r\n;\r\nconst add_debug_info_1 = __webpack_require__(/*! ./mat/find-mat/add-debug-info */ \"./node_modules/flo-mat/node/mat/find-mat/add-debug-info.js\");\r\nconst get_potential_2_prongs_1 = __webpack_require__(/*! ./mat/find-mat/get-potential-2-prongs */ \"./node_modules/flo-mat/node/mat/find-mat/get-potential-2-prongs.js\");\r\nconst get_sharp_corners_1 = __webpack_require__(/*! ./mat/find-mat/get-sharp-corners */ \"./node_modules/flo-mat/node/mat/find-mat/get-sharp-corners.js\");\r\nconst find_and_add_2_prongs_on_all_paths_1 = __webpack_require__(/*! ./mat/find-mat/find-and-add-2-prongs-on-all-paths */ \"./node_modules/flo-mat/node/mat/find-mat/find-and-add-2-prongs-on-all-paths.js\");\r\nconst create_get_interesting_points_on_loop_1 = __webpack_require__(/*! ./mat/find-mat/create-get-interesting-points-on-loop */ \"./node_modules/flo-mat/node/mat/find-mat/create-get-interesting-points-on-loop.js\");\r\nconst find_and_add_hole_closing_2_prongs_1 = __webpack_require__(/*! ./mat/find-mat/find-and-add-hole-closing-2-prongs */ \"./node_modules/flo-mat/node/mat/find-mat/find-and-add-hole-closing-2-prongs.js\");\r\nconst get_loop_area_1 = __webpack_require__(/*! ./get-loop-area */ \"./node_modules/flo-mat/node/get-loop-area.js\");\r\nconst normalize_loop_1 = __webpack_require__(/*! ./loop/normalize/normalize-loop */ \"./node_modules/flo-mat/node/loop/normalize/normalize-loop.js\");\r\n/**\r\n * Find the Medial Axis Transforms (MATs) from the given array of bezier loops\r\n * representing shape boundaries.\r\n * @param bezierLoops An array of (possibly intersecting) loops with each loop\r\n * representing one or more piecewise smooth closed curves (i.e. shapes). Each\r\n * loop consists of an array of beziers represented by an array of control\r\n * points with 2,3 or 4 elements corresponding to linear, quadratic and cubic\r\n * beziers respectively. Each point is a two-element array (ordered pair), the\r\n * first of which is the x-coordinate and the second the y-coordinate.\r\n * @param additionalPointCount Additional points per bezier where a MAT circle\r\n * will be added. Defaults to 3.\r\n */\r\n//function findMats(bezierLoops: number[][][][], additionalPointCount = 3) {\r\nfunction findMats(bezierLoops, additionalPointCount = 1) {\r\n    if (typeof _debug_ !== 'undefined') {\r\n        let timing = _debug_.generated.timing;\r\n        timing.simplify[0] = performance.now();\r\n    }\r\n    //loops_.map(loop => console.log(beziersToSvgPathStr(loop.beziers, 3)));\r\n    // We use 14 here since (14+3)*3 = 51 < 53 (signifcand length). In other\r\n    // words if we change a bezier point coordinate to power basis we add\r\n    // three more significant figures at most (due to multiplication by 6) to\r\n    // get a bit length of 17 so we can multiply 3 coordinates together without\r\n    // any round-off error.\r\n    //let loops = loops_.map(loop => normalizeLoop(loop, max, 13));\r\n    let loops = normalize_loop_1.normalizeLoops(bezierLoops, 14);\r\n    //console.log(loops)\r\n    //loops.map(loop => loop.beziers.map(ps => console.log(ps)))\r\n    //loops.map(loop => console.log(beziersToSvgPathStr(loop.beziers, 0)));\r\n    let { loopss, xMap } = simplify_paths_1.simplifyPaths(loops);\r\n    //console.log(loopss[0][0].beziers)\r\n    for (let i = 0; i < loopss.length; i++) {\r\n        let loops = loopss[i].filter(loopHasNonNegligibleArea(0.1));\r\n        loopss[i] = loops;\r\n    }\r\n    loopss = loopss.filter(loops => loops.length);\r\n    if (typeof _debug_ !== 'undefined') {\r\n        let timing = _debug_.generated.timing;\r\n        timing.simplify[1] += performance.now() - timing.simplify[0];\r\n    }\r\n    let mats = [];\r\n    for (let loops of loopss) {\r\n        loops.sort(simplify_paths_1.ascendingByTopmostPoint);\r\n        let mat = findPartialMat(loops, xMap, additionalPointCount);\r\n        if (mat) {\r\n            mats.push(mat);\r\n        }\r\n    }\r\n    return mats;\r\n}\r\nexports.findMats = findMats;\r\nfunction loopHasNonNegligibleArea(minArea) {\r\n    return (loop) => {\r\n        let area = get_loop_area_1.getLoopArea(loop);\r\n        //console.log(area);\r\n        return Math.abs(area) > minArea;\r\n    };\r\n}\r\n/**\r\n * Find the MAT of the given loops.\r\n * @param loops The loops (that as a precondition must be ordered from highest\r\n * (i.e. smallest y-value) topmost point loops to lowest)\r\n * @param xMap Intersection point map.\r\n * @param additionalPointCount\r\n * @hidden\r\n */\r\nfunction findPartialMat(loops, xMap, additionalPointCount = 3) {\r\n    let extreme = get_extreme_1.getExtreme(loops);\r\n    add_debug_info_1.addDebugInfo1(loops);\r\n    // Gets interesting points on the shape, i.e. those that makes sense to use \r\n    // for the 2-prong procedure.\r\n    let pointsPerLoop = loops.map(create_get_interesting_points_on_loop_1.createGetInterestingPointsOnLoop(additionalPointCount));\r\n    let for2ProngsPerLoop = get_potential_2_prongs_1.getPotential2Prongs(pointsPerLoop);\r\n    let sharpCornersPerLoop = get_sharp_corners_1.getSharpCorners(pointsPerLoop);\r\n    let cpTrees = new Map();\r\n    let cpNode = create_initial_cp_graph_1.createInitialCpGraph(loops, cpTrees, sharpCornersPerLoop, xMap);\r\n    find_and_add_hole_closing_2_prongs_1.findAndAddHoleClosing2Prongs(loops, cpTrees, extreme);\r\n    if (typeof _debug_ !== 'undefined') {\r\n        if (_debug_.directives.stopAfterHoleClosers) {\r\n            return undefined;\r\n        }\r\n    }\r\n    add_debug_info_1.addDebugInfo2(pointsPerLoop);\r\n    cpNode = find_and_add_2_prongs_on_all_paths_1.findAndAdd2ProngsOnAllPaths(loops, cpTrees, for2ProngsPerLoop, extreme);\r\n    //console.log(cpNode)\r\n    add_debug_info_1.addDebugInfo3();\r\n    if (typeof _debug_ !== 'undefined') {\r\n        if (_debug_.directives.stopAfterTwoProngs) {\r\n            return undefined;\r\n        }\r\n    }\r\n    if (cpNode === undefined) {\r\n        return undefined;\r\n    }\r\n    find_and_add_3_prongs_1.findAndAddAll3Prongs(cpTrees, cpNode, extreme);\r\n    if (typeof _debug_ !== 'undefined') {\r\n        if (_debug_.directives.stopAfterThreeProngs) {\r\n            return undefined;\r\n        }\r\n    }\r\n    let mat = new mat_1.Mat(cpNode, cpTrees);\r\n    add_debug_info_1.addDebugInfo4(mat);\r\n    return mat;\r\n}\r\n//# sourceMappingURL=find-mats.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/find-mats.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/get-boundary-bezier-parts-to-next.js":
/*!************************************************************************!*\
  !*** ./node_modules/flo-mat/node/get-boundary-bezier-parts-to-next.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the ordered cubic bezier curves from this CpNode to the next CpNode\r\n * on the boundary.\r\n * @param cpNode\r\n */\r\nfunction getBoundaryBezierPartsToNext(cpNode) {\r\n    let cpThis = cpNode;\r\n    let cpNext = cpNode.next;\r\n    let posThis = cpThis.cp.pointOnShape;\r\n    let posNext = cpNext.cp.pointOnShape;\r\n    let curveThis = posThis.curve;\r\n    let curveNext = posNext.curve;\r\n    if (curveThis.loop !== curveNext.loop) {\r\n        // It is a hole-closer going over to the other loop - a kind of terminal\r\n        // CpNode.\r\n        return undefined;\r\n    }\r\n    let bezierParts = [];\r\n    if (curveNext === curveThis) {\r\n        bezierParts.push({ ps: posThis.curve.ps, ts: [posThis.t, posNext.t] });\r\n    }\r\n    else {\r\n        bezierParts.push({ ps: posThis.curve.ps, ts: [posThis.t, 1] });\r\n        addSkippedBeziers(bezierParts, posThis.curve, posNext.curve, posNext.t);\r\n    }\r\n    return bezierParts;\r\n}\r\nexports.getBoundaryBezierPartsToNext = getBoundaryBezierPartsToNext;\r\n/**\r\n * Adds pieces of skipped beziers.\r\n * @hidden\r\n */\r\nfunction addSkippedBeziers(bezierParts, curveStart, curveEnd, t1) {\r\n    let curveThis = curveStart;\r\n    do {\r\n        curveThis = curveThis.next;\r\n        let bezierPart = curveThis === curveEnd\r\n            ? { ps: curveThis.ps, ts: [0, t1] }\r\n            : { ps: curveThis.ps, ts: [0, 1] };\r\n        bezierParts.push(bezierPart);\r\n    } while (curveThis !== curveEnd);\r\n}\r\n//# sourceMappingURL=get-boundary-bezier-parts-to-next.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/get-boundary-bezier-parts-to-next.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/get-boundary-beziers-to-next.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flo-mat/node/get-boundary-beziers-to-next.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\n/**\r\n * Returns the ordered cubic bezier curves from this CpNode to the next CpNode\r\n * on the boundary.\r\n * @param cpNode\r\n */\r\nfunction getBoundaryBeziersToNext(cpNode) {\r\n    let cpThis = cpNode;\r\n    let cpNext = cpNode.next;\r\n    let posThis = cpThis.cp.pointOnShape;\r\n    let posNext = cpNext.cp.pointOnShape;\r\n    let curveThis = posThis.curve;\r\n    let curveNext = posNext.curve;\r\n    if (curveThis.loop !== curveNext.loop) {\r\n        // It is a hole-closer going over to the other loop - a kind of terminal\r\n        // CpNode.\r\n        return undefined;\r\n    }\r\n    let beziers = [];\r\n    if (curveNext === curveThis) {\r\n        beziers.push(flo_bezier3_1.fromTo(posThis.curve.ps)(posThis.t, posNext.t));\r\n    }\r\n    else {\r\n        beziers.push(flo_bezier3_1.fromTTo1(posThis.curve.ps, posThis.t));\r\n        addSkippedBeziers(beziers, posThis.curve, posNext.curve, posNext.t);\r\n    }\r\n    return beziers;\r\n}\r\nexports.getBoundaryBeziersToNext = getBoundaryBeziersToNext;\r\n/**\r\n * Adds pieces of skipped beziers.\r\n * @hidden\r\n */\r\nfunction addSkippedBeziers(beziers, curveStart, curveEnd, t1) {\r\n    let curveThis = curveStart;\r\n    do {\r\n        curveThis = curveThis.next;\r\n        let tEnd = curveThis === curveEnd ? t1 : 1;\r\n        beziers.push(flo_bezier3_1.from0ToT(curveThis.ps, tEnd));\r\n    } while (curveThis !== curveEnd);\r\n}\r\n//# sourceMappingURL=get-boundary-beziers-to-next.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/get-boundary-beziers-to-next.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/get-branches.js":
/*!***************************************************!*\
  !*** ./node_modules/flo-mat/node/get-branches.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst Vector = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst smoothen_1 = __webpack_require__(/*! ./mat/smoothen/smoothen */ \"./node_modules/flo-mat/node/mat/smoothen/smoothen.js\");\r\nconst defaultTolerance = 1; // 1 degree\r\n/**\r\n * Traverses all edges (depth first) of the given MAT tree starting at the given\r\n * vertex (represented by a [[CpNode]]). Returns the result as an array of\r\n * smooth branches, where smoothness is total or within a given tolerance.\r\n * @param cpNode Any [[CpNode]] representing the start vertex.\r\n * @param tolerance Tolerance given as the degrees difference of the unit\r\n * direction vectors at the interface between curves. A tolerance of zero means\r\n * perfect smoothness is required.\r\n */\r\nfunction getBranches(cpNode, tolerance = defaultTolerance) {\r\n    // Start from a leaf\r\n    while (!cpNode.isFullyTerminating()) {\r\n        cpNode = cpNode.next;\r\n    }\r\n    let branches = [];\r\n    // Since the tree is unrooted we must iterate in all directions from the\r\n    // given vertex.\r\n    let cps = [cpNode.prevOnCircle];\r\n    let branchCpNodes = [];\r\n    while (cps.length) {\r\n        let cp = cps.pop();\r\n        branchCpNodes.push(cp);\r\n        let children = cp.getChildren();\r\n        if (cp.isFullyTerminating()) {\r\n            if (branchCpNodes.length > 1) {\r\n                branches.push(branchCpNodes);\r\n            }\r\n            branchCpNodes = [];\r\n            continue;\r\n        }\r\n        if (children.length === 1) {\r\n            cps.push(children[0]);\r\n            continue;\r\n        }\r\n        children = children.filter(cpNode => !cpNode.isTerminating());\r\n        if (children.length === 0) {\r\n            branches.push(branchCpNodes);\r\n            branchCpNodes = [];\r\n            continue;\r\n        }\r\n        if (children.length > 1) {\r\n            // More than one branch comes together\r\n            branches.push(branchCpNodes);\r\n            branchCpNodes = [];\r\n            cps.push(...children);\r\n            continue;\r\n        }\r\n        let backPointingTan = flo_bezier3_1.tangent(smoothen_1.getCurveToNext(cp.next.prevOnCircle), 0);\r\n        let forwardPointingTan = flo_bezier3_1.tangent(smoothen_1.getCurveToNext(children[0]), 0);\r\n        let cross = Vector.cross(backPointingTan, forwardPointingTan);\r\n        let angle = Math.abs(Math.asin(cross) * (180 / Math.PI));\r\n        if (angle > tolerance) {\r\n            branches.push(branchCpNodes);\r\n            branchCpNodes = [];\r\n        }\r\n        cps.push(children[0]);\r\n    }\r\n    if (branchCpNodes.length) {\r\n        branches.push(branchCpNodes);\r\n    }\r\n    return branches;\r\n}\r\nexports.getBranches = getBranches;\r\n//# sourceMappingURL=get-branches.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/get-branches.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/get-loop-area.js":
/*!****************************************************!*\
  !*** ./node_modules/flo-mat/node/get-loop-area.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst flo_gauss_quadrature_1 = __webpack_require__(/*! flo-gauss-quadrature */ \"./node_modules/flo-gauss-quadrature/node/index.js\");\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\n/**\r\n * See e.g. https://mathinsight.org/greens_theorem_find_area\r\n */\r\nfunction getLoopArea(loop) {\r\n    let totalArea = 0;\r\n    for (let curve of loop.curves) {\r\n        let ps = curve.ps;\r\n        let x = flo_bezier3_1.getX(ps);\r\n        let y = flo_bezier3_1.getY(ps);\r\n        let dx = flo_bezier3_1.getDx(ps);\r\n        let dy = flo_bezier3_1.getDy(ps);\r\n        // xy' named as xy_\r\n        let xy_ = flo_poly_1.multiply(x, dy);\r\n        let yx_ = flo_poly_1.negate(flo_poly_1.multiply(y, dx));\r\n        let poly = flo_poly_1.add(xy_, yx_);\r\n        let f = flo_poly_1.evaluate(poly);\r\n        let area = flo_gauss_quadrature_1.gaussQuadrature(f, [0, 1], 16);\r\n        totalArea += area;\r\n    }\r\n    return -totalArea / 2;\r\n}\r\nexports.getLoopArea = getLoopArea;\r\n//# sourceMappingURL=get-loop-area.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/get-loop-area.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/get-paths-from-str.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-mat/node/get-paths-from-str.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_beziers_from_raw_paths_1 = __webpack_require__(/*! ./svg/fs/get-beziers-from-raw-paths */ \"./node_modules/flo-mat/node/svg/fs/get-beziers-from-raw-paths.js\");\r\nconst parse_path_data_string_1 = __webpack_require__(/*! ./svg/path-data-polyfill/parse-path-data-string */ \"./node_modules/flo-mat/node/svg/path-data-polyfill/parse-path-data-string.js\");\r\n/**\r\n * Returns an array of loops with each loop consisting of an array of beziers\r\n * and each bezier in turn consisting of an array of control points from the\r\n * given SVG path string. An array of loops are returned (as opposed to a single\r\n * loop) since an SVG path may have sub-paths.\r\n * @param str The SVG path string, e.g. 'M1 1 C 5 1 5 2 4 2 C 3 3 1 3 1 1 z'\r\n */\r\nfunction getPathsFromStr(str) {\r\n    return get_beziers_from_raw_paths_1.getBeziersFromRawPaths(parse_path_data_string_1.parsePathDataString(str));\r\n}\r\nexports.getPathsFromStr = getPathsFromStr;\r\n//# sourceMappingURL=get-paths-from-str.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/get-paths-from-str.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/index.js":
/*!********************************************!*\
  !*** ./node_modules/flo-mat/node/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst mat_1 = __webpack_require__(/*! ./mat */ \"./node_modules/flo-mat/node/mat.js\");\r\nexports.Mat = mat_1.Mat;\r\nconst loop_1 = __webpack_require__(/*! ./loop/loop */ \"./node_modules/flo-mat/node/loop/loop.js\");\r\nexports.Loop = loop_1.Loop;\r\nconst curve_1 = __webpack_require__(/*! ./curve */ \"./node_modules/flo-mat/node/curve.js\");\r\nexports.Curve = curve_1.Curve;\r\nconst cp_node_1 = __webpack_require__(/*! ./cp-node/cp-node */ \"./node_modules/flo-mat/node/cp-node/cp-node.js\");\r\nexports.CpNode = cp_node_1.CpNode;\r\nconst point_on_shape_1 = __webpack_require__(/*! ./point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nexports.PointOnShape = point_on_shape_1.PointOnShape;\r\nconst circle_1 = __webpack_require__(/*! ./circle */ \"./node_modules/flo-mat/node/circle.js\");\r\nexports.Circle = circle_1.Circle;\r\nconst contact_point_1 = __webpack_require__(/*! ./contact-point */ \"./node_modules/flo-mat/node/contact-point.js\");\r\nexports.ContactPoint = contact_point_1.ContactPoint;\r\nconst bezier_piece_1 = __webpack_require__(/*! ./bezier-piece */ \"./node_modules/flo-mat/node/bezier-piece.js\");\r\nexports.BezierPiece = bezier_piece_1.BezierPiece;\r\nconst find_mats_1 = __webpack_require__(/*! ./find-mats */ \"./node_modules/flo-mat/node/find-mats.js\");\r\nexports.findMats = find_mats_1.findMats;\r\nconst trim_mat_1 = __webpack_require__(/*! ./mat/trim-mat */ \"./node_modules/flo-mat/node/mat/trim-mat.js\");\r\nexports.trimMat = trim_mat_1.trimMat;\r\nconst to_scale_axis_1 = __webpack_require__(/*! ./to-scale-axis */ \"./node_modules/flo-mat/node/to-scale-axis.js\");\r\nexports.toScaleAxis = to_scale_axis_1.toScaleAxis;\r\nconst traverse_edges_1 = __webpack_require__(/*! ./traverse-edges */ \"./node_modules/flo-mat/node/traverse-edges.js\");\r\nexports.traverseEdges = traverse_edges_1.traverseEdges;\r\nconst get_branches_1 = __webpack_require__(/*! ./get-branches */ \"./node_modules/flo-mat/node/get-branches.js\");\r\nexports.getBranches = get_branches_1.getBranches;\r\nconst traverse_vertices_1 = __webpack_require__(/*! ./traverse-vertices */ \"./node_modules/flo-mat/node/traverse-vertices.js\");\r\nexports.traverseVertices = traverse_vertices_1.traverseVertices;\r\nconst debug_1 = __webpack_require__(/*! ./debug/debug */ \"./node_modules/flo-mat/node/debug/debug.js\");\r\nexports.MatDebug = debug_1.MatDebug;\r\nconst branch_1 = __webpack_require__(/*! ./debug/functions/draw-elem/branch */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/branch.js\");\r\nexports.drawBranch = branch_1.drawBranch;\r\nconst mat_2 = __webpack_require__(/*! ./debug/functions/draw-elem/mat */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/mat.js\");\r\nexports.drawMat = mat_2.drawMat;\r\nconst cp_node_for_debugging_1 = __webpack_require__(/*! ./debug/cp-node-for-debugging */ \"./node_modules/flo-mat/node/debug/cp-node-for-debugging.js\");\r\nexports.CpNodeForDebugging = cp_node_for_debugging_1.CpNodeForDebugging;\r\nconst get_closest_boundary_point_1 = __webpack_require__(/*! ./mat/closest-boundary-point/get-closest-boundary-point */ \"./node_modules/flo-mat/node/mat/closest-boundary-point/get-closest-boundary-point.js\");\r\nexports.getClosestBoundaryPoint = get_closest_boundary_point_1.getClosestBoundaryPoint;\r\n/*\r\nimport { closestPointOnBezier } from\r\n'./mat/closest-boundary-point/closest-point-on-bezier';*/\r\nconst get_paths_from_str_1 = __webpack_require__(/*! ./get-paths-from-str */ \"./node_modules/flo-mat/node/get-paths-from-str.js\");\r\nexports.getPathsFromStr = get_paths_from_str_1.getPathsFromStr;\r\nconst beziers_to_svg_path_str_1 = __webpack_require__(/*! ./beziers-to-svg-path-str */ \"./node_modules/flo-mat/node/beziers-to-svg-path-str.js\");\r\nexports.beziersToSvgPathStr = beziers_to_svg_path_str_1.beziersToSvgPathStr;\r\nconst get_shape_bounds_1 = __webpack_require__(/*! ./svg/fs/get-shape-bounds */ \"./node_modules/flo-mat/node/svg/fs/get-shape-bounds.js\");\r\nexports.getShapeBounds = get_shape_bounds_1.getShapeBounds;\r\nexports.getShapesBounds = get_shape_bounds_1.getShapesBounds;\r\nconst get_boundary_beziers_to_next_1 = __webpack_require__(/*! ./get-boundary-beziers-to-next */ \"./node_modules/flo-mat/node/get-boundary-beziers-to-next.js\");\r\nexports.getBoundaryBeziersToNext = get_boundary_beziers_to_next_1.getBoundaryBeziersToNext;\r\nconst get_boundary_bezier_parts_to_next_1 = __webpack_require__(/*! ./get-boundary-bezier-parts-to-next */ \"./node_modules/flo-mat/node/get-boundary-bezier-parts-to-next.js\");\r\nexports.getBoundaryBezierPartsToNext = get_boundary_bezier_parts_to_next_1.getBoundaryBezierPartsToNext;\r\nconst get_boundary_piece_beziers_1 = __webpack_require__(/*! ./mat/get-boundary-piece-beziers */ \"./node_modules/flo-mat/node/mat/get-boundary-piece-beziers.js\");\r\nexports.getBoundaryPieceBeziers = get_boundary_piece_beziers_1.getBoundaryPieceBeziers;\r\nconst simplify_mat_1 = __webpack_require__(/*! ./mat/simplify-mat */ \"./node_modules/flo-mat/node/mat/simplify-mat.js\");\r\nexports.simplifyMat = simplify_mat_1.simplifyMat;\r\n//import { maxDs, hausdorffDistance } from './hausdorff-distance/hausdorff-distance';\r\nconst draw_elem_1 = __webpack_require__(/*! ./debug/functions/draw-elem/draw-elem */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/draw-elem.js\");\r\nexports.drawElemFunctions = draw_elem_1.drawElemFunctions;\r\nconst smoothen_1 = __webpack_require__(/*! ./mat/smoothen/smoothen */ \"./node_modules/flo-mat/node/mat/smoothen/smoothen.js\");\r\nexports.getCurveToNext = smoothen_1.getCurveToNext;\r\nexports.getCurveBetween = smoothen_1.getCurveBetween;\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/index.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/loop/loop.js":
/*!************************************************!*\
  !*** ./node_modules/flo-mat/node/loop/loop.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst curve_1 = __webpack_require__(/*! ../curve */ \"./node_modules/flo-mat/node/curve.js\");\r\nconst to_grid_1 = __webpack_require__(/*! ../numerical/to-grid */ \"./node_modules/flo-mat/node/numerical/to-grid.js\");\r\n/**\r\n * Represents a two-way linked loop of [[Curve]]s - mostly used internally to\r\n * conveniently represent shape boundaries.\r\n */\r\nclass Loop {\r\n    //parent: Loop = undefined;\r\n    //children: Loop[] = [];\r\n    /**\r\n     * @param beziers - A pre-ordered array of bezier curves to add initially.\r\n     * @param children - Child loops connected via hole closers\r\n     */\r\n    constructor(beziers = []) {\r\n        this.beziers = beziers;\r\n        this.curves = [];\r\n        let loop = this;\r\n        if (beziers.length === 0) {\r\n            return undefined;\r\n        }\r\n        let head;\r\n        let prev = null;\r\n        let node;\r\n        for (let i = 0; i < beziers.length; i++) {\r\n            node = new curve_1.Curve(loop, beziers[i], prev, null, i);\r\n            loop.curves.push(node);\r\n            if (prev) {\r\n                prev.next = node;\r\n            }\r\n            prev = node;\r\n            if (i === 0) {\r\n                head = node;\r\n            }\r\n        }\r\n        // Close loop\r\n        head.prev = node;\r\n        node.next = head;\r\n        this.head = head;\r\n    }\r\n    /**\r\n     * Returns the loop as an array of beziers.\r\n     */\r\n    toBeziers() {\r\n        let beziers = [];\r\n        for (let curve of this.curves) {\r\n            beziers.push(curve.ps);\r\n        }\r\n        return beziers;\r\n    }\r\n    /**\r\n     * Creates and returns a [[Loop]] from the given array of cubic beziers.\r\n     * @param beziers An array of cubic beziers.\r\n     */\r\n    static fromCubicBeziers(beziers = []) {\r\n        return new Loop(beziers);\r\n    }\r\n    /**\r\n     * Perturbs the loop. Not used.\r\n     * @param loop\r\n     * @param x\r\n     * @hidden\r\n     */\r\n    static perturb(loop, x) {\r\n        if (!x) {\r\n            return loop;\r\n        }\r\n        let seed = 2311; // Just some value\r\n        let newItems = [];\r\n        for (let i = 0; i < loop.beziers.length; i++) {\r\n            // This gets us a predictable random number between 0 and 1;\r\n            let rand1 = flo_poly_1.flatCoefficients(6, -1, 1, seed);\r\n            let rs = rand1.p;\r\n            seed = rand1.seed; // Get next seed.\r\n            let vs = rs.map(r => r * x);\r\n            console.log(vs);\r\n            let ps = loop.beziers[i];\r\n            let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n            let newPs = [\r\n                [x0 + vs[0], y0 + vs[1]],\r\n                [x1 + vs[2], y1 + vs[3]],\r\n                [x2 + vs[4], y2 + vs[5]],\r\n                [0, 0]\r\n            ];\r\n            if (i !== 0) {\r\n                let prev = newItems[newItems.length - 1];\r\n                prev[3][0] = newPs[0][0];\r\n                prev[3][1] = newPs[0][1];\r\n            }\r\n            newItems.push(newPs);\r\n        }\r\n        let last = newItems[newItems.length - 1];\r\n        last[3][0] = newItems[0][0][0];\r\n        last[3][1] = newItems[0][0][1];\r\n        return new Loop(newItems);\r\n    }\r\n    /**\r\n     * reduceSignificands of the loop. Not used.\r\n     * @param loop\r\n     * @param x\r\n     * @hidden\r\n     */\r\n    static toGrid(loop, max, significantFigures) {\r\n        let newPss = [];\r\n        function f(a) {\r\n            let res = to_grid_1.toGrid(a, max, significantFigures);\r\n            return res;\r\n        }\r\n        for (let i = 0; i < loop.beziers.length; i++) {\r\n            let ps = loop.beziers[i];\r\n            let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n            let newPs = [\r\n                [f(x0), f(y0)],\r\n                [f(x1), f(y1)],\r\n                [f(x2), f(y2)],\r\n                [f(x3), f(y3)],\r\n            ];\r\n            newPss.push(newPs);\r\n        }\r\n        return new Loop(newPss);\r\n    }\r\n}\r\nexports.Loop = Loop;\r\n//# sourceMappingURL=loop.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/loop/loop.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/loop/normalize/are-all-points-different.js":
/*!******************************************************************************!*\
  !*** ./node_modules/flo-mat/node/loop/normalize/are-all-points-different.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns true if all points in the given array are different, false otherwise.\r\n * @param ps An array of points.\r\n */\r\nfunction areAllPointsDifferent(ps) {\r\n    for (let i = 0; i < ps.length - 1; i++) {\r\n        for (let j = i + 1; j < ps.length; j++) {\r\n            if (ps[i][0] === ps[j][0] && ps[i][1] === ps[j][1]) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexports.areAllPointsDifferent = areAllPointsDifferent;\r\n//# sourceMappingURL=are-all-points-different.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/loop/normalize/are-all-points-different.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/loop/normalize/fix-bezier-by-point-spacing.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/flo-mat/node/loop/normalize/fix-bezier-by-point-spacing.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst are_all_points_different_1 = __webpack_require__(/*! ./are-all-points-different */ \"./node_modules/flo-mat/node/loop/normalize/are-all-points-different.js\");\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\n/**\r\n * Returns the same bezier if its points are well-spaced, e.g. all points not\r\n * coincident, etc., else fix it, if possible, and return the fixed bezier,\r\n * else return undefined.\r\n * @param ps A bezier\r\n */\r\nfunction fixBezierByPointSpacing(ps, gridSpacing, sendToGrid) {\r\n    // Early filter - if all points coincide, we're done - degenerate to point\r\n    if (flo_bezier3_1.lengthSquaredUpperBound(ps) === 0) {\r\n        return undefined; // Cannot fix\r\n    }\r\n    // Early filter - if no points coincide, we're done - well spaced\r\n    if (are_all_points_different_1.areAllPointsDifferent(ps)) {\r\n        return ps;\r\n    }\r\n    if (arePsEqual(ps[0], ps[ps.length - 1])) {\r\n        //console.log(ps);\r\n        // TODO - If first and last points equal we remove the bezier - in future we \r\n        // should simply handle this case for cubics - lines and quadratics degenerate\r\n        // into a point and a self-overlapping curve respectively.\r\n        return undefined;\r\n    }\r\n    if (ps.length === 4) {\r\n        return fixCubic(ps, gridSpacing, sendToGrid);\r\n    }\r\n    else if (ps.length === 3) {\r\n        // At this point not all points same and not all points different and \r\n        // not endpoints coincide, so either:\r\n        // * point 0 and 1 coincide\r\n        // * point 1 and 2 coincide\r\n        // but in that case we simply have a line\r\n        return [ps[0], ps[2]];\r\n    }\r\n    else if (ps.length === 2) {\r\n        // obviously no need to fix line\r\n        return ps;\r\n    }\r\n}\r\nexports.fixBezierByPointSpacing = fixBezierByPointSpacing;\r\nfunction fixCubic(ps, gridSpacing, sendToGrid) {\r\n    // At this point, either:\r\n    // * point 0, 1 and 2 coincide\r\n    // * point 1, 2 and 3 coincide\r\n    // * points 0,1 AND points 2,3 coincide\r\n    // * only point 0 and point 1 coincides\r\n    // * only point 0 and point 2 coincides        \r\n    // * only point 1 and point 2 coincides\r\n    // * only point 1 and point 3 coincides\r\n    // * only point 2 and point 3 coincides\r\n    // If point 0, 1 and 2 coincide OR point 1, 2 and 3 coincide OR\r\n    // points 0,1 AND points 2,3 coincide we have a line\r\n    if ((arePsEqual(ps[0], ps[1]) &&\r\n        arePsEqual(ps[1], ps[2])) ||\r\n        (arePsEqual(ps[1], ps[2]) &&\r\n            arePsEqual(ps[2], ps[3])) ||\r\n        (arePsEqual(ps[0], ps[1]) &&\r\n            arePsEqual(ps[2], ps[3]))) {\r\n        // Check if first and last point are sufficiently far apart to split\r\n        // the bezier into a line so that all points differ.\r\n        if (ps[0][0] - ps[3][0] > (3 + 1) * gridSpacing ||\r\n            ps[0][1] - ps[3][1] > (3 + 1) * gridSpacing) {\r\n            return [ps[0], ps[ps.length - 1]];\r\n        }\r\n        else {\r\n            // Points are not sufficiently far apart to resolve onto grid -\r\n            // cannot fix it.\r\n            return undefined;\r\n        }\r\n    }\r\n    // At this point, either:\r\n    // * only point 0 and point 1 coincides\r\n    // * only point 0 and point 2 coincides        \r\n    // * only point 1 and point 2 coincides\r\n    // * only point 1 and point 3 coincides\r\n    // * only point 2 and point 3 coincides\r\n    // If points 0,2 OR points 1,3 OR points 1,2 coincide we're done - I\r\n    // don't think these are problematic\r\n    if (arePsEqual(ps[0], ps[2]) ||\r\n        arePsEqual(ps[1], ps[3]) ||\r\n        arePsEqual(ps[1], ps[2])) {\r\n        return ps;\r\n    }\r\n    // At this point, either:\r\n    // * only point 0 and point 1 coincides\r\n    // * only point 2 and point 3 coincides\r\n    if (arePsEqual(ps[0], ps[1])) {\r\n        // Move point 1 towards point 2 without surpassing it and ensuring it\r\n        // will be on a new grid point\r\n        // If squared distance between the points < 4 * gridSpacing just \r\n        // move them onto each other - this shouldn't affect the overall \r\n        // accuracy of the algorithm and it ensures the move > gridSpacing.\r\n        if (flo_vector2d_1.squaredDistanceBetween(ps[1], ps[2]) < 4 * gridSpacing) {\r\n            return [\r\n                ps[0],\r\n                ps[2],\r\n                ps[2],\r\n                ps[3]\r\n            ];\r\n        }\r\n        else {\r\n            let v = flo_vector2d_1.toLength(flo_vector2d_1.fromTo(ps[1], ps[2]), 2 * gridSpacing);\r\n            let p1 = flo_vector2d_1.translate(ps[1], v);\r\n            return [\r\n                ps[0],\r\n                sendToGrid(p1),\r\n                ps[2],\r\n                ps[3]\r\n            ];\r\n        }\r\n    }\r\n    if (arePsEqual(ps[2], ps[3])) {\r\n        // Move point 2 towards point 1 without surpassing it and ensuring it\r\n        // will be on a new grid point\r\n        // If squared distance between the points < 4 * gridSpacing just \r\n        // move them onto each other - this shouldn't affect the overall \r\n        // accuracy of the algorithm and it ensures the move > gridSpacing.\r\n        if (flo_vector2d_1.squaredDistanceBetween(ps[2], ps[1]) < 4 * gridSpacing) {\r\n            return [\r\n                ps[0],\r\n                ps[1],\r\n                ps[1],\r\n                ps[3]\r\n            ];\r\n        }\r\n        else {\r\n            let v = flo_vector2d_1.toLength(flo_vector2d_1.fromTo(ps[2], ps[1]), 2 * gridSpacing);\r\n            let p2 = flo_vector2d_1.translate(ps[2], v);\r\n            return ps = [\r\n                ps[0],\r\n                ps[1],\r\n                sendToGrid(p2),\r\n                ps[3]\r\n            ];\r\n        }\r\n    }\r\n}\r\n/** Returns true if the points are the same */\r\nfunction arePsEqual(p1, p2) {\r\n    return p1[0] === p2[0] && p1[1] === p2[1];\r\n}\r\n//# sourceMappingURL=fix-bezier-by-point-spacing.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/loop/normalize/fix-bezier-by-point-spacing.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/loop/normalize/fix-beziers.js":
/*!*****************************************************************!*\
  !*** ./node_modules/flo-mat/node/loop/normalize/fix-beziers.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst to_grid_1 = __webpack_require__(/*! ../../numerical/to-grid */ \"./node_modules/flo-mat/node/numerical/to-grid.js\");\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst fix_bezier_by_point_spacing_1 = __webpack_require__(/*! ./fix-bezier-by-point-spacing */ \"./node_modules/flo-mat/node/loop/normalize/fix-bezier-by-point-spacing.js\");\r\n/**\r\n * Returns the grid-aligned loop derived from the given input loop.\r\n *\r\n * Also ensures that:\r\n * * All points are coerced onto a grid.\r\n * * All bezier points of a single curve are seperated.\r\n * @param expMax The exponent, e, such that 2^e > all bezier coordinate points.\r\n * @param maxBitLength\r\n */\r\nfunction fixBeziers(expMax, maxBitLength) {\r\n    /** The actual control point grid spacing */\r\n    let gridSpacing = Math.pow(2, expMax) * Math.pow(2, (-maxBitLength));\r\n    function sendToGrid(p) {\r\n        return [\r\n            to_grid_1.toGrid(p[0], expMax, maxBitLength),\r\n            to_grid_1.toGrid(p[1], expMax, maxBitLength)\r\n        ];\r\n    }\r\n    return (loop) => {\r\n        let newPss = [];\r\n        //let _p_ = loop.beziers[0][0];\r\n        for (let i = 0; i < loop.length; i++) {\r\n            let ps = loop[i].slice();\r\n            // Get endpoint of last good bezier or else the original start point\r\n            let len = newPss.length;\r\n            let prevGoodBezier = newPss[len - 1];\r\n            let prevGoodBezierEndpoint = prevGoodBezier\r\n                ? prevGoodBezier[prevGoodBezier.length - 1]\r\n                : sendToGrid(loop[0][0]); // Bit-align original start point\r\n            // Set the start point to the previous good bezier's endpoint\r\n            ps[0] = prevGoodBezierEndpoint;\r\n            // Align to grid before doing any further checks\r\n            ps = ps.map(p => sendToGrid(p));\r\n            // Check if ps degenerates into a self-overlapping line\r\n            if (flo_bezier3_1.isSelfOverlapping(ps)) {\r\n                //console.log(ps);\r\n                //console.log(isSelfOverlapping(ps));\r\n                // Change into a line with endponts that of the original bezier\r\n                ps = [ps[0], ps[ps.length - 1]];\r\n            }\r\n            ps = fix_bezier_by_point_spacing_1.fixBezierByPointSpacing(ps, gridSpacing, sendToGrid);\r\n            if (ps) {\r\n                newPss.push(ps);\r\n            }\r\n        }\r\n        let len = newPss.length;\r\n        if (!len) {\r\n            return [];\r\n        }\r\n        // Connect the last bezier end-point to the first bezier start-point.\r\n        let ps = newPss[len - 1];\r\n        ps[ps.length - 1] = newPss[0][0];\r\n        return newPss;\r\n    };\r\n}\r\nexports.fixBeziers = fixBeziers;\r\n//# sourceMappingURL=fix-beziers.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/loop/normalize/fix-beziers.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/loop/normalize/get-max-coordinate.js":
/*!************************************************************************!*\
  !*** ./node_modules/flo-mat/node/loop/normalize/get-max-coordinate.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the maximum control point coordinate value (x or y) within any loop.\r\n * @param loops The array of loops\r\n */\r\nfunction getMaxCoordinate(loops) {\r\n    let max = 0;\r\n    for (let loop of loops) {\r\n        for (let ps of loop) {\r\n            for (let p of ps) {\r\n                for (let c of p) {\r\n                    let c_ = Math.abs(c);\r\n                    if (c_ > max) {\r\n                        max = c_;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return max;\r\n}\r\nexports.getMaxCoordinate = getMaxCoordinate;\r\n//# sourceMappingURL=get-max-coordinate.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/loop/normalize/get-max-coordinate.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/loop/normalize/in-same-k-family-and-maybe-intersecting.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/loop/normalize/in-same-k-family-and-maybe-intersecting.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst are_boxes_intersecting_1 = __webpack_require__(/*! ../../sweep-line/are-boxes-intersecting */ \"./node_modules/flo-mat/node/sweep-line/are-boxes-intersecting.js\");\r\nfunction inSameKFamliyAndMaybeIntersecting(ps1, ps2) {\r\n    let bbPs1 = flo_bezier3_1.getBoundingBox(ps1);\r\n    let bbPs2 = flo_bezier3_1.getBoundingBox(ps2);\r\n    // We need to take special care of horizontal / vertical lines since their\r\n    // open bounding boxes vanish and even though an intersection may exist\r\n    // between ps1 and ps2 it will be reported otherwise.\r\n    if (flo_bezier3_1.isHorizontalLine(ps1) && flo_bezier3_1.isHorizontalLine(ps2)) {\r\n        if (ps1[0][1] !== ps2[0][1]) {\r\n            return false;\r\n        }\r\n        let [[ax0,], [ax1,]] = bbPs1;\r\n        let [[bx0,], [bx1,]] = bbPs2;\r\n        // Swap so smaller coordinate comes first\r\n        if (ax0 > ax1) {\r\n            [ax0, ax1] = [ax1, ax0];\r\n        }\r\n        ;\r\n        if (bx0 > bx1) {\r\n            [bx0, bx1] = [bx1, bx0];\r\n        }\r\n        ;\r\n        return ax0 < bx1 && ax1 > bx0;\r\n    }\r\n    else if (flo_bezier3_1.isVerticalLine(ps1) && flo_bezier3_1.isVerticalLine(ps2)) {\r\n        if (ps1[0][0] !== ps2[0][0]) {\r\n            return false;\r\n        }\r\n        let [[, ay0], [, ay1]] = bbPs1;\r\n        let [[, by0], [, by1]] = bbPs2;\r\n        // Swap so smaller coordinate comes first\r\n        if (ay0 > ay1) {\r\n            [ay0, ay1] = [ay1, ay0];\r\n        }\r\n        ;\r\n        if (by0 > by1) {\r\n            [by0, by1] = [by1, by0];\r\n        }\r\n        ;\r\n        return by0 < ay1 && by1 > ay0;\r\n    }\r\n    // It is better to check for open box intersection in this case, \r\n    // otherwise many beziers will be reported as possibly intersecting\r\n    // even though they intersect only at endpoints which we don't care\r\n    // about here.\r\n    let areBoxesIntersectingOpen = are_boxes_intersecting_1.areBoxesIntersecting(false);\r\n    return (areBoxesIntersectingOpen(bbPs1, bbPs2) &&\r\n        flo_bezier3_1.areBeziersInSameKFamily(ps1, ps2));\r\n}\r\nexports.inSameKFamliyAndMaybeIntersecting = inSameKFamliyAndMaybeIntersecting;\r\n//# sourceMappingURL=in-same-k-family-and-maybe-intersecting.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/loop/normalize/in-same-k-family-and-maybe-intersecting.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/loop/normalize/normalize-loop.js":
/*!********************************************************************!*\
  !*** ./node_modules/flo-mat/node/loop/normalize/normalize-loop.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst loop_1 = __webpack_require__(/*! ../loop */ \"./node_modules/flo-mat/node/loop/loop.js\");\r\nconst get_max_coordinate_1 = __webpack_require__(/*! ./get-max-coordinate */ \"./node_modules/flo-mat/node/loop/normalize/get-max-coordinate.js\");\r\nconst fix_beziers_1 = __webpack_require__(/*! ./fix-beziers */ \"./node_modules/flo-mat/node/loop/normalize/fix-beziers.js\");\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst sweep_line_1 = __webpack_require__(/*! ../../sweep-line/sweep-line */ \"./node_modules/flo-mat/node/sweep-line/sweep-line.js\");\r\nconst in_same_k_family_and_maybe_intersecting_1 = __webpack_require__(/*! ./in-same-k-family-and-maybe-intersecting */ \"./node_modules/flo-mat/node/loop/normalize/in-same-k-family-and-maybe-intersecting.js\");\r\n/**\r\n * Returns loops that is the result of putting the given loops in general\r\n * position (loosely speaking). The modifications to the input loop should be\r\n * such that no discernable visual changes occur.\r\n *\r\n * The following guarantees are put in place for the returned loops:\r\n * * No bezier is of zero length.\r\n * * All points are coerced onto a grid. In other words, such that the\r\n * significand of all points are reduced to a specified number of bits and the\r\n * significant bits of all points overlap.\r\n * * All bezier points of a single curve are seperated - this prevents infinite\r\n * curvature at the endpoints, etc.\r\n * * TODO - All curves are x-monotone (i.e. the x-coordinate of any bezier curve is a\r\n * (non-strict) increasing (or decreasing) function of its parameter)\r\n * * TODO - All curves are y-monotone (i.e. the y-coordinate of any bezier curve is a\r\n * (non-strict) increasing (or decreasing) function of its parameter)\r\n * * TODO - No two bezier curves are in the same K-family (i.e. the same curve when the\r\n * parameter can vary in [-inf, +inf]) unless they are non-intersecting.\r\n * * TODO - no bezier cusps\r\n * * TODO - no bezier self-intersections (including single bezier closed loops)\r\n * * TODO !!IMPORTANT!! No self-intersections at infinitely many points, i.e.\r\n * where the curve goes back on itself.\r\n *\r\n * This gives us some good guarantees for the rest of the algorithm. In\r\n * particular, the algorithms is made much less complex and runs much faster.\r\n *\r\n * @param loop\r\n * @param maxCoordinate\r\n */\r\nfunction normalizeLoops(bezierLoops, maxBitLength) {\r\n    let maxCoordinate = get_max_coordinate_1.getMaxCoordinate(bezierLoops);\r\n    /** The exponent, e, such that 2^e >= all bezier coordinate points. */\r\n    let expMax = Math.ceil(Math.log2(maxCoordinate));\r\n    let gridSpacing = Math.pow(2, expMax) * Math.pow(2, (-maxBitLength));\r\n    let fixBeziers_ = fix_beziers_1.fixBeziers(expMax, maxBitLength);\r\n    let loops = bezierLoops.slice();\r\n    let seed = SEED;\r\n    let maxTries = 10;\r\n    let i = 0;\r\n    while (true) {\r\n        if (++i >= maxTries) {\r\n            throw new Error('max tries exceeded');\r\n        }\r\n        loops = loops.map(fixBeziers_);\r\n        // Check if any two beziers are in the same K-family and are not seperated\r\n        // Otherwise move a coordinate in some direction by a small amount and\r\n        // retest and re-align to grid.\r\n        let pss = [];\r\n        loops.forEach(function (loop) {\r\n            loop.forEach((ps, idx) => {\r\n                pss.push({ ps, loop, idx });\r\n            });\r\n        });\r\n        let pairs = sweep_line_1.sweepLine(pss, ps => getLeftmost(ps.ps), ps => getRightmost(ps.ps), (ps1, ps2) => in_same_k_family_and_maybe_intersecting_1.inSameKFamliyAndMaybeIntersecting(ps1.ps, ps2.ps));\r\n        if (!pairs.length) {\r\n            break;\r\n        }\r\n        //console.log(pairs);\r\n        for (let pair of pairs) {\r\n            //console.log(pair);\r\n            // Randomly choose one of the 2 beziers\r\n            let v;\r\n            ({ v, seed } = randomInt(seed, 1));\r\n            let ps_ = v === 0 ? pair[0] : pair[1];\r\n            let ps = ps_.ps;\r\n            // Choose a random point of the bezier\r\n            ({ v, seed } = randomInt(seed, ps.length - 1));\r\n            // Move that point by an amount gridSpacing in a random direction\r\n            let newPs = ps.map((p, i) => {\r\n                let p_;\r\n                if (i !== v) {\r\n                    return p;\r\n                } // Leave p unchanged\r\n                ({ p: p_, seed } = movePointInRandomDirection(p, seed, gridSpacing));\r\n                return p_;\r\n            });\r\n            let { idx, loop } = ps_;\r\n            // Splice in the new bezier\r\n            loop.splice(idx, 1, newPs);\r\n            // If first endpoints moved, also move prev/next beziers' endpoints\r\n            let prevIdx = idx === 0 ? loop.length - 1 : idx - 1;\r\n            let nextIdx = (idx + 1) % loop.length;\r\n            let prevPs = loop[prevIdx];\r\n            let nextPs = loop[nextIdx];\r\n            loop.splice(prevIdx, 1, replacePoint(prevPs, newPs[0], prevPs.length - 1));\r\n            loop.splice(nextIdx, 1, replacePoint(nextPs, newPs[newPs.length - 1], 0));\r\n        }\r\n    }\r\n    return loops.map(loop => new loop_1.Loop(loop));\r\n}\r\nexports.normalizeLoops = normalizeLoops;\r\n/**\r\n * Returns a new point by moving the previous point in a predictably random\r\n * direction\r\n * @param p A point\r\n */\r\nfunction movePointInRandomDirection(p, seed_, gridSpacing) {\r\n    let { v, seed } = randomInt(seed_, 3);\r\n    let p_;\r\n    if (v === 0) {\r\n        // Move up\r\n        p_ = [p[0], p[1] - gridSpacing];\r\n    }\r\n    else if (v === 1) {\r\n        // Move down\r\n        p_ = [p[0], p[1] + gridSpacing];\r\n    }\r\n    else if (v === 2) {\r\n        // Move left\r\n        p_ = [p[0] - gridSpacing, p[1]];\r\n    }\r\n    else {\r\n        // Move right\r\n        p_ = [p[0] + gridSpacing, p[1]];\r\n    }\r\n    return { p: p_, seed };\r\n}\r\nfunction replacePoint(ps, p, idx) {\r\n    return ps.map((p_, i) => i === idx ? p : p_);\r\n}\r\n/**\r\n * Returns a random number from 0 to upTo\r\n * @param v A number in [0,1)\r\n */\r\nfunction randomInt(seed, upTo) {\r\n    seed = predictiveRandom(seed);\r\n    let v = Math.floor((seed / RANGE) * (upTo + 1));\r\n    return { v, seed };\r\n}\r\n/**\r\n * Some seed value for the simple random number generator.\r\n * @ignore\r\n */\r\nconst SEED = 123456789;\r\n/**\r\n * The range for the simple random number generator, i.e. the generated\r\n * numbers will be in [0,RANGE].\r\n * @ignore\r\n */\r\nconst RANGE = 4294967296;\r\n/**\r\n * Returns a quasi-random number to be used as the next input to this function.\r\n * See https://stackoverflow.com/a/3062783\r\n * @private\r\n * @param seed\r\n */\r\nfunction predictiveRandom(seed = SEED) {\r\n    const a = 134775813;\r\n    return (a * seed + 1) % RANGE;\r\n}\r\nfunction getLeftmost(ps) {\r\n    let bounds = flo_bezier3_1.getBounds(ps);\r\n    return bounds.box[0][0];\r\n}\r\nfunction getRightmost(ps) {\r\n    let bounds = flo_bezier3_1.getBounds(ps);\r\n    return bounds.box[1][0];\r\n}\r\n//# sourceMappingURL=normalize-loop.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/loop/normalize/normalize-loop.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat.js":
/*!******************************************!*\
  !*** ./node_modules/flo-mat/node/mat.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Represents a complete Medial Axis Transform (MAT).\r\n *\r\n * The MAT is fully described through its [[CpNode]] property. The [[cpTrees]]\r\n * property is only added to facilitate extension of the MAT, e.g. by adding\r\n * extra maximal disks and is typically not used. See [[CpNode]] for more\r\n * details.\r\n */\r\nclass Mat {\r\n    /**\r\n     * @param cpNode A complete representation of the MAT. See [[CpNode]].\r\n     * @param cpTrees Primarily for internal use. A tree structure storing the\r\n     * [[CpNode]]s of the MAT by their compare order, i.e. their cyclic order\r\n     * around the shape boundary.\r\n     */\r\n    constructor(cpNode, cpTrees) {\r\n        this.cpNode = cpNode;\r\n        this.cpTrees = cpTrees;\r\n    }\r\n}\r\nexports.Mat = Mat;\r\n//# sourceMappingURL=mat.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/add-to-cp-graph.js":
/*!**********************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/add-to-cp-graph.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst contact_point_1 = __webpack_require__(/*! ../contact-point */ \"./node_modules/flo-mat/node/contact-point.js\");\r\nconst cp_node_1 = __webpack_require__(/*! ../cp-node/cp-node */ \"./node_modules/flo-mat/node/cp-node/cp-node.js\");\r\nconst get_neighboring_cps_1 = __webpack_require__(/*! ./get-neighboring-cps */ \"./node_modules/flo-mat/node/mat/get-neighboring-cps.js\");\r\n/**\r\n *\r\n * @param circle\r\n * @param orders\r\n * @param cpTrees\r\n * @param poss\r\n * @param neighbors\r\n * @hidden\r\n */\r\nfunction addToCpGraph(circle, orders, cpTrees, poss, neighbors) {\r\n    let newCps = poss.map((pos, i) => {\r\n        let cpTree = cpTrees.get(pos.curve.loop);\r\n        let newCp_ = new contact_point_1.ContactPoint(pos, circle, orders[i], 0);\r\n        let neighboringCp = neighbors\r\n            ? neighbors[i]\r\n            : get_neighboring_cps_1.getNeighbouringPoints(cpTree, pos, orders[i], 0);\r\n        let newCp = cp_node_1.CpNode.insert(false, false, cpTree, newCp_, neighboringCp[0]);\r\n        return newCp;\r\n    });\r\n    let len = poss.length;\r\n    for (let i = 0; i < len; i++) {\r\n        let indxPrev = i === 0 ? len - 1 : i - 1;\r\n        let indxNext = i === len - 1 ? 0 : i + 1;\r\n        newCps[i].prevOnCircle = newCps[indxPrev];\r\n        newCps[i].nextOnCircle = newCps[indxNext];\r\n    }\r\n}\r\nexports.addToCpGraph = addToCpGraph;\r\n//# sourceMappingURL=add-to-cp-graph.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/add-to-cp-graph.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/closest-boundary-point/closest-point-on-curve.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/closest-boundary-point/closest-point-on-curve.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nlet DELTA = 1e-11;\r\n/**\r\n *\r\n * @param curve The bezier\r\n * @param p The point from which to check\r\n * @param tRange The allowed t range\r\n * @param touchedCurve The bezier on which p is located\r\n * @param t The t value of the bezier that locates p\r\n */\r\nfunction closestPointOnCurve(curve, p, tRange = [0, 1], touchedCurve, t) {\r\n    let poly = flo_bezier3_1.getTangentPolyFromPoint(curve.ps, p);\r\n    if (curve === touchedCurve) {\r\n        poly = flo_poly_1.deflate(poly, t);\r\n    }\r\n    let roots = flo_poly_1.allRoots(poly, tRange[0], tRange[1]);\r\n    // Also test the endpoints\r\n    let push0 = true;\r\n    let push1 = true;\r\n    if ((t === 1 && curve === touchedCurve.next) ||\r\n        (t === 0 && curve === touchedCurve)) {\r\n        push0 = false;\r\n    }\r\n    if ((t === 0 && curve === touchedCurve.prev) ||\r\n        (t === 1 && curve === touchedCurve)) {\r\n        push1 = false;\r\n    }\r\n    if (tRange[0] === 0) {\r\n        if (push0) {\r\n            roots.push(0);\r\n        }\r\n    }\r\n    else if (tRange[0] === 1) {\r\n        if (push1) {\r\n            roots.push(1);\r\n        }\r\n    }\r\n    else {\r\n        roots.push(tRange[0]);\r\n    }\r\n    if (tRange[1] === 0) {\r\n        if (push0) {\r\n            roots.push(0);\r\n        }\r\n    }\r\n    else if (tRange[1] === 1) {\r\n        if (push1) {\r\n            roots.push(1);\r\n        }\r\n    }\r\n    else {\r\n        roots.push(tRange[1]);\r\n    }\r\n    // This is to take care of a numerical issue - see shape p1.svg.\r\n    let roots_ = [];\r\n    for (let i = 0; i < roots.length; i++) {\r\n        let root = roots[i];\r\n        if (root !== 0 && root < DELTA) {\r\n            root = 0;\r\n        }\r\n        else if (root !== 1 && 1 - root < DELTA) {\r\n            root = 1;\r\n        }\r\n        roots_.push(root);\r\n    }\r\n    let ev = flo_bezier3_1.evaluate(curve.ps);\r\n    let ps = roots_.map(\r\n    //let ps = roots.map(\r\n    root => ({ p: ev(root), t: root }));\r\n    return flo_vector2d_1.getObjClosestTo(p, ps, p => p.p);\r\n}\r\nexports.closestPointOnCurve = closestPointOnCurve;\r\n//# sourceMappingURL=closest-point-on-curve.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/closest-boundary-point/closest-point-on-curve.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/closest-boundary-point/closest-points-on-curve.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/closest-boundary-point/closest-points-on-curve.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\n/**\r\n *\r\n * @param curve The bezier\r\n * @param p The point from which to check\r\n * @param tRange The allowed t range\r\n * @param touchedCurve The bezier on which p is located\r\n * @param t The t value of the bezier that locates p\r\n */\r\nfunction closestPointsOnCurve(curve, p, tRange = [0, 1], touchedCurve, t, distance, distanceTolerance) {\r\n    let poly = flo_bezier3_1.getTangentPolyFromPoint(curve.ps, p);\r\n    if (curve === touchedCurve) {\r\n        poly = flo_poly_1.deflate(poly, t);\r\n    }\r\n    let roots = flo_poly_1.allRoots(poly, tRange[0], tRange[1]);\r\n    // Also test the endpoints\r\n    let push0 = true;\r\n    let push1 = true;\r\n    if ((t === 1 && curve === touchedCurve.next) ||\r\n        (curve === touchedCurve && t === 0)) {\r\n        push0 = false;\r\n    }\r\n    if ((t === 0 && curve === touchedCurve.prev) ||\r\n        (curve === touchedCurve && t === 1)) {\r\n        push1 = false;\r\n    }\r\n    if (tRange[0] === 0) {\r\n        if (push0) {\r\n            roots.push(tRange[0]);\r\n        }\r\n    }\r\n    else if (tRange[0] === 1) {\r\n        if (push1) {\r\n            roots.push(tRange[0]);\r\n        }\r\n    }\r\n    else {\r\n        roots.push(tRange[0]);\r\n    }\r\n    if (tRange[1] === 0) {\r\n        if (push0) {\r\n            roots.push(tRange[1]);\r\n        }\r\n    }\r\n    else if (tRange[1] === 1) {\r\n        if (push1) {\r\n            roots.push(tRange[1]);\r\n        }\r\n    }\r\n    else {\r\n        roots.push(tRange[1]);\r\n    }\r\n    // This is to take care of a numerical issue.\r\n    let roots_ = [];\r\n    for (let i = 0; i < roots.length; i++) {\r\n        let root = roots[i];\r\n        if (root !== 0 && root < 1e-10) {\r\n            root = 0;\r\n        }\r\n        else if (root !== 1 && 1 - root < 1e-10) {\r\n            root = 1;\r\n        }\r\n        roots_.push(root);\r\n    }\r\n    let ev = flo_bezier3_1.evaluate(curve.ps);\r\n    let ps = roots.map(root => ({ p: ev(root), t: root }));\r\n    return ps;\r\n}\r\nexports.closestPointsOnCurve = closestPointsOnCurve;\r\n//# sourceMappingURL=closest-points-on-curve.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/closest-boundary-point/closest-points-on-curve.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/closest-boundary-point/cull-bezier-pieces.js":
/*!************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/closest-boundary-point/cull-bezier-pieces.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_best_distance_squared_1 = __webpack_require__(/*! ./get-best-distance-squared */ \"./node_modules/flo-mat/node/mat/closest-boundary-point/get-best-distance-squared.js\");\r\nconst cull_by_loose_bounding_box_1 = __webpack_require__(/*! ./cull-by-loose-bounding-box */ \"./node_modules/flo-mat/node/mat/closest-boundary-point/cull-by-loose-bounding-box.js\");\r\nconst cull_by_tight_boundary_box_1 = __webpack_require__(/*! ./cull-by-tight-boundary-box */ \"./node_modules/flo-mat/node/mat/closest-boundary-point/cull-by-tight-boundary-box.js\");\r\n/**\r\n *\r\n * @param bezierPieces\r\n * @param p\r\n * @param extreme\r\n */\r\nfunction cullBezierPieces(bezierPieces, p) {\r\n    const CULL_THRESHOLD = 0;\r\n    if (bezierPieces.length > CULL_THRESHOLD) {\r\n        let bestSquaredDistance = get_best_distance_squared_1.getBestDistanceSquared(bezierPieces, p);\r\n        bezierPieces = cull_by_loose_bounding_box_1.cullByLooseBoundingBox(bezierPieces, p, bestSquaredDistance);\r\n        bezierPieces = cull_by_tight_boundary_box_1.cullByTightBoundingBox(bezierPieces, p, bestSquaredDistance);\r\n    }\r\n    return bezierPieces;\r\n}\r\nexports.cullBezierPieces = cullBezierPieces;\r\n//# sourceMappingURL=cull-bezier-pieces.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/closest-boundary-point/cull-bezier-pieces.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/closest-boundary-point/cull-by-loose-bounding-box.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/closest-boundary-point/cull-by-loose-bounding-box.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst get_closest_square_distance_to_rect_1 = __webpack_require__(/*! ../geometry/get-closest-square-distance-to-rect */ \"./node_modules/flo-mat/node/mat/geometry/get-closest-square-distance-to-rect.js\");\r\n/**\r\n * When checking distances, ignore all those with closest possible distance\r\n * further than 'bestSquaredDistance', i.e. cull them.\r\n * @param bezierPieces\r\n * @param p\r\n * @param dSquared\r\n */\r\nfunction cullByLooseBoundingBox(bezierPieces, p, dSquared) {\r\n    let candidateBezierPieces = [];\r\n    for (let i = 0; i < bezierPieces.length; i++) {\r\n        let bezierPiece = bezierPieces[i];\r\n        let ps = bezierPiece.curve.ps;\r\n        let boundingBox = flo_bezier3_1.getBoundingBox(ps);\r\n        let d = get_closest_square_distance_to_rect_1.getClosestSquareDistanceToRect(boundingBox, p);\r\n        if (d <= dSquared) {\r\n            candidateBezierPieces.push(bezierPiece);\r\n        }\r\n    }\r\n    return candidateBezierPieces;\r\n}\r\nexports.cullByLooseBoundingBox = cullByLooseBoundingBox;\r\n//# sourceMappingURL=cull-by-loose-bounding-box.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/closest-boundary-point/cull-by-loose-bounding-box.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/closest-boundary-point/cull-by-tight-boundary-box.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/closest-boundary-point/cull-by-tight-boundary-box.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst get_closest_squared_distance_to_rotated_rect_1 = __webpack_require__(/*! ../geometry/get-closest-squared-distance-to-rotated-rect */ \"./node_modules/flo-mat/node/mat/geometry/get-closest-squared-distance-to-rotated-rect.js\");\r\n/**\r\n * When checking distances, ignore all those with closest possible distance\r\n * further than 'bestSquaredDistance', i.e. cull them.\r\n * @param bezierPieces\r\n * @param p\r\n * @param bestSquaredDistance\r\n */\r\nfunction cullByTightBoundingBox(bezierPieces, p, bestSquaredDistance) {\r\n    let candidateBezierPieces = [];\r\n    for (let i = 0; i < bezierPieces.length; i++) {\r\n        let bezierPiece = bezierPieces[i];\r\n        let ps = bezierPiece.curve.ps;\r\n        let tightBoundingBox = flo_bezier3_1.getBoundingBoxTight(ps);\r\n        let d = get_closest_squared_distance_to_rotated_rect_1.getClosestSquaredDistanceToRotatedRect(tightBoundingBox, p);\r\n        if (d <= bestSquaredDistance) {\r\n            candidateBezierPieces.push(bezierPiece);\r\n        }\r\n    }\r\n    return candidateBezierPieces;\r\n}\r\nexports.cullByTightBoundingBox = cullByTightBoundingBox;\r\n//# sourceMappingURL=cull-by-tight-boundary-box.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/closest-boundary-point/cull-by-tight-boundary-box.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/closest-boundary-point/get-best-distance-squared.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/closest-boundary-point/get-best-distance-squared.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\n/**\r\n * Finds an initial distance such that the closest point can not be further than\r\n * this distance away.\r\n */\r\nfunction getBestDistanceSquared(bezierPieces, p) {\r\n    let bestSquaredDistance = Number.POSITIVE_INFINITY;\r\n    for (let i = 0; i < bezierPieces.length; i++) {\r\n        let bezierPiece = bezierPieces[i];\r\n        let ps = bezierPiece.curve.ps;\r\n        let evPs = flo_bezier3_1.evaluate(ps);\r\n        let p1 = evPs(bezierPiece.ts[0]);\r\n        let p2 = evPs(bezierPiece.ts[1]);\r\n        let d = Math.min(flo_vector2d_1.squaredDistanceBetween(p, p1), flo_vector2d_1.squaredDistanceBetween(p, p2));\r\n        if (d < bestSquaredDistance) {\r\n            bestSquaredDistance = d;\r\n        }\r\n    }\r\n    // The extra multiplier is to account for floating point precision.\r\n    return bestSquaredDistance * 1.01;\r\n}\r\nexports.getBestDistanceSquared = getBestDistanceSquared;\r\n//# sourceMappingURL=get-best-distance-squared.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/closest-boundary-point/get-best-distance-squared.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/closest-boundary-point/get-close-boundary-points.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/closest-boundary-point/get-close-boundary-points.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nconst cull_bezier_pieces_1 = __webpack_require__(/*! ./cull-bezier-pieces */ \"./node_modules/flo-mat/node/mat/closest-boundary-point/cull-bezier-pieces.js\");\r\nconst closest_points_on_curve_1 = __webpack_require__(/*! ./closest-points-on-curve */ \"./node_modules/flo-mat/node/mat/closest-boundary-point/closest-points-on-curve.js\");\r\n/**\r\n * Returns the closest boundary point to the given point, limited to the given\r\n * bezier pieces, including the beziers actually checked after culling.\r\n * @param bezierPieces\r\n * @param point\r\n * @param touchedCurve\r\n * @param t\r\n * @param extreme\r\n */\r\nfunction getCloseBoundaryPoints(bezierPieces, point, y, distance) {\r\n    let touchedCurve = y.curve;\r\n    let t = y.t;\r\n    let p_ = y.p;\r\n    bezierPieces = cull_bezier_pieces_1.cullBezierPieces(bezierPieces, point);\r\n    // TODO - integrate with is-another-cp-closeby - we MUST check angle too!\r\n    let DISTANCE_TOLERANCE = 1e-9;\r\n    let posInfos = [];\r\n    for (let i = 0; i < bezierPieces.length; i++) {\r\n        let bezierPiece = bezierPieces[i];\r\n        // TOOD - important - should be able to return multiple points\r\n        let ps = closest_points_on_curve_1.closestPointsOnCurve(bezierPiece.curve, point, bezierPiece.ts, touchedCurve, t, distance, DISTANCE_TOLERANCE);\r\n        //if (ps === undefined) { continue; }\r\n        for (let j = 0; j < ps.length; j++) {\r\n            let p = ps[j];\r\n            let d = flo_vector2d_1.distanceBetween(p.p, point);\r\n            let curve = bezierPiece.curve;\r\n            let t_ = p.t;\r\n            if (Math.abs(d - distance) < DISTANCE_TOLERANCE) {\r\n                if (t_ === 0) {\r\n                    t_ = 1;\r\n                    curve = bezierPiece.curve.prev;\r\n                }\r\n                posInfos.push({ pos: new point_on_shape_1.PointOnShape(curve, t_), d });\r\n            }\r\n        }\r\n    }\r\n    if (posInfos.length > 1) {\r\n        // Remove ones that are too close together.\r\n        // TODO - in future remove all these checks and join n-prongs when they\r\n        // are being added - much simpler and more symmetric. Remeber order when\r\n        // comparing closeness!\r\n        let indexesToCheck = [];\r\n        for (let i = 0; i < posInfos.length; i++) {\r\n            let pi = posInfos[i];\r\n            // Only check if they are close to the edges. Why??\r\n            //if (pi.pos.t < 1e-2 || 1-pi.pos.t < 1e-2) {\r\n            indexesToCheck.push(i);\r\n            //}\r\n        }\r\n        let indexesToRemove = [];\r\n        for (let i = 0; i < indexesToCheck.length; i++) {\r\n            for (let j = i + 1; j < indexesToCheck.length; j++) {\r\n                if (i === j) {\r\n                    continue;\r\n                }\r\n                let p1 = posInfos[indexesToCheck[i]].pos.p;\r\n                let p2 = posInfos[indexesToCheck[j]].pos.p;\r\n                // Below checks for source point too - similar to \r\n                // isAnotherCpCloseBy\r\n                let p3 = p_;\r\n                if ((Math.abs(p1[0] - p2[0]) < 1e-6 &&\r\n                    Math.abs(p1[1] - p2[1]) < 1e-6) ||\r\n                    (Math.abs(p1[0] - p3[0]) < 1e-6 &&\r\n                        Math.abs(p1[1] - p3[1]) < 1e-6)) {\r\n                    //console.log(i);\r\n                    indexesToRemove.push(indexesToCheck[i]);\r\n                }\r\n            }\r\n        }\r\n        for (let i = indexesToRemove.length - 1; i >= 0; i--) {\r\n            posInfos.splice(indexesToRemove[i], 1);\r\n        }\r\n        /*\r\n        if (posInfos.length > 1) {\r\n            console.log(p_);\r\n            console.log(posInfos.map(pi => pi.d), posInfos.map(pi => pi.pos.p), posInfos.map(pi => pi.pos.t))\r\n            console.log('-------');\r\n        }*/\r\n    }\r\n    return posInfos;\r\n}\r\nexports.getCloseBoundaryPoints = getCloseBoundaryPoints;\r\n//# sourceMappingURL=get-close-boundary-points.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/closest-boundary-point/get-close-boundary-points.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/closest-boundary-point/get-closest-boundary-point.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/closest-boundary-point/get-closest-boundary-point.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nconst cull_bezier_pieces_1 = __webpack_require__(/*! ./cull-bezier-pieces */ \"./node_modules/flo-mat/node/mat/closest-boundary-point/cull-bezier-pieces.js\");\r\nconst closest_point_on_curve_1 = __webpack_require__(/*! ./closest-point-on-curve */ \"./node_modules/flo-mat/node/mat/closest-boundary-point/closest-point-on-curve.js\");\r\n/**\r\n * Returns the closest boundary point to the given point, limited to the given\r\n * bezier pieces, including the beziers actually checked after culling.\r\n * @param bezierPieces\r\n * @param point\r\n * @param touchedCurve\r\n * @param t\r\n * @param extreme\r\n */\r\nfunction getClosestBoundaryPoint(bezierPieces, point, touchedCurve, t) {\r\n    bezierPieces = cull_bezier_pieces_1.cullBezierPieces(bezierPieces, point);\r\n    let bestDistance = Number.POSITIVE_INFINITY;\r\n    let posInfo;\r\n    for (let i = 0; i < bezierPieces.length; i++) {\r\n        let bezierPiece = bezierPieces[i];\r\n        let p = closest_point_on_curve_1.closestPointOnCurve(bezierPiece.curve, point, bezierPiece.ts, touchedCurve, t);\r\n        if (p === undefined) {\r\n            continue;\r\n        }\r\n        let d = flo_vector2d_1.distanceBetween(p.p, point);\r\n        let curve = bezierPiece.curve;\r\n        let t_ = p.t;\r\n        if (d < bestDistance) {\r\n            if (t_ === 0) {\r\n                t_ = 1;\r\n                curve = bezierPiece.curve.prev;\r\n            }\r\n            posInfo = { pos: new point_on_shape_1.PointOnShape(curve, t_), d };\r\n            bestDistance = d;\r\n        }\r\n    }\r\n    return posInfo;\r\n}\r\nexports.getClosestBoundaryPoint = getClosestBoundaryPoint;\r\n//# sourceMappingURL=get-closest-boundary-point.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/closest-boundary-point/get-closest-boundary-point.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/create-new-cp-tree.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/create-new-cp-tree.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_ll_rb_tree_1 = __webpack_require__(/*! flo-ll-rb-tree */ \"./node_modules/flo-ll-rb-tree/node/index.js\");\r\nconst cp_node_1 = __webpack_require__(/*! ../cp-node/cp-node */ \"./node_modules/flo-mat/node/cp-node/cp-node.js\");\r\nfunction createNewCpTree(cpNode) {\r\n    let newCpTrees = new Map();\r\n    let cps = cpNode.getAllOnLoop();\r\n    cps.forEach(f);\r\n    function f(cpNode) {\r\n        let loop = cpNode.cp.pointOnShape.curve.loop;\r\n        let cpTree = newCpTrees.get(loop);\r\n        if (!cpTree) {\r\n            cpTree = new flo_ll_rb_tree_1.default(cp_node_1.CpNode.comparator, [], true);\r\n            newCpTrees.set(loop, cpTree);\r\n        }\r\n        cpTree.insert(cpNode);\r\n    }\r\n    return newCpTrees;\r\n}\r\nexports.createNewCpTree = createNewCpTree;\r\n//# sourceMappingURL=create-new-cp-tree.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/create-new-cp-tree.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/add-1-prong.js":
/*!***************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/add-1-prong.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nconst add_to_cp_graph_1 = __webpack_require__(/*! ../add-to-cp-graph */ \"./node_modules/flo-mat/node/mat/add-to-cp-graph.js\");\r\nconst is_another_cp_closeby_1 = __webpack_require__(/*! ../is-another-cp-closeby */ \"./node_modules/flo-mat/node/mat/is-another-cp-closeby.js\");\r\n/**\r\n * Add a 1-prong to the MAT.\r\n * @param cpGraphs\r\n * @param pos\r\n */\r\nfunction add1Prong(maxOsculatingCircleRadius, cpGraphs, pos) {\r\n    if (point_on_shape_1.PointOnShape.isDullCorner(pos)) {\r\n        // This is a 1-prong at a dull corner.\r\n        // TODO IMPORTANT \r\n        // Remove this line, uncomment piece below it and implement the \r\n        // following strategy to find the 3-prongs: if deltas are conjoined due \r\n        // to dull corner, split the conjoinment by inserting successively \r\n        // closer (binary division) 2-prongs. If a 2-prong actually fails, \r\n        // simply remove the 1-prong at the dull corner. In this way **all** \r\n        // terminal points are found, e.g. zoom in on top left leg of ant.\r\n        // Afterthought: there is a better way - split points by two prongs.\r\n        //toRemove.push(posNode); // this!\r\n        if (typeof _debug_ !== 'undefined') {\r\n            _debug_.generated.elems.oneProngAtDullCorner.push(pos);\r\n        }\r\n        return;\r\n    }\r\n    let circle = point_on_shape_1.PointOnShape.getOsculatingCircle(maxOsculatingCircleRadius, pos);\r\n    //console.log(maxOsculatingCircleRadius)\r\n    let order = point_on_shape_1.PointOnShape.calcOrder(circle, pos);\r\n    // Make sure there isn't already a ContactPoint close by - it can cause\r\n    // floating point stability issues.\r\n    if (is_another_cp_closeby_1.isAnotherCpCloseby(cpGraphs, pos, circle, order, 0, 1000, 'magenta')) {\r\n        return;\r\n    }\r\n    add_to_cp_graph_1.addToCpGraph(circle, [-0.5, +0.5], cpGraphs, [pos, pos]);\r\n    if (typeof _debug_ !== 'undefined') {\r\n        _debug_.generated.elems.oneProng.push(pos);\r\n    }\r\n}\r\nexports.add1Prong = add1Prong;\r\n//# sourceMappingURL=add-1-prong.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/add-1-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/add-2-prong.js":
/*!***************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/add-2-prong.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst cp_node_1 = __webpack_require__(/*! ../../cp-node/cp-node */ \"./node_modules/flo-mat/node/cp-node/cp-node.js\");\r\nconst contact_point_1 = __webpack_require__(/*! ../../contact-point */ \"./node_modules/flo-mat/node/contact-point.js\");\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nconst is_another_cp_closeby_1 = __webpack_require__(/*! ../is-another-cp-closeby */ \"./node_modules/flo-mat/node/mat/is-another-cp-closeby.js\");\r\nconst get_neighboring_cps_1 = __webpack_require__(/*! ../get-neighboring-cps */ \"./node_modules/flo-mat/node/mat/get-neighboring-cps.js\");\r\n/**\r\n * Adds a 2-prong contact circle to the shape.\r\n * @param cpGraphs\r\n * @param circle Circle containing the 2 contact points\r\n * @param posSource The source point on shape\r\n * @param posAntipode The found antipodal point on shape\r\n * @param holeClosing True if this is a hole-closing 2-prong, false otherwise\r\n * @param extreme The maximum coordinate value used to calculate floating point\r\n * tolerances.\r\n */\r\nfunction add2Prong(cpGraphs, circle, posSource, \r\n//posAntipode   : PointOnShape, \r\nposAntipodes, holeClosing, extreme) {\r\n    //console.log(circle.center[0], circle.center[1])\r\n    /*\r\n    if (posAntipodes.length > 1) {\r\n        console.log('>1')\r\n    }\r\n    */\r\n    /*\r\n    if (circle.center[0] === 241 && circle.center[1] === -342.0764118857498) {\r\n        return;\r\n    }\r\n    */\r\n    let orderSource = point_on_shape_1.PointOnShape.calcOrder(circle, posSource);\r\n    let orderAntipodes = posAntipodes.map(posAntipode => {\r\n        //console.log(circle.center)\r\n        return point_on_shape_1.PointOnShape.calcOrder(circle, posAntipode.pos);\r\n    });\r\n    let t_s = posSource.t;\r\n    let curve;\r\n    if (t_s === 0) {\r\n        t_s = 1;\r\n        curve = posSource.curve.prev;\r\n        posSource = new point_on_shape_1.PointOnShape(curve, t_s);\r\n    }\r\n    // Make sure there isn't already a ContactPoint close by - it can cause\r\n    // floating point stability issues.\r\n    // TODO - possibly combine n-prongs in this case\r\n    let isCloseByAntipodes = false;\r\n    for (let i = 0; i < posAntipodes.length; i++) {\r\n        let posAntipode = posAntipodes[i];\r\n        let orderAntipode = orderAntipodes[i];\r\n        if (is_another_cp_closeby_1.isAnotherCpCloseby(cpGraphs, posAntipode.pos, circle, orderAntipode, 0, extreme, 'red')) {\r\n            isCloseByAntipodes = true;\r\n            break;\r\n        }\r\n    }\r\n    if (is_another_cp_closeby_1.isAnotherCpCloseby(cpGraphs, posSource, circle, orderSource, 0, extreme, 'red') ||\r\n        isCloseByAntipodes) {\r\n        if (typeof _debug_ !== 'undefined') {\r\n            if (holeClosing) {\r\n                _debug_.generated.elems['twoProng_holeClosing'].pop();\r\n            }\r\n            else {\r\n                _debug_.generated.elems['twoProng_regular'].pop();\r\n            }\r\n        }\r\n        return;\r\n    }\r\n    // Antipode\r\n    let newCpAntipodes = [];\r\n    let cpAntipodes = [];\r\n    let cpTreeAntipodes = [];\r\n    let deltaAntipodes = [];\r\n    let loopAntipodes = [];\r\n    for (let i = 0; i < posAntipodes.length; i++) {\r\n        let posAntipode = posAntipodes[i];\r\n        let orderAntipode = orderAntipodes[i];\r\n        let cpAntipode = new contact_point_1.ContactPoint(posAntipode.pos, circle, orderAntipode, 0);\r\n        cpAntipodes.push(cpAntipode);\r\n        let loopAntipode = posAntipode.pos.curve.loop;\r\n        loopAntipodes.push(loopAntipode);\r\n        let cpTreeAntipode = cpGraphs.get(loopAntipode);\r\n        cpTreeAntipodes.push(cpTreeAntipode);\r\n        let deltaAntipode = get_neighboring_cps_1.getNeighbouringPoints(cpTreeAntipode, posAntipode.pos, orderAntipode, 0);\r\n        deltaAntipodes.push(deltaAntipode);\r\n        newCpAntipodes.push(cp_node_1.CpNode.insert(holeClosing, false, cpTreeAntipode, cpAntipode, deltaAntipode[0]));\r\n    }\r\n    //console.log(cpAntipode.pointOnShape.t);\r\n    // Source\r\n    let cpSource = new contact_point_1.ContactPoint(posSource, circle, orderSource, 0);\r\n    let loopSource = posSource.curve.loop;\r\n    let cpTreeSource = cpGraphs.get(loopSource);\r\n    let deltaSource = get_neighboring_cps_1.getNeighbouringPoints(cpTreeSource, posSource, orderSource, 0);\r\n    let newCpSource = cp_node_1.CpNode.insert(holeClosing, false, cpTreeSource, cpSource, deltaSource[0]);\r\n    //console.log(cpSource.pointOnShape.t);\r\n    // Connect graph\r\n    if (newCpAntipodes.length === 1) {\r\n        newCpSource.prevOnCircle = newCpAntipodes[0];\r\n        newCpSource.nextOnCircle = newCpAntipodes[0];\r\n        newCpAntipodes[0].prevOnCircle = newCpSource;\r\n        newCpAntipodes[0].nextOnCircle = newCpSource;\r\n    }\r\n    else {\r\n        let cpNodes = newCpAntipodes.slice();\r\n        cpNodes.push(newCpSource);\r\n        // This sometimes didn't work as it compares only according to it's own\r\n        // loop.\r\n        //cpNodes.sort(CpNode.comparator);\r\n        // Order points according to their angle with the x-axis\r\n        cpNodes.sort(byAngle(circle));\r\n        for (let i = 0; i < cpNodes.length; i++) {\r\n            let iNext = (i + 1 === cpNodes.length) ? 0 : i + 1;\r\n            let iPrev = (i === 0) ? cpNodes.length - 1 : i - 1;\r\n            let cpNodeCurr = cpNodes[i];\r\n            let cpNodeNext = cpNodes[iNext];\r\n            let cpNodePrev = cpNodes[iPrev];\r\n            cpNodeCurr.nextOnCircle = cpNodeNext;\r\n            cpNodeCurr.prevOnCircle = cpNodePrev;\r\n        }\r\n    }\r\n    if (holeClosing) {\r\n        // TODO - important - take care of case where there are more than 1 antipode\r\n        // Duplicate ContactPoints\r\n        let cpB2 = new contact_point_1.ContactPoint(posAntipodes[0].pos, circle, cpAntipodes[0].order, +1);\r\n        let newCpB2Node = cp_node_1.CpNode.insert(true, false, cpTreeAntipodes[0], cpB2, newCpAntipodes[0]);\r\n        let cpB1 = new contact_point_1.ContactPoint(posSource, circle, cpSource.order, -1);\r\n        let newCpB1Node = cp_node_1.CpNode.insert(true, false, cpTreeSource, cpB1, newCpSource.prev);\r\n        // Connect graph\r\n        newCpB1Node.prevOnCircle = newCpB2Node;\r\n        newCpB1Node.nextOnCircle = newCpB2Node;\r\n        newCpB2Node.prevOnCircle = newCpB1Node;\r\n        newCpB2Node.nextOnCircle = newCpB1Node;\r\n        newCpAntipodes[0].next = newCpSource;\r\n        newCpSource.prev = newCpAntipodes[0];\r\n        newCpB1Node.next = newCpB2Node;\r\n        newCpB2Node.prev = newCpB1Node;\r\n    }\r\n    if (typeof _debug_ !== 'undefined') {\r\n        let elems;\r\n        if (holeClosing) {\r\n            elems = _debug_.generated.elems['twoProng_holeClosing'];\r\n        }\r\n        else {\r\n            elems = _debug_.generated.elems['twoProng_regular'];\r\n        }\r\n        let elem = elems[elems.length - 1];\r\n        if (!newCpSource) {\r\n            console.log('asas');\r\n        }\r\n        elem.cpNode = newCpSource;\r\n    }\r\n    return newCpSource;\r\n}\r\nexports.add2Prong = add2Prong;\r\nfunction scale(n, exp) {\r\n    return n * (Math.pow(2, -(exp + 1)));\r\n}\r\nfunction getSize(x, y) {\r\n    // Get size of a\r\n    if (x > 0) {\r\n        if (x > 0.5) {\r\n            return y; // ~ -0.7 -> 0.7, i.e. -(sqrt(2)/2) -> +(sqrt(2)/2) \r\n        }\r\n        else {\r\n            if (y < 0) {\r\n                return x - 2; // ~ -2.0 -> -1.3\r\n            }\r\n            else {\r\n                return -x + 2; // ~ 1.3 -> 2.0\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        if (x < -0.5) {\r\n            return -y + 4; // ~ 3.3 -> 4.7\r\n        }\r\n        else {\r\n            if (y < 0) {\r\n                return x + 6; // ~ 5.3 -> 6.0\r\n            }\r\n            else {\r\n                return -x + 2; // ~ 2 -> 2.7\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction byAngle(circle) {\r\n    let c = circle.center;\r\n    let r = circle.radius;\r\n    let exp = flo_numerical_1.exponent(r);\r\n    return function (_a, _b) {\r\n        let a = _a.cp.pointOnShape.p;\r\n        let b = _b.cp.pointOnShape.p;\r\n        // Move onto origin\r\n        a = [a[0] - c[0], a[1] - c[1]];\r\n        b = [b[0] - c[0], b[1] - c[1]];\r\n        // Scale\r\n        let ax = scale(a[0], exp);\r\n        let ay = scale(a[1], exp);\r\n        let bx = scale(b[0], exp);\r\n        let by = scale(b[1], exp);\r\n        // Get 'size'\r\n        let sa = getSize(ax, ay);\r\n        let sb = getSize(bx, by);\r\n        return sb - sa;\r\n    };\r\n}\r\n//# sourceMappingURL=add-2-prong.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/add-2-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/add-3-prong.js":
/*!***************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/add-3-prong.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst add_to_cp_graph_1 = __webpack_require__(/*! ../add-to-cp-graph */ \"./node_modules/flo-mat/node/mat/add-to-cp-graph.js\");\r\nconst is_another_cp_closeby_1 = __webpack_require__(/*! ../is-another-cp-closeby */ \"./node_modules/flo-mat/node/mat/is-another-cp-closeby.js\");\r\n/**\r\n * Adds a 3-prong MAT circle according to the 3 given (previously calculated)\r\n * points on the shape.\r\n * @param cpTrees\r\n * @param orders\r\n * @param threeProng\r\n */\r\nfunction add3Prong(cpTrees, orders, threeProng) {\r\n    let { circle, ps: poss, δ3s } = threeProng;\r\n    // Keep for possible future debugging.\t\r\n    /*\r\n    if (typeof _debug_ !== 'undefined') {\r\n        for (let i=0; i<3; i++) {\r\n            let cpBef = threeProng.δ3s[i][0].cp;\r\n            let cpAft = threeProng.δ3s[i][1].cp;\r\n            //let cmpBef = PointOnShape.compareInclOrder(cpBef.pointOnShape, ps[i], cpBef.order, orders[i]);\r\n            //let cmpAft = PointOnShape.compareInclOrder(cpAft.pointOnShape, ps[i], cpAft.order, orders[i]);\r\n\r\n            let cmpBef = PointOnShape.compare(cpBef.pointOnShape, ps[i]);\r\n            let cmpAft = PointOnShape.compare(cpAft.pointOnShape, ps[i]);\r\n\r\n            // len is used by debug functions to reference a particular\r\n            // three-prong.\r\n            let len = _debug_.generated.elems.threeProng.length-1;\r\n            if (cmpBef > 0) {\r\n                console.log('----------------------------------------');\r\n                console.log(`3-prong order is wrong (bef) : i: ${i} - cmp: ${cmpBef} - n: ${len}`);\r\n                console.log(threeProng);\r\n                console.log(cpBef);\r\n                console.log(cpAft);\r\n                console.log(ps[i]);\r\n            }\r\n            if (cmpAft < 0) {\r\n                console.log('----------------------------------------');\r\n                console.log(`3-prong order is wrong (aft) : i: ${i} - cmp: ${cmpAft} - n: ${len}`);\r\n                console.log(threeProng);\r\n                console.log(cpBef);\r\n                console.log(cpAft);\r\n                console.log(ps[i]);\r\n            }\r\n        }\r\n    }\r\n    */\r\n    // TODO - replace 1000 below with correct value\r\n    is_another_cp_closeby_1.isAnotherCpCloseby(cpTrees, poss[0], circle, orders[0], 0, 1000, 'blue');\r\n    is_another_cp_closeby_1.isAnotherCpCloseby(cpTrees, poss[1], circle, orders[1], 0, 1000, 'blue');\r\n    is_another_cp_closeby_1.isAnotherCpCloseby(cpTrees, poss[2], circle, orders[2], 0, 1000, 'blue');\r\n    add_to_cp_graph_1.addToCpGraph(circle, orders, cpTrees, poss, δ3s);\r\n    return circle;\r\n}\r\nexports.add3Prong = add3Prong;\r\n//# sourceMappingURL=add-3-prong.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/add-3-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/add-debug-info.js":
/*!******************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/add-debug-info.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst curve_1 = __webpack_require__(/*! ../../curve */ \"./node_modules/flo-mat/node/curve.js\");\r\nfunction addDebugInfo1(loops) {\r\n    if (typeof _debug_ === 'undefined') {\r\n        return;\r\n    }\r\n    for (let loop of loops) {\r\n        _debug_.fs.nameObj(loop, 'l|');\r\n    }\r\n    let generated = _debug_.generated;\r\n    generated.timing.holeClosers[0] = performance.now();\r\n    generated.elems.loop.push(...loops);\r\n    generated.elems.loops.push(loops);\r\n    for (let loop of loops) {\r\n        let i = 0;\r\n        loop.curves.forEach(function (curve) {\r\n            let ps = curve.ps;\r\n            let hull = flo_bezier3_1.getBoundingHull(ps);\r\n            generated.elems.boundingHull.push(hull);\r\n            let looseBoundingBox = flo_bezier3_1.getBoundingBox(ps);\r\n            generated.elems.looseBoundingBox.push(looseBoundingBox);\r\n            let tightBoundingBox = flo_bezier3_1.getBoundingBoxTight(ps);\r\n            generated.elems.tightBoundingBox.push(tightBoundingBox);\r\n            /*\r\n            if (PointOnShape.isSharpCorner(pos)) {\r\n                generated.elems.sharpCorner.push(pos);\r\n            } else if (PointOnShape.isDullCorner(pos)) {\r\n                generated.elems.dullCorner.push(pos);\r\n            }\r\n            */\r\n            let corner = curve_1.Curve.getCornerAtEnd(curve);\r\n            if (corner.isSharp) {\r\n                generated.elems.sharpCorner.push(curve);\r\n            }\r\n            else if (corner.isDull) {\r\n                generated.elems.dullCorner.push(curve);\r\n            }\r\n            i++;\r\n        });\r\n    }\r\n}\r\nexports.addDebugInfo1 = addDebugInfo1;\r\nfunction addDebugInfo2(pointOnShapeArrPerLoop) {\r\n    if (typeof _debug_ === 'undefined') {\r\n        return;\r\n    }\r\n    let generated = _debug_.generated;\r\n    let timing = generated.timing;\r\n    let now = performance.now();\r\n    timing.holeClosers[1] += now - timing.holeClosers[0];\r\n    timing.oneAnd2Prongs[0] = now;\r\n    /*\r\n    for (let pointsOnShape of pointOnShapeArrPerLoop) {\r\n        for (let pos of pointsOnShape) {\r\n            if (PointOnShape.isSharpCorner(pos)) {\r\n                generated.elems.sharpCorner.push(pos);\r\n            } else if (PointOnShape.isDullCorner(pos)) {\r\n                generated.elems.dullCorner.push(pos);\r\n            }\r\n        }\r\n    }\r\n    */\r\n}\r\nexports.addDebugInfo2 = addDebugInfo2;\r\nfunction addDebugInfo3() {\r\n    if (typeof _debug_ === 'undefined') {\r\n        return;\r\n    }\r\n    let generated = _debug_.generated;\r\n    let timing = generated.timing;\r\n    let now = performance.now();\r\n    timing.oneAnd2Prongs[1] += now - timing.oneAnd2Prongs[0];\r\n    timing.threeProngs[0] = now;\r\n}\r\nexports.addDebugInfo3 = addDebugInfo3;\r\nfunction addDebugInfo4(mat) {\r\n    if (typeof _debug_ === 'undefined') {\r\n        return;\r\n    }\r\n    let generated = _debug_.generated;\r\n    let timing = generated.timing;\r\n    generated.elems.mat.push(mat);\r\n    timing.threeProngs[1] += performance.now() - timing.threeProngs[0];\r\n    timing.mats[1] =\r\n        timing.holeClosers[1] +\r\n            timing.oneAnd2Prongs[1] +\r\n            timing.threeProngs[1];\r\n}\r\nexports.addDebugInfo4 = addDebugInfo4;\r\n//# sourceMappingURL=add-debug-info.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/add-debug-info.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/create-get-interesting-points-on-loop.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/create-get-interesting-points-on-loop.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_contact_circles_at_interface_1 = __webpack_require__(/*! ../get-contact-circles-at-interface */ \"./node_modules/flo-mat/node/mat/get-contact-circles-at-interface.js\");\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\n/**\r\n * Get useful points on the shape - these incude points of maximum curvature and\r\n * points at the bezier-bezier interfaces.\r\n * @param loop\r\n * @param additionalPointCount\r\n */\r\nfunction createGetInterestingPointsOnLoop(additionalPointCount = 3) {\r\n    return function (loop) {\r\n        let allPoints = [];\r\n        for (let i = 0; i < loop.curves.length; i++) {\r\n            let curve = loop.curves[i];\r\n            let { maxCurvatureTs, maxNegativeCurvatureTs } = flo_bezier3_1.getCurvatureExtrema(curve.ps);\r\n            let maxCurvatures = maxCurvatureTs.map(t => new point_on_shape_1.PointOnShape(curve, t));\r\n            let maxNegativeCurvatures = maxNegativeCurvatureTs.map(t => new point_on_shape_1.PointOnShape(curve, t));\r\n            allPoints.push(...get_contact_circles_at_interface_1.getContactCirclesAtInterface(curve), ...maxCurvatures, ...maxNegativeCurvatures);\r\n            //let ts = splitByMaxCurveLength(curve.ps, 50);\r\n            //let ts = splitByMaxCurvature(curve.ps, 1.01);\r\n            let ts = flo_bezier3_1.splitByCurvatureAndLength(curve.ps, 1.001, 10);\r\n            if (ts.length === 2) {\r\n                ts = [0, 0.5, 1];\r\n            }\r\n            for (let i = 1; i < ts.length - 1; i++) {\r\n                allPoints.push(new point_on_shape_1.PointOnShape(curve, ts[i]));\r\n            }\r\n        }\r\n        allPoints.sort(point_on_shape_1.PointOnShape.compare);\r\n        return allPoints;\r\n    };\r\n}\r\nexports.createGetInterestingPointsOnLoop = createGetInterestingPointsOnLoop;\r\n//# sourceMappingURL=create-get-interesting-points-on-loop.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/create-get-interesting-points-on-loop.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/create-initial-cp-graph.js":
/*!***************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/create-initial-cp-graph.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_ll_rb_tree_1 = __webpack_require__(/*! flo-ll-rb-tree */ \"./node_modules/flo-ll-rb-tree/node/index.js\");\r\nconst circle_1 = __webpack_require__(/*! ../../circle */ \"./node_modules/flo-mat/node/circle.js\");\r\nconst cp_node_1 = __webpack_require__(/*! ../../cp-node/cp-node */ \"./node_modules/flo-mat/node/cp-node/cp-node.js\");\r\nconst contact_point_1 = __webpack_require__(/*! ../../contact-point */ \"./node_modules/flo-mat/node/contact-point.js\");\r\n/**\r\n * Creates the initial ContactPoint loops from the given sharp corners.\r\n * @param shape\r\n * @param sharpCornerss\r\n */\r\nfunction createInitialCpGraph(loops, cpTrees, sharpCornerss, xMap) {\r\n    let cpNode;\r\n    for (let k = 0; k < sharpCornerss.length; k++) {\r\n        let sharpCorners = sharpCornerss[k];\r\n        let cpTree = new flo_ll_rb_tree_1.default(cp_node_1.CpNode.comparator, [], true);\r\n        let cpNode1 = undefined;\r\n        let cpNode2 = undefined;\r\n        for (let pos of sharpCorners) {\r\n            let ps = pos.curve.next.ps;\r\n            let x = xMap.get(ps);\r\n            let isIntersection = !!x;\r\n            let circle = new circle_1.Circle(pos.p, 0);\r\n            let cp1 = new contact_point_1.ContactPoint(pos, circle, -1, 0);\r\n            let cp2 = new contact_point_1.ContactPoint(pos, circle, +1, 0);\r\n            cpNode1 = cp_node_1.CpNode.insert(false, isIntersection, cpTree, cp1, cpNode2);\r\n            cpNode2 = cp_node_1.CpNode.insert(false, isIntersection, cpTree, cp2, cpNode1);\r\n            cpNode1.prevOnCircle = cpNode2;\r\n            cpNode2.prevOnCircle = cpNode1;\r\n            cpNode1.nextOnCircle = cpNode2;\r\n            cpNode2.nextOnCircle = cpNode1;\r\n        }\r\n        if (!cpNode) {\r\n            cpNode = cpNode1;\r\n        }\r\n        let loop = loops[k];\r\n        cpTrees.set(loop, cpTree);\r\n    }\r\n    return cpNode;\r\n}\r\nexports.createInitialCpGraph = createInitialCpGraph;\r\n//# sourceMappingURL=create-initial-cp-graph.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/create-initial-cp-graph.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/find-2-prong/add-debug-info.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/find-2-prong/add-debug-info.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst two_prong_for_debugging_1 = __webpack_require__(/*! ../../../debug/two-prong-for-debugging */ \"./node_modules/flo-mat/node/debug/two-prong-for-debugging.js\");\r\nconst get_two_prong_type_1 = __webpack_require__(/*! ../../get-two-prong-type */ \"./node_modules/flo-mat/node/mat/get-two-prong-type.js\");\r\nfunction addDebugInfo(bezierPieces, failed, pos, circle, z, δ, xs, holeClosing) {\r\n    let twoProng = new two_prong_for_debugging_1.TwoProngForDebugging(_debug_.generated, bezierPieces, pos, δ, z ? z.p : undefined, circle, xs, failed, holeClosing, false, false);\r\n    let twoProngType = get_two_prong_type_1.getTwoProngType(twoProng);\r\n    _debug_.generated.elems[twoProngType].push(twoProng);\r\n}\r\nexports.addDebugInfo = addDebugInfo;\r\n//# sourceMappingURL=add-debug-info.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/find-2-prong/add-debug-info.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/find-2-prong/cull-bezier-pieces.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/find-2-prong/cull-bezier-pieces.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst get_closest_square_distance_to_rect_1 = __webpack_require__(/*! ../../geometry/get-closest-square-distance-to-rect */ \"./node_modules/flo-mat/node/mat/geometry/get-closest-square-distance-to-rect.js\");\r\n/**\r\n * Cull all bezierPieces not within given radius of a given point.\r\n * @param extreme\r\n * @param bezierPieces\r\n * @param p\r\n * @param rSquared\r\n */\r\nfunction cullBezierPieces(bezierPieces, p, rSquared) {\r\n    const CULL_THRESHOLD = 5;\r\n    const TOLERANCE = 1 + 1e-3;\r\n    if (bezierPieces.length <= CULL_THRESHOLD) {\r\n        return bezierPieces;\r\n    }\r\n    let newPieces = [];\r\n    for (let bezierPiece of bezierPieces) {\r\n        let ps = bezierPiece.curve.ps;\r\n        let rect = flo_bezier3_1.getBoundingBox(ps);\r\n        let bd = get_closest_square_distance_to_rect_1.getClosestSquareDistanceToRect(rect, p);\r\n        if (bd <= rSquared * TOLERANCE) {\r\n            newPieces.push(bezierPiece);\r\n        }\r\n    }\r\n    return newPieces;\r\n}\r\nexports.cullBezierPieces = cullBezierPieces;\r\n//# sourceMappingURL=cull-bezier-pieces.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/find-2-prong/cull-bezier-pieces.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/find-2-prong/find-2-prong.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/find-2-prong/find-2-prong.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst line_line_intersection_1 = __webpack_require__(/*! ../../geometry/line-line-intersection */ \"./node_modules/flo-mat/node/mat/geometry/line-line-intersection.js\");\r\nconst get_closest_boundary_point_1 = __webpack_require__(/*! ../../closest-boundary-point/get-closest-boundary-point */ \"./node_modules/flo-mat/node/mat/closest-boundary-point/get-closest-boundary-point.js\");\r\nconst circle_1 = __webpack_require__(/*! ../../../circle */ \"./node_modules/flo-mat/node/circle.js\");\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nconst add_1_prong_1 = __webpack_require__(/*! ../add-1-prong */ \"./node_modules/flo-mat/node/mat/find-mat/add-1-prong.js\");\r\nconst add_debug_info_1 = __webpack_require__(/*! ./add-debug-info */ \"./node_modules/flo-mat/node/mat/find-mat/find-2-prong/add-debug-info.js\");\r\nconst cull_bezier_pieces_1 = __webpack_require__(/*! ./cull-bezier-pieces */ \"./node_modules/flo-mat/node/mat/find-mat/find-2-prong/cull-bezier-pieces.js\");\r\nconst find_equidistant_point_on_line_1 = __webpack_require__(/*! ./find-equidistant-point-on-line */ \"./node_modules/flo-mat/node/mat/find-mat/find-2-prong/find-equidistant-point-on-line.js\");\r\nconst get_initial_bezier_pieces_1 = __webpack_require__(/*! ./get-initial-bezier-pieces */ \"./node_modules/flo-mat/node/mat/find-mat/find-2-prong/get-initial-bezier-pieces.js\");\r\nconst get_close_boundary_points_1 = __webpack_require__(/*! ../../closest-boundary-point/get-close-boundary-points */ \"./node_modules/flo-mat/node/mat/closest-boundary-point/get-close-boundary-points.js\");\r\n/**\r\n * Adds a 2-prong to the MAT. The first point on the shape boundary is given and\r\n * the second one is found by the algorithm.\r\n *\r\n * A 2-prong is defined as a MAT circle that touches the shape at exactly 2\r\n * points.\r\n *\r\n * Before any 2-prongs are added the entire shape is our δΩ (1-prongs do not\r\n * reduce the boundary).\r\n *\r\n * As per the paper by Choi, Choi, Moon and Wee:\r\n *   \"The starting point of this algorithm is a choice of a circle Br(x)\r\n *    centered at an interior point x which contains two boundary portions c and\r\n *    d of dΩ as in Fig. 19.\"\r\n * In fact, we (and they) start by fixing one point on the boundary beforehand.\r\n * @param loops A shape represented by path loops\r\n * @param extreme The extreme coordinate value of the shape\r\n * @param squaredDiagonalLength The squared diagonal length of the shape\r\n * bounding box.\r\n * @param y The source point of the 2-prong to be found\r\n * @param isHoleClosing True if this is a hole-closing two-prong, false otherwise\r\n * @param k The loop array index\r\n */\r\nfunction find2Prong(loops, extreme, squaredDiagonalLength, cpTrees, y, isHoleClosing, k) {\r\n    const MAX_ITERATIONS = 25;\r\n    const squaredSeperationTolerance = Math.pow((1e-6 * extreme), 2);\r\n    //const oneProngTolerance = 1+1e-4;\r\n    const oneProngTolerance = Math.pow((1e-4), 2);\r\n    const squaredErrorTolerance = 1e-2 * squaredSeperationTolerance;\r\n    const maxOsculatingCircleRadiusSquared = squaredDiagonalLength;\r\n    // The boundary piece that should contain the other point of \r\n    // the 2-prong circle. (Defined by start and end points).\r\n    let { bezierPieces, δ } = get_initial_bezier_pieces_1.getInitialBezierPieces(isHoleClosing, k, loops, cpTrees, y);\r\n    /** The center of the two-prong (successively refined) */\r\n    let x;\r\n    let p;\r\n    let r;\r\n    if (isHoleClosing) {\r\n        p = [y.p[0], y.p[1]];\r\n        x = [p[0], p[1] - Math.sqrt(maxOsculatingCircleRadiusSquared)];\r\n        r = maxOsculatingCircleRadiusSquared;\r\n    }\r\n    else {\r\n        p = y.p;\r\n        x = point_on_shape_1.PointOnShape.getOsculatingCircle(maxOsculatingCircleRadiusSquared, y).center;\r\n        r = flo_vector2d_1.squaredDistanceBetween(p, x);\r\n    }\r\n    // The lines below is an optimization.\r\n    let r_ = reduceRadius(extreme, bezierPieces, p, x);\r\n    if (r > r_) {\r\n        x = flo_vector2d_1.interpolate(p, x, Math.sqrt(r_ / r));\r\n    }\r\n    let xs = []; // Trace the convergence (for debugging).\r\n    let z; // The antipode if the two-prong (successively refined)\r\n    let i = 0;\r\n    let done = 0;\r\n    let failed = false; // The failed flag is set if a 2-prong cannot be found.\r\n    let bezierPieces_ = bezierPieces;\r\n    do {\r\n        i++;\r\n        let r = flo_vector2d_1.squaredDistanceBetween(x, y.p);\r\n        bezierPieces_ = cull_bezier_pieces_1.cullBezierPieces(bezierPieces_, x, r);\r\n        z = get_closest_boundary_point_1.getClosestBoundaryPoint(bezierPieces_, x, y.curve, y.t);\r\n        if (z === undefined) {\r\n            if (typeof _debug_ !== 'undefined') {\r\n                let elems = _debug_.generated.elems;\r\n                let elem = isHoleClosing\r\n                    ? elems.twoProng_holeClosing\r\n                    : elems.twoProng_regular;\r\n                let elemStr = isHoleClosing\r\n                    ? 'hole-closing: ' + elem.length\r\n                    : 'regular: ' + elem.length;\r\n                console.log('failed: no closest point - ' + elemStr);\r\n            }\r\n            failed = true;\r\n            break;\r\n        }\r\n        if (typeof _debug_ !== 'undefined') {\r\n            xs.push({ x, y, z: z.pos, t: y.t });\r\n        }\r\n        let d = flo_vector2d_1.squaredDistanceBetween(x, z.pos.p);\r\n        //if (i === 1 && d*oneProngTolerance >= r) {\r\n        if (i === 1 && r < d + oneProngTolerance) {\r\n            // It is a 1-prong.\r\n            add_1_prong_1.add1Prong(Math.sqrt(maxOsculatingCircleRadiusSquared), cpTrees, y);\r\n            return undefined;\r\n        }\r\n        // TODO - squaredSeperationTolerance should in future be replaced with\r\n        // a relative error, i.e. distance between y (or z) / length(y (or z)).\r\n        if (!isHoleClosing && flo_vector2d_1.squaredDistanceBetween(y.p, z.pos.p) <= squaredSeperationTolerance) {\r\n            if (typeof _debug_ !== 'undefined') {\r\n                let elems = _debug_.generated.elems;\r\n                let elem = isHoleClosing\r\n                    ? elems.twoProng_holeClosing\r\n                    : elems.twoProng_regular;\r\n                let elemStr = isHoleClosing\r\n                    ? 'hole-closing: ' + elem.length\r\n                    : 'regular: ' + elem.length;\r\n                /*\r\n                console.log(\r\n                    'failed: two-prong radius too small - ' + elemStr\r\n                );\r\n                */\r\n            }\r\n            failed = true;\r\n            break;\r\n        }\r\n        // TODO - Accuracy optimization: tolerance should not be between x and \r\n        // nextX, but rather (distance from x to y) - (distance from x to z)\r\n        // Find the point on the line connecting y with x that is  \r\n        // equidistant from y and z. This will be our next x.\r\n        let nextX = find_equidistant_point_on_line_1.findEquidistantPointOnLine(x, y.p, z.pos.p);\r\n        let squaredError = flo_vector2d_1.squaredDistanceBetween(x, nextX);\r\n        x = nextX;\r\n        if (squaredError < squaredErrorTolerance) {\r\n            //console.log(Math.sqrt(squaredError));\r\n            done++; // Do one more iteration\r\n        }\r\n        else if (i === MAX_ITERATIONS) {\r\n            // Convergence was too slow.\r\n            failed = true;\r\n            break; // We're done\r\n        }\r\n    } while (done < 1);\r\n    // TODO - Optimization: only do this if second closest point is within the\r\n    // tolerance which can be checked in getClosestBoundaryPoint algorithm\r\n    let zs = [];\r\n    if (!failed) {\r\n        zs = get_close_boundary_points_1.getCloseBoundaryPoints(bezierPieces_, x, y, flo_vector2d_1.distanceBetween(x, z.pos.p));\r\n        //if (point[0] === 228 && point[1] === -308) {\r\n        //if (zs.length > 1) { console.log(zs); }\r\n        if (!zs.length) {\r\n            //console.log(zs);\r\n            // Numerical issue\r\n            zs.push(z);\r\n        }\r\n        //zs = [z];\r\n    }\r\n    let circle;\r\n    if (z !== undefined) {\r\n        circle = new circle_1.Circle(x, flo_vector2d_1.distanceBetween(x, z.pos.p));\r\n    }\r\n    if (typeof _debug_ !== 'undefined' && !failed) {\r\n        xs.push({ x, y, z: z.pos, t: y.t });\r\n        add_debug_info_1.addDebugInfo(bezierPieces, failed, y, circle, z.pos, δ, xs, isHoleClosing);\r\n    }\r\n    return failed ? undefined : { circle, zs };\r\n    //return failed ? undefined : { circle, z: z.pos };\r\n}\r\nexports.find2Prong = find2Prong;\r\n/**\r\n * Reduces the circle radius initially as an optimization step.\r\n */\r\nfunction reduceRadius(extreme, bezierPieces, p, x) {\r\n    const TOLERANCE = extreme * 1e-3;\r\n    let prevP = undefined;\r\n    let minRadius = Number.POSITIVE_INFINITY;\r\n    for (let i = 0; i < bezierPieces.length; i++) {\r\n        let bezierPiece = bezierPieces[i];\r\n        let ps = bezierPiece.curve.ps;\r\n        let ev = flo_bezier3_1.evaluate(ps);\r\n        let p1 = ev(bezierPiece.ts[0]);\r\n        let r1 = Number.POSITIVE_INFINITY;\r\n        // Prevent evaluating the same points twice\r\n        if (!prevP || prevP[0] !== p1[0] || prevP[1] !== p1[1]) {\r\n            let cc1 = getCircleCenterFrom2PointsAndNormal(extreme, p, x, p1);\r\n            if (cc1) {\r\n                r1 = flo_vector2d_1.squaredDistanceBetween(p, cc1);\r\n            }\r\n        }\r\n        let r2 = Number.POSITIVE_INFINITY;\r\n        let p2 = ev(bezierPiece.ts[1]);\r\n        let cc2 = getCircleCenterFrom2PointsAndNormal(extreme, p, x, p2);\r\n        if (cc2) {\r\n            r2 = flo_vector2d_1.squaredDistanceBetween(p, cc2);\r\n        }\r\n        prevP = p2;\r\n        let d = Math.min(r1, r2);\r\n        if (d < minRadius) {\r\n            minRadius = d;\r\n        }\r\n    }\r\n    // The extra bit is to account for floating point precision.\r\n    return minRadius + TOLERANCE;\r\n}\r\n/**\r\n *\r\n * @param p A point on the circle with normal pointing to x towards the center\r\n * of the circle.\r\n * @param x\r\n * @param p1 Another point on the circle.\r\n */\r\nfunction getCircleCenterFrom2PointsAndNormal(extreme, p, x, p1) {\r\n    let TOLERANCE = Math.pow((1e-4 * extreme), 2);\r\n    // Ignore if p and p1 are too close together\r\n    if (flo_vector2d_1.squaredDistanceBetween(p, p1) < TOLERANCE) {\r\n        return undefined;\r\n    }\r\n    /** The perpindicular bisector between the two given points on the circle */\r\n    let pb = [\r\n        (p[0] + p1[0]) / 2,\r\n        (p[1] + p1[1]) / 2,\r\n    ];\r\n    let tangent = [p1[0] - p[0], p1[1] - p[1]];\r\n    let normal = [-tangent[1], tangent[0]]; // Rotate by 90 degrees\r\n    let pb2 = [pb[0] + normal[0], pb[1] + normal[1]];\r\n    let res = line_line_intersection_1.lineLineIntersection([p, x], [pb, pb2]);\r\n    if (!res) {\r\n        return undefined;\r\n    }\r\n    let resO = [res[0] - p[0], res[1] - p[1]];\r\n    let xO = [x[0] - p[0], x[1] - p[1]];\r\n    if (flo_vector2d_1.dot(resO, xO) < 0) {\r\n        return undefined;\r\n    }\r\n    return res;\r\n}\r\n//# sourceMappingURL=find-2-prong.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/find-2-prong/find-2-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/find-2-prong/find-equidistant-point-on-line.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/find-2-prong/find-equidistant-point-on-line.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n *\r\n * @param x\r\n * @param y\r\n * @param z\r\n * @returns The point on the line from y to x that is equidistant from y and z.\r\n */\r\nfunction findEquidistantPointOnLine(x, y, z) {\r\n    // Some basic algebra (not shown) finds the required point.\r\n    // Swap axes if x and y are more aligned to y-axis than to x-axis.\r\n    let swapAxes = Math.abs((x[1] - y[1]) / (x[0] - y[0])) > 1;\r\n    // Cache\r\n    let x1, x2, y1, y2, z1, z2;\r\n    if (swapAxes) {\r\n        x1 = x[1];\r\n        x2 = x[0];\r\n        y1 = y[1];\r\n        y2 = y[0];\r\n        z1 = z[1];\r\n        z2 = z[0];\r\n    }\r\n    else {\r\n        x1 = x[0];\r\n        x2 = x[1];\r\n        y1 = y[0];\r\n        y2 = y[1];\r\n        z1 = z[0];\r\n        z2 = z[1];\r\n    }\r\n    // a <= 1 (due to swapped axes)\r\n    let a = (x2 - y2) / (x1 - y1);\r\n    let b = y2 - a * y1;\r\n    let c = (y1 * y1 + y2 * y2 - z1 * z1 - z2 * z2) + 2 * b * (z2 - y2);\r\n    let d = y1 - z1 + a * (y2 - z2);\r\n    let t1 = c / (2 * d);\r\n    let t2 = a * t1 + b;\r\n    return swapAxes ? [t2, t1] : [t1, t2];\r\n}\r\nexports.findEquidistantPointOnLine = findEquidistantPointOnLine;\r\n//# sourceMappingURL=find-equidistant-point-on-line.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/find-2-prong/find-equidistant-point-on-line.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/find-2-prong/get-initial-bezier-pieces.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/find-2-prong/get-initial-bezier-pieces.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_neighboring_cps_1 = __webpack_require__(/*! ../../get-neighboring-cps */ \"./node_modules/flo-mat/node/mat/get-neighboring-cps.js\");\r\nconst get_boundary_piece_beziers_1 = __webpack_require__(/*! ../../get-boundary-piece-beziers */ \"./node_modules/flo-mat/node/mat/get-boundary-piece-beziers.js\");\r\nconst bezier_piece_1 = __webpack_require__(/*! ../../../bezier-piece */ \"./node_modules/flo-mat/node/bezier-piece.js\");\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nfunction getInitialBezierPieces(isHoleClosing, k, loops, cpTrees, y) {\r\n    let bezierPieces;\r\n    let δ;\r\n    if (isHoleClosing) {\r\n        bezierPieces = [];\r\n        for (let k2 = 0; k2 < k; k2++) {\r\n            let pieces = loops[k2].curves\r\n                .map(curve => new bezier_piece_1.BezierPiece(curve, [0, 1]));\r\n            bezierPieces.push(...pieces);\r\n        }\r\n    }\r\n    else {\r\n        //aaa y.curve\r\n        let order = point_on_shape_1.PointOnShape.isDullCorner(y)\r\n            ? y.t === 1 ? -1 : +1\r\n            : 0;\r\n        let loop = loops[k];\r\n        let cpNode = get_neighboring_cps_1.getNeighbouringPoints(cpTrees.get(loop), y, order, 0)[0];\r\n        δ = [cpNode, cpNode];\r\n        if (!cpNode ||\r\n            // The special case if there is only a single sharp corner or \r\n            // terminating 2-prong currently in the MAT. Don't remove!\r\n            (cpNode === cpNode.next.next)) {\r\n            bezierPieces = loop.curves\r\n                .map(curve => new bezier_piece_1.BezierPiece(curve, [0, 1]));\r\n        }\r\n        else {\r\n            bezierPieces = get_boundary_piece_beziers_1.getBoundaryPieceBeziers(δ);\r\n        }\r\n    }\r\n    return { bezierPieces, δ };\r\n}\r\nexports.getInitialBezierPieces = getInitialBezierPieces;\r\n//# sourceMappingURL=get-initial-bezier-pieces.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/find-2-prong/get-initial-bezier-pieces.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/find-3-prong/calc-better-x.js":
/*!******************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/find-3-prong/calc-better-x.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst get_closest_points_1 = __webpack_require__(/*! ./get-closest-points */ \"./node_modules/flo-mat/node/mat/find-mat/find-3-prong/get-closest-points.js\");\r\n/**\r\n * Find new x and ps that are a better estimate of the 3-prong circle.\r\n * The potential function, V, is defined as the distance to the actual 3 prong\r\n * circle center.\r\n * @param bezierPiece3s The three boundary pieces, each of which should contain\r\n * a point of the 3-prong to be found.\r\n * @param x The currently best guess at the center of the 3-prong circle.\r\n * @param vectorToZeroV\r\n * @param extreme\r\n */\r\nfunction calcBetterX(bezierPiece3s, x, vectorToZeroV) {\r\n    let V = flo_vector2d_1.len(vectorToZeroV);\r\n    let nu = 1;\r\n    let better;\r\n    let newX;\r\n    let newPs;\r\n    let newV;\r\n    let i = 0; // Safeguard\r\n    do {\r\n        let shift = flo_vector2d_1.scale(vectorToZeroV, nu);\r\n        newX = flo_vector2d_1.translate(shift, x);\r\n        newPs = get_closest_points_1.getClosestPoints(newX, bezierPiece3s);\r\n        //console.log(newPs.map(pos => '' + pos.p[0] + ' ' + pos.p[1]))\r\n        // Point of zero V\r\n        let newCircleCenter = flo_vector2d_1.circumCenter(newPs.map(pos => pos.p));\r\n        let newVectorToZeroV = flo_vector2d_1.fromTo(newX, newCircleCenter);\r\n        newV = flo_vector2d_1.len(newVectorToZeroV);\r\n        better = newV < V;\r\n        nu = nu / 2;\r\n        i++;\r\n    } while (!better && i < 3);\r\n    return { newX, newV, newPs };\r\n}\r\nexports.calcBetterX = calcBetterX;\r\n//# sourceMappingURL=calc-better-x.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/find-3-prong/calc-better-x.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/find-3-prong/calc-initial-3-prong-center.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/find-3-prong/calc-initial-3-prong-center.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst get_closest_boundary_point_1 = __webpack_require__(/*! ../../closest-boundary-point/get-closest-boundary-point */ \"./node_modules/flo-mat/node/mat/closest-boundary-point/get-closest-boundary-point.js\");\r\n/**\r\n * Finds an initial 3-prong circle center point from which to iterate. The point\r\n * must be within the shape.\r\n * @param δ3s - The three boundary pieces of which we need to find the three\r\n * 3-prong points.\r\n * @param bezierPiece3s\r\n * @param extreme\r\n */\r\nfunction calcInitial3ProngCenter(δ3s, bezierPiece3s) {\r\n    let twoProngCircleCenter = δ3s[0][0].cp.circle.center;\r\n    let posInfo = get_closest_boundary_point_1.getClosestBoundaryPoint(bezierPiece3s[1], twoProngCircleCenter, undefined, // curve\r\n    undefined // t\r\n    );\r\n    let meanPoints = [\r\n        δ3s[0][0].cp.pointOnShape.p,\r\n        posInfo.pos.p,\r\n        δ3s[2][1].cp.pointOnShape.p,\r\n    ];\r\n    return flo_vector2d_1.circumCenter(meanPoints);\r\n}\r\nexports.calcInitial3ProngCenter = calcInitial3ProngCenter;\r\n//# sourceMappingURL=calc-initial-3-prong-center.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/find-3-prong/calc-initial-3-prong-center.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/find-3-prong/find-3-prong-for-delta3s.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/find-3-prong/find-3-prong-for-delta3s.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst circle_1 = __webpack_require__(/*! ../../../circle */ \"./node_modules/flo-mat/node/circle.js\");\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nconst get_closest_boundary_point_1 = __webpack_require__(/*! ../../closest-boundary-point/get-closest-boundary-point */ \"./node_modules/flo-mat/node/mat/closest-boundary-point/get-closest-boundary-point.js\");\r\nconst calc_initial_3_prong_center_1 = __webpack_require__(/*! ./calc-initial-3-prong-center */ \"./node_modules/flo-mat/node/mat/find-mat/find-3-prong/calc-initial-3-prong-center.js\");\r\nconst get_closest_points_1 = __webpack_require__(/*! ./get-closest-points */ \"./node_modules/flo-mat/node/mat/find-mat/find-3-prong/get-closest-points.js\");\r\nconst calc_better_x_1 = __webpack_require__(/*! ./calc-better-x */ \"./node_modules/flo-mat/node/mat/find-mat/find-3-prong/calc-better-x.js\");\r\nconst curve_1 = __webpack_require__(/*! ../../../curve */ \"./node_modules/flo-mat/node/curve.js\");\r\nconst calcVectorToZeroV_StraightToIt = flo_vector2d_1.fromTo;\r\n/**\r\n * Finds a 3-prong using only the 3 given δs.\r\n * @param δs The boundary pieces\r\n * @param idx δ identifier\r\n * @param bezierPiecess\r\n * @param extreme The maximum coordinate value used to calculate floating point\r\n * tolerances.\r\n */\r\nfunction find3ProngForDelta3s(δs, idx, k, bezierPiecess, extreme) {\r\n    const TOLERANCE = extreme * 1e-10;\r\n    const MAX_ITERATIONS = 10;\r\n    let δs_ = [\r\n        δs[0],\r\n        δs[idx],\r\n        δs[δs.length - 1]\r\n    ];\r\n    let bezierPieces_ = [\r\n        bezierPiecess[0],\r\n        bezierPiecess[idx],\r\n        bezierPiecess[δs.length - 1]\r\n    ];\r\n    let δ3ss = [\r\n        [δs_[0], δs_[1], δs_[2]],\r\n        [δs_[1], δs_[2], δs_[0]],\r\n        [δs_[2], δs_[0], δs_[1]],\r\n    ];\r\n    let bezierPiecess_ = [\r\n        [bezierPieces_[0], bezierPieces_[1], bezierPieces_[2]],\r\n        [bezierPieces_[1], bezierPieces_[2], bezierPieces_[0]],\r\n        [bezierPieces_[2], bezierPieces_[0], bezierPieces_[1]],\r\n    ];\r\n    let δ3s = δ3ss[k];\r\n    let bezierPiece3s = bezierPiecess_[k];\r\n    if (δ3s[0][0].isSharp()) {\r\n        return undefined;\r\n    }\r\n    let ps;\r\n    let circumCenter_;\r\n    let j = 0; // Safeguard for slow convergence\r\n    //console.log(bezierPieces_)\r\n    let x = calc_initial_3_prong_center_1.calcInitial3ProngCenter(δ3s, bezierPiece3s);\r\n    if (typeof _debug_ !== 'undefined') {\r\n        let threeProngs = _debug_.generated.elems.threeProng;\r\n        let d = threeProngs[threeProngs.length - 1];\r\n        let trace = d.traces[d.traces.length - 1];\r\n        trace.push(x);\r\n    }\r\n    let tolerance = Number.POSITIVE_INFINITY;\r\n    while (tolerance > TOLERANCE && j < MAX_ITERATIONS) {\r\n        j++;\r\n        ps = get_closest_points_1.getClosestPoints(x, bezierPiece3s);\r\n        if (!Number.isFinite(x[0]) || !Number.isFinite(x[1])) {\r\n            // TODO - the code can be cleaned up and sped up a lot if we don't\r\n            // use this function as is but instead use δs[0] and δs[2] as is\r\n            // and make δs[1] include all the rest of the beziers around the \r\n            // loop. This check, for instance, would be eliminated completely.\r\n            return undefined;\r\n        }\r\n        circumCenter_ = flo_vector2d_1.circumCenter(ps.map(x => x.p));\r\n        let vectorToZeroV = calcVectorToZeroV_StraightToIt(x, circumCenter_);\r\n        //console.log('' + x[0] + ' ' + x[1])\r\n        //console.log('' + vectorToZeroV[0] + ' ' + vectorToZeroV[1]);\r\n        if (!Number.isFinite(vectorToZeroV[0]) || !Number.isFinite(vectorToZeroV[1])) {\r\n            // TODO - the code can be cleaned up and sped up a lot if we don't\r\n            // use this function as is but instead use δs[0] and δs[2] as is\r\n            // and make δs[1] include all the rest of the beziers around the \r\n            // loop. This check, for instance, would be eliminated completely.\r\n            return undefined;\r\n        }\r\n        let upds = calc_better_x_1.calcBetterX(bezierPiece3s, x, vectorToZeroV);\r\n        x = upds.newX;\r\n        ps = upds.newPs;\r\n        if (typeof _debug_ !== 'undefined') {\r\n            let threeProngs = _debug_.generated.elems.threeProng;\r\n            let d = threeProngs[threeProngs.length - 1];\r\n            let trace = d.traces[d.traces.length - 1];\r\n            trace.push(x);\r\n        }\r\n        let V = flo_vector2d_1.len(vectorToZeroV); // The 'potential'\r\n        tolerance = Math.abs(V - upds.newV);\r\n    }\r\n    //_debug_.fs.draw.dot(_debug_.generated.g, x, 0.05);\r\n    let radius = (flo_vector2d_1.distanceBetween(x, ps[0].p) +\r\n        flo_vector2d_1.distanceBetween(x, ps[1].p) +\r\n        flo_vector2d_1.distanceBetween(x, ps[2].p)) / 3;\r\n    let circle = new circle_1.Circle(x, radius);\r\n    //-------------------------------------------------------------------------\r\n    // Calculate the unit tangent vector at 3-prong circle points - they should \r\n    // be very close to tangent to the boundary piece tangents at those points \r\n    // (up to sign). Sharp corners are a common special case.\r\n    //-------------------------------------------------------------------------\r\n    let totalAngleError = 0;\r\n    for (let i = 0; i < 3; i++) {\r\n        let p = ps[i];\r\n        //----------------------------\r\n        // Tangent of circle at point\r\n        //----------------------------\r\n        let v = flo_vector2d_1.toUnitVector(flo_vector2d_1.fromTo(p.p, x));\r\n        let v1 = flo_vector2d_1.rotate90Degrees(v);\r\n        //-----------------------------------\r\n        // Check if point is on dull crorner\r\n        //-----------------------------------\r\n        if (point_on_shape_1.PointOnShape.isDullCorner(p)) {\r\n            let corner = curve_1.Curve.getCornerAtEnd(p.curve);\r\n            let tans = corner.tangents;\r\n            let perps = tans.map(flo_vector2d_1.rotate90Degrees);\r\n            let angleError1 = Math.asin(flo_vector2d_1.cross(perps[0], v));\r\n            let angleError2 = Math.asin(flo_vector2d_1.cross(v, perps[1]));\r\n            let angleError = 0;\r\n            if (angleError1 > 0) {\r\n                angleError += angleError1;\r\n            }\r\n            if (angleError2 > 0) {\r\n                angleError += angleError2;\r\n            }\r\n            totalAngleError += angleError;\r\n        }\r\n        else {\r\n            //---------------------------\r\n            // Tangent of curve at point\r\n            //---------------------------\r\n            let v2 = flo_vector2d_1.toUnitVector(flo_bezier3_1.tangent(p.curve.ps, p.t));\r\n            // Cross is more numerically stable than Vector.dot at angles a\r\n            // multiple of Math.PI **and** is close to the actual angle value\r\n            // and can thus just be added to cone method of looking at \r\n            // tolerance.\r\n            // Should be close to zero and is close to the actual angle.\r\n            let cross_ = Math.abs(Math.asin(flo_vector2d_1.cross(v1, v2)));\r\n            totalAngleError += cross_;\r\n        }\r\n    }\r\n    //-------------------------------------------------------------------------\r\n    // Calculate radiusDelta, the difference between the radius and the closest\r\n    // point to the 3-prong. It should be around 0. If not, this is not a good \r\n    // candidate for the 3-prong.\r\n    //-------------------------------------------------------------------------\r\n    let closestDs = [];\r\n    for (let i = 0; i < bezierPiecess.length; i++) {\r\n        let p = get_closest_boundary_point_1.getClosestBoundaryPoint(bezierPiecess[i], x, undefined, undefined);\r\n        closestDs.push(flo_vector2d_1.distanceBetween(p.pos.p, x));\r\n    }\r\n    let closestD = Math.min(...closestDs);\r\n    let radiusDelta = Math.abs(radius - closestD);\r\n    // Weights below still need to be optimized.\r\n    let W1 = 1;\r\n    let W2 = 1;\r\n    let error = W1 * radiusDelta + W2 * totalAngleError;\r\n    return { ps, circle, error, δ3s };\r\n}\r\nexports.find3ProngForDelta3s = find3ProngForDelta3s;\r\n//# sourceMappingURL=find-3-prong-for-delta3s.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/find-3-prong/find-3-prong-for-delta3s.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/find-3-prong/find-3-prong.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/find-3-prong/find-3-prong.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst three_prong_for_debugging_1 = __webpack_require__(/*! ../../../debug/three-prong-for-debugging */ \"./node_modules/flo-mat/node/debug/three-prong-for-debugging.js\");\r\nconst find_3_prong_for_delta3s_1 = __webpack_require__(/*! ./find-3-prong-for-delta3s */ \"./node_modules/flo-mat/node/mat/find-mat/find-3-prong/find-3-prong-for-delta3s.js\");\r\nconst get_boundary_piece_beziers_1 = __webpack_require__(/*! ../../get-boundary-piece-beziers */ \"./node_modules/flo-mat/node/mat/get-boundary-piece-beziers.js\");\r\n/**\r\n * Find and return a 3-prong from the given boundary piece.\r\n * @param δs A boundary piece\r\n * @param extreme The maximum coordinate value used to calculate floating point\r\n * tolerances.\r\n */\r\nfunction find3Prong(δs, extreme) {\r\n    let bezierPiecess = δs.map(get_boundary_piece_beziers_1.getBoundaryPieceBeziers);\r\n    if (typeof _debug_ !== 'undefined') {\r\n        let threeProngs = _debug_.generated.elems.threeProng;\r\n        threeProngs.push(new three_prong_for_debugging_1.ThreeProngForDebugging());\r\n        let d = threeProngs[threeProngs.length - 1];\r\n        d.boundaries = [];\r\n        for (let bezierPieces of bezierPiecess) {\r\n            let boundary = [];\r\n            d.boundaries.push(boundary);\r\n            for (let bezierPiece of bezierPieces) {\r\n                let bezier = flo_bezier3_1.fromTo(bezierPiece.curve.ps)(bezierPiece.ts[0], bezierPiece.ts[1]);\r\n                boundary.push(bezier);\r\n            }\r\n        }\r\n        d.traces = [];\r\n    }\r\n    let candidateThreeProngs = [];\r\n    // The best candidate amongst the different 'permutations' of the given δs.\r\n    let threeProng;\r\n    let bestIndx = undefined;\r\n    let smallestError = Number.POSITIVE_INFINITY;\r\n    for (let i = 1; i < δs.length - 1; i++) {\r\n        for (let k = 0; k < 3; k++) {\r\n            //let k = 0;\r\n            if (typeof _debug_ !== 'undefined') {\r\n                let threeProngs = _debug_.generated.elems.threeProng;\r\n                let d = threeProngs[threeProngs.length - 1];\r\n                let trace = [];\r\n                d.traces.push(trace);\r\n            }\r\n            let threeProngInfo = find_3_prong_for_delta3s_1.find3ProngForDelta3s(δs, i, k, bezierPiecess, extreme);\r\n            if (!threeProngInfo) {\r\n                continue;\r\n            }\r\n            let { circle, ps, error, δ3s } = threeProngInfo;\r\n            if (typeof _debug_ !== 'undefined') {\r\n                candidateThreeProngs.push({ circle, ps });\r\n            }\r\n            if (error < smallestError) {\r\n                smallestError = error;\r\n                bestIndx = i - 1;\r\n                threeProng = { circle, ps, δ3s };\r\n            }\r\n        }\r\n    }\r\n    //threeProng.δ3s = [δs[0], δs[bestIndx+1], δs[δs.length-1]];\r\n    if (typeof _debug_ !== 'undefined') {\r\n        let threeProngs = _debug_.generated.elems.threeProng;\r\n        let d = threeProngs[threeProngs.length - 1];\r\n        d.generated = _debug_.generated;\r\n        d.circle = threeProng.circle,\r\n            d.poss = threeProng.ps;\r\n        d.cp3ss = threeProng.δ3s;\r\n        d.cpss = δs;\r\n        d.bestIndx = bestIndx;\r\n        d.candidateThreeProngs = candidateThreeProngs;\r\n    }\r\n    return threeProng;\r\n}\r\nexports.find3Prong = find3Prong;\r\n//# sourceMappingURL=find-3-prong.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/find-3-prong/find-3-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/find-3-prong/get-closest-points.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/find-3-prong/get-closest-points.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_closest_boundary_point_1 = __webpack_require__(/*! ../../closest-boundary-point/get-closest-boundary-point */ \"./node_modules/flo-mat/node/mat/closest-boundary-point/get-closest-boundary-point.js\");\r\n/**\r\n *\r\n * @param x\r\n * @param bezierPiece3s\r\n * @param extreme\r\n */\r\nfunction getClosestPoints(x, bezierPiece3s) {\r\n    return bezierPiece3s.map(bezierPieces => {\r\n        let posInfo = get_closest_boundary_point_1.getClosestBoundaryPoint(bezierPieces, x, undefined, // curve\r\n        undefined // t\r\n        );\r\n        return posInfo ? posInfo.pos : undefined;\r\n    });\r\n}\r\nexports.getClosestPoints = getClosestPoints;\r\n//# sourceMappingURL=get-closest-points.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/find-3-prong/get-closest-points.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/find-and-add-2-prongs-on-all-paths.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/find-and-add-2-prongs-on-all-paths.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst find_and_add_2_prongs_1 = __webpack_require__(/*! ./find-and-add-2-prongs */ \"./node_modules/flo-mat/node/mat/find-mat/find-and-add-2-prongs.js\");\r\n/**\r\n * Add 2 prongs. See comments on the add2Prong function.\r\n * @param loops\r\n * @param cpGraphs\r\n * @param for2Prongss\r\n * @param extreme The maximum coordinate value used to calculate floating point\r\n * tolerances.\r\n */\r\nfunction findAndAdd2ProngsOnAllPaths(loops, cpGraphs, for2Prongss, extreme) {\r\n    let cpNode;\r\n    //console.log(loops);\r\n    for (let k = 0; k < for2Prongss.length; k++) {\r\n        let for2Prongs = for2Prongss[k];\r\n        cpNode = find_and_add_2_prongs_1.findAndAdd2Prongs(loops, cpGraphs, k, for2Prongs, extreme);\r\n    }\r\n    return cpNode;\r\n}\r\nexports.findAndAdd2ProngsOnAllPaths = findAndAdd2ProngsOnAllPaths;\r\n//# sourceMappingURL=find-and-add-2-prongs-on-all-paths.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/find-and-add-2-prongs-on-all-paths.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/find-and-add-2-prongs.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/find-and-add-2-prongs.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_shape_bounds_1 = __webpack_require__(/*! ../../svg/fs/get-shape-bounds */ \"./node_modules/flo-mat/node/svg/fs/get-shape-bounds.js\");\r\nconst find_2_prong_1 = __webpack_require__(/*! ./find-2-prong/find-2-prong */ \"./node_modules/flo-mat/node/mat/find-mat/find-2-prong/find-2-prong.js\");\r\nconst add_2_prong_1 = __webpack_require__(/*! ./add-2-prong */ \"./node_modules/flo-mat/node/mat/find-mat/add-2-prong.js\");\r\n/**\r\n * Find and add two-prongs.\r\n * @param loops\r\n * @param cpGraphs\r\n * @param k\r\n * @param for2Prongs\r\n * @param extreme The maximum coordinate value used to calculate floating point\r\n * tolerances.\r\n */\r\nfunction findAndAdd2Prongs(loops, cpGraphs, k, for2Prongs, extreme) {\r\n    let len = for2Prongs.length;\r\n    let index = indexLinear(len);\r\n    //let index = indexInterlaced(len); // Keep for possible future use.\r\n    let cpNode_;\r\n    let bounds = get_shape_bounds_1.getShapeBounds(loops);\r\n    let squaredDiagonalLength = Math.pow((bounds.maxX.p[0] - bounds.minX.p[0]), 2) +\r\n        Math.pow((bounds.maxY.p[1] - bounds.minY.p[1]), 2);\r\n    for (let i = 0; i < len; i++) {\r\n        let pos = for2Prongs[index[i]];\r\n        let twoProngInfo;\r\n        twoProngInfo = find_2_prong_1.find2Prong(loops, extreme, squaredDiagonalLength, cpGraphs, pos, false, k);\r\n        //console.log(twoProngInfo.circle.radius)\r\n        if (twoProngInfo) {\r\n            let { circle, zs } = twoProngInfo;\r\n            let cpNode = add_2_prong_1.add2Prong(cpGraphs, circle, pos, zs, false, extreme);\r\n            // TODO - below should certainly be explained\r\n            if (!cpNode_ && cpNode) {\r\n                cpNode_ = cpNode;\r\n            }\r\n        } /* else {\r\n            console.log('aaaaaaaaa')\r\n        }*/\r\n        if (typeof _debug_ !== 'undefined') {\r\n            if (i + 1 === _debug_.directives.stopAfterTwoProngsNum) {\r\n                return undefined;\r\n            }\r\n        }\r\n    }\r\n    return cpNode_;\r\n}\r\nexports.findAndAdd2Prongs = findAndAdd2Prongs;\r\n/**\r\n * Simple linear array indexing.\r\n * @param n\r\n */\r\nfunction indexLinear(n) {\r\n    let arr = [];\r\n    for (let i = 0; i < n; i++) {\r\n        arr.push(i);\r\n    }\r\n    return arr;\r\n}\r\n/**\r\n * Creates a kind of interlaced index vector.\r\n * @param n\r\n*/\r\nfunction indexInterlaced(n) {\r\n    let source = {};\r\n    let arr = [];\r\n    // l is the lowest power of 2 so that 2^l > n\r\n    let l = Math.pow(2, Math.floor(Math.log2(n)));\r\n    while (l >= 1) {\r\n        let k = 0;\r\n        while (k < n) {\r\n            if (!source[k]) {\r\n                arr.push(k);\r\n                source[k] = true;\r\n            }\r\n            k = k + l;\r\n        }\r\n        l = l / 2;\r\n    }\r\n    return arr;\r\n}\r\n//# sourceMappingURL=find-and-add-2-prongs.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/find-and-add-2-prongs.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/find-and-add-3-prongs.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/find-and-add-3-prongs.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nconst find_3_prong_1 = __webpack_require__(/*! ./find-3-prong/find-3-prong */ \"./node_modules/flo-mat/node/mat/find-mat/find-3-prong/find-3-prong.js\");\r\nconst add_3_prong_1 = __webpack_require__(/*! ../find-mat/add-3-prong */ \"./node_modules/flo-mat/node/mat/find-mat/add-3-prong.js\");\r\n/**\r\n * Finds and adds all 3-prongs.\r\n * @param cpGraphs\r\n * @param cpStart The CpNode to start traversing from.\r\n * @param extreme The maximum coordinate value used to calculate floating point\r\n * tolerances.\r\n */\r\nfunction findAndAddAll3Prongs(cpGraphs, cpStart, extreme) {\r\n    // Don't change this function to be recursive, the call stack may overflow \r\n    // if there are too many two-prongs.\r\n    let visitedEdges = new Map();\r\n    let edgesToCheck = [{ fromCpNode: undefined, cpStart }];\r\n    while (edgesToCheck.length) {\r\n        let { fromCpNode, cpStart } = edgesToCheck.shift();\r\n        markEdgeAsTaken(visitedEdges, fromCpNode, cpStart);\r\n        for (let cpNode of cpStart.getCpNodesOnCircle()) {\r\n            if (!point_on_shape_1.PointOnShape.isSharpCorner(cpNode.cp.pointOnShape)) {\r\n                findAndAdd3Prongs(cpGraphs, cpNode, extreme);\r\n            }\r\n            if (hasEdgeBeenTaken(visitedEdges, cpNode, cpNode.next)) {\r\n                continue; // We already visited this edge\r\n            }\r\n            edgesToCheck.push({ fromCpNode: cpStart, cpStart: cpNode.next });\r\n        }\r\n    }\r\n}\r\nexports.findAndAddAll3Prongs = findAndAddAll3Prongs;\r\n/**\r\n * Marks the given edge as already taken.\r\n */\r\nfunction markEdgeAsTaken(visitedEdges, cp1, cp2) {\r\n    if (cp1 === undefined) {\r\n        return;\r\n    }\r\n    f(cp1, cp2);\r\n    f(cp2, cp1);\r\n    function f(cp1, cp2) {\r\n        let visited = visitedEdges.get(cp1);\r\n        if (!visited) {\r\n            visited = new Set();\r\n            visitedEdges.set(cp1, visited);\r\n        }\r\n        visited.add(cp2);\r\n    }\r\n}\r\nfunction hasEdgeBeenTaken(visitedEdges, cp1, cp2) {\r\n    let cps;\r\n    cps = visitedEdges.get(cp1);\r\n    let takenForward = cps && cps.has(cp2);\r\n    cps = visitedEdges.get(cp2);\r\n    let takenBackwards = cps && cps.has(cp1);\r\n    return takenForward || takenBackwards;\r\n}\r\n/**\r\n * Traverses the shape from the given ContactPoint going around contact circles\r\n * so that only a piece of the shape is traversed and returns the visited\r\n * CpNodes (starting from the given CpNode).\r\n * @param cpStart The ContactPoint from where to start the traversal.\r\n */\r\nfunction traverseShape(cpStart) {\r\n    let cpNode = cpStart;\r\n    if (cpNode === cpNode.next.prevOnCircle) {\r\n        return [cpNode];\r\n    }\r\n    let visitedCps = [];\r\n    do {\r\n        visitedCps.push(cpNode);\r\n        let next = cpNode.next.prevOnCircle;\r\n        cpNode = cpNode === next\r\n            ? cpNode = cpNode.next.next // Terminal vertex\r\n            : cpNode = next; // Take last exit\r\n    } while (cpNode !== cpStart);\r\n    return visitedCps;\r\n}\r\n/**\r\n * Starting from some ContactPoint, traverses the shape going around Vertices\r\n * and if more than two Vertices have been visited in total then recursively\r\n * adds 3-prongs until only one or two Vertices have been visited.\r\n *\r\n * This process further subdivides the shape.\r\n * @param cpGraphs\r\n * @param cpStart The ContactPoint from where to start the process.\r\n * @param extreme The maximum coordinate value used to calculate floating point\r\n * tolerances.\r\n */\r\nfunction findAndAdd3Prongs(cpGraphs, cpStart, extreme) {\r\n    let visitedCps;\r\n    do {\r\n        visitedCps = traverseShape(cpStart);\r\n        if (visitedCps.length > 2) {\r\n            findAndAdd3Prong(cpGraphs, visitedCps, extreme);\r\n        }\r\n    } while (visitedCps.length > 2);\r\n    return visitedCps;\r\n}\r\n/**\r\n * Finds and add a 3-prong MAT circle to the given shape.\r\n * @param cpGraphs\r\n * @param visitedCps\r\n * @param extreme The maximum coordinate value used to calculate floating point\r\n * tolerances.\r\n */\r\nfunction findAndAdd3Prong(cpGraphs, visitedCps, extreme) {\r\n    let δs = [];\r\n    for (let visitedCp of visitedCps) {\r\n        δs.push([visitedCp, visitedCp.next]);\r\n    }\r\n    let threeProng = find_3_prong_1.find3Prong(δs, extreme);\r\n    let orders = [];\r\n    for (let i = 0; i < 3; i++) {\r\n        orders.push(point_on_shape_1.PointOnShape.calcOrder(threeProng.circle, threeProng.ps[i]));\r\n    }\r\n    let circle = add_3_prong_1.add3Prong(cpGraphs, orders, threeProng);\r\n    if (typeof _debug_ !== 'undefined') {\r\n        add3ProngDebugInfo(circle, visitedCps);\r\n    }\r\n}\r\nfunction add3ProngDebugInfo(circle, visitedCps) {\r\n    let threeProngs = _debug_.generated.elems.threeProng;\r\n    let len = threeProngs.length;\r\n    let data = threeProngs[len - 1];\r\n    data.visitedCps = visitedCps;\r\n    data.circle = circle;\r\n}\r\n//# sourceMappingURL=find-and-add-3-prongs.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/find-and-add-3-prongs.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/find-and-add-hole-closing-2-prongs.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/find-and-add-hole-closing-2-prongs.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_shape_bounds_1 = __webpack_require__(/*! ../../svg/fs/get-shape-bounds */ \"./node_modules/flo-mat/node/svg/fs/get-shape-bounds.js\");\r\nconst get_min_y_pos_1 = __webpack_require__(/*! ../../svg/fs/get-min-y-pos */ \"./node_modules/flo-mat/node/svg/fs/get-min-y-pos.js\");\r\nconst find_2_prong_1 = __webpack_require__(/*! ./find-2-prong/find-2-prong */ \"./node_modules/flo-mat/node/mat/find-mat/find-2-prong/find-2-prong.js\");\r\nconst add_2_prong_1 = __webpack_require__(/*! ./add-2-prong */ \"./node_modules/flo-mat/node/mat/find-mat/add-2-prong.js\");\r\n/**\r\n * Find and add two-prongs that remove any holes in the shape.\r\n * @param loops The loops (that as a precondition must be ordered from\r\n * highest (i.e. smallest y-value) topmost point loops to lowest)\r\n * @param cpTrees\r\n * @param extreme The maximum coordinate value used to calculate floating point\r\n * tolerances.\r\n */\r\nfunction findAndAddHoleClosing2Prongs(loops, cpTrees, extreme) {\r\n    let bounds = get_shape_bounds_1.getShapeBounds(loops);\r\n    let squaredDiagonalLength = Math.pow((bounds.maxX.p[0] - bounds.minX.p[0]), 2) +\r\n        Math.pow((bounds.maxY.p[1] - bounds.minY.p[1]), 2);\r\n    // Find the topmost points on each loop.\r\n    let minYs = loops.map(get_min_y_pos_1.getMinYPos);\r\n    // We start at 1 since 0 is the outer (root) loop\r\n    for (let k = 1; k < minYs.length; k++) {\r\n        let posSource = minYs[k];\r\n        let holeClosingTwoProng = find_2_prong_1.find2Prong(loops, extreme, squaredDiagonalLength, cpTrees, posSource, true, k);\r\n        if (!holeClosingTwoProng) {\r\n            throw new Error(`Unable to find hole-closing 2-prong`);\r\n        }\r\n        // TODO important - handle case of n-prong, i.e. more than one antipode\r\n        // - currently we only handle case of single antipode (the general case)\r\n        let { circle, zs: posAntipodes } = holeClosingTwoProng;\r\n        //let posAntipode = posAntipodes[0];\r\n        //let parent = posSource.curve.loop;\r\n        //let child = posAntipode.pos.curve.loop;\r\n        //parent.children.push(child);\r\n        add_2_prong_1.add2Prong(cpTrees, circle, posSource, [posAntipodes[0]], true, extreme);\r\n    }\r\n}\r\nexports.findAndAddHoleClosing2Prongs = findAndAddHoleClosing2Prongs;\r\n//# sourceMappingURL=find-and-add-hole-closing-2-prongs.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/find-and-add-hole-closing-2-prongs.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/get-potential-2-prongs.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/get-potential-2-prongs.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nfunction getPotential2Prongs(possPerLoop) {\r\n    let for2ProngsArray = [];\r\n    for (let poss of possPerLoop) {\r\n        let for2Prongs = [];\r\n        for (let pos of poss) {\r\n            if (!point_on_shape_1.PointOnShape.isQuiteSharpCorner(pos)) {\r\n                for2Prongs.push(pos);\r\n            }\r\n        }\r\n        for2ProngsArray.push(for2Prongs);\r\n    }\r\n    return for2ProngsArray;\r\n}\r\nexports.getPotential2Prongs = getPotential2Prongs;\r\n//# sourceMappingURL=get-potential-2-prongs.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/get-potential-2-prongs.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/get-sharp-corners.js":
/*!*********************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/get-sharp-corners.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nfunction getSharpCorners(possPerLoop) {\r\n    let sharpCornersPerLoop = [];\r\n    for (let poss of possPerLoop) {\r\n        let sharpCorners = [];\r\n        for (let pos of poss) {\r\n            if (point_on_shape_1.PointOnShape.isQuiteSharpCorner(pos)) {\r\n                sharpCorners.push(pos);\r\n            }\r\n        }\r\n        sharpCornersPerLoop.push(sharpCorners);\r\n    }\r\n    return sharpCornersPerLoop;\r\n}\r\nexports.getSharpCorners = getSharpCorners;\r\n//# sourceMappingURL=get-sharp-corners.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/get-sharp-corners.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/geometry/get-closest-square-distance-to-rect.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/geometry/get-closest-square-distance-to-rect.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\n/**\r\n *\r\n */\r\nfunction getClosestSquareDistanceToRect(box, p) {\r\n    let [[x0, y0], [x1, y1]] = box;\r\n    let [xp, yp] = p;\r\n    if (xp < x0) {\r\n        if (yp < y0) {\r\n            return flo_vector2d_1.squaredDistanceBetween(box[0], p);\r\n        }\r\n        else if (yp > y1) {\r\n            return flo_vector2d_1.squaredDistanceBetween([x0, y1], p);\r\n        }\r\n        else {\r\n            let d = x0 - xp;\r\n            return d * d;\r\n        }\r\n    }\r\n    else if (xp > x1) {\r\n        if (yp < y0) {\r\n            return flo_vector2d_1.squaredDistanceBetween([x1, y0], p);\r\n        }\r\n        else if (yp > y1) {\r\n            return flo_vector2d_1.squaredDistanceBetween(box[1], p);\r\n        }\r\n        else {\r\n            let d = xp - x1;\r\n            return d * d;\r\n        }\r\n    }\r\n    else {\r\n        if (yp < y0) {\r\n            let d = y0 - yp;\r\n            return d * d;\r\n        }\r\n        else if (yp > y1) {\r\n            let d = yp - y1;\r\n            return d * d;\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n}\r\nexports.getClosestSquareDistanceToRect = getClosestSquareDistanceToRect;\r\n//# sourceMappingURL=get-closest-square-distance-to-rect.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/geometry/get-closest-square-distance-to-rect.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/geometry/get-closest-squared-distance-to-rotated-rect.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/geometry/get-closest-squared-distance-to-rotated-rect.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\n/**\r\n *\r\n */\r\nfunction getClosestSquaredDistanceToRotatedRect(ps, p) {\r\n    let ds = [0, 1, 2, 3].map(i => flo_vector2d_1.squaredDistanceBetweenPointAndLineSegment(p, [ps[i], ps[(i + 1) % 4]]));\r\n    let width = flo_vector2d_1.squaredDistanceBetween(ps[0], ps[1]);\r\n    let height = flo_vector2d_1.squaredDistanceBetween(ps[0], ps[3]);\r\n    if (ds[0] <= height && ds[2] <= height &&\r\n        ds[1] <= width && ds[3] <= width) {\r\n        return 0; // Inside rotated rect\r\n    }\r\n    return Math.min(...ds);\r\n}\r\nexports.getClosestSquaredDistanceToRotatedRect = getClosestSquaredDistanceToRotatedRect;\r\n//# sourceMappingURL=get-closest-squared-distance-to-rotated-rect.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/geometry/get-closest-squared-distance-to-rotated-rect.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/geometry/line-line-intersection.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/geometry/line-line-intersection.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Find point where two lines intersect. Returns he point where the two lines\r\n * intersect or undefined if they don't intersect or are the same line.\r\n * @param l1 - A line\r\n * @param l2 - Another line\r\n */\r\nfunction lineLineIntersection(l1, l2) {\r\n    let [[p1x, p1y], [p2x, p2y]] = l1;\r\n    let [[p3x, p3y], [p4x, p4y]] = l2;\r\n    let v1x = p2x - p1x;\r\n    let v1y = p2y - p1y;\r\n    let v2x = p4x - p3x;\r\n    let v2y = p4y - p3y;\r\n    let cross = v2x * v1y - v2y * v1x;\r\n    if (cross === 0) {\r\n        // parallel\r\n        return undefined;\r\n    }\r\n    let b = ((p3y - p1y) * v1x - (p3x - p1x) * v1y) / cross;\r\n    return [p3x + b * v2x, p3y + b * v2y];\r\n}\r\nexports.lineLineIntersection = lineLineIntersection;\r\n//# sourceMappingURL=line-line-intersection.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/geometry/line-line-intersection.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/get-boundary-piece-beziers.js":
/*!*********************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/get-boundary-piece-beziers.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst bezier_piece_1 = __webpack_require__(/*! ../bezier-piece */ \"./node_modules/flo-mat/node/bezier-piece.js\");\r\nconst point_on_shape_1 = __webpack_require__(/*! ../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nconst contact_point_1 = __webpack_require__(/*! ../contact-point */ \"./node_modules/flo-mat/node/contact-point.js\");\r\n/**\r\n* Returns the ordered cubic bezier pieces (i.e a bezier with a t range)\r\n* from the given boundary piece.\r\n* @param cpNodes - An ordered pair that represents the start and end points of\r\n* the boundary piece\r\n*/\r\nfunction getBoundaryPieceBeziers(cpNodes) {\r\n    let cpThis = cpNodes[0];\r\n    let cpEnd = cpNodes[1];\r\n    let bezierPieces = [];\r\n    // As opposed to going around the circle and taking the last exit\r\n    let goStraight = true;\r\n    do {\r\n        if (!goStraight) {\r\n            goStraight = true;\r\n            cpThis = cpThis.prevOnCircle; // take last exit\r\n            continue;\r\n        }\r\n        goStraight = false;\r\n        let posThis = cpThis.cp.pointOnShape;\r\n        let posNext = cpThis.next.cp.pointOnShape;\r\n        if (posNext.curve === posThis.curve &&\r\n            point_on_shape_1.PointOnShape.isQuiteSharpCorner(posThis) &&\r\n            point_on_shape_1.PointOnShape.isQuiteSharpCorner(posNext)) {\r\n            // Do nothing\r\n        }\r\n        else if (posNext.curve === posThis.curve &&\r\n            contact_point_1.ContactPoint.compare(cpThis.next.cp, cpThis.cp) > 0) {\r\n            bezierPieces.push(new bezier_piece_1.BezierPiece(posThis.curve, [posThis.t, posNext.t]));\r\n        }\r\n        else {\r\n            bezierPieces.push(new bezier_piece_1.BezierPiece(posThis.curve, [posThis.t, 1]));\r\n            if (cpThis.cp.pointOnShape.curve.loop === cpThis.next.cp.pointOnShape.curve.loop) {\r\n                addSkippedBeziers(bezierPieces, posThis.curve, posNext.curve, posNext.t);\r\n            }\r\n        }\r\n        cpThis = cpThis.next;\r\n    } while (cpThis !== cpEnd);\r\n    return bezierPieces;\r\n}\r\nexports.getBoundaryPieceBeziers = getBoundaryPieceBeziers;\r\n/**\r\n * Adds pieces of skipped beziers\r\n */\r\nfunction addSkippedBeziers(bezierPieces, curveStart, curveEnd, t1) {\r\n    let curveThis = curveStart;\r\n    do {\r\n        curveThis = curveThis.next;\r\n        let tEnd = curveThis === curveEnd ? t1 : 1;\r\n        bezierPieces.push(new bezier_piece_1.BezierPiece(curveThis, [0, tEnd]));\r\n    } while (curveThis !== curveEnd);\r\n}\r\n//# sourceMappingURL=get-boundary-piece-beziers.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/get-boundary-piece-beziers.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/get-contact-circles-at-interface.js":
/*!***************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/get-contact-circles-at-interface.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst curve_1 = __webpack_require__(/*! ../curve */ \"./node_modules/flo-mat/node/curve.js\");\r\nconst point_on_shape_1 = __webpack_require__(/*! ../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nfunction getContactCirclesAtInterface(curve) {\r\n    let { isQuiteSharp, isQuiteDull } = curve_1.Curve.getCornerAtEnd(curve);\r\n    //return [];\r\n    if (isQuiteSharp) {\r\n        return [new point_on_shape_1.PointOnShape(curve, 1)];\r\n    }\r\n    else if (isQuiteDull) {\r\n        return [\r\n            new point_on_shape_1.PointOnShape(curve, 1),\r\n            new point_on_shape_1.PointOnShape(curve.next, 0)\r\n        ];\r\n    }\r\n    return [];\r\n}\r\nexports.getContactCirclesAtInterface = getContactCirclesAtInterface;\r\n//# sourceMappingURL=get-contact-circles-at-interface.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/get-contact-circles-at-interface.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/get-largest-vertex.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/get-largest-vertex.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction getLargestVertex(cpNodes) {\r\n    return cpNodes.reduce(function (maxCpNode, cpNode) {\r\n        return maxCpNode.cp.circle.radius >= cpNode.cp.circle.radius\r\n            ? maxCpNode\r\n            : cpNode;\r\n    }, cpNodes[0]);\r\n}\r\nexports.getLargestVertex = getLargestVertex;\r\n//# sourceMappingURL=get-largest-vertex.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/get-largest-vertex.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/get-leaves.js":
/*!*****************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/get-leaves.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction getLeaves(cpNode) {\r\n    let leaves = [];\r\n    let cps = cpNode.getAllOnLoop();\r\n    cps.forEach(function (cp) {\r\n        if (cp.isTerminating()) {\r\n            leaves.push(cp);\r\n        }\r\n    });\r\n    /*\r\n    traverseEdges(cpNode, f, true);\r\n\r\n    function f(cp: CpNode, isLeaf: boolean) {\r\n        if (isLeaf) {\r\n            leaves.push(cp);\r\n        }\r\n    }\r\n    */\r\n    return leaves;\r\n}\r\nexports.getLeaves = getLeaves;\r\n//# sourceMappingURL=get-leaves.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/get-leaves.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/get-neighboring-cps.js":
/*!**************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/get-neighboring-cps.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst cp_node_1 = __webpack_require__(/*! ../cp-node/cp-node */ \"./node_modules/flo-mat/node/cp-node/cp-node.js\");\r\nconst contact_point_1 = __webpack_require__(/*! ../contact-point */ \"./node_modules/flo-mat/node/contact-point.js\");\r\n/**\r\n * Returns the boundary piece that starts at the immediate previous point on the\r\n * shape and ends at the immediate next point.\r\n * @param cpTree\r\n * @param pos\r\n * @param order\r\n * @param order2\r\n */\r\nfunction getNeighbouringPoints(cpTree, pos, order, order2) {\r\n    let cps = cpTree.findBounds(new cp_node_1.CpNode(new contact_point_1.ContactPoint(pos, undefined, order, order2), false, false));\r\n    if (!cps[0] && !cps[1]) {\r\n        // The tree is still empty\r\n        return [undefined, undefined];\r\n    }\r\n    if (!cps[0] || !cps[1]) {\r\n        // Smaller than all -> cptree.min() === cps[1].data OR\r\n        // Larger  than all -> cptree.max() === cps[0].data\r\n        return [\r\n            cpTree.max(cpTree.root),\r\n            cpTree.min(cpTree.root)\r\n        ];\r\n    }\r\n    return [\r\n        cps[0].data,\r\n        cps[1].data\r\n    ];\r\n}\r\nexports.getNeighbouringPoints = getNeighbouringPoints;\r\n//# sourceMappingURL=get-neighboring-cps.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/get-neighboring-cps.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/get-two-prong-type.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/get-two-prong-type.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction getTwoProngType(e) {\r\n    if (e.holeClosing) {\r\n        return 'twoProng_holeClosing';\r\n    }\r\n    return 'twoProng_regular';\r\n}\r\nexports.getTwoProngType = getTwoProngType;\r\n//# sourceMappingURL=get-two-prong-type.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/get-two-prong-type.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/is-another-cp-closeby.js":
/*!****************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/is-another-cp-closeby.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst get_neighboring_cps_1 = __webpack_require__(/*! ./get-neighboring-cps */ \"./node_modules/flo-mat/node/mat/get-neighboring-cps.js\");\r\n//const ANGLE_THRESHOLD = Math.cos(3 * (Math.PI / 180)); // 3 degrees\r\nconst ANGLE_THRESHOLD = 0.9986295347545738; // === Math.cos(3  degrees)\r\n//const ANGLE_THRESHOLD = 0.9848077530122080; // === Math.cos(10 degrees)\r\n//const ANGLE_THRESHOLD = 0.9998476951563913; // === Math.cos(1 degrees)\r\n//const ANGLE_THRESHOLD = 0.9999984769132877; // === Math.cos(0.1 degrees)   \r\n//const ANGLE_THRESHOLD = 0.9999999847691291  // === Math.cos(0.01 degrees)   \r\n/**\r\n * Returns true if another CpNode is close to the given implied (via pos, order\r\n * and order2) CpNode.\r\n * @param cpTrees\r\n * @param pos\r\n * @param circle\r\n * @param order\r\n * @param order2\r\n * @param extreme The maximum coordinate value used to calculate floating point\r\n * tolerances.\r\n * @param color Used for debugging only\r\n */\r\nfunction isAnotherCpCloseby(cpTrees, pos, circle, order, order2, extreme, color) {\r\n    //console.log(extreme)\r\n    //const DISTANCE_THRESHOLD = extreme * 1e-1; \r\n    //const DISTANCE_THRESHOLD = extreme * 1e-1;\r\n    const DISTANCE_THRESHOLD = extreme * 1e-4;\r\n    //const DISTANCE_THRESHOLD = extreme * 1e-4; - was this\r\n    //const DISTANCE_THRESHOLD = extreme * 1e-6;\r\n    //const DISTANCE_THRESHOLD = extreme * 1e-12;\r\n    // It seems this can be zero else the ordering should be correct\r\n    //const DISTANCE_THRESHOLD = 0;\r\n    let cpTree = cpTrees.get(pos.curve.loop);\r\n    let cpNodes = get_neighboring_cps_1.getNeighbouringPoints(cpTree, pos, order, order2);\r\n    if (!cpNodes[0]) {\r\n        return false;\r\n    }\r\n    for (let cpNode of cpNodes) {\r\n        let pos2 = cpNode.cp.pointOnShape;\r\n        let p1 = pos.p;\r\n        let p2 = pos2.p;\r\n        if (flo_vector2d_1.distanceBetween(p1, p2) > DISTANCE_THRESHOLD) {\r\n            continue;\r\n        }\r\n        let v1 = flo_vector2d_1.toUnitVector(flo_vector2d_1.fromTo(cpNode.cp.pointOnShape.p, cpNode.cp.circle.center));\r\n        let v2 = flo_vector2d_1.toUnitVector(flo_vector2d_1.fromTo(p1, circle.center));\r\n        let cosTheta = flo_vector2d_1.dot(v1, v2);\r\n        if (cosTheta > ANGLE_THRESHOLD) {\r\n            //console.log(`%c${cosTheta} - ${distanceBetween(p1,p2)}`, `color: ${color}`);\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nexports.isAnotherCpCloseby = isAnotherCpCloseby;\r\n//# sourceMappingURL=is-another-cp-closeby.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/is-another-cp-closeby.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/simplify-mat.js":
/*!*******************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/simplify-mat.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_branches_1 = __webpack_require__(/*! ../get-branches */ \"./node_modules/flo-mat/node/get-branches.js\");\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst smoothen_1 = __webpack_require__(/*! ./smoothen/smoothen */ \"./node_modules/flo-mat/node/mat/smoothen/smoothen.js\");\r\n/**\r\n * Simplifies the given MAT by replacing piecewise quad beziers with a single\r\n * one.\r\n * @param cpNode\r\n */\r\nfunction simplifyMat(cpNode, anlgeTolerance = 15, hausdorffTolerance = 1e0, hausdorffSpacing = 1e0) {\r\n    let simpleMap = new Map();\r\n    // Start from a leaf\r\n    while (!cpNode.isTerminating()) {\r\n        cpNode = cpNode.next;\r\n    }\r\n    let branches = get_branches_1.getBranches(cpNode, anlgeTolerance);\r\n    //let g = document.getElementById('svg').getElementsByTagName('g')[0] as SVGGElement;\r\n    let canDeletes = [];\r\n    //console.log(branches)\r\n    for (let k = 0; k < branches.length; k++) {\r\n        let branch = branches[k];\r\n        //drawBranch(g, branch, (k+1)*1000);\r\n        //drawBranch(g, branch);\r\n        // Try to remove some\r\n        let j = 0;\r\n        while (j < branch.length) {\r\n            let i = j;\r\n            while (true) {\r\n                j++;\r\n                if (j === branch.length) {\r\n                    break;\r\n                }\r\n                let hd = getTotalHausdorffDistance(i, j, branch, hausdorffSpacing);\r\n                if (hd > hausdorffTolerance) {\r\n                    break;\r\n                }\r\n                else {\r\n                    canDeletes.push(branch[j]);\r\n                }\r\n            }\r\n            if (i + 1 === j) {\r\n                // no simplification occured\r\n            }\r\n            else {\r\n                let branStart = branch[i];\r\n                let branEnd = branch[j - 1];\r\n                let medial = flo_bezier3_1.toCubic(smoothen_1.getCurveBetween(branStart, branEnd.next));\r\n                let rev = medial.slice().reverse();\r\n                let curCpNode = branStart;\r\n                let prevT = 0;\r\n                while (curCpNode !== branEnd) {\r\n                    let t = flo_bezier3_1.closestPointOnBezier(medial, curCpNode.next.cp.circle.center).t;\r\n                    simpleMap.set(curCpNode, { ps: medial, ts: [prevT, t] });\r\n                    let oppositeCpNode = curCpNode.nextOnCircle.prev;\r\n                    //let rev = medial.slice().reverse();\r\n                    simpleMap.set(oppositeCpNode, { ps: rev, ts: [1 - t, 1 - prevT] });\r\n                    prevT = t;\r\n                    curCpNode = curCpNode.next;\r\n                }\r\n                simpleMap.set(curCpNode, { ps: medial, ts: [prevT, 1] });\r\n                let oppositeCpNode = curCpNode.nextOnCircle.prev;\r\n                //let rev = medial.slice().reverse();\r\n                simpleMap.set(oppositeCpNode, { ps: rev, ts: [0, 1 - prevT] });\r\n            }\r\n        }\r\n    }\r\n    /*\r\n    for (let cpNode of canDeletes) {\r\n        let isTerminating = cpNode.isTerminating();\r\n        let onCircleCount = cpNode.getCpNodesOnCircle().length;\r\n        if (isTerminating || onCircleCount !== 2) {\r\n            continue;\r\n        }\r\n\r\n        CpNode.remove(cpNode);\r\n    }\r\n    */\r\n    /*\r\n    let newBranches = getBranches(cpNode, anlgeTolerance);\r\n    //console.log(newBranches);\r\n    let branchCount = branches.reduce((pv, cv) => pv+cv.length, 0);\r\n    let newBranchCount = newBranches.reduce((pv, cv) => pv+cv.length, 0);\r\n\r\n    console.log(branchCount, newBranchCount)\r\n    //console.log(newBranches[0].map(cpNode => cpNode));\r\n    */\r\n    return { simpleMap, cpNode };\r\n}\r\nexports.simplifyMat = simplifyMat;\r\nfunction getTotalHausdorffDistance(i, j, branch, hausdorffSpacing) {\r\n    let hds = [];\r\n    let longCurve = smoothen_1.getCurveBetween(branch[i], branch[j].next);\r\n    for (let m = i; m < j + 1; m++) {\r\n        hds.push(flo_bezier3_1.hausdorffDistance(smoothen_1.getCurveToNext(branch[m]), longCurve, hausdorffSpacing));\r\n    }\r\n    return Math.max(...hds);\r\n}\r\n//# sourceMappingURL=simplify-mat.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/simplify-mat.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/smoothen/get-edge-direction.js":
/*!**********************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/smoothen/get-edge-direction.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\n/**\r\n * Returns a line segment of unit length starting in the given Vertex center and\r\n * pointing in the direction of the medial axis (viewed as a rooted tree).\r\n * @param cpNode\r\n */\r\nfunction getEdgeDirection(cpNode) {\r\n    let circleCenter = cpNode.cp.circle.center;\r\n    let cp1 = cpNode;\r\n    let cp2 = cpNode.nextOnCircle;\r\n    let pos1 = cp1.cp.pointOnShape;\r\n    let pos2 = cp2.cp.pointOnShape;\r\n    let p1 = pos1.p;\r\n    let p2 = pos2.p;\r\n    let vDir;\r\n    if (!point_on_shape_1.PointOnShape.isSharpCorner(pos1)) {\r\n        if (p1[0] === p2[0] && p1[1] === p2[1]) {\r\n            vDir = flo_vector2d_1.fromTo(p1, circleCenter); // A 1-prong\r\n        }\r\n        else {\r\n            vDir = flo_vector2d_1.rotate90Degrees(flo_vector2d_1.fromTo(p1, p2)); // not a 1-prong.\r\n        }\r\n    }\r\n    else {\r\n        let curve1;\r\n        let curve2;\r\n        // TODO - test if pos1.t can ever be 0 - it is terminating\r\n        if (pos1.t === 0) {\r\n            curve1 = pos1.curve;\r\n            curve2 = pos1.curve.prev;\r\n        }\r\n        else if (pos1.t === 1) {\r\n            curve1 = pos1.curve.next;\r\n            curve2 = pos1.curve;\r\n        }\r\n        let tan1 = flo_bezier3_1.tangent(curve1.ps)(0);\r\n        let tan2 = flo_vector2d_1.reverse(flo_bezier3_1.tangent(curve2.ps)(1));\r\n        let x = flo_vector2d_1.dot(tan1, tan2);\r\n        // Recall the identities sin(acos(x)) = sqrt(1-x^2), etc. Also \r\n        // recall the half angle formulas. Then the rotation matrix, R, can \r\n        // be calculated.\r\n        let cosθ = Math.sqrt((1 + x) / 2);\r\n        let sinθ = Math.sqrt((1 - x) / 2);\r\n        vDir = flo_vector2d_1.rotate(sinθ, cosθ, tan2);\r\n    }\r\n    let v = flo_vector2d_1.translate(flo_vector2d_1.toUnitVector(vDir), circleCenter);\r\n    return [circleCenter, v];\r\n}\r\nexports.getEdgeDirection = getEdgeDirection;\r\n//# sourceMappingURL=get-edge-direction.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/smoothen/get-edge-direction.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/smoothen/smoothen.js":
/*!************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/smoothen/smoothen.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst line_line_intersection_1 = __webpack_require__(/*! ../geometry/line-line-intersection */ \"./node_modules/flo-mat/node/mat/geometry/line-line-intersection.js\");\r\nconst get_edge_direction_1 = __webpack_require__(/*! ./get-edge-direction */ \"./node_modules/flo-mat/node/mat/smoothen/get-edge-direction.js\");\r\nconst TOLERANCE_ADD_2PRONG = 0.01;\r\nconst TOLERANCE_USE_LINE = 0.0001; // else cubic\r\nfunction getCurveToNext(cpNode) {\r\n    return getCurveBetween(cpNode, cpNode.next);\r\n}\r\nexports.getCurveToNext = getCurveToNext;\r\nfunction getCurveBetween(cpNodeFrom, cpNodeTo) {\r\n    let fromCc = cpNodeFrom.cp.circle.center;\r\n    let fromL = get_edge_direction_1.getEdgeDirection(cpNodeFrom);\r\n    let toCc = cpNodeTo.cp.circle.center;\r\n    let toL = get_edge_direction_1.getEdgeDirection(cpNodeTo.prevOnCircle);\r\n    let mid = line_line_intersection_1.lineLineIntersection(fromL, toL);\r\n    let c = flo_vector2d_1.fromTo(fromCc, toCc);\r\n    let twisted;\r\n    if (!mid) {\r\n        twisted = true;\r\n    }\r\n    else {\r\n        let a = flo_vector2d_1.fromTo(fromCc, mid);\r\n        let b = flo_vector2d_1.fromTo(toCc, mid);\r\n        twisted = flo_vector2d_1.dot(a, c) < 0 || flo_vector2d_1.dot(b, c) > 0;\r\n    }\r\n    if (!twisted) {\r\n        return [fromCc, mid, toCc];\r\n    }\r\n    let r = flo_vector2d_1.rotate90Degrees(c);\r\n    let w1 = flo_vector2d_1.fromTo(fromL[0], fromL[1]); // This is a unit vector\r\n    let w2 = flo_vector2d_1.fromTo(toL[0], toL[1]); // This is a unit vector\r\n    let d1 = Math.abs(flo_vector2d_1.cross(c, w1)) / (3 * 3);\r\n    let d2 = Math.abs(flo_vector2d_1.cross(c, w2)) / (3 * 3);\r\n    if (d1 > TOLERANCE_ADD_2PRONG || d2 > TOLERANCE_ADD_2PRONG) {\r\n        // TODO - not within tolerance - must add additional 2-prong\r\n        return [fromCc, toCc];\r\n    }\r\n    if (d1 > TOLERANCE_USE_LINE || d2 > TOLERANCE_USE_LINE) {\r\n        // approximate with cubic bezier\r\n        let m1 = flo_vector2d_1.interpolate(fromCc, toCc, 1 / 3);\r\n        let m2 = flo_vector2d_1.interpolate(fromCc, toCc, 2 / 3);\r\n        let v1 = flo_vector2d_1.translate(r, m1);\r\n        let v2 = flo_vector2d_1.translate(r, m2);\r\n        let l1 = [m1, v1];\r\n        let l2 = [m2, v2];\r\n        let mid1 = line_line_intersection_1.lineLineIntersection(fromL, l1);\r\n        let mid2 = line_line_intersection_1.lineLineIntersection(toL, l2);\r\n        return [fromCc, mid1, mid2, toCc];\r\n    }\r\n    // Within tolerance - approximate with a straight line.\r\n    return [fromCc, toCc];\r\n}\r\nexports.getCurveBetween = getCurveBetween;\r\n//# sourceMappingURL=smoothen.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/smoothen/smoothen.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/to-scale-axis/add-debug-info.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/to-scale-axis/add-debug-info.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction addDebugInfo(sat) {\r\n    if (typeof _debug_ === 'undefined') {\r\n        return;\r\n    }\r\n    let generated = _debug_.generated;\r\n    generated.elems.sat.push(sat);\r\n    let timing = generated.timing;\r\n    timing.sats[1] += performance.now() - timing.sats[0];\r\n}\r\nexports.addDebugInfo = addDebugInfo;\r\n//# sourceMappingURL=add-debug-info.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/to-scale-axis/add-debug-info.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/to-scale-axis/cull-non-cycles.js":
/*!************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/to-scale-axis/cull-non-cycles.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_leaves_1 = __webpack_require__(/*! ../get-leaves */ \"./node_modules/flo-mat/node/mat/get-leaves.js\");\r\nconst cp_node_1 = __webpack_require__(/*! ../../cp-node/cp-node */ \"./node_modules/flo-mat/node/cp-node/cp-node.js\");\r\n/**\r\n * Cull all edges not part of a cycle in the MAT planar graph.\r\n * @param cpStart The start CpNode which must reprsesent the maximal 3-prong\r\n * vertex.\r\n */\r\nfunction cullNonCycles(cpStart) {\r\n    let cpNodeKept = cpStart;\r\n    let leaves = get_leaves_1.getLeaves(cpStart);\r\n    while (leaves.length) {\r\n        let leaf = leaves.pop();\r\n        // Preserve topology - keep cycles.\r\n        if (leaf.isHoleClosing || leaf.isIntersection) {\r\n            continue;\r\n        }\r\n        let cpNode = leaf.next; // Turn around\r\n        while (true) {\r\n            cpNode = cpNode.next;\r\n            let cut = false;\r\n            let cp1 = cpNode.prevOnCircle;\r\n            if (cpNode.getProngCount() > 2) {\r\n                //let cp2 = cp1.prevOnCircle;\r\n                let cp2 = cpNode.nextOnCircle;\r\n                //if (cpStart === cpNode || cpStart === cp1 || cpStart === cp2) {\r\n                if (cp_node_1.CpNode.isOnSameCircle(cpNode, cpStart)) {\r\n                    cut = true; // We are at the max disk - cut whole edge\r\n                }\r\n                else if (cpNode.next === cp2) {\r\n                    cpNode = cp2;\r\n                }\r\n                else if (cp2.next !== cp1) {\r\n                    cut = true; // Cut whole edge\r\n                }\r\n            }\r\n            else if (cpNode.isTerminating() && !cpNode.isIntersection) {\r\n                cpNodeKept = cpNode;\r\n                return undefined;\r\n            }\r\n            if (cut) {\r\n                cp1.next = cpNode;\r\n                cpNode.prev = cp1;\r\n                cpNodeKept = cpNode;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return cpNodeKept;\r\n}\r\nexports.cullNonCycles = cullNonCycles;\r\n//# sourceMappingURL=cull-non-cycles.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/to-scale-axis/cull-non-cycles.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/to-scale-axis/cull.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/to-scale-axis/cull.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_leaves_1 = __webpack_require__(/*! ../get-leaves */ \"./node_modules/flo-mat/node/mat/get-leaves.js\");\r\nconst cp_node_1 = __webpack_require__(/*! ../../cp-node/cp-node */ \"./node_modules/flo-mat/node/cp-node/cp-node.js\");\r\n/**\r\n * Returns the set of Vertices passing the following test: walk the MAT tree and\r\n * keep all Vertices not in the current cull set and any Vertices that have a\r\n * non-culled node further down the line toward the tree leaves.\r\n * @param culls The CpNodes (referred to by circles) that should be culled.\r\n * @param maxCpNode The start CpNode which must reprsesent the maximal vertex.\r\n */\r\nfunction cull(culls, maxCpNode) {\r\n    let leaves = get_leaves_1.getLeaves(maxCpNode);\r\n    function getNonTrivialEdges(cpStart) {\r\n        let cp = cpStart;\r\n        let cps = [];\r\n        do {\r\n            if (cp.next !== cp.nextOnCircle) {\r\n                cps.push(cp);\r\n            }\r\n            cp = cp.nextOnCircle;\r\n        } while (cp !== cpStart.prevOnCircle);\r\n        return cps;\r\n    }\r\n    while (leaves.length) {\r\n        let leaf = leaves.pop();\r\n        // Preserve topology.\r\n        if (leaf.isHoleClosing || leaf.isIntersection) {\r\n            continue;\r\n        }\r\n        if (!culls.has(leaf.cp.circle)) {\r\n            continue;\r\n        }\r\n        let cpNode = leaf.next; // Turn around\r\n        while (true) {\r\n            cpNode = cpNode.next;\r\n            let cut = false;\r\n            let cp1 = cpNode.prevOnCircle;\r\n            if (!culls.has(cpNode.cp.circle)) {\r\n                // Cut off the edge once a non-cull has been reached.\r\n                cut = true;\r\n            }\r\n            else if (cp_node_1.CpNode.isOnSameCircle(cpNode, maxCpNode)) {\r\n                cut = true; // We are at the max disk - cut whole edge\r\n            }\r\n            else {\r\n                let cps = getNonTrivialEdges(cpNode);\r\n                if (cps.length === 1) {\r\n                    cpNode = cps[0];\r\n                }\r\n                else {\r\n                    cut = true;\r\n                }\r\n            }\r\n            if (cut) {\r\n                cp1.next = cpNode;\r\n                cpNode.prev = cp1;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.cull = cull;\r\n//# sourceMappingURL=cull.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/to-scale-axis/cull.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/trim-mat.js":
/*!***************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/trim-mat.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst mat_1 = __webpack_require__(/*! ../mat */ \"./node_modules/flo-mat/node/mat.js\");\r\nconst create_new_cp_tree_1 = __webpack_require__(/*! ./create-new-cp-tree */ \"./node_modules/flo-mat/node/mat/create-new-cp-tree.js\");\r\nconst cull_non_cycles_1 = __webpack_require__(/*! ./to-scale-axis/cull-non-cycles */ \"./node_modules/flo-mat/node/mat/to-scale-axis/cull-non-cycles.js\");\r\nconst clone_1 = __webpack_require__(/*! ../cp-node/clone */ \"./node_modules/flo-mat/node/cp-node/clone.js\");\r\n/**\r\n * Trims the given Medial Axis Transform so that only cycles remain. Similar to\r\n * toScaleAxis(mat, Number.POSITIVE_INFINITY).\r\n * @param mat The MAT to trim.\r\n */\r\nfunction trimMat(mat) {\r\n    let cpNode = cull_non_cycles_1.cullNonCycles(clone_1.clone(mat.cpNode));\r\n    if (!cpNode) {\r\n        return undefined;\r\n    }\r\n    let mat_ = new mat_1.Mat(cpNode, create_new_cp_tree_1.createNewCpTree(cpNode));\r\n    /*\r\n    if (typeof _debug_ !== 'undefined') {\r\n        let generated = _debug_.generated;\r\n        generated.elems.sat.push(mat_);\r\n    }\r\n    */\r\n    return mat_;\r\n}\r\nexports.trimMat = trimMat;\r\n//# sourceMappingURL=trim-mat.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/trim-mat.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/numerical/to-grid.js":
/*!********************************************************!*\
  !*** ./node_modules/flo-mat/node/numerical/to-grid.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\n/**\r\n * Sends a onto a fixed-spacing grid with 2**12 divisions.\r\n * @param a\r\n * @param expMax Max extent of grid in positive and negative directions - given\r\n * as 2^expMax\r\n */\r\nfunction toGrid(a, expMax, significantFigures) {\r\n    let expA = Math.floor(Math.log2(Math.abs(a)));\r\n    let expDif = expMax - expA;\r\n    let newSig = significantFigures - expDif + 1;\r\n    if (newSig <= 0) {\r\n        return 0;\r\n    }\r\n    let res = flo_numerical_1.reduceSignificand(a, newSig);\r\n    return res;\r\n}\r\nexports.toGrid = toGrid;\r\n//# sourceMappingURL=to-grid.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/numerical/to-grid.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/point-on-shape.js":
/*!*****************************************************!*\
  !*** ./node_modules/flo-mat/node/point-on-shape.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst curve_1 = __webpack_require__(/*! ./curve */ \"./node_modules/flo-mat/node/curve.js\");\r\nconst circle_1 = __webpack_require__(/*! ./circle */ \"./node_modules/flo-mat/node/circle.js\");\r\n/**\r\n * Represents a point on the shape boundary for which MAT vertex information\r\n * has not *necessarily* been calculated.\r\n */\r\nclass PointOnShape {\r\n    /**\r\n     * @param curve\tThe [[Curve]] on the shape boundary this points belong to.\r\n     * @param t The bezier parameter value on the curve to identify the point\r\n     * coordinates.\r\n     */\r\n    constructor(curve, t) {\r\n        this.curve = curve;\r\n        this.t = t;\r\n        // Cache\r\n        this.p_ = undefined;\r\n    }\r\n    /**\r\n     * The planar point coordinates of this [[PointOnShape]].\r\n     */\r\n    get p() {\r\n        return this.p_ === undefined\r\n            ? this.p_ = flo_bezier3_1.evaluate(this.curve.ps, this.t)\r\n            : this.p_;\r\n    }\r\n    /**\r\n     * Returns the osculating circle at this point of the curve.\r\n     * @param maxOsculatingCircleRadius If not Number.POSITIVE_INFINITY then the\r\n     * circle radius will be limited to this value.\r\n     * @param pos The [[PointOnShape]] identifying the point.\r\n     */\r\n    static getOsculatingCircle(maxOsculatingCircleRadius, pos) {\r\n        if (PointOnShape.isSharpCorner(pos)) {\r\n            return new circle_1.Circle(pos.p, 0);\r\n        }\r\n        let radius = PointOnShape.calcOsculatingCircleRadius(pos);\r\n        if (radius < 0) {\r\n            radius = Number.POSITIVE_INFINITY;\r\n        }\r\n        radius = Math.min(radius, maxOsculatingCircleRadius);\r\n        let ps = pos.curve.ps;\r\n        let t = pos.t;\r\n        let normal_ = flo_bezier3_1.normal(ps, t);\r\n        let p = flo_bezier3_1.evaluate(ps, t);\r\n        let circleCenter = [\r\n            p[0] + normal_[0] * radius,\r\n            p[1] + normal_[1] * radius\r\n        ];\r\n        return new circle_1.Circle(circleCenter, radius);\r\n    }\r\n    /**\r\n     * Calculates the order (to distinguish between points lying on top of each\r\n     * other) of the contact point if it is a dull corner.\r\n     * @param pos\r\n     * @hidden\r\n     */\r\n    static calcOrder(circle, pos) {\r\n        if (!PointOnShape.isCorner(pos)) {\r\n            return 0;\r\n        }\r\n        if (!PointOnShape.isDullCorner(pos)) {\r\n            return 0;\r\n        }\r\n        let corner = PointOnShape.getCorner(pos);\r\n        let n = flo_vector2d_1.rotateNeg90Degrees(corner.tangents[0]);\r\n        let v = flo_vector2d_1.toUnitVector(flo_vector2d_1.fromTo(pos.p, circle.center));\r\n        return -flo_vector2d_1.dot(n, v);\r\n    }\r\n}\r\nexports.PointOnShape = PointOnShape;\r\n/**\r\n * Calculates and returns the osculating circle radius of the bezier at a\r\n * specific t. If it is found to have negative or nearly zero radius\r\n * it is clipped to have positive radius so it can point into the shape.\r\n * @param ps\r\n * @param t\r\n * @hidden\r\n */\r\nPointOnShape.calcOsculatingCircleRadius = flo_memoize_1.memoize(function (pos) {\r\n    let ps = pos.curve.ps;\r\n    let t = pos.t;\r\n    let κ = -flo_bezier3_1.κ(ps, t);\r\n    // κ > 0 => bending inwards\r\n    return 1 / κ;\r\n});\r\n/**\r\n * Compares two [[PointOnShape]]s according to their cyclic ordering imposed\r\n * by their relative positions on the shape boundary.\r\n * @param a The first [[PointOnShape]].\r\n * @param b The second [[PointOnShape]].\r\n * @hidden\r\n */\r\nPointOnShape.compare = function (a, b) {\r\n    if (a === undefined || b === undefined) {\r\n        return undefined;\r\n    }\r\n    let res;\r\n    res = a.curve.idx - b.curve.idx;\r\n    if (res !== 0) {\r\n        return res;\r\n    }\r\n    res = a.t - b.t;\r\n    return res;\r\n};\r\n/**\r\n * Ignores order2 (used in hole-closing two-prongs only)\r\n * @hidden\r\n */\r\nPointOnShape.compareInclOrder = function (a, b, aOrder, bOrder) {\r\n    let res = PointOnShape.compare(a, b);\r\n    if (res === undefined) {\r\n        return undefined;\r\n    }\r\n    if (res !== 0) {\r\n        return res;\r\n    }\r\n    res = aOrder - bOrder;\r\n    return res;\r\n};\r\n/**\r\n * @hidden\r\n */\r\nPointOnShape.isCorner = function (pos) {\r\n    return (pos.t === 0 || pos.t === 1);\r\n};\r\n/**\r\n * @hidden\r\n */\r\nPointOnShape.getCorner = function (pos) {\r\n    return curve_1.Curve.getCornerAtEnd(pos.t === 1 ? pos.curve : pos.curve.prev);\r\n};\r\n/**\r\n * @hidden\r\n */\r\nPointOnShape.isSharpCorner = flo_memoize_1.memoize(function (pos) {\r\n    if (!PointOnShape.isCorner(pos)) {\r\n        return false;\r\n    }\r\n    let corner = PointOnShape.getCorner(pos);\r\n    return corner.isSharp;\r\n});\r\n/**\r\n * @hidden\r\n */\r\nPointOnShape.isDullCorner = flo_memoize_1.memoize(function (pos) {\r\n    if (!PointOnShape.isCorner(pos)) {\r\n        return false;\r\n    }\r\n    let corner = PointOnShape.getCorner(pos);\r\n    return corner.isDull;\r\n});\r\n/**\r\n * @hidden\r\n */\r\nPointOnShape.isQuiteSharpCorner = flo_memoize_1.memoize(function (pos) {\r\n    if (!PointOnShape.isCorner(pos)) {\r\n        return false;\r\n    }\r\n    let corner = PointOnShape.getCorner(pos);\r\n    return corner.isQuiteSharp;\r\n});\r\n/**\r\n * @hidden\r\n */\r\nPointOnShape.isQuiteDullCorner = flo_memoize_1.memoize(function (pos) {\r\n    if (!PointOnShape.isCorner(pos)) {\r\n        return false;\r\n    }\r\n    let corner = PointOnShape.getCorner(pos);\r\n    return corner.isQuiteDull;\r\n});\r\n/**\r\n * Returns a human-readable string of the given [[PointOnShape]].\r\n * For debugging only.\r\n * @hidden\r\n */\r\nPointOnShape.toHumanString = function (pos) {\r\n    return '' + pos.p[0] + ', ' + pos.p[1] +\r\n        ' | bz: ' + pos.curve.idx +\r\n        ' | t: ' + pos.t;\r\n};\r\n//# sourceMappingURL=point-on-shape.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/point-on-shape.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/fs/get-beziers-from-raw-paths.js":
/*!************************************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/fs/get-beziers-from-raw-paths.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst path_state_1 = __webpack_require__(/*! ../path-state */ \"./node_modules/flo-mat/node/svg/path-state.js\");\r\nconst z_1 = __webpack_require__(/*! ../path-segment/z */ \"./node_modules/flo-mat/node/svg/path-segment/z.js\");\r\nconst c_1 = __webpack_require__(/*! ../path-segment/c */ \"./node_modules/flo-mat/node/svg/path-segment/c.js\");\r\nconst s_1 = __webpack_require__(/*! ../path-segment/s */ \"./node_modules/flo-mat/node/svg/path-segment/s.js\");\r\nconst l_1 = __webpack_require__(/*! ../path-segment/l */ \"./node_modules/flo-mat/node/svg/path-segment/l.js\");\r\nconst h_1 = __webpack_require__(/*! ../path-segment/h */ \"./node_modules/flo-mat/node/svg/path-segment/h.js\");\r\nconst v_1 = __webpack_require__(/*! ../path-segment/v */ \"./node_modules/flo-mat/node/svg/path-segment/v.js\");\r\nconst q_1 = __webpack_require__(/*! ../path-segment/q */ \"./node_modules/flo-mat/node/svg/path-segment/q.js\");\r\nconst t_1 = __webpack_require__(/*! ../path-segment/t */ \"./node_modules/flo-mat/node/svg/path-segment/t.js\");\r\nconst a_1 = __webpack_require__(/*! ../path-segment/a */ \"./node_modules/flo-mat/node/svg/path-segment/a.js\");\r\nconst pathFs = {\r\n    a: a_1.a,\r\n    c: // elliptical arc\r\n    c_1.c,\r\n    h: // cubic bezier\r\n    h_1.h,\r\n    l: // horizontal line\r\n    l_1.l,\r\n    q: // line\r\n    q_1.q,\r\n    s: // quadratic bezier\r\n    s_1.s,\r\n    t: // cubic bezier (smooth)\r\n    t_1.t,\r\n    v: // quadratic bezier (smooth)\r\n    v_1.v,\r\n    z: // vertical line\r\n    z_1.z // close path\r\n};\r\n/**\r\n * Returns order 1, 2 and 3 beziers from the given SVG DOM element. If a path\r\n * data tag is not \"C, Q or L, etc\", i.e. if it is not an absolute bezier\r\n * coordinate then it is converted into one.\r\n * @param paths An SVG element\r\n */\r\nfunction getBeziersFromRawPaths(paths) {\r\n    if (paths.length === 0) {\r\n        return []; // A shape is not described   \r\n    }\r\n    if (paths[0].type.toLowerCase() !== 'm') {\r\n        throw new Error('Invalid SVG - every new path must start with an M or m.');\r\n    }\r\n    let s = new path_state_1.PathState();\r\n    let beziersArrays = [];\r\n    let beziers = [];\r\n    let prevType;\r\n    for (let i = 0; i < paths.length; i++) {\r\n        let pathSeg = paths[i];\r\n        let type = pathSeg.type.toLowerCase();\r\n        s.vals = pathSeg.values;\r\n        // If pathSeg was lowercase, it is relative - make absolute\r\n        if (pathSeg.type === type) {\r\n            if (type === 'v') {\r\n                s.vals[0] += s.p[1];\r\n            }\r\n            else if (type === 'a') {\r\n                s.vals[5] += s.p[0];\r\n                s.vals[6] += s.p[1];\r\n            }\r\n            else {\r\n                for (let i = 0; i < s.vals.length; i++) {\r\n                    s.vals[i] += s.p[i % 2];\r\n                }\r\n            }\r\n        }\r\n        if (type === 'm') {\r\n            if (beziers.length) {\r\n                // This is a subpath, close as if the previous command was a \r\n                // Z or z.\r\n                if (prevType !== 'z') {\r\n                    beziers.push(z_1.z(s));\r\n                }\r\n                // Start new path\r\n                beziersArrays.push(beziers);\r\n                beziers = [];\r\n            }\r\n            s.initialPoint = s.p = s.vals;\r\n            prevType = type;\r\n            continue;\r\n        }\r\n        let f = pathFs[type];\r\n        if (!f) {\r\n            throw new Error('Invalid SVG - command not recognized.');\r\n        }\r\n        let ps = f(s);\r\n        s.p = ps[ps.length - 1]; // Update current point\r\n        beziers.push(ps);\r\n        prevType = type;\r\n    }\r\n    if (beziers.length) {\r\n        // This is a subpath, close as if the previous command was a Z or z.\r\n        if (prevType !== 'z') {\r\n            beziers.push(z_1.z(s));\r\n        }\r\n        // Start new path\r\n        beziersArrays.push(beziers);\r\n    }\r\n    return beziersArrays;\r\n}\r\nexports.getBeziersFromRawPaths = getBeziersFromRawPaths;\r\n//# sourceMappingURL=get-beziers-from-raw-paths.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/fs/get-beziers-from-raw-paths.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/fs/get-extreme.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/fs/get-extreme.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_shape_bounds_1 = __webpack_require__(/*! ./get-shape-bounds */ \"./node_modules/flo-mat/node/svg/fs/get-shape-bounds.js\");\r\n/**\r\n * Returns the max extreme point coordinate value for the given shape. This is\r\n * used for floating point tolerance calculations.\r\n * @param loops\r\n */\r\nfunction getExtreme(loops) {\r\n    let bounds = get_shape_bounds_1.getShapeBounds(loops);\r\n    return Math.max(Math.abs(bounds.minX.p[0]), Math.abs(bounds.minY.p[1]), Math.abs(bounds.maxX.p[0]), Math.abs(bounds.maxY.p[1]));\r\n}\r\nexports.getExtreme = getExtreme;\r\n//# sourceMappingURL=get-extreme.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/fs/get-extreme.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/fs/get-loop-bounds.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/fs/get-loop-bounds.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nconst INF = Number.POSITIVE_INFINITY;\r\nlet getLoopBounds = /*memoize*/ (function (loop) {\r\n    let extremes = [\r\n        [\r\n            { bezier: undefined, t: undefined, val: INF },\r\n            { bezier: undefined, t: undefined, val: INF }\r\n        ],\r\n        [\r\n            { bezier: undefined, t: undefined, val: -INF },\r\n            { bezier: undefined, t: undefined, val: -INF }\r\n        ]\r\n    ];\r\n    loop.curves.forEach(function (curve) {\r\n        let ps = curve.ps;\r\n        let bounds = flo_bezier3_1.getBounds(ps);\r\n        for (let i = 0; i < 2; i++) {\r\n            for (let j = 0; j < 2; j++) {\r\n                let v = bounds.box[i][j];\r\n                let m = i === 0 ? -1 : 1; // min or max?\r\n                let x = extremes[i][j].val;\r\n                if (m * v > m * x || (v === x && bounds.ts[i][j] > extremes[i][j].t)) {\r\n                    extremes[i][j] = {\r\n                        bezier: curve,\r\n                        t: bounds.ts[i][j],\r\n                        val: v\r\n                    };\r\n                }\r\n            }\r\n        }\r\n    });\r\n    return {\r\n        minX: new point_on_shape_1.PointOnShape(extremes[0][0].bezier, extremes[0][0].t),\r\n        minY: new point_on_shape_1.PointOnShape(extremes[0][1].bezier, extremes[0][1].t),\r\n        maxX: new point_on_shape_1.PointOnShape(extremes[1][0].bezier, extremes[1][0].t),\r\n        maxY: new point_on_shape_1.PointOnShape(extremes[1][1].bezier, extremes[1][1].t)\r\n    };\r\n});\r\nexports.getLoopBounds = getLoopBounds;\r\n//# sourceMappingURL=get-loop-bounds.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/fs/get-loop-bounds.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/fs/get-min-y-pos.js":
/*!***********************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/fs/get-min-y-pos.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_loop_bounds_1 = __webpack_require__(/*! ./get-loop-bounds */ \"./node_modules/flo-mat/node/svg/fs/get-loop-bounds.js\");\r\n/**\r\n * Get topmost PointOnShape the given loop.\r\n */\r\nfunction getMinYPos(loop) {\r\n    let pos = get_loop_bounds_1.getLoopBounds(loop).minY;\r\n    if (typeof _debug_ !== 'undefined') {\r\n        _debug_.generated.elems.minY.push(pos);\r\n    }\r\n    return pos;\r\n}\r\nexports.getMinYPos = getMinYPos;\r\n//# sourceMappingURL=get-min-y-pos.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/fs/get-min-y-pos.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/fs/get-shape-bounds.js":
/*!**************************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/fs/get-shape-bounds.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\r\nconst get_loop_bounds_1 = __webpack_require__(/*! ./get-loop-bounds */ \"./node_modules/flo-mat/node/svg/fs/get-loop-bounds.js\");\r\nlet getShapeBounds = flo_memoize_1.memoize(function (loops) {\r\n    let minX_ = Number.POSITIVE_INFINITY;\r\n    let maxX_ = Number.NEGATIVE_INFINITY;\r\n    let minY_ = Number.POSITIVE_INFINITY;\r\n    let maxY_ = Number.NEGATIVE_INFINITY;\r\n    let minX;\r\n    let maxX;\r\n    let minY;\r\n    let maxY;\r\n    for (let loop of loops) {\r\n        let bounds = get_loop_bounds_1.getLoopBounds(loop);\r\n        if (bounds.minX.p[0] < minX_) {\r\n            minX = bounds.minX;\r\n            minX_ = bounds.minX.p[0];\r\n        }\r\n        if (bounds.maxX.p[0] > maxX_) {\r\n            maxX = bounds.maxX;\r\n            maxX_ = bounds.maxX.p[0];\r\n        }\r\n        if (bounds.minY.p[1] < minY_) {\r\n            minY = bounds.minY;\r\n            minY_ = bounds.minY.p[1];\r\n        }\r\n        if (bounds.maxY.p[1] > maxY_) {\r\n            maxY = bounds.maxY;\r\n            maxY_ = bounds.maxY.p[1];\r\n        }\r\n    }\r\n    return { minX, minY, maxX, maxY };\r\n});\r\nexports.getShapeBounds = getShapeBounds;\r\nlet getShapesBounds = flo_memoize_1.memoize(function (loopss) {\r\n    let minX_ = Number.POSITIVE_INFINITY;\r\n    let maxX_ = Number.NEGATIVE_INFINITY;\r\n    let minY_ = Number.POSITIVE_INFINITY;\r\n    let maxY_ = Number.NEGATIVE_INFINITY;\r\n    let minX;\r\n    let maxX;\r\n    let minY;\r\n    let maxY;\r\n    for (let loops of loopss) {\r\n        let bounds = getShapeBounds(loops);\r\n        if (bounds.minX.p[0] < minX_) {\r\n            minX = bounds.minX;\r\n            minX_ = bounds.minX.p[0];\r\n        }\r\n        if (bounds.maxX.p[0] > maxX_) {\r\n            maxX = bounds.maxX;\r\n            maxX_ = bounds.maxX.p[0];\r\n        }\r\n        if (bounds.minY.p[1] < minY_) {\r\n            minY = bounds.minY;\r\n            minY_ = bounds.minY.p[1];\r\n        }\r\n        if (bounds.maxY.p[1] > maxY_) {\r\n            maxY = bounds.maxY;\r\n            maxY_ = bounds.maxY.p[1];\r\n        }\r\n    }\r\n    return { minX, minY, maxX, maxY };\r\n});\r\nexports.getShapesBounds = getShapesBounds;\r\n//# sourceMappingURL=get-shape-bounds.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/fs/get-shape-bounds.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/fs/is-path-positively-oriented.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/fs/is-path-positively-oriented.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\r\nconst curve_1 = __webpack_require__(/*! ../../curve */ \"./node_modules/flo-mat/node/curve.js\");\r\nconst get_loop_bounds_1 = __webpack_require__(/*! ./get-loop-bounds */ \"./node_modules/flo-mat/node/svg/fs/get-loop-bounds.js\");\r\n/**\r\n * Returns true if the given beizer loop is positively orientated, false\r\n * otherwise. Careful! Checks leftmost part of loop so twisted complex paths\r\n * may give an ambiguous orientation.\r\n */\r\nlet isPathPositivelyOrientated = flo_memoize_1.memoize(function (loop) {\r\n    let extreme = get_loop_bounds_1.getLoopBounds(loop).minY;\r\n    let t = extreme.t;\r\n    let curve;\r\n    if (t === 0) {\r\n        curve = extreme.curve.prev;\r\n        t = 1;\r\n    }\r\n    else {\r\n        curve = extreme.curve;\r\n    }\r\n    let ps = curve.ps;\r\n    let tan = flo_bezier3_1.tangent(ps)(t);\r\n    if (t !== 1) {\r\n        // Not a sharp corner\r\n        return tan[0] > 0;\r\n    }\r\n    let psNext = curve.next.ps;\r\n    let tanNext = flo_bezier3_1.tangent(psNext)(0);\r\n    if (tan[0] * tanNext[0] > 0) {\r\n        // Both tangents points left or both points right.\r\n        return tan[0] > 0;\r\n    }\r\n    let corner = curve_1.getCorner(ps, psNext);\r\n    return corner.isDull;\r\n});\r\nexports.isPathPositivelyOrientated = isPathPositivelyOrientated;\r\n//# sourceMappingURL=is-path-positively-oriented.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/fs/is-path-positively-oriented.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/fs/simplify-paths/complete-loop.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/fs/simplify-paths/complete-loop.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst get_next_x_1 = __webpack_require__(/*! ./get-next-x */ \"./node_modules/flo-mat/node/svg/fs/simplify-paths/get-next-x.js\");\r\nfunction completeLoop(intersections, takenXs, xStack, loopTree, x) {\r\n    let beziers = [];\r\n    let reversed = (loopTree.windingNum === 0 && loopTree.orientation === -1) ||\r\n        (loopTree.windingNum !== 0 && loopTree.orientation === +1);\r\n    let pos = reversed ? x.pos : x.opposite.pos;\r\n    let startBez = pos.curve;\r\n    let startT = pos.t;\r\n    let curBez = startBez;\r\n    let curT = startT;\r\n    let fromX = x.isDummy\r\n        ? undefined\r\n        : reversed ? x.opposite : x;\r\n    let wasOnX = true;\r\n    while (true) {\r\n        let xs = intersections.get(curBez);\r\n        let x_ = xs ? get_next_x_1.getNextX(xs, curT, !reversed, wasOnX) : undefined;\r\n        // Add a bezier to the component loop.\r\n        if (x_) {\r\n            // We are at an intersection\r\n            wasOnX = true;\r\n            if (curT !== x_.pos.t) {\r\n                let ps = reversed\r\n                    ? flo_bezier3_1.reverse(flo_bezier3_1.fromTo(curBez.ps)(x_.pos.t, curT))\r\n                    : flo_bezier3_1.fromTo(curBez.ps)(curT, x_.pos.t);\r\n                beziers.push(ps);\r\n                addXOutPs(reversed, fromX, ps);\r\n                fromX = x_;\r\n            }\r\n            // Move onto next bezier\r\n            curBez = x_.opposite.pos.curve; // Switch to other path's bezier\r\n            curT = x_.opposite.pos.t; // ...\r\n            let _x_ = reversed ? x_.opposite : x_;\r\n            _x_.loopTree = loopTree;\r\n            if (!takenXs.has(_x_.opposite)) {\r\n                xStack.push(_x_.opposite);\r\n            }\r\n            takenXs.add(_x_); // Mark this intersection as taken\r\n        }\r\n        else {\r\n            wasOnX = false;\r\n            let t = reversed ? 0 : 1;\r\n            if (curT !== t) {\r\n                let ps = reversed\r\n                    ? flo_bezier3_1.reverse(flo_bezier3_1.fromTo(curBez.ps)(0, curT))\r\n                    : flo_bezier3_1.fromTo(curBez.ps)(curT, 1);\r\n                beziers.push(ps);\r\n                addXOutPs(reversed, fromX, ps);\r\n                fromX = undefined;\r\n            }\r\n            // Move onto next bezier on current path\r\n            curBez = reversed ? curBez.prev : curBez.next;\r\n            curT = reversed ? 1 : 0;\r\n        }\r\n        if (curBez === startBez && curT === startT) {\r\n            break;\r\n        }\r\n    }\r\n    return beziers;\r\n}\r\nexports.completeLoop = completeLoop;\r\nfunction addXOutPs(reversed, fromX, ps) {\r\n    if (fromX && !fromX.isDummy) {\r\n        let x = reversed ? fromX : fromX.opposite;\r\n        x.outPs = ps;\r\n        fromX = undefined;\r\n        //_debug_.fs.draw.bezier(_debug_.generated.g, ps, 'red thin10 nofill');\r\n    }\r\n}\r\n//# sourceMappingURL=complete-loop.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/fs/simplify-paths/complete-loop.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/fs/simplify-paths/complete-path.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/fs/simplify-paths/complete-path.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst loop_1 = __webpack_require__(/*! ../../../loop/loop */ \"./node_modules/flo-mat/node/loop/loop.js\");\r\nconst complete_loop_1 = __webpack_require__(/*! ./complete-loop */ \"./node_modules/flo-mat/node/svg/fs/simplify-paths/complete-loop.js\");\r\nconst get_initial_x_1 = __webpack_require__(/*! ./get-initial-x */ \"./node_modules/flo-mat/node/svg/fs/simplify-paths/get-initial-x.js\");\r\nconst get_loop_metrics_1 = __webpack_require__(/*! ./get-loop-metrics */ \"./node_modules/flo-mat/node/svg/fs/simplify-paths/get-loop-metrics.js\");\r\n/**\r\n *\r\n * @param intersections\r\n * @param loopsTaken\r\n * @param loop\r\n * @param parent\r\n */\r\nfunction completePath(intersections, loopsTaken, parent, loop) {\r\n    // Each loop generated by xs in xStack will give rise to one componentLoop. \r\n    // The initial intersection in the stack is a dummy.\r\n    /** Intersection stack */\r\n    let initialX = get_initial_x_1.getInitialX(intersections, parent, loop);\r\n    let curve = initialX.pos.curve;\r\n    let xs = intersections.get(curve) || [];\r\n    if (xs.length === 0) {\r\n        intersections.set(curve, xs);\r\n    }\r\n    xs.push(initialX);\r\n    let xStack = [initialX];\r\n    let takenXs = new Set(); // Taken intersections\r\n    while (xStack.length) {\r\n        let x = xStack.pop();\r\n        loopsTaken.add(x.pos.curve.loop);\r\n        if (takenXs.has(x)) {\r\n            continue;\r\n        }\r\n        let loopTree = get_loop_metrics_1.getLoopMetrics(x);\r\n        loopTree.beziers = complete_loop_1.completeLoop(intersections, takenXs, xStack, loopTree, x);\r\n        loopTree.loop = loop_1.Loop.fromCubicBeziers(loopTree.beziers);\r\n    }\r\n}\r\nexports.completePath = completePath;\r\n//# sourceMappingURL=complete-path.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/fs/simplify-paths/complete-path.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/fs/simplify-paths/get-initial-x.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/fs/simplify-paths/get-initial-x.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nconst is_path_positively_oriented_1 = __webpack_require__(/*! ../../fs/is-path-positively-oriented */ \"./node_modules/flo-mat/node/svg/fs/is-path-positively-oriented.js\");\r\nconst get_loop_bounds_1 = __webpack_require__(/*! ../get-loop-bounds */ \"./node_modules/flo-mat/node/svg/fs/get-loop-bounds.js\");\r\nconst x_1 = __webpack_require__(/*! ../../../x/x */ \"./node_modules/flo-mat/node/x/x.js\");\r\n/**\r\n * Get initial intersection which is really a dummy intersection.\r\n * @param loop\r\n * @param parent\r\n */\r\nfunction getInitialX(intersections, parent, loop) {\r\n    let dummyLoop = {\r\n        parent,\r\n        children: new Set(),\r\n        beziers: [],\r\n        loop: undefined,\r\n        orientation: is_path_positively_oriented_1.isPathPositivelyOrientated(loop) ? -1 : +1,\r\n        windingNum: parent.windingNum\r\n    };\r\n    let pos = get_loop_bounds_1.getLoopBounds(loop).minY;\r\n    let xs = intersections.get(pos.curve);\r\n    // If no intersections on this curve, just start at 0\r\n    if (!xs) {\r\n        pos = new point_on_shape_1.PointOnShape(pos.curve, 0);\r\n    }\r\n    let x = new x_1.X(pos, true, undefined, // will be set just below\r\n    dummyLoop);\r\n    x.opposite = x;\r\n    return x;\r\n}\r\nexports.getInitialX = getInitialX;\r\n//# sourceMappingURL=get-initial-x.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/fs/simplify-paths/get-initial-x.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/fs/simplify-paths/get-intersections.js":
/*!******************************************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/fs/simplify-paths/get-intersections.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst x_1 = __webpack_require__(/*! ../../../x/x */ \"./node_modules/flo-mat/node/x/x.js\");\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nconst pair_set_1 = __webpack_require__(/*! ./pair-set */ \"./node_modules/flo-mat/node/svg/fs/simplify-paths/pair-set.js\");\r\nconst sweep_line_1 = __webpack_require__(/*! ../../../sweep-line/sweep-line */ \"./node_modules/flo-mat/node/sweep-line/sweep-line.js\");\r\nconst are_boxes_intersecting_1 = __webpack_require__(/*! ../../../sweep-line/are-boxes-intersecting */ \"./node_modules/flo-mat/node/sweep-line/are-boxes-intersecting.js\");\r\n// TODO - DELTA is somewhat arbitrary\r\nconst DELTA = 1e-10;\r\n/**\r\n * Find and return all intersections on all given loops.\r\n * @param loops\r\n */\r\nfunction getIntersections(loops) {\r\n    // intersection <=> X\r\n    let { boxes, boxInfoMap } = getBoxInfos(loops);\r\n    //let boxIntersections = findBbIntersections(boxes);\r\n    let boxIntersections = sweep_line_1.sweepLine(boxes, box => Math.min(box[0][0], box[1][0]), box => Math.max(box[0][0], box[1][0]), are_boxes_intersecting_1.areBoxesIntersecting(true));\r\n    //console.log(boxIntersections);\r\n    /*\r\n    if (typeof _debug_ !== 'undefined') {\r\n        let g = document.getElementsByTagName('g')[0];\r\n        for (let boxIntersection of boxIntersections) {\r\n            let [box1, box2] = boxIntersection;\r\n            let box1_ = [[box1[0][0], box1[0][1]], [box1[1][0], box1[1][1]]];\r\n            let box2_ = [[box2[0][0], box2[0][1]], [box2[1][0], box2[1][1]]];\r\n            if (box1_[0][0] === box1_[1][0]) {\r\n                box1_[1][0] += 1;\r\n            }\r\n            if (box1_[0][1] === box1_[1][1]) {\r\n                box1_[1][1] += 1;\r\n            }\r\n            if (box2_[0][0] === box2_[1][0]) {\r\n                box2_[1][0] += 1;\r\n            }\r\n            if (box2_[0][1] === box2_[1][1]) {\r\n                box2_[1][1] += 1;\r\n            }\r\n            _debug_.fs.draw.rect(g, box1_, 'red thin10 nofill');\r\n            _debug_.fs.draw.rect(g, box2_, 'green thin10 nofill');\r\n        }\r\n    }\r\n    */\r\n    // Check curve intersection amongst possibilities\r\n    /** A map from each curve to its intersectings */\r\n    let xMap = new Map();\r\n    let checkedPairs = new Map();\r\n    for (let i = 0; i < boxIntersections.length; i++) {\r\n        let [box1, box2] = boxIntersections[i];\r\n        let curves = [\r\n            boxInfoMap.get(box1).curve,\r\n            boxInfoMap.get(box2).curve,\r\n        ];\r\n        if (pair_set_1.pairSet_has(checkedPairs, curves)) {\r\n            continue;\r\n        }\r\n        pair_set_1.pairSet_add(checkedPairs, curves);\r\n        let pss = curves.map(curve => curve.ps);\r\n        let tPairs = flo_bezier3_1.bezier3Intersection(pss[0], pss[1], 1e-12);\r\n        if (!tPairs.length) {\r\n            continue;\r\n        }\r\n        for (let tPair of tPairs) {\r\n            let curves_ = confirmIntersection(checkedPairs, curves, tPair);\r\n            if (curves_ === undefined) {\r\n                continue;\r\n            }\r\n            let xs = [];\r\n            for (let j of [0, 1]) {\r\n                let curve = curves_[j];\r\n                let x = new x_1.X(new point_on_shape_1.PointOnShape(curve, tPair[j]));\r\n                if (typeof _debug_ !== 'undefined') {\r\n                    if (j === 0) {\r\n                        _debug_.generated.elems.intersection.push(x);\r\n                    }\r\n                }\r\n                // Get intersections stored at this curve\r\n                let curveXs = xMap.get(curve) || [];\r\n                if (!curveXs.length) {\r\n                    xMap.set(curve, curveXs);\r\n                }\r\n                // Add an intersection to this curve\r\n                curveXs.push(x);\r\n                xs.push(x);\r\n            }\r\n            xs[0].opposite = xs[1];\r\n            xs[1].opposite = xs[0];\r\n        }\r\n    }\r\n    //console.log(`X.lenth: ${_debug_.generated.elems.intersection.length}`);\r\n    /*\r\n    {\r\n        let xs = _debug_.generated.elems.intersection;\r\n        for (let x of xs) {\r\n            console.log(x.pos.p);\r\n        }\r\n    }\r\n    */\r\n    //console.log(xMap)\r\n    return xMap;\r\n}\r\nexports.getIntersections = getIntersections;\r\n/**\r\n *\r\n */\r\nfunction confirmIntersection(checkedPairs, curves, tPair) {\r\n    let curves_ = curves.slice();\r\n    // TODO - the below check is temporary - there is a better way\r\n    // TODO - eliminate the fact that intersections are found twice\r\n    if (((Math.abs(tPair[0]) < DELTA && Math.abs(tPair[1] - 1) < DELTA) ||\r\n        (Math.abs(tPair[0] - 1) < DELTA && Math.abs(tPair[1]) < DELTA) ||\r\n        (Math.abs(tPair[0]) < DELTA && Math.abs(tPair[1]) < DELTA) ||\r\n        (Math.abs(tPair[0] - 1) < DELTA && Math.abs(tPair[1] - 1) < DELTA)) &&\r\n        (curves_[0].next === curves_[1] || curves_[1].next === curves_[0])) {\r\n        return undefined;\r\n    }\r\n    if (Math.abs(tPair[0]) < DELTA) {\r\n        // If the intersection occurs near the start, move it to the start\r\n        // so we don't have a very small bezier piece left.\r\n        tPair[0] = 0;\r\n    }\r\n    if (Math.abs(tPair[1]) < DELTA) {\r\n        // If the intersection occurs near the start, move it to the start\r\n        // so we don't have a very small bezier piece left.\r\n        tPair[1] = 0;\r\n    }\r\n    if (Math.abs(tPair[0] - 1) < DELTA) {\r\n        // If the intersection occurs at the end, move it to the start\r\n        // so we don't have a very small bezier piece left.\r\n        curves_[0] = curves_[0].next;\r\n        tPair[0] = 0;\r\n        // Recheck\r\n        if (pair_set_1.pairSet_has(checkedPairs, [curves_[0], curves_[1]])) {\r\n            return undefined;\r\n        }\r\n        // Above seems wrong, there will already be an intersection at the\r\n        // start so no need to move it.\r\n        return undefined;\r\n    }\r\n    if (Math.abs(tPair[1] - 1) < DELTA) {\r\n        // If the intersection occurs at the end, move it to the start\r\n        // so we don't have a very small bezier piece left.\r\n        curves_[1] = curves_[1].next;\r\n        tPair[1] = 0;\r\n        // Recheck\r\n        if (pair_set_1.pairSet_has(checkedPairs, [curves_[0], curves_[1]])) {\r\n            return undefined;\r\n        }\r\n        // Above seems wrong, there will already be an intersection at the\r\n        // start so no need to move it.\r\n        return undefined;\r\n    }\r\n    return curves_;\r\n}\r\n/**\r\n * Returns an array of lines of the bounding hulls of the Loop beziers' control\r\n * points including a map that maps each line to its hull, path and curve.\r\n * @param loops An array of Loops\r\n */\r\nfunction getBoxInfos(loops) {\r\n    /** Map that maps a line segment to some info. */\r\n    let boxInfoMap = new Map();\r\n    let boxes = [];\r\n    // Get lines making up the hulls of the paths\r\n    for (let loop of loops) {\r\n        loop.curves.forEach(function (curve) {\r\n            let box = flo_bezier3_1.getBoundingBox(curve.ps);\r\n            boxes.push(box);\r\n            boxInfoMap.set(box, { box, loop, curve });\r\n        });\r\n    }\r\n    return { boxes, boxInfoMap };\r\n}\r\n//# sourceMappingURL=get-intersections.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/fs/simplify-paths/get-intersections.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/fs/simplify-paths/get-loop-metrics.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/fs/simplify-paths/get-loop-metrics.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\n/**\r\n *\r\n * @param x The intersection\r\n */\r\nfunction getLoopMetrics(x) {\r\n    let oppositeLoopTree = x.opposite.loopTree;\r\n    let oppositeOrientation = oppositeLoopTree.orientation;\r\n    let oppositeWindingNum = oppositeLoopTree.windingNum;\r\n    // Left or right turning? - The current X\r\n    let oldInBez = x.opposite.pos.curve.ps;\r\n    let oldOutBez = x.pos.curve.ps;\r\n    let orientation;\r\n    let windingNum;\r\n    let parent;\r\n    if (oldInBez !== oldOutBez) {\r\n        let tanIn = flo_bezier3_1.tangent(oldInBez, x.opposite.pos.t);\r\n        let tanOut = flo_bezier3_1.tangent(oldOutBez, x.pos.t);\r\n        // TODO - if cross product is close to 0 check second derivatives (the \r\n        // same can be done at cusps in the mat code). E.g. a figure eight with \r\n        // coinciding bezier stretches may cause floating point instability.\r\n        let isLeft = flo_vector2d_1.cross(tanIn, tanOut) > 0;\r\n        let isTwist = (isLeft && oppositeOrientation === +1) ||\r\n            (!isLeft && oppositeOrientation === -1);\r\n        let windingNumberInc = isTwist\r\n            ? -2 * oppositeOrientation\r\n            : oppositeOrientation;\r\n        orientation = isTwist\r\n            ? -1 * oppositeOrientation\r\n            : +1 * oppositeOrientation;\r\n        windingNum = oppositeWindingNum + windingNumberInc;\r\n        parent = isTwist ? oppositeLoopTree.parent : oppositeLoopTree;\r\n    }\r\n    else {\r\n        // This is the first loop's start - it's a special case\r\n        orientation = oppositeOrientation === +1 ? -1 : +1;\r\n        windingNum = oppositeWindingNum + orientation;\r\n        parent = oppositeLoopTree.parent;\r\n    }\r\n    let iLoopTree = {\r\n        parent,\r\n        children: new Set(),\r\n        beziers: undefined,\r\n        loop: undefined,\r\n        orientation,\r\n        windingNum\r\n    };\r\n    parent.children.add(iLoopTree);\r\n    return iLoopTree;\r\n}\r\nexports.getLoopMetrics = getLoopMetrics;\r\n//# sourceMappingURL=get-loop-metrics.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/fs/simplify-paths/get-loop-metrics.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/fs/simplify-paths/get-next-x.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/fs/simplify-paths/get-next-x.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n *\r\n * @param xs An array of intersections on the curve\r\n * @param curT The current t value\r\n * @param forwards If true go forwards else go backwards\r\n */\r\nfunction getNextX(xs, curT, forwards, wasOnX) {\r\n    let bestX = undefined;\r\n    let bestT = Number.POSITIVE_INFINITY;\r\n    for (let i = 0; i < xs.length; i++) {\r\n        let x = xs[i];\r\n        let t = x.pos.t;\r\n        let deltaT = forwards\r\n            ? t - curT\r\n            : curT - t;\r\n        if ((deltaT > 0 || (deltaT === 0 && !wasOnX)) && deltaT < bestT) {\r\n            bestX = x;\r\n            bestT = deltaT;\r\n        }\r\n    }\r\n    return bestX;\r\n}\r\nexports.getNextX = getNextX;\r\n/**\r\n *\r\n * @param xs An array of intersections on the curve\r\n * @param t The current t value\r\n */\r\nfunction getThisX(xs, t) {\r\n    for (let i = 0; i < xs.length; i++) {\r\n        let x = xs[i];\r\n        if (x.pos.t - t === 0) {\r\n            return x;\r\n        }\r\n    }\r\n}\r\nexports.getThisX = getThisX;\r\n//# sourceMappingURL=get-next-x.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/fs/simplify-paths/get-next-x.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/fs/simplify-paths/get-tightest-containing-loop.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/fs/simplify-paths/get-tightest-containing-loop.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst is_loop_in_loop_1 = __webpack_require__(/*! ./is-loop-in-loop */ \"./node_modules/flo-mat/node/svg/fs/simplify-paths/is-loop-in-loop.js\");\r\n/**\r\n *\r\n * @param root\r\n * @param loop\r\n */\r\nfunction getTightestContainingLoop(root, loop) {\r\n    let containingLoop = undefined;\r\n    let stack = [root];\r\n    while (stack.length) {\r\n        let loopTree = stack.pop();\r\n        f(loopTree);\r\n    }\r\n    //console.log(containingLoop)\r\n    return containingLoop;\r\n    function f(parent) {\r\n        if (parent === root || is_loop_in_loop_1.isLoopInLoop([loop, parent.loop])) {\r\n            containingLoop = parent;\r\n            for (let child of parent.children) {\r\n                stack.push(child);\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.getTightestContainingLoop = getTightestContainingLoop;\r\n//# sourceMappingURL=get-tightest-containing-loop.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/fs/simplify-paths/get-tightest-containing-loop.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/fs/simplify-paths/is-loop-in-loop.js":
/*!****************************************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/fs/simplify-paths/is-loop-in-loop.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nconst get_loop_bounds_1 = __webpack_require__(/*! ../get-loop-bounds */ \"./node_modules/flo-mat/node/svg/fs/get-loop-bounds.js\");\r\nconst DELTA = 1e-6;\r\n/**\r\n * Returns true if the first loop is contained wholly within the second. At this\r\n * stage we already know the loop is either wholly contained inside the loop\r\n * or is wholly outside.\r\n * @param loops\r\n */\r\nfunction isLoopInLoop(loops) {\r\n    let i = 0;\r\n    let seed = 1231; // Just some value\r\n    do {\r\n        i++;\r\n        // This gets us a predictable random number between 0 and 1;\r\n        let rand1 = flo_poly_1.flatCoefficients(1, 0, 1, seed);\r\n        let t = rand1.p[0];\r\n        seed = rand1.seed; // Get next seed.\r\n        // This gets us a predictable random number roughly between 0 and the \r\n        // number of curves in the loop.\r\n        let curveCount = loops[0].curves.length;\r\n        let rand2 = flo_poly_1.flatCoefficients(1, 0, curveCount, seed);\r\n        let idx = Math.floor(rand2.p[0]);\r\n        seed = rand2.seed; // Get next seed.\r\n        let ps = loops[0].curves[idx].ps;\r\n        let p = flo_bezier3_1.evaluate(ps, t);\r\n        let res = f(loops, p);\r\n        if (res !== undefined) {\r\n            return res;\r\n        }\r\n    } while (i < 10);\r\n    return undefined; // There's no chance we'll get up to this point.\r\n    function f(loops, p) {\r\n        if (isLoopNotInLoop(loops)) {\r\n            return false;\r\n        }\r\n        //let g = _debug_.generated.g;\r\n        //let bounds = getShapeBounds(loops);\r\n        //_debug_.fs.draw.dot(g, p, (bounds.maxX.p[0] - bounds.minX.p[0]) * 0.002, 'blue');\r\n        let intersections = getAxisAlignedRayLoopIntersections(loops[1], p, 'left');\r\n        //console.log(intersections, intersections.length % 2 !== 0);\r\n        if (intersections) {\r\n            return intersections.length % 2 !== 0;\r\n        }\r\n    }\r\n}\r\nexports.isLoopInLoop = isLoopInLoop;\r\n/**\r\n * Returns true if the first loop is not wholly within the second. The converse\r\n * is not necessarily true. It is assumed the loops don't intersect.\r\n * @param loops\r\n */\r\nfunction isLoopNotInLoop(loops) {\r\n    let loopBoundss = loops.map(get_loop_bounds_1.getLoopBounds);\r\n    let boundss = loopBoundss.map(loopBound => {\r\n        return {\r\n            minX: loopBound.minX.p[0],\r\n            maxX: loopBound.maxX.p[0],\r\n            minY: loopBound.minY.p[1],\r\n            maxY: loopBound.maxY.p[1]\r\n        };\r\n    });\r\n    return (boundss[0].minX < boundss[1].minX ||\r\n        boundss[0].maxX > boundss[1].maxX ||\r\n        boundss[0].minY < boundss[1].minY ||\r\n        boundss[0].maxY > boundss[1].maxY);\r\n}\r\n//enum Dir { LEFT, RIGHT, UP, DOWN }\r\n/**\r\n *\r\n * @param p The point where the horizontal ray starts\r\n * @param toLeft The ray to the left of this point (else right)\r\n * @param loop A loop of curves\r\n */\r\nfunction getAxisAlignedRayLoopIntersections(loop, p, dir) {\r\n    let [x, y] = p;\r\n    let curves = loop.curves;\r\n    let possAll = [];\r\n    for (let i = 0; i < curves.length; i++) {\r\n        let curve = curves[i];\r\n        let ps = curve.ps;\r\n        //------------------------------------------------------/\r\n        //---- Check if ray intersects bezier bounding box -----/\r\n        //------------------------------------------------------/\r\n        let [[minX, minY], [maxX, maxY]] = flo_bezier3_1.getBoundingBox(ps);\r\n        let notIntersecting = ((dir === 'left' || dir === 'right') && (minY > y || maxY < y)) ||\r\n            ((dir === 'up' || dir === 'down') && (minX > x || maxX < x));\r\n        notIntersecting = notIntersecting ||\r\n            (dir === 'left' && minX > x) || (dir === 'right' && maxX < x) ||\r\n            (dir === 'down' && minY > y) || (dir === 'up' && maxY < y);\r\n        if (notIntersecting) {\r\n            continue;\r\n        } // No intersection with bezier\r\n        //------------------------------------------------------/\r\n        //----------- Get intersection ts on bezier ------------/\r\n        //------------------------------------------------------/\r\n        // Get the bezier's x-coordinate power representation.\r\n        let ts = [];\r\n        let f;\r\n        let offset;\r\n        let axis;\r\n        let dirIsDecreasing = (dir === 'left' || dir === 'up');\r\n        if (dir === 'left' || dir === 'right') {\r\n            f = flo_bezier3_1.getY;\r\n            offset = [0, -y];\r\n            axis = 0;\r\n        }\r\n        else {\r\n            f = flo_bezier3_1.getX;\r\n            offset = [-x, 0];\r\n            axis = 1;\r\n        }\r\n        let translatedPs = flo_bezier3_1.translate(offset, ps);\r\n        let poly = f(translatedPs);\r\n        let ev = flo_bezier3_1.evaluate(translatedPs);\r\n        let ts_ = flo_poly_1.allRoots(poly, 0 - DELTA, 1 + DELTA);\r\n        for (let i = 0; i < ts_.length; i++) {\r\n            let t = ts_[i];\r\n            if (Math.abs(t) < DELTA || Math.abs(t - 1) < DELTA) {\r\n                // We don't know the exact number of intersections due to\r\n                // floating point arithmetic. \r\n                return undefined;\r\n            }\r\n            let p_ = ev(t);\r\n            if ((dirIsDecreasing && p[axis] >= p_[axis]) ||\r\n                (!dirIsDecreasing && p[axis] <= p_[axis])) {\r\n                ts.push(t);\r\n            }\r\n        }\r\n        //------------------------------------------------------/\r\n        //----- Check if line is tangent to intersections ------/\r\n        //------------------------------------------------------/\r\n        // We only care if there were 1 or 3 intersections.\r\n        if (ts.length === 1 || ts.length === 3) {\r\n            for (let t of ts) {\r\n                let tan = flo_bezier3_1.tangent(ps, t);\r\n                if (((dir === 'left' || dir === 'right') && Math.abs(tan[1]) < DELTA) ||\r\n                    ((dir === 'down' || dir === 'up') && Math.abs(tan[0]) < DELTA)) {\r\n                    // We don't know the exact number of intersections due to\r\n                    // floating point arithmetic\r\n                    return undefined;\r\n                }\r\n            }\r\n        }\r\n        possAll.push(...ts.map(t => new point_on_shape_1.PointOnShape(curve, t)));\r\n    }\r\n    return possAll;\r\n}\r\n//# sourceMappingURL=is-loop-in-loop.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/fs/simplify-paths/is-loop-in-loop.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/fs/simplify-paths/pair-set.js":
/*!*********************************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/fs/simplify-paths/pair-set.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Adds an unordered pair of values to the set (given as a special map)\r\n * @param map The map representing the pairs.\r\n * @param vs The pair to add.\r\n */\r\nfunction pairSet_add(map, vs) {\r\n    if (pairSet_has(map, vs)) {\r\n        return;\r\n    }\r\n    f(vs[0], vs[1]);\r\n    f(vs[1], vs[0]);\r\n    function f(v1, v2) {\r\n        let set = map.get(v1);\r\n        if (!set) {\r\n            set = new Set();\r\n            map.set(v1, set);\r\n        }\r\n        set.add(v2);\r\n    }\r\n}\r\nexports.pairSet_add = pairSet_add;\r\n/**\r\n * Returns true if the unordered pair is in the set of pairs (represented by a\r\n * map).\r\n * @param map The map representing the pairs.\r\n * @param vs The pair to check.\r\n */\r\nfunction pairSet_has(map, vs) {\r\n    let set;\r\n    set = map.get(vs[0]);\r\n    let has1 = set && set.has(vs[1]);\r\n    set = map.get(vs[1]);\r\n    let has2 = set && set.has(vs[0]);\r\n    return has1 || has2;\r\n}\r\nexports.pairSet_has = pairSet_has;\r\n/**\r\n * Returns the unordered pairs as an array.\r\n * @param map The map representing the pairs.\r\n */\r\nfunction pairSet_asArray(map) {\r\n    let items = [];\r\n    let map_ = new Map();\r\n    for (let m of map) {\r\n        for (let s of m[1]) {\r\n            let vs = [m[0], s];\r\n            if (!pairSet_has(map_, vs)) {\r\n                items.push(vs);\r\n                pairSet_add(map_, vs);\r\n            }\r\n        }\r\n    }\r\n    return items;\r\n}\r\nexports.pairSet_asArray = pairSet_asArray;\r\n//# sourceMappingURL=pair-set.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/fs/simplify-paths/pair-set.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/fs/simplify-paths/simplify-paths.js":
/*!***************************************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/fs/simplify-paths/simplify-paths.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst loop_1 = __webpack_require__(/*! ../../../loop/loop */ \"./node_modules/flo-mat/node/loop/loop.js\");\r\nconst get_loop_bounds_1 = __webpack_require__(/*! ../get-loop-bounds */ \"./node_modules/flo-mat/node/svg/fs/get-loop-bounds.js\");\r\nconst get_intersections_1 = __webpack_require__(/*! ./get-intersections */ \"./node_modules/flo-mat/node/svg/fs/simplify-paths/get-intersections.js\");\r\nconst complete_path_1 = __webpack_require__(/*! ./complete-path */ \"./node_modules/flo-mat/node/svg/fs/simplify-paths/complete-path.js\");\r\nconst get_tightest_containing_loop_1 = __webpack_require__(/*! ./get-tightest-containing-loop */ \"./node_modules/flo-mat/node/svg/fs/simplify-paths/get-tightest-containing-loop.js\");\r\n/**\r\n * Uses the algorithm of Lavanya Subramaniam (PARTITION OF A NON-SIMPLE POLYGON\r\n * INTO SIMPLE POLYGONS) but modified to use cubic bezier curves (as opposed to\r\n * polygons) and to additionally take care of paths with multiple subpaths, i.e.\r\n * such as disjoint nested paths.\r\n * @param loops An array of possibly intersecting paths\r\n */\r\nfunction simplifyPaths(loops) {\r\n    /** A map from each curve to an array of intersections on that curve. */\r\n    let intersections = get_intersections_1.getIntersections(loops);\r\n    let loopsTaken = new Set();\r\n    let root = {\r\n        parent: undefined,\r\n        children: new Set(),\r\n        beziers: undefined,\r\n        loop: undefined,\r\n        orientation: undefined,\r\n        windingNum: 0\r\n    };\r\n    loops.sort(ascendingByTopmostPoint);\r\n    if (typeof _debug_ !== 'undefined') {\r\n        for (let loop of loops) {\r\n            _debug_.fs.nameObj(loop);\r\n        }\r\n    }\r\n    //console.log(loops)\r\n    for (let loop of loops) {\r\n        // TODO - handle special case of 1 curve - maybe just delete lines below\r\n        if (loop.curves.length <= 1) {\r\n            continue;\r\n        }\r\n        if (loopsTaken.has(loop)) {\r\n            continue;\r\n        }\r\n        loopsTaken.add(loop);\r\n        let parent = get_tightest_containing_loop_1.getTightestContainingLoop(root, loop);\r\n        complete_path_1.completePath(intersections, loopsTaken, parent, loop);\r\n    }\r\n    // Take the forest of trees, create a new root making it a tree and snip\r\n    // branches such that each branch determines a new set of loops each \r\n    // representing an individual independent shape that possess its own Medial\r\n    // Axis Transform (still to be determined).\r\n    let loopTrees = splitLoopTrees(root);\r\n    let iLoopSets = loopTrees.map(getLoopsFromTree);\r\n    let loopss = iLoopSets.map(loopSet => loopSet.map(iLoop => loop_1.Loop.fromCubicBeziers(iLoop.beziers)));\r\n    let xMap = new Map();\r\n    for (let intersection of intersections) {\r\n        for (let x of intersection[1]) {\r\n            if (x.isDummy) {\r\n                continue;\r\n            }\r\n            xMap.set(x.outPs, { ps: x.opposite.outPs });\r\n        }\r\n    }\r\n    return { loopss, xMap };\r\n}\r\nexports.simplifyPaths = simplifyPaths;\r\nfunction splitLoopTrees(root) {\r\n    let iLoopTrees = [];\r\n    let nodeStack = [root];\r\n    while (nodeStack.length) {\r\n        let parent = nodeStack.pop();\r\n        for (let child of parent.children) {\r\n            if (parent.windingNum === 0) {\r\n                iLoopTrees.push(child);\r\n            }\r\n            nodeStack.push(child);\r\n        }\r\n        if (parent.windingNum === 0) {\r\n            parent.children = new Set(); // Make it a leaf\r\n        }\r\n    }\r\n    return iLoopTrees;\r\n}\r\n/**\r\n * Returns an array of LoopTrees from the given LoopTree where each returned\r\n * LoopTree is one of the nodes of the tree. Nodes with winding number > 1 are\r\n * not returned.\r\n * @param root\r\n */\r\nfunction getLoopsFromTree(root) {\r\n    let loopTrees = [];\r\n    let stack = [root];\r\n    while (stack.length) {\r\n        let node = stack.pop();\r\n        f(node);\r\n    }\r\n    return loopTrees;\r\n    function f(parent) {\r\n        //console.log(parent.windingNum);\r\n        if (Math.abs(parent.windingNum) <= 1) {\r\n            loopTrees.push(parent);\r\n        }\r\n        for (let child of parent.children) {\r\n            stack.push(child);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Returns < 0 if loopA's topmost point is higher (i.e. smaller) than that of\r\n * loopB. Using this function in a sort will sort from highest topmost point\r\n * loops to lowest.\r\n * @param loopA\r\n * @param loopB\r\n * @hidden\r\n */\r\nfunction ascendingByTopmostPoint(loopA, loopB) {\r\n    let boundsA = get_loop_bounds_1.getLoopBounds(loopA);\r\n    let boundsB = get_loop_bounds_1.getLoopBounds(loopB);\r\n    let a = boundsA.minY.p[1];\r\n    let b = boundsB.minY.p[1];\r\n    return a - b;\r\n}\r\nexports.ascendingByTopmostPoint = ascendingByTopmostPoint;\r\n//# sourceMappingURL=simplify-paths.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/fs/simplify-paths/simplify-paths.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/path-data-polyfill/parse-number.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/path-data-polyfill/parse-number.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// Parse a number from an SVG path. This very closely follows genericParseNumber(...) from\r\n// Source/core/svg/SVGParserUtilities.cpp.\r\n// Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-PathDataBNF\r\nfunction parseNumber(source) {\r\n    var exponent = 0;\r\n    var integer = 0;\r\n    var frac = 1;\r\n    var decimal = 0;\r\n    var sign = 1;\r\n    var expsign = 1;\r\n    var startIndex = source._currentIndex;\r\n    source._skipOptionalSpaces();\r\n    // Read the sign.\r\n    if (source._currentIndex < source._endIndex && source._string[source._currentIndex] === \"+\") {\r\n        source._currentIndex += 1;\r\n    }\r\n    else if (source._currentIndex < source._endIndex && source._string[source._currentIndex] === \"-\") {\r\n        source._currentIndex += 1;\r\n        sign = -1;\r\n    }\r\n    if (source._currentIndex === source._endIndex ||\r\n        ((source._string[source._currentIndex] < \"0\" || source._string[source._currentIndex] > \"9\") &&\r\n            source._string[source._currentIndex] !== \".\")) {\r\n        // The first character of a number must be one of [0-9+-.].\r\n        return null;\r\n    }\r\n    // Read the integer part, build right-to-left.\r\n    var startIntPartIndex = source._currentIndex;\r\n    while (source._currentIndex < source._endIndex &&\r\n        source._string[source._currentIndex] >= \"0\" &&\r\n        source._string[source._currentIndex] <= \"9\") {\r\n        source._currentIndex += 1; // Advance to first non-digit.\r\n    }\r\n    if (source._currentIndex !== startIntPartIndex) {\r\n        var scanIntPartIndex = source._currentIndex - 1;\r\n        var multiplier = 1;\r\n        while (scanIntPartIndex >= startIntPartIndex) {\r\n            integer += multiplier * (Number(source._string[scanIntPartIndex]) - 0);\r\n            scanIntPartIndex -= 1;\r\n            multiplier *= 10;\r\n        }\r\n    }\r\n    // Read the decimals.\r\n    if (source._currentIndex < source._endIndex && source._string[source._currentIndex] === \".\") {\r\n        source._currentIndex += 1;\r\n        // There must be a least one digit following the .\r\n        if (source._currentIndex >= source._endIndex ||\r\n            source._string[source._currentIndex] < \"0\" ||\r\n            source._string[source._currentIndex] > \"9\") {\r\n            return null;\r\n        }\r\n        while (source._currentIndex < source._endIndex &&\r\n            source._string[source._currentIndex] >= \"0\" &&\r\n            source._string[source._currentIndex] <= \"9\") {\r\n            frac *= 10;\r\n            decimal += (Number(source._string.charAt(source._currentIndex))) / frac;\r\n            source._currentIndex += 1;\r\n        }\r\n    }\r\n    // Read the exponent part.\r\n    if (source._currentIndex !== startIndex &&\r\n        source._currentIndex + 1 < source._endIndex &&\r\n        (source._string[source._currentIndex] === \"e\" || source._string[source._currentIndex] === \"E\") &&\r\n        (source._string[source._currentIndex + 1] !== \"x\" && source._string[source._currentIndex + 1] !== \"m\")) {\r\n        source._currentIndex += 1;\r\n        // Read the sign of the exponent.\r\n        if (source._string[source._currentIndex] === \"+\") {\r\n            source._currentIndex += 1;\r\n        }\r\n        else if (source._string[source._currentIndex] === \"-\") {\r\n            source._currentIndex += 1;\r\n            expsign = -1;\r\n        }\r\n        // There must be an exponent.\r\n        if (source._currentIndex >= source._endIndex ||\r\n            source._string[source._currentIndex] < \"0\" ||\r\n            source._string[source._currentIndex] > \"9\") {\r\n            return null;\r\n        }\r\n        while (source._currentIndex < source._endIndex &&\r\n            source._string[source._currentIndex] >= \"0\" &&\r\n            source._string[source._currentIndex] <= \"9\") {\r\n            exponent *= 10;\r\n            exponent += (Number(source._string[source._currentIndex]));\r\n            source._currentIndex += 1;\r\n        }\r\n    }\r\n    var number = integer + decimal;\r\n    number *= sign;\r\n    if (exponent) {\r\n        number *= Math.pow(10, expsign * exponent);\r\n    }\r\n    if (startIndex === source._currentIndex) {\r\n        return null;\r\n    }\r\n    source._skipOptionalSpacesOrDelimiter();\r\n    return number;\r\n}\r\nexports.parseNumber = parseNumber;\r\n//# sourceMappingURL=parse-number.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/path-data-polyfill/parse-number.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/path-data-polyfill/parse-path-data-string.js":
/*!************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/path-data-polyfill/parse-path-data-string.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst source_1 = __webpack_require__(/*! ./source */ \"./node_modules/flo-mat/node/svg/path-data-polyfill/source.js\");\r\nfunction parsePathDataString(string) {\r\n    if (!string.length)\r\n        return [];\r\n    let source = new source_1.Source(string);\r\n    let pathData = [];\r\n    if (!source.initialCommandIsMoveTo()) {\r\n        return [];\r\n    }\r\n    while (source.hasMoreData()) {\r\n        let pathSeg = source.parseSegment();\r\n        if (pathSeg === null) {\r\n            break;\r\n        }\r\n        else {\r\n            pathData.push(pathSeg);\r\n        }\r\n    }\r\n    return pathData;\r\n}\r\nexports.parsePathDataString = parsePathDataString;\r\n//# sourceMappingURL=parse-path-data-string.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/path-data-polyfill/parse-path-data-string.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/path-data-polyfill/source.js":
/*!********************************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/path-data-polyfill/source.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst parse_number_1 = __webpack_require__(/*! ./parse-number */ \"./node_modules/flo-mat/node/svg/path-data-polyfill/parse-number.js\");\r\nconst COMMAND_MAP = {\r\n    \"Z\": \"Z\", \"M\": \"M\", \"L\": \"L\", \"C\": \"C\", \"Q\": \"Q\", \"A\": \"A\", \"H\": \"H\", \"V\": \"V\", \"S\": \"S\", \"T\": \"T\",\r\n    \"z\": \"Z\", \"m\": \"m\", \"l\": \"l\", \"c\": \"c\", \"q\": \"q\", \"a\": \"a\", \"h\": \"h\", \"v\": \"v\", \"s\": \"s\", \"t\": \"t\"\r\n};\r\nclass Source {\r\n    constructor(string) {\r\n        this._string = string;\r\n        this._currentIndex = 0;\r\n        this._endIndex = this._string.length;\r\n        this._prevCommand = null;\r\n        this._skipOptionalSpaces();\r\n    }\r\n    parseSegment() {\r\n        var char = this._string[this._currentIndex];\r\n        var command = COMMAND_MAP[char] ? COMMAND_MAP[char] : null;\r\n        if (command === null) {\r\n            // Possibly an implicit command. Not allowed if this is the first command.\r\n            if (this._prevCommand === null) {\r\n                return null;\r\n            }\r\n            // Check for remaining coordinates in the current command.\r\n            if ((char === \"+\" || char === \"-\" || char === \".\" || (char >= \"0\" && char <= \"9\")) && this._prevCommand !== \"Z\") {\r\n                if (this._prevCommand === \"M\") {\r\n                    command = \"L\";\r\n                }\r\n                else if (this._prevCommand === \"m\") {\r\n                    command = \"l\";\r\n                }\r\n                else {\r\n                    command = this._prevCommand;\r\n                }\r\n            }\r\n            else {\r\n                command = null;\r\n            }\r\n            if (command === null) {\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            this._currentIndex += 1;\r\n        }\r\n        this._prevCommand = command;\r\n        var values = null;\r\n        var cmd = command.toUpperCase();\r\n        if (cmd === \"H\" || cmd === \"V\") {\r\n            values = [parse_number_1.parseNumber(this)];\r\n        }\r\n        else if (cmd === \"M\" || cmd === \"L\" || cmd === \"T\") {\r\n            values = [parse_number_1.parseNumber(this), parse_number_1.parseNumber(this)];\r\n        }\r\n        else if (cmd === \"S\" || cmd === \"Q\") {\r\n            values = [parse_number_1.parseNumber(this), parse_number_1.parseNumber(this), parse_number_1.parseNumber(this), parse_number_1.parseNumber(this)];\r\n        }\r\n        else if (cmd === \"C\") {\r\n            values = [\r\n                parse_number_1.parseNumber(this),\r\n                parse_number_1.parseNumber(this),\r\n                parse_number_1.parseNumber(this),\r\n                parse_number_1.parseNumber(this),\r\n                parse_number_1.parseNumber(this),\r\n                parse_number_1.parseNumber(this)\r\n            ];\r\n        }\r\n        else if (cmd === \"A\") {\r\n            values = [\r\n                parse_number_1.parseNumber(this),\r\n                parse_number_1.parseNumber(this),\r\n                parse_number_1.parseNumber(this),\r\n                this._parseArcFlag(),\r\n                this._parseArcFlag(),\r\n                parse_number_1.parseNumber(this),\r\n                parse_number_1.parseNumber(this)\r\n            ];\r\n        }\r\n        else if (cmd === \"Z\") {\r\n            this._skipOptionalSpaces();\r\n            values = [];\r\n        }\r\n        if (values === null || values.indexOf(null) >= 0) {\r\n            // Unknown command or known command with invalid values\r\n            return null;\r\n        }\r\n        else {\r\n            return { type: command, values };\r\n        }\r\n    }\r\n    hasMoreData() {\r\n        return this._currentIndex < this._endIndex;\r\n    }\r\n    peekSegmentType() {\r\n        var char = this._string[this._currentIndex];\r\n        return COMMAND_MAP[char] ? COMMAND_MAP[char] : null;\r\n    }\r\n    initialCommandIsMoveTo() {\r\n        // If the path is empty it is still valid, so return true.\r\n        if (!this.hasMoreData()) {\r\n            return true;\r\n        }\r\n        var command = this.peekSegmentType();\r\n        // Path must start with moveTo.\r\n        return command === \"M\" || command === \"m\";\r\n    }\r\n    _isCurrentSpace() {\r\n        var char = this._string[this._currentIndex];\r\n        return char <= \" \" && (char === \" \" || char === \"\\n\" || char === \"\\t\" || char === \"\\r\" || char === \"\\f\");\r\n    }\r\n    _skipOptionalSpaces() {\r\n        while (this._currentIndex < this._endIndex && this._isCurrentSpace()) {\r\n            this._currentIndex += 1;\r\n        }\r\n        return this._currentIndex < this._endIndex;\r\n    }\r\n    _skipOptionalSpacesOrDelimiter() {\r\n        if (this._currentIndex < this._endIndex &&\r\n            !this._isCurrentSpace() &&\r\n            this._string[this._currentIndex] !== \",\") {\r\n            return false;\r\n        }\r\n        if (this._skipOptionalSpaces()) {\r\n            if (this._currentIndex < this._endIndex && this._string[this._currentIndex] === \",\") {\r\n                this._currentIndex += 1;\r\n                this._skipOptionalSpaces();\r\n            }\r\n        }\r\n        return this._currentIndex < this._endIndex;\r\n    }\r\n    _parseArcFlag() {\r\n        if (this._currentIndex >= this._endIndex) {\r\n            return null;\r\n        }\r\n        var flag = null;\r\n        var flagChar = this._string[this._currentIndex];\r\n        this._currentIndex += 1;\r\n        if (flagChar === \"0\") {\r\n            flag = 0;\r\n        }\r\n        else if (flagChar === \"1\") {\r\n            flag = 1;\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n        this._skipOptionalSpacesOrDelimiter();\r\n        return flag;\r\n    }\r\n}\r\nexports.Source = Source;\r\n//# sourceMappingURL=source.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/path-data-polyfill/source.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/path-segment/a.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/path-segment/a.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/*\r\n * A and a: (from www.w3.org)\r\n *\r\n * params: rx ry x-axis-rotation large-arc-flag sweep-flag x y\r\n *\r\n * Draws an elliptical arc from the current point to (x, y). The size and\r\n * orientation of the ellipse are defined by two radii (rx, ry) and an\r\n * x-axis-rotation, which indicates how the ellipse as a whole is rotated\r\n * relative to the current coordinate system. The center (cx, cy) of the ellipse\r\n * is calculated automatically to satisfy the constraints imposed by the other\r\n * parameters. large-arc-flag and sweep-flag contribute to the automatic\r\n * calculations and help determine how the arc is drawn.\r\n */\r\nfunction a(s) {\r\n    // TODO - not implemented yet (or not necessary)\r\n    s.prev2ndCubicControlPoint = undefined;\r\n    s.prev2ndQuadraticControlPoint = undefined;\r\n    // Update current point\r\n    //x0 = ? ps[3][0]; \r\n    //y0 = ? ps[3][1];\r\n    return undefined;\r\n}\r\nexports.a = a;\r\n//# sourceMappingURL=a.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/path-segment/a.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/path-segment/c.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/path-segment/c.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * C and c: (from www.w3.org)\r\n *\r\n * params: x1 y1 x2 y2 x y\r\n *\r\n * Draws a cubic Bézier curve from the current point to (x,y)\r\n * using (x1,y1) as the control point at the beginning of the\r\n * curve and (x2,y2) as the control point at the end of the\r\n * curve. C (uppercase) indicates that absolute coordinates\r\n * will follow; c (lowercase) indicates that relative\r\n * coordinates will follow. Multiple sets of coordinates may\r\n * be specified to draw a polybézier. At the end of the\r\n * command, the new current point becomes the final (x,y)\r\n * coordinate pair used in the polybézier.\r\n */\r\nfunction c(s) {\r\n    let ps = [\r\n        s.p,\r\n        [s.vals[0], s.vals[1]],\r\n        [s.vals[2], s.vals[3]],\r\n        [s.vals[4], s.vals[5]]\r\n    ];\r\n    s.prev2ndCubicControlPoint = ps[2];\r\n    s.prev2ndQuadraticControlPoint = undefined;\r\n    return ps;\r\n}\r\nexports.c = c;\r\n//# sourceMappingURL=c.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/path-segment/c.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/path-segment/h.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/path-segment/h.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * H and h: (from www.w3.org)\r\n *\r\n * params: x\r\n *\r\n * Draws a horizontal line from the current point (cpx, cpy) to (x, cpy). H\r\n * (uppercase) indicates that absolute coordinates will follow; h (lowercase)\r\n * indicates that relative coordinates will follow. Multiple x values can be\r\n * provided (although usually this doesn't make sense). At the end of the\r\n * command, the new current point becomes (x, cpy) for the final value of x.\r\n */\r\nfunction h(s) {\r\n    /*\r\n    let xInterval = (s.vals[0] - s.p[0]) / 3;\r\n    let ps = [\r\n        s.p,\r\n        [s.p[0] + xInterval*1, s.p[1]],\r\n        [s.p[0] + xInterval*2, s.p[1]],\r\n        [s.p[0] + xInterval*3, s.p[1]]\r\n    ];\r\n    */\r\n    let ps = [\r\n        s.p, [s.vals[0], s.p[1]]\r\n    ];\r\n    s.prev2ndCubicControlPoint = undefined;\r\n    s.prev2ndQuadraticControlPoint = undefined;\r\n    return ps;\r\n}\r\nexports.h = h;\r\n//# sourceMappingURL=h.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/path-segment/h.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/path-segment/l.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/path-segment/l.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * L and l: (from www.w3.org)\r\n *\r\n * params: x y\r\n *\r\n * Draw a line from the current point to the given (x,y) coordinate which\r\n * becomes the new current point. L (uppercase) indicates that absolute\r\n * coordinates will follow; l (lowercase) indicates that relative coordinates\r\n * will follow. A number of coordinates pairs may be specified to draw a\r\n * polyline. At the end of the command, the new current point is set to the\r\n * final set of coordinates provided.\r\n */\r\nfunction l(s) {\r\n    /*\r\n    let xInterval = (s.vals[0] - s.p[0])/3;\r\n    let yInterval = (s.vals[1] - s.p[1])/3;\r\n    let ps = [\r\n        s.p,\r\n        [s.p[0] + xInterval*1, s.p[1] + yInterval*1],\r\n        [s.p[0] + xInterval*2, s.p[1] + yInterval*2],\r\n        [s.p[0] + xInterval*3, s.p[1] + yInterval*3]\r\n    ];\r\n    */\r\n    let ps = [\r\n        s.p,\r\n        s.vals\r\n    ];\r\n    s.prev2ndCubicControlPoint = undefined;\r\n    s.prev2ndQuadraticControlPoint = undefined;\r\n    return ps;\r\n}\r\nexports.l = l;\r\n//# sourceMappingURL=l.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/path-segment/l.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/path-segment/q.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/path-segment/q.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Q and q: (from www.w3.org)\r\n *\r\n * params: x1 y1 x y\r\n *\r\n * Draws a quadratic Bézier curve from the current point to (x,y) using (x1,y1)\r\n * as the control point. Q (uppercase) indicates that absolute coordinates will\r\n * follow; q (lowercase) indicates that relative coordinates will follow.\r\n * Multiple sets of coordinates may be specified to draw a polybézier. At the\r\n * end of the command, the new current point becomes the final (x,y) coordinate\r\n * pair used in the polybézier.\r\n */\r\nfunction q(s) {\r\n    //---------------------------------------------------\r\n    // Convert quadratic to cubic\r\n    // see https://stackoverflow.com/questions/3162645/convert-a-quadratic-bezier-to-a-cubic/3162732#3162732\r\n    //---------------------------------------------------\r\n    let QP0 = s.p;\r\n    let QP1 = [s.vals[0], s.vals[1]];\r\n    let QP2 = [s.vals[2], s.vals[3]];\r\n    /*\r\n    // Endpoints stay the same\r\n    let CP0 = QP0;\r\n    let CP3 = QP2;\r\n    \r\n    // CP1 = QP0 + 2/3 *(QP1-QP0)\r\n    let CP1 = [\r\n        QP0[0] + (2/3)*(QP1[0]-QP0[0]),\r\n        QP0[1] + (2/3)*(QP1[1]-QP0[1])\r\n    ];\r\n    // CP2 = QP2 + 2/3 *(QP1-QP2)\r\n    let CP2 = [\r\n        QP2[0] + (2/3)*(QP1[0]-QP2[0]),\r\n        QP2[1] + (2/3)*(QP1[1]-QP2[1])\r\n    ];\r\n    \r\n    let ps = [CP0, CP1, CP2, CP3];\r\n    */\r\n    s.prev2ndCubicControlPoint = undefined;\r\n    s.prev2ndQuadraticControlPoint = QP1;\r\n    let ps = [QP0, QP1, QP2];\r\n    return ps;\r\n}\r\nexports.q = q;\r\n//# sourceMappingURL=q.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/path-segment/q.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/path-segment/s.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/path-segment/s.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * S and s: (from www.w3.org)\r\n *\r\n * params: x2 y2 x y\r\n *\r\n * Draws a cubic Bézier curve from the current point to (x,y). The first control\r\n * point is assumed to be the reflection of the second control point on the\r\n * previous command relative to the current point. (If there is no previous\r\n * command or if the previous command was not an C, c, S or s, assume the first\r\n * control point is coincident with the current point.) (x2,y2) is the second\r\n * control point (i.e., the control point at the end of the curve). S\r\n * (uppercase) indicates that absolute coordinates will follow; s (lowercase)\r\n * indicates that relative coordinates will follow. Multiple sets of coordinates\r\n * may be specified to draw a polybézier. At the end of the command, the new\r\n * current point becomes the final (x,y) coordinate pair used in the polybézier.\r\n */\r\nfunction s(s) {\r\n    let p = [undefined, undefined];\r\n    if (s.prev2ndCubicControlPoint) {\r\n        p[0] = (s.p[0] - s.prev2ndCubicControlPoint[0]) + s.p[0];\r\n        p[1] = (s.p[1] - s.prev2ndCubicControlPoint[1]) + s.p[1];\r\n    }\r\n    else {\r\n        p = s.p;\r\n    }\r\n    let ps = [\r\n        s.p,\r\n        p,\r\n        [s.vals[0], s.vals[1]],\r\n        [s.vals[2], s.vals[3]]\r\n    ];\r\n    s.prev2ndCubicControlPoint = ps[2];\r\n    s.prev2ndQuadraticControlPoint = undefined;\r\n    return ps;\r\n}\r\nexports.s = s;\r\n//# sourceMappingURL=s.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/path-segment/s.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/path-segment/t.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/path-segment/t.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * T and t: (from www.w3.org)\r\n *\r\n * params: x y\r\n *\r\n * Draws a quadratic Bézier curve from the current point to (x,y). The control\r\n * point is assumed to be the reflection of the control point on the previous\r\n * command relative to the current point. (If there is no previous command or if\r\n * the previous command was not a Q, q, T or t, assume the control point is\r\n * coincident with the current point.) T (uppercase) indicates that absolute\r\n * coordinates will follow; t (lowercase) indicates that relative coordinates\r\n * will follow. At the end of the command, the new current point becomes the\r\n * final (x,y) coordinate pair used in the polybézier.\r\n */\r\nfunction t(s) {\r\n    let p = [undefined, undefined];\r\n    if (s.prev2ndQuadraticControlPoint) {\r\n        p[0] = (s.p[0] - s.prev2ndQuadraticControlPoint[0]) + s.p[0];\r\n        p[1] = (s.p[1] - s.prev2ndQuadraticControlPoint[1]) + s.p[1];\r\n    }\r\n    else {\r\n        p = s.p;\r\n    }\r\n    //---------------------------------------------------\r\n    // Convert quadratic to cubic\r\n    // see https://stackoverflow.com/questions/3162645/convert-a-quadratic-bezier-to-a-cubic/3162732#3162732\r\n    //---------------------------------------------------\r\n    let QP0 = s.p;\r\n    let QP1 = p;\r\n    let QP2 = [s.vals[0], s.vals[1]];\r\n    /*\r\n    // CP1 = QP0 + 2/3 *(QP1-QP0)\r\n    let CP1 = [\r\n        QP0[0] + (2/3)*(QP1[0]-QP0[0]),\r\n        QP0[1] + (2/3)*(QP1[1]-QP0[1])\r\n    ];\r\n    // CP2 = QP2 + 2/3 *(QP1-QP2)\r\n    let CP2 = [\r\n        QP2[0] + (2/3)*(QP1[0]-QP2[0]),\r\n        QP2[1] + (2/3)*(QP1[1]-QP2[1])\r\n    ];\r\n    \r\n    let ps = [QP0, CP1, CP2, QP2];\r\n    */\r\n    s.prev2ndCubicControlPoint = undefined;\r\n    s.prev2ndQuadraticControlPoint = QP1;\r\n    let ps = [QP0, QP1, QP2];\r\n    return ps;\r\n}\r\nexports.t = t;\r\n//# sourceMappingURL=t.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/path-segment/t.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/path-segment/v.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/path-segment/v.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/*\r\n * V and v: (from www.w3.org)\r\n *\r\n * params: y\r\n *\r\n * Draws a vertical line from the current point (cpx, cpy) to (cpx, y). V\r\n * (uppercase) indicates that absolute coordinates will follow; v (lowercase)\r\n * indicates that relative coordinates will follow. Multiple y values can be\r\n * provided (although usually this doesn't make sense). At the end of the\r\n * command, the new current point becomes (cpx, y) for the final value of y.\r\n */\r\nfunction v(s) {\r\n    let yInterval = (s.vals[0] - s.p[1]) / 3;\r\n    let ps = [\r\n        s.p,\r\n        [s.p[0], s.p[1] + yInterval * 1],\r\n        [s.p[0], s.p[1] + yInterval * 2],\r\n        [s.p[0], s.p[1] + yInterval * 3]\r\n    ];\r\n    s.prev2ndCubicControlPoint = undefined;\r\n    s.prev2ndQuadraticControlPoint = undefined;\r\n    return ps;\r\n}\r\nexports.v = v;\r\n//# sourceMappingURL=v.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/path-segment/v.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/path-segment/z.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/path-segment/z.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Z and z: (from www.w3.org)\r\n *\r\n * params: (none)\r\n *\r\n * Close the current subpath by drawing a straight line from the current point\r\n * to current subpath's initial point. Since the Z and z commands take no\r\n * parameters, they have an identical effect.\r\n */\r\nfunction z(s) {\r\n    let ps = [\r\n        s.p,\r\n        s.initialPoint\r\n    ];\r\n    s.prev2ndCubicControlPoint = undefined;\r\n    s.prev2ndQuadraticControlPoint = undefined;\r\n    return ps;\r\n}\r\nexports.z = z;\r\n//# sourceMappingURL=z.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/path-segment/z.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/path-state.js":
/*!*****************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/path-state.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass PathState {\r\n    constructor() {\r\n        this.initialPoint = undefined;\r\n        // Used in conjunction with \"S\" and \"s\"\r\n        this.prev2ndCubicControlPoint = undefined;\r\n        this.prev2ndQuadraticControlPoint = undefined;\r\n        this.p = [0, 0];\r\n    }\r\n}\r\nexports.PathState = PathState;\r\n//# sourceMappingURL=path-state.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/path-state.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/sweep-line/are-boxes-intersecting.js":
/*!************************************************************************!*\
  !*** ./node_modules/flo-mat/node/sweep-line/are-boxes-intersecting.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns true if the 2 given (closed) boxes intersect. At this stage we already\r\n * know their x-axis intersect.\r\n * @param a A rectangular box\r\n * @param a Another rectangular box\r\n * @param closed (defaults to true) Interpret boxes as being closed (i.e. they\r\n * contain their border) or open.\r\n */\r\nfunction areBoxesIntersecting(closed) {\r\n    return (a, b) => {\r\n        let [[ax0, ay0], [ax1, ay1]] = a;\r\n        let [[bx0, by0], [bx1, by1]] = b;\r\n        // Swap so smaller coordinate comes first\r\n        if (ay0 > ay1) {\r\n            [ay0, ay1] = [ay1, ay0];\r\n        }\r\n        ;\r\n        if (by0 > by1) {\r\n            [by0, by1] = [by1, by0];\r\n        }\r\n        ;\r\n        if (ax0 > ax1) {\r\n            [ax0, ax1] = [ax1, ax0];\r\n        }\r\n        ;\r\n        if (bx0 > bx1) {\r\n            [bx0, bx1] = [bx1, bx0];\r\n        }\r\n        ;\r\n        return closed\r\n            ? (ax0 <= bx1 && ax1 >= bx0 &&\r\n                by0 <= ay1 && by1 >= ay0)\r\n            : (ax0 < bx1 && ax1 > bx0 &&\r\n                by0 < ay1 && by1 > ay0);\r\n    };\r\n}\r\nexports.areBoxesIntersecting = areBoxesIntersecting;\r\n//# sourceMappingURL=are-boxes-intersecting.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/sweep-line/are-boxes-intersecting.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/sweep-line/sweep-line.js":
/*!************************************************************!*\
  !*** ./node_modules/flo-mat/node/sweep-line/sweep-line.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst EVENT_LEFT = 0;\r\nconst EVENT_RIGHT = 1;\r\n/**\r\n * Generalized sweepline algorithm.\r\n *\r\n * Typically used to turn O(n^2) algorithms into roughly O(n logn) algorithms.\r\n *\r\n * @param items An array of items that are to be compared. Items should\r\n * typically be geometric objects in 2d space with well-defined left and right\r\n * endpoints.\r\n * @param getLeftmostPoint A function that returns the leftmost point of the\r\n * geometric object of interest.\r\n * @param getRightmostPoint A function that returns the rightmost point of the\r\n * geometric object of interest.\r\n * @param predicate A predicate that takes two geometric objects and returns\r\n * true if they are of interest or false otherwise.\r\n */\r\nfunction sweepLine(items, getLeftmost, getRightmost, predicate) {\r\n    // Initialize event queue to contain all endpoints.\r\n    let events = [];\r\n    for (let item of items) {\r\n        events.push({\r\n            type: EVENT_LEFT,\r\n            item,\r\n            x: getLeftmost(item)\r\n        });\r\n        events.push({\r\n            type: EVENT_RIGHT,\r\n            item,\r\n            x: getRightmost(item)\r\n        });\r\n    }\r\n    events.sort(compare);\r\n    let activeItems = new Set();\r\n    /** A list of pairs of items that passed the predicate */\r\n    let pairedItems = [];\r\n    for (let event of events) {\r\n        let { item } = event;\r\n        if (event.type === EVENT_LEFT) {\r\n            for (let activeItem of activeItems.values()) {\r\n                if (predicate(item, activeItem)) {\r\n                    pairedItems.push([item, activeItem]);\r\n                }\r\n            }\r\n            activeItems.add(item);\r\n        }\r\n        else if (event.type === EVENT_RIGHT) {\r\n            activeItems.delete(event.item);\r\n        }\r\n    }\r\n    return pairedItems;\r\n}\r\nexports.sweepLine = sweepLine;\r\n/**\r\n * Compare two Events by their x-axis and then by their type. Since it is\r\n * open boxes that are compared we must let the right endpoint type come\r\n * before the left.\r\n * @param a An event\r\n * @param b Another event\r\n */\r\nfunction compare(a, b) {\r\n    let res = a.x - b.x;\r\n    if (res !== 0) {\r\n        return res;\r\n    }\r\n    // Alwys put left events before right ones.\r\n    return a.type === EVENT_LEFT ? -1 : +1;\r\n}\r\n//# sourceMappingURL=sweep-line.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/sweep-line/sweep-line.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/to-scale-axis.js":
/*!****************************************************!*\
  !*** ./node_modules/flo-mat/node/to-scale-axis.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst mat_1 = __webpack_require__(/*! ./mat */ \"./node_modules/flo-mat/node/mat.js\");\r\nconst traverse_edges_1 = __webpack_require__(/*! ./traverse-edges */ \"./node_modules/flo-mat/node/traverse-edges.js\");\r\nconst traverse_vertices_1 = __webpack_require__(/*! ./traverse-vertices */ \"./node_modules/flo-mat/node/traverse-vertices.js\");\r\nconst get_largest_vertex_1 = __webpack_require__(/*! ./mat/get-largest-vertex */ \"./node_modules/flo-mat/node/mat/get-largest-vertex.js\");\r\nconst create_new_cp_tree_1 = __webpack_require__(/*! ./mat/create-new-cp-tree */ \"./node_modules/flo-mat/node/mat/create-new-cp-tree.js\");\r\nconst get_leaves_1 = __webpack_require__(/*! ./mat/get-leaves */ \"./node_modules/flo-mat/node/mat/get-leaves.js\");\r\nconst cull_1 = __webpack_require__(/*! ./mat/to-scale-axis/cull */ \"./node_modules/flo-mat/node/mat/to-scale-axis/cull.js\");\r\nconst add_debug_info_1 = __webpack_require__(/*! ./mat/to-scale-axis/add-debug-info */ \"./node_modules/flo-mat/node/mat/to-scale-axis/add-debug-info.js\");\r\nconst clone_1 = __webpack_require__(/*! ./cp-node/clone */ \"./node_modules/flo-mat/node/cp-node/clone.js\");\r\nconst smoothen_1 = __webpack_require__(/*! ./mat/smoothen/smoothen */ \"./node_modules/flo-mat/node/mat/smoothen/smoothen.js\");\r\n/*\r\nfunction inverseScale(cpNode: CpNode, s: number) {\r\n    let rMax = cpNode.cp.circle.radius;\r\n\r\n    return function(r: number) {\r\n        let s_ = 1 + (s-1)*((rMax+0.1)/(r+0.1));\r\n        //console.log(s,s_,r)\r\n        return s_*r;\r\n    }\r\n}\r\n*/\r\nfunction linearScale(cpNode, s) {\r\n    return function (r) {\r\n        return s * r;\r\n    };\r\n}\r\nlet len = flo_bezier3_1.length([0, 1]);\r\n/**\r\n * Apply and returns an enhanced version of the Scale Axis Transform (SAT) to\r\n * the given MAT. The returned SAT is guaranteed to be a subset of the MAT and\r\n * preserves topology at any scale.\r\n *\r\n * Typically the MAT contains too many branches caused by minute details on the\r\n * boundary of the shape. The SAT is a simplification of the MAT that preserves\r\n * less detail the higher the applied scale factor. The severity at which noise\r\n * are removed depends on the local scale of the shape.\r\n * @param mat The Medial Axis Transform ([[Mat]]) on which to apply the SAT.\r\n * @param s The scale factor >= 1 (e.g. 1.3)\r\n */\r\nfunction toScaleAxis(mat, s, f = linearScale) {\r\n    if (typeof _debug_ !== 'undefined') {\r\n        _debug_.generated.timing.sats[0] = performance.now();\r\n        let leaves = get_leaves_1.getLeaves(mat.cpNode);\r\n        _debug_.generated.elems.leaves.push(leaves);\r\n    }\r\n    /** The largest vertex (as measured by its inscribed disk) */\r\n    let cpNodes = [];\r\n    traverse_vertices_1.traverseVertices(clone_1.clone(mat.cpNode), cpNode => { cpNodes.push(cpNode); });\r\n    let cpNode = get_largest_vertex_1.getLargestVertex(cpNodes);\r\n    let f_ = f(cpNode, s);\r\n    if (typeof _debug_ !== 'undefined') {\r\n        _debug_.generated.elems.maxVertex.push(cpNode);\r\n    }\r\n    /**\r\n     * All vertices that are set to be culled initially. This may change later\r\n     * in order to preserve topology.\r\n     */\r\n    let culls = new Set();\r\n    let rMap = new Map();\r\n    traverse_edges_1.traverseEdges(cpNode, function (cpNode) {\r\n        /** The occulating radius stored with this vertex. */\r\n        let R = rMap.get(cpNode) || f_(cpNode.cp.circle.radius);\r\n        //let R = rMap.get(cpNode) || s * rThis;\r\n        let cpNode_ = cpNode.next;\r\n        //let c  = cpNode .cp.circle.center;\r\n        //let c_ = cpNode_.cp.circle.center;\r\n        /** Distance between this vertex and the next. */\r\n        //let l = distanceBetween(c, c_); // Almost always precise enough\r\n        //let l = len(cpNode.matCurveToNextVertex);\r\n        let l = len(smoothen_1.getCurveToNext(cpNode));\r\n        let r = cpNode_.cp.circle.radius;\r\n        //let s_ = 1 + (s-1)*(rMax/r);\r\n        //let r_ = s * r;\r\n        let r_ = f_(r);\r\n        if (R - l > r_) {\r\n            for (let cpNode of cpNode_.getCpNodesOnCircle()) {\r\n                rMap.set(cpNode, R - l); // Update osculating radii\r\n            }\r\n            culls.add(cpNode_.cp.circle);\r\n        }\r\n    });\r\n    cull_1.cull(culls, cpNode);\r\n    if (typeof _debug_ !== 'undefined') {\r\n        _debug_.generated.elems.culls.push(Array.from(culls));\r\n    }\r\n    let sat = new mat_1.Mat(cpNode, create_new_cp_tree_1.createNewCpTree(cpNode));\r\n    add_debug_info_1.addDebugInfo(sat);\r\n    return sat;\r\n}\r\nexports.toScaleAxis = toScaleAxis;\r\n//# sourceMappingURL=to-scale-axis.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/to-scale-axis.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/traverse-edges.js":
/*!*****************************************************!*\
  !*** ./node_modules/flo-mat/node/traverse-edges.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Traverses all edges (depth first) of the given MAT tree starting at the given\r\n * vertex (represented by a [[CpNode]]).\r\n * @param cpNode Any [[CpNode]] representing the start vertex.\r\n * @param f A callback function for each CpNode representing the vertex at the\r\n * start of an edge.\r\n  */\r\nfunction traverseEdges(cpNode, f) {\r\n    // Since the tree is unrooted we must iterate in all directions from the\r\n    // given vertex.\r\n    let cps = cpNode.getCpNodesOnCircle();\r\n    while (cps.length) {\r\n        let cp = cps.pop();\r\n        f(cp);\r\n        if (cp.isTerminating()) {\r\n            continue;\r\n        }\r\n        cps.push(...cp.getChildren());\r\n    }\r\n}\r\nexports.traverseEdges = traverseEdges;\r\n//# sourceMappingURL=traverse-edges.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/traverse-edges.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/traverse-vertices.js":
/*!********************************************************!*\
  !*** ./node_modules/flo-mat/node/traverse-vertices.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Traverses the MAT tree and calls the given callback function for each vertex\r\n * (represented by a [[CpNode]]) on the MAT.\r\n *\r\n * It is usually preferable to use [[traverseEdges]] as it allows for the\r\n * traversal of all the smooth curves representing the MAT.\r\n * @param cpNode Any [[CpNode]] representing the start vertex.\r\n * @param f A callback function taking a single [[CpNode]] as parameter.\r\n */\r\nfunction traverseVertices(cpNode, f) {\r\n    f(cpNode);\r\n    // Since the tree is unrooted we must iterate in all directions from the\r\n    // given cpNode.\t\r\n    cpNode.getCpNodesOnCircle()\r\n        .filter(cpNode => !cpNode.isTerminating())\r\n        .map(cpNode => cpNode.next)\r\n        .forEach(f_);\r\n    function f_(cpNode) {\r\n        let cps = [cpNode];\r\n        let i = 0;\r\n        while (cps.length) {\r\n            i++;\r\n            /*\r\n            if (i > 5000) {\r\n                //debugger;\r\n                //throw new Error('maxed')\r\n                console.log('maxed')\r\n                break;\r\n            }\r\n            */\r\n            let cp = cps.pop();\r\n            f(cp);\r\n            cps.push(...cp.vertexChildren);\r\n        }\r\n    }\r\n}\r\nexports.traverseVertices = traverseVertices;\r\n//# sourceMappingURL=traverse-vertices.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/traverse-vertices.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/x/x.js":
/*!******************************************!*\
  !*** ./node_modules/flo-mat/node/x/x.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Representation of one side of an intersection. The opposite side is at\r\n * X.opposite.\r\n */\r\nclass X {\r\n    constructor(\r\n    /**\r\n     * The PointOnShape on the curve of the intersection. This side of the\r\n     * intersection is represented by the incoming part of this curve.\r\n     */\r\n    pos, isDummy = false, \r\n    /** The opposite side of the intersection */\r\n    opposite, loopTree, \r\n    //public inPs?     : number[][],\r\n    outPs) {\r\n        this.pos = pos;\r\n        this.isDummy = isDummy;\r\n        this.opposite = opposite;\r\n        this.loopTree = loopTree;\r\n        this.outPs = outPs;\r\n    }\r\n}\r\nexports.X = X;\r\n//# sourceMappingURL=x.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/x/x.js?");

/***/ }),

/***/ "./node_modules/flo-memoize/node/index.js":
/*!************************************************!*\
  !*** ./node_modules/flo-memoize/node/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst SUPPORTED = typeof WeakMap === 'function';\r\n/**\r\n * Memoize the given arity 1 function.\r\n */\r\nfunction memoize(f) {\r\n    if (!SUPPORTED) {\r\n        return f;\r\n    }\r\n    let results = new WeakMap();\r\n    return function (a) {\r\n        let result = results.get(a);\r\n        if (result !== undefined) {\r\n            //console.log('cache hit');\r\n            return result;\r\n        }\r\n        //console.log('cache miss');\r\n        result = f(a);\r\n        results.set(a, result);\r\n        return result;\r\n    };\r\n}\r\nexports.memoize = memoize;\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-memoize/node/index.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/abs.js":
/*!************************************************!*\
  !*** ./node_modules/flo-numerical/node/abs.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst sign_1 = __webpack_require__(/*! ./sign */ \"./node_modules/flo-numerical/node/sign.js\");\r\nconst negative_of_1 = __webpack_require__(/*! ./negative-of */ \"./node_modules/flo-numerical/node/negative-of.js\");\r\n/**\r\n * Returns the absolute value of the given expansion.\r\n * @param a A floating point number expansion\r\n */\r\nfunction abs(a) {\r\n    if (sign_1.sign(a) < 0) {\r\n        return negative_of_1.negativeOf(a);\r\n    }\r\n    return a;\r\n}\r\nexports.abs = abs;\r\n//# sourceMappingURL=abs.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/abs.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/calculate-sum.js":
/*!**********************************************************!*\
  !*** ./node_modules/flo-numerical/node/calculate-sum.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst two_sum_1 = __webpack_require__(/*! ./two-sum */ \"./node_modules/flo-numerical/node/two-sum.js\");\r\nconst grow_expansion_1 = __webpack_require__(/*! ./grow-expansion */ \"./node_modules/flo-numerical/node/grow-expansion.js\");\r\nconst fast_expansion_sum_1 = __webpack_require__(/*! ./fast-expansion-sum */ \"./node_modules/flo-numerical/node/fast-expansion-sum.js\");\r\n/**\r\n * Returns the result of summing an array of floating point expansions.\r\n *\r\n * The result is exact in the form of a non-overlapping floating point\r\n * expansion.\r\n * @param terms An array of numbers to be summed; A term is represented by a\r\n * floating point expansion.\r\n */\r\n// The terms parameter were chosen to always be expansions in order to keep the \r\n// function monomorhic, but whether it's really worth it I am not sure.\r\nfunction calculateSum(terms) {\r\n    let total = [0];\r\n    for (let i = 0; i < terms.length; i++) {\r\n        let term = terms[i];\r\n        // add\r\n        if (term.length === 1) {\r\n            if (total.length === 1) {\r\n                total = two_sum_1.twoSum(total[0], term[0]);\r\n            }\r\n            else {\r\n                total = grow_expansion_1.growExpansion(total, term[0]);\r\n            }\r\n        }\r\n        else {\r\n            if (total.length === 1) {\r\n                total = grow_expansion_1.growExpansion(term, total[0]);\r\n            }\r\n            else {\r\n                total = fast_expansion_sum_1.fastExpansionSum(total, term);\r\n            }\r\n        }\r\n    }\r\n    return total;\r\n}\r\nexports.calculateSum = calculateSum;\r\n//# sourceMappingURL=calculate-sum.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/calculate-sum.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/calculate.js":
/*!******************************************************!*\
  !*** ./node_modules/flo-numerical/node/calculate.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst expansion_product_1 = __webpack_require__(/*! ./expansion-product */ \"./node_modules/flo-numerical/node/expansion-product.js\");\r\nconst two_product_1 = __webpack_require__(/*! ./two-product */ \"./node_modules/flo-numerical/node/two-product.js\");\r\nconst scale_expansion_1 = __webpack_require__(/*! ./scale-expansion */ \"./node_modules/flo-numerical/node/scale-expansion.js\");\r\nconst two_sum_1 = __webpack_require__(/*! ./two-sum */ \"./node_modules/flo-numerical/node/two-sum.js\");\r\nconst grow_expansion_1 = __webpack_require__(/*! ./grow-expansion */ \"./node_modules/flo-numerical/node/grow-expansion.js\");\r\nconst fast_expansion_sum_1 = __webpack_require__(/*! ./fast-expansion-sum */ \"./node_modules/flo-numerical/node/fast-expansion-sum.js\");\r\n/**\r\n * Return the result of summing an array of terms, each term being an array of\r\n * floating point expansions to be multiplied together.\r\n *\r\n * The result is exact in the form of a non-overlapping floating point\r\n * expansion.\r\n * @param terms An array of terms to be summed; A term consists of an\r\n * array of floating point expansions to be multiplied together.\r\n */\r\n// The terms parameter were chosen to always be expansions in order to keep the \r\n// function monomorhic, but whether it's really worth it I am not sure.\r\nfunction calculate(terms) {\r\n    let total = [0];\r\n    for (let i = 0; i < terms.length; i++) {\r\n        let term = terms[i];\r\n        let product = term[0];\r\n        for (let j = 1; j < term.length; j++) {\r\n            let multiplicant = term[j];\r\n            if (multiplicant.length == 1) {\r\n                if (product.length === 1) {\r\n                    product = two_product_1.twoProduct(product[0], multiplicant[0]);\r\n                }\r\n                else {\r\n                    product = scale_expansion_1.scaleExpansion(product, multiplicant[0]);\r\n                }\r\n            }\r\n            else if (product.length === 1) {\r\n                product = scale_expansion_1.scaleExpansion(multiplicant, product[1]);\r\n            }\r\n            else {\r\n                product = expansion_product_1.expansionProduct(multiplicant, product);\r\n            }\r\n        }\r\n        // add\r\n        if (product.length === 1) {\r\n            if (total.length === 1) {\r\n                total = two_sum_1.twoSum(total[0], product[0]);\r\n            }\r\n            else {\r\n                total = grow_expansion_1.growExpansion(total, product[0]);\r\n            }\r\n        }\r\n        else {\r\n            if (total.length === 1) {\r\n                total = grow_expansion_1.growExpansion(product, total[0]);\r\n            }\r\n            else {\r\n                total = fast_expansion_sum_1.fastExpansionSum(total, product);\r\n            }\r\n        }\r\n    }\r\n    return total;\r\n}\r\nexports.calculate = calculate;\r\n//# sourceMappingURL=calculate.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/calculate.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/compare.js":
/*!****************************************************!*\
  !*** ./node_modules/flo-numerical/node/compare.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst expansion_diff_1 = __webpack_require__(/*! ./expansion-diff */ \"./node_modules/flo-numerical/node/expansion-diff.js\");\r\nconst sign_1 = __webpack_require__(/*! ./sign */ \"./node_modules/flo-numerical/node/sign.js\");\r\n/**\r\n * See Shewchuk https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n *\r\n * Returns 0 if a === b, a +tive value if a > b or a negative value if a < b.\r\n *\r\n * \"The easiest way to compare two expansions is to subtract one from the other,\r\n * and test the sign of the result. An expansion’s sign can be easily tested\r\n * because of the nonoverlapping property; simply check the sign of the\r\n * expansion's most significant nonzero component...\"\r\n */\r\nfunction compare(a, b) {\r\n    return sign_1.sign(expansion_diff_1.expansionDiff(a, b));\r\n}\r\nexports.compare = compare;\r\n//# sourceMappingURL=compare.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/compare.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/compress.js":
/*!*****************************************************!*\
  !*** ./node_modules/flo-numerical/node/compress.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * See Shewchuk https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n *\r\n * Theorem 23 (Shewchuck): Let e = sum_(i=1)^m(e_i) be a nonoverlapping\r\n * expansion of m p-bit components, where m >= 3. Suppose that the components of\r\n * e are sorted in order of increasing magnitude, except that any of the e_i may\r\n * be zero. Then the following algorithm will produce a nonoverlapping expansion\r\n * (nonadjacent if round-to even tiebreaking is used) such that\r\n * h = sum_(i=1)^n(h_i) = e, where the components h_i are in order of increasing\r\n * magnitude. If h != 0, none of the h_i will be zero. Furthermore, the largest\r\n * component h_n approximates h with an error smaller than ulp(h_n).\r\n */\r\nfunction compress(e) {\r\n    let e_ = e.slice();\r\n    let m = e_.length;\r\n    if (e_.length === 1) {\r\n        return e_;\r\n    }\r\n    let Q = e_[e_.length - 1];\r\n    let bottom = m;\r\n    for (let i = m - 2; i >= 0; --i) {\r\n        let a = Q;\r\n        let b = e_[i];\r\n        Q = a + b;\r\n        let bv = Q - a;\r\n        let q = b - bv;\r\n        if (q) {\r\n            e_[--bottom] = Q;\r\n            Q = q;\r\n        }\r\n    }\r\n    let top = 0;\r\n    for (let i = bottom; i < m; ++i) {\r\n        let a = e_[i];\r\n        let b = Q;\r\n        Q = a + b;\r\n        let bv = Q - a;\r\n        let q = b - bv;\r\n        if (q) {\r\n            e_[top++] = q;\r\n        }\r\n    }\r\n    e_[top++] = Q;\r\n    e_.length = top;\r\n    if (e_.length === 0) {\r\n        return [0];\r\n    }\r\n    return e_;\r\n}\r\nexports.compress = compress;\r\n//# sourceMappingURL=compress.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/compress.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/estimate.js":
/*!*****************************************************!*\
  !*** ./node_modules/flo-numerical/node/estimate.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the result of the given floating point expansion rounded to a single\r\n * floating point number.\r\n *\r\n * See Shewchuk https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n * @param e A floating point expansion\r\n */\r\nfunction estimate(e) {\r\n    let Q = e[0];\r\n    for (let i = 1; i < e.length; i++) {\r\n        Q += e[i];\r\n    }\r\n    return Q;\r\n}\r\nexports.estimate = estimate;\r\n//# sourceMappingURL=estimate.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/estimate.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/expansion-diff.js":
/*!***********************************************************!*\
  !*** ./node_modules/flo-numerical/node/expansion-diff.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst fast_expansion_sum_1 = __webpack_require__(/*! ./fast-expansion-sum */ \"./node_modules/flo-numerical/node/fast-expansion-sum.js\");\r\nconst negative_of_1 = __webpack_require__(/*! ./negative-of */ \"./node_modules/flo-numerical/node/negative-of.js\");\r\n/**\r\n * Returns the difference between two floating point expansions, i.e. e - f.\r\n *\r\n * See Shewchuk https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n * @param e A floating point expansion\r\n * @param f Another floating point expansion\r\n */\r\nfunction expansionDiff(e, f) {\r\n    let g = negative_of_1.negativeOf(f);\r\n    return fast_expansion_sum_1.fastExpansionSum(e, g);\r\n}\r\nexports.expansionDiff = expansionDiff;\r\n//# sourceMappingURL=expansion-diff.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/expansion-diff.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/expansion-product.js":
/*!**************************************************************!*\
  !*** ./node_modules/flo-numerical/node/expansion-product.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst fast_expansion_sum_1 = __webpack_require__(/*! ./fast-expansion-sum */ \"./node_modules/flo-numerical/node/fast-expansion-sum.js\");\r\nconst scale_expansion_1 = __webpack_require__(/*! ./scale-expansion */ \"./node_modules/flo-numerical/node/scale-expansion.js\");\r\nconst compress_1 = __webpack_require__(/*! ./compress */ \"./node_modules/flo-numerical/node/compress.js\");\r\n/**\r\n * Returns the product of two expansions.\r\n *\r\n * See Shewchuk https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n *\r\n * Ase per Shewchuk in the above paper: \"To find the product of two expansions\r\n * e and f, use SCALE-EXPANSION (with zero elimination) to form the expansions\r\n * ef_1, ef_2, ..., then sum these using a distillation tree.\"\r\n *\r\n * A distillation tree used with fastExpansionSum will give use O(k*log k) vs\r\n * O(k^2) operations.\r\n *\r\n * TODO - currently implemented naively and not as described above (i.e. the\r\n * algorithm takes O(k^2) operations).\r\n * @param e An expansion\r\n * @param f Another expansion\r\n */\r\nfunction expansionProduct(e, f) {\r\n    let sum = [0];\r\n    for (let i = 0; i < e.length; i++) {\r\n        sum = fast_expansion_sum_1.fastExpansionSum(sum, scale_expansion_1.scaleExpansion(f, e[i]));\r\n    }\r\n    return compress_1.compress(sum);\r\n}\r\nexports.expansionProduct = expansionProduct;\r\n//# sourceMappingURL=expansion-product.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/expansion-product.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/fast-expansion-sum.js":
/*!***************************************************************!*\
  !*** ./node_modules/flo-numerical/node/fast-expansion-sum.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst merge_1 = __webpack_require__(/*! ./merge */ \"./node_modules/flo-numerical/node/merge.js\");\r\nconst fast_two_sum_1 = __webpack_require__(/*! ./fast-two-sum */ \"./node_modules/flo-numerical/node/fast-two-sum.js\");\r\nconst two_sum_1 = __webpack_require__(/*! ./two-sum */ \"./node_modules/flo-numerical/node/two-sum.js\");\r\nconst compress_1 = __webpack_require__(/*! ./compress */ \"./node_modules/flo-numerical/node/compress.js\");\r\n/**\r\n * Returns the result of adding two expansions. This function is nearly always\r\n * preferred above expansionSum.\r\n *\r\n * Theorem 13: Let e = sum_(i=1)^m(e_i) and f = sum_(i=1)^n(f_i) be strongly\r\n * nonoverlapping expansions of m and n p-bit components, respectively, where\r\n * p >= 4. Suppose that the components of both e and f are sorted in order of\r\n * increasing magnitude, except that any of the e_i or f_i may be zero. On a\r\n * machine whose arithmetic uses the round-to-even rule, the following algorithm\r\n * will produce a strongly nonoverlapping expansion h such that\r\n * sum_(i=1)^(m+n)(e_i + f_i) = e + f, where the components of h are also in\r\n * order of increasing magnitude, except that any of the h_i may be zero.\r\n *\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n */\r\nfunction fastExpansionSum(e, f) {\r\n    let g = merge_1.merge(e, f);\r\n    if (g.length === 1) {\r\n        return g;\r\n    }\r\n    let len = g.length;\r\n    let h = new Array(len);\r\n    let q;\r\n    [h[0], q] = fast_two_sum_1.fastTwoSum(g[1], g[0]);\r\n    for (let i = 2; i < len; i++) {\r\n        [h[i - 1], q] = two_sum_1.twoSum(q, g[i]);\r\n    }\r\n    h[len - 1] = q;\r\n    return compress_1.compress(h);\r\n}\r\nexports.fastExpansionSum = fastExpansionSum;\r\n//# sourceMappingURL=fast-expansion-sum.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/fast-expansion-sum.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/fast-two-diff.js":
/*!**********************************************************!*\
  !*** ./node_modules/flo-numerical/node/fast-two-diff.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the difference and exact error of subtracting two floating point\r\n * numbers.\r\n * Uses an EFT (error-free transformation), i.e. a-b === x+y exactly.\r\n * The returned result is a non-overlapping expansion (smallest value first!).\r\n *\r\n * Precondition: abs(a) >= abs(b) - A fast test that can be used is\r\n * (a > b) === (a > -b)\r\n *\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n */\r\nfunction fastTwoDiff(a, b) {\r\n    let x = a - b;\r\n    let y = (a - x) - b;\r\n    return [y, x];\r\n}\r\nexports.fastTwoDiff = fastTwoDiff;\r\n//# sourceMappingURL=fast-two-diff.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/fast-two-diff.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/fast-two-sum.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-numerical/node/fast-two-sum.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the sum and exact error of adding two floating point numbers.\r\n * Uses an EFT (error-free transformation), i.e. a+b === x+y exactly.\r\n * The returned sum is a non-overlapping expansion (smallest value first!).\r\n *\r\n * Precondition: abs(a) >= abs(b) - A fast test that can be used is\r\n * (a > b) === (a > -b)\r\n *\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n */\r\nfunction fastTwoSum(a, b) {\r\n    let x = a + b;\r\n    let y = b - (x - a);\r\n    return [y, x];\r\n}\r\nexports.fastTwoSum = fastTwoSum;\r\n//# sourceMappingURL=fast-two-sum.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/fast-two-sum.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/grow-expansion.js":
/*!***********************************************************!*\
  !*** ./node_modules/flo-numerical/node/grow-expansion.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst two_sum_1 = __webpack_require__(/*! ./two-sum */ \"./node_modules/flo-numerical/node/two-sum.js\");\r\nconst compress_1 = __webpack_require__(/*! ./compress */ \"./node_modules/flo-numerical/node/compress.js\");\r\n/**\r\n * Returns the result of adding a double to an expansion.\r\n *\r\n * Let e be a nonoverlapping expansion of m p-bit components, and let b be a\r\n * p-bit value where p >= 3. Suppose that the components e_1, ..., e_m are\r\n * sorted in order of *increasing* magnitude, except that any of the ei may be\r\n * zero.\r\n * Then the following algorithm will produce a nonoverlapping expansion such\r\n * that h = sum_i(h_i) = e + b, where the components h_1, ..., h_(m+1) are also\r\n * in order of increasing magnitude, except that any of the h_i may be zero.\r\n * Furthermore, if e is nonadjacent and round-to-even tiebreaking is used, then\r\n * h is nonadjacent.\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n * @param e A floating point expansion\r\n * @param b Another floating point expansion\r\n */\r\nfunction growExpansion(e, b) {\r\n    let m = e.length;\r\n    let q = b;\r\n    let h = new Array(m + 1);\r\n    for (let i = 0; i < m; i++) {\r\n        // Note the use of twoSum and not fastTwoSum.\r\n        [h[i], q] = two_sum_1.twoSum(q, e[i]);\r\n    }\r\n    h[m] = q;\r\n    return compress_1.compress(h);\r\n}\r\nexports.growExpansion = growExpansion;\r\n//# sourceMappingURL=grow-expansion.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/grow-expansion.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/index.js":
/*!**************************************************!*\
  !*** ./node_modules/flo-numerical/node/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst compress_1 = __webpack_require__(/*! ./compress */ \"./node_modules/flo-numerical/node/compress.js\");\r\nexports.compress = compress_1.compress;\r\nconst compare_1 = __webpack_require__(/*! ./compare */ \"./node_modules/flo-numerical/node/compare.js\");\r\nexports.compare = compare_1.compare;\r\nconst abs_1 = __webpack_require__(/*! ./abs */ \"./node_modules/flo-numerical/node/abs.js\");\r\nexports.abs = abs_1.abs;\r\nconst estimate_1 = __webpack_require__(/*! ./estimate */ \"./node_modules/flo-numerical/node/estimate.js\");\r\nexports.estimate = estimate_1.estimate;\r\nconst expansion_diff_1 = __webpack_require__(/*! ./expansion-diff */ \"./node_modules/flo-numerical/node/expansion-diff.js\");\r\nexports.expansionDiff = expansion_diff_1.expansionDiff;\r\nconst fast_expansion_sum_1 = __webpack_require__(/*! ./fast-expansion-sum */ \"./node_modules/flo-numerical/node/fast-expansion-sum.js\");\r\nexports.fastExpansionSum = fast_expansion_sum_1.fastExpansionSum;\r\nconst fast_two_diff_1 = __webpack_require__(/*! ./fast-two-diff */ \"./node_modules/flo-numerical/node/fast-two-diff.js\");\r\nexports.fastTwoDiff = fast_two_diff_1.fastTwoDiff;\r\nconst fast_two_sum_1 = __webpack_require__(/*! ./fast-two-sum */ \"./node_modules/flo-numerical/node/fast-two-sum.js\");\r\nexports.fastTwoSum = fast_two_sum_1.fastTwoSum;\r\nconst grow_expansion_1 = __webpack_require__(/*! ./grow-expansion */ \"./node_modules/flo-numerical/node/grow-expansion.js\");\r\nexports.growExpansion = grow_expansion_1.growExpansion;\r\nconst is_adjacent_1 = __webpack_require__(/*! ./is-adjacent */ \"./node_modules/flo-numerical/node/is-adjacent.js\");\r\nexports.isAdjacent = is_adjacent_1.isAdjacent;\r\nconst is_overlapping_1 = __webpack_require__(/*! ./is-overlapping */ \"./node_modules/flo-numerical/node/is-overlapping.js\");\r\nexports.isOverlapping = is_overlapping_1.isOverlapping;\r\nexports.isNonOverlapping = is_overlapping_1.isNonOverlapping;\r\nexports.isNonOverlappingAll = is_overlapping_1.isNonOverlappingAll;\r\nconst merge_1 = __webpack_require__(/*! ./merge */ \"./node_modules/flo-numerical/node/merge.js\");\r\nexports.merge = merge_1.merge;\r\nconst negative_of_1 = __webpack_require__(/*! ./negative-of */ \"./node_modules/flo-numerical/node/negative-of.js\");\r\nexports.negativeOf = negative_of_1.negativeOf;\r\nconst orient2d_1 = __webpack_require__(/*! ./orient2d */ \"./node_modules/flo-numerical/node/orient2d.js\");\r\nexports.orient2d = orient2d_1.orient2d;\r\nconst scale_expansion_1 = __webpack_require__(/*! ./scale-expansion */ \"./node_modules/flo-numerical/node/scale-expansion.js\");\r\nexports.scaleExpansion = scale_expansion_1.scaleExpansion;\r\nconst split_1 = __webpack_require__(/*! ./split */ \"./node_modules/flo-numerical/node/split.js\");\r\nexports.split = split_1.split;\r\nconst two_diff_1 = __webpack_require__(/*! ./two-diff */ \"./node_modules/flo-numerical/node/two-diff.js\");\r\nexports.twoDiff = two_diff_1.twoDiff;\r\nconst two_product_1 = __webpack_require__(/*! ./two-product */ \"./node_modules/flo-numerical/node/two-product.js\");\r\nexports.twoProduct = two_product_1.twoProduct;\r\nconst two_sum_1 = __webpack_require__(/*! ./two-sum */ \"./node_modules/flo-numerical/node/two-sum.js\");\r\nexports.twoSum = two_sum_1.twoSum;\r\nconst reduce_significand_1 = __webpack_require__(/*! ./reduce-significand */ \"./node_modules/flo-numerical/node/reduce-significand.js\");\r\nexports.reduceSignificand = reduce_significand_1.reduceSignificand;\r\nconst expansion_product_1 = __webpack_require__(/*! ./expansion-product */ \"./node_modules/flo-numerical/node/expansion-product.js\");\r\nexports.expansionProduct = expansion_product_1.expansionProduct;\r\nconst parse_double_1 = __webpack_require__(/*! ./representation/parse-double */ \"./node_modules/flo-numerical/node/representation/parse-double.js\");\r\nexports.parseDouble = parse_double_1.parseDouble;\r\nexports.parseDoubleDetailed = parse_double_1.parseDoubleDetailed;\r\nconst is_bit_aligned_1 = __webpack_require__(/*! ./representation/is-bit-aligned */ \"./node_modules/flo-numerical/node/representation/is-bit-aligned.js\");\r\nexports.isBitAligned = is_bit_aligned_1.isBitAligned;\r\nconst msb_exponent_1 = __webpack_require__(/*! ./representation/msb-exponent */ \"./node_modules/flo-numerical/node/representation/msb-exponent.js\");\r\nexports.msbExponent = msb_exponent_1.msbExponent;\r\nconst lsb_exponent_1 = __webpack_require__(/*! ./representation/lsb-exponent */ \"./node_modules/flo-numerical/node/representation/lsb-exponent.js\");\r\nexports.lsbExponent = lsb_exponent_1.lsbExponent;\r\nconst sign_1 = __webpack_require__(/*! ./sign */ \"./node_modules/flo-numerical/node/sign.js\");\r\nexports.sign = sign_1.sign;\r\nconst bit_length_1 = __webpack_require__(/*! ./representation/bit-length */ \"./node_modules/flo-numerical/node/representation/bit-length.js\");\r\nexports.bitLength = bit_length_1.bitLength;\r\nconst calculate_1 = __webpack_require__(/*! ./calculate */ \"./node_modules/flo-numerical/node/calculate.js\");\r\nexports.calculate = calculate_1.calculate;\r\nconst calculate_sum_1 = __webpack_require__(/*! ./calculate-sum */ \"./node_modules/flo-numerical/node/calculate-sum.js\");\r\nexports.calculateSum = calculate_sum_1.calculateSum;\r\nconst exponent_1 = __webpack_require__(/*! ./representation/exponent */ \"./node_modules/flo-numerical/node/representation/exponent.js\");\r\nexports.exponent = exponent_1.exponent;\r\nconst significand_1 = __webpack_require__(/*! ./representation/significand */ \"./node_modules/flo-numerical/node/representation/significand.js\");\r\nexports.significand = significand_1.significand;\r\nconst binary_string_to_double_1 = __webpack_require__(/*! ./representation/binary-string-to-double */ \"./node_modules/flo-numerical/node/representation/binary-string-to-double.js\");\r\nexports.binaryStringToDouble = binary_string_to_double_1.binaryStringToDouble;\r\nconst double_to_binary_string_1 = __webpack_require__(/*! ./representation/double-to-binary-string */ \"./node_modules/flo-numerical/node/representation/double-to-binary-string.js\");\r\nexports.doubleToBinaryString = double_to_binary_string_1.doubleToBinaryString;\r\nconst double_to_octets_1 = __webpack_require__(/*! ./representation/double-to-octets */ \"./node_modules/flo-numerical/node/representation/double-to-octets.js\");\r\nexports.doubleToOctets = double_to_octets_1.doubleToOctets;\r\nconst octets_to_double_1 = __webpack_require__(/*! ./representation/octets-to-double */ \"./node_modules/flo-numerical/node/representation/octets-to-double.js\");\r\nexports.octetsToDouble = octets_to_double_1.octetsToDouble;\r\nconst get_max_set_bit_1 = __webpack_require__(/*! ./representation/get-max-set-bit */ \"./node_modules/flo-numerical/node/representation/get-max-set-bit.js\");\r\nexports.getHighestSetBit = get_max_set_bit_1.getHighestSetBit;\r\nexports.getLowestSetBit = get_max_set_bit_1.getLowestSetBit;\r\nconst is_valid_1 = __webpack_require__(/*! ./representation/is-valid */ \"./node_modules/flo-numerical/node/representation/is-valid.js\");\r\nexports.isValid = is_valid_1.isValid;\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/index.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/is-adjacent.js":
/*!********************************************************!*\
  !*** ./node_modules/flo-numerical/node/is-adjacent.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst is_overlapping_1 = __webpack_require__(/*! ./is-overlapping */ \"./node_modules/flo-numerical/node/is-overlapping.js\");\r\n/**\r\n * Returns true if x and y is adjacent, false otherwise.\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n * @param x A double floating point number\r\n * @param y Another double floating point number\r\n */\r\nfunction isAdjacent(x, y) {\r\n    return is_overlapping_1.isOverlapping(x, y) ||\r\n        is_overlapping_1.isOverlapping(x, 2 * y) ||\r\n        is_overlapping_1.isOverlapping(2 * x, y);\r\n}\r\nexports.isAdjacent = isAdjacent;\r\n//# sourceMappingURL=is-adjacent.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/is-adjacent.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/is-overlapping.js":
/*!***********************************************************!*\
  !*** ./node_modules/flo-numerical/node/is-overlapping.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_max_set_bit_1 = __webpack_require__(/*! ./representation/get-max-set-bit */ \"./node_modules/flo-numerical/node/representation/get-max-set-bit.js\");\r\nconst exponent_1 = __webpack_require__(/*! ./representation/exponent */ \"./node_modules/flo-numerical/node/representation/exponent.js\");\r\n/**\r\n * Returns true if a and b does not overlap, false otherwise.\r\n *\r\n * Two floating-point values x and y are nonoverlapping if the least significant\r\n * nonzero bit of x is more significant than the most significant nonzero bit of\r\n * y.\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n *\r\n * Implemented for testing purposes.\r\n * @param a A double\r\n * @param b Another double\r\n */\r\nfunction isOverlapping(a, b) {\r\n    return !isNonOverlapping(a, b);\r\n}\r\nexports.isOverlapping = isOverlapping;\r\n/**\r\n * Returns true if a and b overlaps, false otherwise.\r\n *\r\n * Two floating-point values x and y are nonoverlapping if the least significant\r\n * nonzero bit of x is more significant than the most significant nonzero bit of\r\n * y.\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n *\r\n * Implemented for testing purposes.\r\n *\r\n * @param a A double\r\n * @param b Another double\r\n */\r\nfunction isNonOverlapping(a, b) {\r\n    if (a === 0 || b === 0) {\r\n        return true;\r\n    }\r\n    if (Math.abs(b) > Math.abs(a)) {\r\n        [a, b] = [b, a];\r\n    }\r\n    // At this point abs(a) > abs(b)\r\n    let l = get_max_set_bit_1.getLowestSetBit(a);\r\n    let h = get_max_set_bit_1.getHighestSetBit(b);\r\n    let shift = exponent_1.exponent(a) - exponent_1.exponent(b);\r\n    return (l + shift) > h;\r\n}\r\nexports.isNonOverlapping = isNonOverlapping;\r\n/**\r\n * Returns true if all components of the given expansion is non-overlapping,\r\n * false otherwise.\r\n * @param e An expansion\r\n */\r\nfunction isNonOverlappingAll(e) {\r\n    for (let i = 1; i < e.length; i++) {\r\n        if (isOverlapping(e[i - 1], e[i])) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexports.isNonOverlappingAll = isNonOverlappingAll;\r\n//# sourceMappingURL=is-overlapping.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/is-overlapping.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/merge.js":
/*!**************************************************!*\
  !*** ./node_modules/flo-numerical/node/merge.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the result of merging an expansion e and f into a single expansion,\r\n * in order of nondecreasing magnitude (possibly with interspersed zeros).\r\n * (This function is zero-eliminating)\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n * @param e A floating point expansion\r\n * @param f Another floating point expansion\r\n */\r\nfunction merge(e, f) {\r\n    let lenE = e.length;\r\n    let lenF = f.length;\r\n    let i = 0;\r\n    let j = 0;\r\n    let merged = [];\r\n    while (i < lenE && j < lenF) {\r\n        if (e[i] === 0) {\r\n            i++;\r\n            continue;\r\n        }\r\n        if (f[j] === 0) {\r\n            j++;\r\n            continue;\r\n        }\r\n        if (Math.abs(e[i]) <= Math.abs(f[j])) {\r\n            merged.push(e[i]);\r\n            i++;\r\n        }\r\n        else {\r\n            merged.push(f[j]);\r\n            j++;\r\n        }\r\n    }\r\n    while (i < lenE) {\r\n        merged.push(e[i]);\r\n        i++;\r\n    }\r\n    while (j < lenF) {\r\n        merged.push(f[j]);\r\n        j++;\r\n    }\r\n    if (merged.length === 0) {\r\n        return [0];\r\n    }\r\n    return merged;\r\n}\r\nexports.merge = merge;\r\n//# sourceMappingURL=merge.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/merge.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/negative-of.js":
/*!********************************************************!*\
  !*** ./node_modules/flo-numerical/node/negative-of.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the negative of the given floating point expansion.\r\n * @param e A floating point number expansion\r\n */\r\nfunction negativeOf(e) {\r\n    let m = e.length;\r\n    let h = new Array(m);\r\n    for (let i = 0; i < m; i++) {\r\n        h[i] = -e[i];\r\n    }\r\n    return h;\r\n}\r\nexports.negativeOf = negativeOf;\r\n//# sourceMappingURL=negative-of.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/negative-of.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/orient2d.js":
/*!*****************************************************!*\
  !*** ./node_modules/flo-numerical/node/orient2d.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst two_product_1 = __webpack_require__(/*! ./two-product */ \"./node_modules/flo-numerical/node/two-product.js\");\r\nconst expansion_diff_1 = __webpack_require__(/*! ./expansion-diff */ \"./node_modules/flo-numerical/node/expansion-diff.js\");\r\nconst estimate_1 = __webpack_require__(/*! ./estimate */ \"./node_modules/flo-numerical/node/estimate.js\");\r\nconst two_diff_1 = __webpack_require__(/*! ./two-diff */ \"./node_modules/flo-numerical/node/two-diff.js\");\r\nconst fast_expansion_sum_1 = __webpack_require__(/*! ./fast-expansion-sum */ \"./node_modules/flo-numerical/node/fast-expansion-sum.js\");\r\nconst compress_1 = __webpack_require__(/*! ./compress */ \"./node_modules/flo-numerical/node/compress.js\");\r\nlet ccwerrboundA = 3.330669073875472e-16;\r\nlet ccwerrboundB = 2.220446049250315e-16;\r\nlet ccwerrboundC = 1.109335647967049e-31;\r\nlet resulterrbound = 3.330669073875471e-16;\r\n/**\r\n * Ported from (Shewchuk) http://docs.ros.org/kinetic/api/asr_approx_mvbb/html/Predicates_8cpp_source.html\r\n * See also https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n *\r\n * * Adaptive exact 2d orientation test.\r\n *\r\n * * Robust.\r\n *\r\n * Return a positive value if the points pa, pb, and pc occur in\r\n * counterclockwise order; a negative value if they occur in clockwise order;\r\n * and zero if they are collinear.  The result is also a rough approximation of\r\n * twice the signed area of the triangle defined by the three points.\r\n *\r\n * The result returned is the determinant of a matrix. This determinant is\r\n * computed adaptively, in the sense that exact arithmetic is used only to the\r\n * degree it is needed to ensure that the returned value has the correct sign.\r\n * Hence, orient2d() is usually quite fast, but will run more slowly when the\r\n * input points are collinear or nearly so.\r\n */\r\nfunction orient2d(A, B, C) {\r\n    let detleft = (A[0] - C[0]) * (B[1] - C[1]);\r\n    let detright = (A[1] - C[1]) * (B[0] - C[0]);\r\n    let det = detleft - detright;\r\n    let detsum;\r\n    if (detleft > 0) {\r\n        if (detright <= 0) {\r\n            // Anti-clockwise\r\n            return det;\r\n        }\r\n        else {\r\n            detsum = detleft + detright;\r\n        }\r\n    }\r\n    else if (detleft < 0) {\r\n        if (detright >= 0) {\r\n            // Clockwise\r\n            return det;\r\n        }\r\n        else {\r\n            detsum = -detleft - detright;\r\n        }\r\n    }\r\n    else {\r\n        // Anti-clockwise, clockwise or straight\r\n        return det;\r\n    }\r\n    if (Math.abs(det) >= ccwerrboundA * detsum) {\r\n        // Anti-clockwise or clockwise\r\n        return det;\r\n    }\r\n    return orient2dAdapt(A, B, C, detsum);\r\n}\r\nexports.orient2d = orient2d;\r\nfunction orient2dAdapt(A, B, C, detsum) {\r\n    let acx = A[0] - C[0];\r\n    let bcx = B[0] - C[0];\r\n    let acy = A[1] - C[1];\r\n    let bcy = B[1] - C[1];\r\n    let b = expansion_diff_1.expansionDiff(two_product_1.twoProduct(acx, bcy), two_product_1.twoProduct(acy, bcx));\r\n    let det = estimate_1.estimate(b);\r\n    if (Math.abs(det) >= ccwerrboundB * detsum) {\r\n        // Anti-clockwise or clockwise\r\n        return det;\r\n    }\r\n    let acxtail = two_diff_1.twoDiff(A[0], C[0])[0];\r\n    let bcxtail = two_diff_1.twoDiff(B[0], C[0])[0];\r\n    let acytail = two_diff_1.twoDiff(A[1], C[1])[0];\r\n    let bcytail = two_diff_1.twoDiff(B[1], C[1])[0];\r\n    if (acxtail === 0 && acytail === 0 &&\r\n        bcxtail === 0 && bcytail === 0) {\r\n        // Straight\r\n        return det;\r\n    }\r\n    let errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);\r\n    det += (acx * bcytail + bcy * acxtail) - (acy * bcxtail + bcx * acytail);\r\n    if (Math.abs(det) >= errbound) {\r\n        return det;\r\n    }\r\n    let a = expansion_diff_1.expansionDiff(two_product_1.twoProduct(acxtail, bcy), two_product_1.twoProduct(acytail, bcx));\r\n    let c = fast_expansion_sum_1.fastExpansionSum(b, a);\r\n    let d = expansion_diff_1.expansionDiff(two_product_1.twoProduct(acx, bcytail), two_product_1.twoProduct(acy, bcxtail));\r\n    let e = fast_expansion_sum_1.fastExpansionSum(c, d);\r\n    let f = expansion_diff_1.expansionDiff(two_product_1.twoProduct(acxtail, bcytail), two_product_1.twoProduct(acytail, bcxtail));\r\n    let D = fast_expansion_sum_1.fastExpansionSum(e, f);\r\n    D = compress_1.compress(D);\r\n    return D[D.length - 1];\r\n}\r\n//# sourceMappingURL=orient2d.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/orient2d.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/reduce-significand.js":
/*!***************************************************************!*\
  !*** ./node_modules/flo-numerical/node/reduce-significand.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Truncates a floating point value's significand. Similar to split, but with\r\n * the ability to specify the number of bits to keep.\r\n *\r\n * Theorem 17 (Veltkamp-Dekker): Let a be a p-bit floating-point number, where\r\n * p >= 3. Choose a splitting point s such that p/2 <= s <= p-1. Then the\r\n * following algorithm will produce a (p-s)-bit value a_hi and a\r\n * nonoverlapping (s-1)-bit value a_lo such that abs(a_hi) >= abs(a_lo) and\r\n * a = a_hi + a_lo.\r\n *\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n * @param a The number\r\n * @param bits The number of significand bits to leave intact.\r\n */\r\nfunction reduceSignificand(a, bits) {\r\n    let s = 53 - bits;\r\n    let f = Math.pow(2, s) + 1;\r\n    let c = f * a;\r\n    let r = c - (c - a);\r\n    return r;\r\n}\r\nexports.reduceSignificand = reduceSignificand;\r\n//# sourceMappingURL=reduce-significand.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/reduce-significand.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/representation/binary-string-to-double.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/representation/binary-string-to-double.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n// Modified from https://github.com/bartaz/ieee754-visualization/\r\n// under the MIT license\r\n// Copyright 2013 Bartek Szopka (original author)\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst octets_to_double_1 = __webpack_require__(/*! ./octets-to-double */ \"./node_modules/flo-numerical/node/representation/octets-to-double.js\");\r\n/**\r\n * @param str\r\n */\r\nfunction binaryStringToDouble(str) {\r\n    return octets_to_double_1.octetsToDouble(str.match(/.{8}/g).map(binaryStringToInt));\r\n}\r\nexports.binaryStringToDouble = binaryStringToDouble;\r\n/**\r\n * e.g. \"10001000\" -> 136\r\n */\r\nfunction binaryStringToInt(b) {\r\n    return parseInt(b, 2);\r\n}\r\n//# sourceMappingURL=binary-string-to-double.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/representation/binary-string-to-double.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/representation/bit-length.js":
/*!**********************************************************************!*\
  !*** ./node_modules/flo-numerical/node/representation/bit-length.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_max_set_bit_1 = __webpack_require__(/*! ./get-max-set-bit */ \"./node_modules/flo-numerical/node/representation/get-max-set-bit.js\");\r\n/**\r\n * Returns the bit-length of the significand of the given number in such a way\r\n * that trailing zeros are not counted.\r\n * @param a A double precision floating point number\r\n */\r\nfunction bitLength(a) {\r\n    if (a === 0) {\r\n        return 0;\r\n    }\r\n    return get_max_set_bit_1.getHighestSetBit(a) - get_max_set_bit_1.getLowestSetBit(a) + 1;\r\n}\r\nexports.bitLength = bitLength;\r\n//# sourceMappingURL=bit-length.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/representation/bit-length.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/representation/double-to-binary-string.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/representation/double-to-binary-string.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n// Modified from https://github.com/bartaz/ieee754-visualization/\r\n// under the MIT license\r\n// Copyright 2013 Bartek Szopka (original author)\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst double_to_octets_1 = __webpack_require__(/*! ./double-to-octets */ \"./node_modules/flo-numerical/node/representation/double-to-octets.js\");\r\nfunction doubleToBinaryString(number) {\r\n    return octetsToBinaryString(double_to_octets_1.doubleToOctets(number));\r\n}\r\nexports.doubleToBinaryString = doubleToBinaryString;\r\n/**\r\n * @param octets The 8 bytes composing a double (msb first)\r\n */\r\nfunction octetsToBinaryString(octets) {\r\n    return octets\r\n        .map(int8ToBinaryString)\r\n        .join('');\r\n}\r\n/**\r\n * intToBinaryString(8) -> \"00001000\"\r\n */\r\nfunction int8ToBinaryString(i) {\r\n    let iStr = i.toString(2);\r\n    for (; iStr.length < 8; iStr = \"0\" + iStr)\r\n        ;\r\n    return iStr;\r\n}\r\n//# sourceMappingURL=double-to-binary-string.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/representation/double-to-binary-string.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/representation/double-to-octets.js":
/*!****************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/representation/double-to-octets.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n// Modified from https://github.com/bartaz/ieee754-visualization/\r\n// under the MIT license\r\n// Copyright 2013 Bartek Szopka (original author)\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the ieee-574 8 bytes composing the given double, starting from the\r\n * sign bit and ending in the lsb of the significand.\r\n * e.g. 123.456 -> [64, 94, 221, 47, 26, 159, 190, 119]\r\n */\r\nfunction doubleToOctets(number) {\r\n    var buffer = new ArrayBuffer(8);\r\n    new DataView(buffer).setFloat64(0, number, false);\r\n    return Array.from(new Uint8Array(buffer));\r\n}\r\nexports.doubleToOctets = doubleToOctets;\r\n//# sourceMappingURL=double-to-octets.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/representation/double-to-octets.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/representation/exponent.js":
/*!********************************************************************!*\
  !*** ./node_modules/flo-numerical/node/representation/exponent.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst parse_double_1 = __webpack_require__(/*! ./parse-double */ \"./node_modules/flo-numerical/node/representation/parse-double.js\");\r\n/**\r\n * Returns the normalized exponent of the given number.\r\n * @param a A double\r\n */\r\nfunction exponent(a) {\r\n    return parse_double_1.parseDouble(a).exponent;\r\n}\r\nexports.exponent = exponent;\r\n//# sourceMappingURL=exponent.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/representation/exponent.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/representation/get-max-set-bit.js":
/*!***************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/representation/get-max-set-bit.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst significand_1 = __webpack_require__(/*! ./significand */ \"./node_modules/flo-numerical/node/representation/significand.js\");\r\n/**\r\n * Returns the lowest set bit of the given value in [1, (2**31)-1],\r\n * i.e. from 1 up to 2147483647 else if no bit is set (input === 0) returns\r\n * NaN, otherwise if the number is out of range returns a non-finite\r\n * number.\r\n * See https://stackoverflow.com/a/35190288/2010061\r\n */\r\nfunction getLowestSetBit_(a) {\r\n    return Math.log2(a & -a);\r\n}\r\n/**\r\n * Returns the lowest set bit of the given number's significand (where the lsb\r\n * is bit 0 and the msb is bit 52). If no bit is set (input === 0 or +-inf or\r\n * NaN) returns NaN.\r\n * See https://stackoverflow.com/a/35190288/2010061\r\n */\r\nfunction getLowestSetBit(a) {\r\n    if (a === 0 || !Number.isFinite(a)) {\r\n        // There is no lowest set bit\r\n        return NaN;\r\n    }\r\n    // Note: the significand includes the hidden bit!\r\n    let s = significand_1.significand(a);\r\n    let len = s.length;\r\n    for (let i = len - 1; i >= 0; i--) {\r\n        if (s[i] === 0) {\r\n            continue;\r\n        }\r\n        let l = getLowestSetBit_(s[i]);\r\n        if (Number.isFinite(l)) {\r\n            return (8 * (len - i - 1)) + l;\r\n        }\r\n    }\r\n    return NaN;\r\n}\r\nexports.getLowestSetBit = getLowestSetBit;\r\n/**\r\n * Returns the highest set bit of the given value in [1, 255], i.e. from 1 up\r\n * to 255. If the input number === 0 returns NaN.\r\n * See https://stackoverflow.com/a/35190288/2010061\r\n */\r\nfunction getHighestSetBit_(a) {\r\n    return a >= 128 ? 7\r\n        : a >= 64 ? 6\r\n            : a >= 32 ? 5\r\n                : a >= 16 ? 4\r\n                    : a >= 8 ? 3\r\n                        : a >= 4 ? 2\r\n                            : a >= 2 ? 1\r\n                                : a >= 1 ? 0\r\n                                    : NaN;\r\n}\r\n/**\r\n * Returns the highest set bit of the given double. If no bit is set (input\r\n * === 0 or +/-inf or NaN) returns NaN.\r\n * See https://stackoverflow.com/a/35190288/2010061\r\n */\r\nfunction getHighestSetBit(a) {\r\n    if (a === 0 || !Number.isFinite(a)) {\r\n        // There is no lowest set bit\r\n        return NaN;\r\n    }\r\n    // At this point there must be a highest set bit (always === 52 if the \r\n    // number is not a subnormal.\r\n    let s = significand_1.significand(a);\r\n    let len = s.length;\r\n    for (let i = 0; i < len; i++) {\r\n        let l = getHighestSetBit_(s[i]);\r\n        if (Number.isFinite(l)) {\r\n            return (8 * (len - i - 1)) + l;\r\n        }\r\n    }\r\n    return NaN;\r\n}\r\nexports.getHighestSetBit = getHighestSetBit;\r\n//# sourceMappingURL=get-max-set-bit.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/representation/get-max-set-bit.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/representation/is-bit-aligned.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/representation/is-bit-aligned.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_max_set_bit_1 = __webpack_require__(/*! ./get-max-set-bit */ \"./node_modules/flo-numerical/node/representation/get-max-set-bit.js\");\r\nconst exponent_1 = __webpack_require__(/*! ./exponent */ \"./node_modules/flo-numerical/node/representation/exponent.js\");\r\n/**\r\n * Returns true if the given number is bit-aligned in the sense that its a\r\n * multiple of a given power of 2, say e, and such that the number, say a,\r\n * conforms to: a/2^e < 2^(l-e), where l is the max allowed bit length.\r\n * This essentially means the numbers act somewhat like fixed-point numbers\r\n * which can drastically speed up some geometric algorithms and also reduce\r\n * their complexity.\r\n *\r\n * Visually:\r\n * These numbers (a,b and c) are grid aligned with e === 3 and max\r\n * bitlength === 6:\r\n *   a -> 00|101100|000\r\n *   b -> 00|000100|000\r\n *   c -> 00|110111|000\r\n * These are not\r\n *   a -> 01|101100|000\r\n *   b -> 00|000100|000\r\n * These are not\r\n *   a -> 00|101100|000\r\n *   b -> 00|000100|100\r\n * These are not\r\n *   a -> 00|101100|100\r\n *   b -> 00|000100|100\r\n * @param as An array of numbers to check\r\n * @param maxBitLength The max allowed bitlength\r\n * @param gridSpacingExponent The grid spacing === 1^gridSpacingExponent\r\n */\r\nfunction isBitAligned(a, maxBitLength, gridSpacingExponent) {\r\n    if (a === 0) {\r\n        return true;\r\n    }\r\n    let e = exponent_1.exponent(a);\r\n    let maxSetBit = get_max_set_bit_1.getHighestSetBit(a) - 52 + e;\r\n    let minSetBit = get_max_set_bit_1.getLowestSetBit(a) - 52 + e;\r\n    let minBitBigEnough = minSetBit >= gridSpacingExponent;\r\n    let maxBitSmallEnough = maxSetBit <= maxBitLength - 1 + gridSpacingExponent;\r\n    return minBitBigEnough && maxBitSmallEnough;\r\n}\r\nexports.isBitAligned = isBitAligned;\r\n//# sourceMappingURL=is-bit-aligned.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/representation/is-bit-aligned.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/representation/is-valid.js":
/*!********************************************************************!*\
  !*** ./node_modules/flo-numerical/node/representation/is-valid.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst is_adjacent_1 = __webpack_require__(/*! ../is-adjacent */ \"./node_modules/flo-numerical/node/is-adjacent.js\");\r\n/**\r\n * Returns true if the given floating point expansion is non-adjacent and\r\n * components of the expansion are ordered in ascending order by absolute value,\r\n * except that some components may be zero.\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf for the\r\n * definition of adjacency.\r\n * Implemented for testing purposes.\r\n * @param x A floating point expansion.\r\n */\r\nfunction isValid(x) {\r\n    for (let i = 1; i < x.length; i++) {\r\n        if (x[i] !== 0 && x[i - 1] !== 0 &&\r\n            Math.abs(x[i - 1]) >= Math.abs(x[i])) {\r\n            //console.log('Not in ascending order.');\r\n            return false;\r\n        }\r\n        if (is_adjacent_1.isAdjacent(x[i - 1], x[i])) {\r\n            //console.log('The expansion has adjacent components.');\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexports.isValid = isValid;\r\n//# sourceMappingURL=is-valid.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/representation/is-valid.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/representation/lsb-exponent.js":
/*!************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/representation/lsb-exponent.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_max_set_bit_1 = __webpack_require__(/*! ./get-max-set-bit */ \"./node_modules/flo-numerical/node/representation/get-max-set-bit.js\");\r\nconst exponent_1 = __webpack_require__(/*! ./exponent */ \"./node_modules/flo-numerical/node/representation/exponent.js\");\r\n/**\r\n * Returns the true exponent of the lsb that is set of the given number or\r\n * NaN if a === 0 or +-inf or NaN.\r\n * @param a An array of numbers to check\r\n */\r\nfunction lsbExponent(a) {\r\n    if (a === 0 || !Number.isFinite(a)) {\r\n        return NaN;\r\n    }\r\n    let e = exponent_1.exponent(a);\r\n    return get_max_set_bit_1.getLowestSetBit(a) - 52 + e;\r\n}\r\nexports.lsbExponent = lsbExponent;\r\n//# sourceMappingURL=lsb-exponent.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/representation/lsb-exponent.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/representation/msb-exponent.js":
/*!************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/representation/msb-exponent.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_max_set_bit_1 = __webpack_require__(/*! ./get-max-set-bit */ \"./node_modules/flo-numerical/node/representation/get-max-set-bit.js\");\r\nconst exponent_1 = __webpack_require__(/*! ./exponent */ \"./node_modules/flo-numerical/node/representation/exponent.js\");\r\n/**\r\n * Returns the true exponent of the msb that is set of the given number or\r\n * NaN if a === 0 or +-inf or NaN.\r\n * @param a An array of numbers to check\r\n */\r\nfunction msbExponent(a) {\r\n    if (a === 0 || !Number.isFinite(a)) {\r\n        return NaN;\r\n    }\r\n    let e = exponent_1.exponent(a);\r\n    // Will return e for all but subnormal numbers\r\n    return get_max_set_bit_1.getHighestSetBit(a) - 52 + e;\r\n}\r\nexports.msbExponent = msbExponent;\r\n//# sourceMappingURL=msb-exponent.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/representation/msb-exponent.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/representation/octets-to-double.js":
/*!****************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/representation/octets-to-double.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n// Modified from https://github.com/bartaz/ieee754-visualization/\r\n// under the MIT license\r\n// Copyright 2013 Bartek Szopka (original author)\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * [64, 94, 221, 47, 26, 159, 190, 119] -> 123.456\r\n */\r\nfunction octetsToDouble(octets) {\r\n    var buffer = new ArrayBuffer(8);\r\n    new Uint8Array(buffer).set(octets);\r\n    return new DataView(buffer).getFloat64(0, false);\r\n}\r\nexports.octetsToDouble = octetsToDouble;\r\n//# sourceMappingURL=octets-to-double.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/representation/octets-to-double.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/representation/parse-double.js":
/*!************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/representation/parse-double.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n// Modified from https://github.com/bartaz/ieee754-visualization/\r\n// under the MIT license\r\n// Copyright 2013 Bartek Szopka (original author)\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst double_to_binary_string_1 = __webpack_require__(/*! ./double-to-binary-string */ \"./node_modules/flo-numerical/node/representation/double-to-binary-string.js\");\r\nconst double_to_octets_1 = __webpack_require__(/*! ./double-to-octets */ \"./node_modules/flo-numerical/node/representation/double-to-octets.js\");\r\n/**\r\n * Returns the relevant parts of the given IEEE-754 double. The returned\r\n * exponent has been normalized (i.e. 1023 ha been subtracted) and the\r\n * significand has the hidden bit added if appropriate.\r\n * See https://github.com/bartaz/ieee754-visualization\r\n */\r\nfunction parseDouble(x) {\r\n    let parts = double_to_octets_1.doubleToOctets(x);\r\n    let p0 = parts[0];\r\n    let p1 = parts[1];\r\n    let sign = p0 >> 7;\r\n    let exponent_ = ((p0 & 127) << 4) + ((p1 & 0b11110000) >> 4);\r\n    //---- Check for negative / positive zero / denormalized numbers.\r\n    let hiddenMsb = exponent_ === 0 ? 0 : 16;\r\n    // Note: exponent === 0 => 0 or denormalized number (a.k.a. subnormal number).\r\n    let exponent = exponent_ === 0\r\n        ? exponent_ - 1022 // Subnormals also use an biased exponent of 1 (not 0!)\r\n        : exponent_ - 1023;\r\n    //---- Break up the significand into bytes\r\n    let significand = parts.slice(1);\r\n    significand[0] = (p1 & 15) + hiddenMsb;\r\n    return {\r\n        sign,\r\n        exponent,\r\n        significand\r\n    };\r\n}\r\nexports.parseDouble = parseDouble;\r\n/**\r\n * Returns the relevant parts of the given IEEE-754 double.\r\n * See https://github.com/bartaz/ieee754-visualization.\r\n * This is a slower version of parseDouble that gives binary string\r\n * representations of the components.\r\n */\r\nfunction parseDoubleDetailed(x) {\r\n    let str = double_to_binary_string_1.doubleToBinaryString(x);\r\n    // sign{1} exponent{11} fraction{52} === 64 bits (+1 hidden!)\r\n    let [, sign, exponent, significand] = str.match(/^(.)(.{11})(.{52})$/);\r\n    let exponent_ = parseInt(exponent, 2);\r\n    let hidden = exponent_ === 0 ? \"0\" : \"1\";\r\n    return {\r\n        full: sign + exponent + hidden + significand,\r\n        sign,\r\n        exponent,\r\n        hidden,\r\n        significand\r\n    };\r\n}\r\nexports.parseDoubleDetailed = parseDoubleDetailed;\r\n//# sourceMappingURL=parse-double.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/representation/parse-double.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/representation/significand.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flo-numerical/node/representation/significand.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst parse_double_1 = __webpack_require__(/*! ./parse-double */ \"./node_modules/flo-numerical/node/representation/parse-double.js\");\r\n/**\r\n * Return the significand of the given double with the hidden bit added (in case\r\n * a is not subnormal or 0, etc.)\r\n * @param a A double\r\n */\r\nfunction significand(a) {\r\n    return parse_double_1.parseDouble(a).significand;\r\n}\r\nexports.significand = significand;\r\n//# sourceMappingURL=significand.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/representation/significand.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/scale-expansion.js":
/*!************************************************************!*\
  !*** ./node_modules/flo-numerical/node/scale-expansion.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst two_product_1 = __webpack_require__(/*! ./two-product */ \"./node_modules/flo-numerical/node/two-product.js\");\r\nconst two_sum_1 = __webpack_require__(/*! ./two-sum */ \"./node_modules/flo-numerical/node/two-sum.js\");\r\nconst fast_two_sum_1 = __webpack_require__(/*! ./fast-two-sum */ \"./node_modules/flo-numerical/node/fast-two-sum.js\");\r\nconst compress_1 = __webpack_require__(/*! ./compress */ \"./node_modules/flo-numerical/node/compress.js\");\r\n/**\r\n * Returns the result of multiplying an expansion by a double.\r\n *\r\n * Theorem 19 (Shwechuk): Let e = sum_(i=1)^m(e_i) be a nonoverlapping expansion\r\n * of m p-bit components, and let b be a p-bit value where p >= 4. Suppose that\r\n * the components of e are sorted in order of increasing magnitude, except that\r\n * any of the e_i may be zero. Then the following algorithm will produce a\r\n * nonoverlapping expansion h such that h = sum_(i=1)^(2m)(h_i) = be, where the\r\n * components of h are also in order of increasing magnitude, except that any of\r\n * the h_i may be zero. Furthermore, if e is nonadjacent and round-to-even\r\n * tiebreaking is used, then h is non-adjacent.\r\n *\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n * @param e\r\n * @param b\r\n */\r\nfunction scaleExpansion(e, b) {\r\n    let m = e.length;\r\n    let h = new Array(2 * m);\r\n    let q;\r\n    let q_;\r\n    [h[0], q] = two_product_1.twoProduct(e[0], b);\r\n    for (let i = 1; i < m; i++) {\r\n        let [t, T] = two_product_1.twoProduct(e[i], b);\r\n        [h[2 * i - 1], q_] = two_sum_1.twoSum(q, t);\r\n        [h[2 * i], q] = fast_two_sum_1.fastTwoSum(T, q_);\r\n    }\r\n    h[2 * m - 1] = q;\r\n    return compress_1.compress(h);\r\n}\r\nexports.scaleExpansion = scaleExpansion;\r\n//# sourceMappingURL=scale-expansion.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/scale-expansion.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/sign.js":
/*!*************************************************!*\
  !*** ./node_modules/flo-numerical/node/sign.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the sign of the given expansion. From Shewchuk: \"A nonoverlapping\r\n * expansion is desirable because it is easy to determine its sign (take the\r\n * sign of the largest component) ... \"\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n * @param e A floating point expansion with zeroes eliminated.\r\n */\r\nfunction sign(e) {\r\n    if (e.length === 0) {\r\n        return 0;\r\n    }\r\n    return Math.sign(e[e.length - 1]);\r\n}\r\nexports.sign = sign;\r\n//# sourceMappingURL=sign.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/sign.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/split.js":
/*!**************************************************!*\
  !*** ./node_modules/flo-numerical/node/split.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * === Math.ceil(p/2) where p is the # of significand bits in a double === 53.\r\n */\r\nlet f = Math.pow(2, 27) + 1;\r\n/**\r\n * Returns the result of splitting a double into 2 26-bit doubles.\r\n *\r\n * Theorem 17 (Veltkamp-Dekker): Let a be a p-bit floating-point number, where\r\n * p >= 3. Choose a splitting point s such that p/2 <= s <= p-1. Then the\r\n * following algorithm will produce a (p-s)-bit value a_hi and a\r\n * nonoverlapping (s-1)-bit value a_lo such that abs(a_hi) >= abs(a_lo) and\r\n * a = a_hi + a_lo.\r\n *\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n * @param a A double floating point number\r\n */\r\nfunction split(a) {\r\n    let c = f * a;\r\n    let a_h = c - (c - a);\r\n    let a_l = a - a_h;\r\n    return [a_h, a_l];\r\n}\r\nexports.split = split;\r\n//# sourceMappingURL=split.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/split.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/two-diff.js":
/*!*****************************************************!*\
  !*** ./node_modules/flo-numerical/node/two-diff.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the exact result of subtracting b from a (as a floating point\r\n * expansion).\r\n * @param a\r\n * @param b\r\n */\r\nfunction twoDiff(a, b) {\r\n    let x = a - b;\r\n    let bvirt = a - x;\r\n    let y = (a - (x + bvirt)) + (bvirt - b);\r\n    return [y, x];\r\n}\r\nexports.twoDiff = twoDiff;\r\n//# sourceMappingURL=two-diff.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/two-diff.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/two-product.js":
/*!********************************************************!*\
  !*** ./node_modules/flo-numerical/node/two-product.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst split_1 = __webpack_require__(/*! ./split */ \"./node_modules/flo-numerical/node/split.js\");\r\n/**\r\n * Returns the exact result of multiplying two doubles.\r\n *\r\n * Theorem 18 (Shewchuk): Let a and b be p-bit floating-point numbers, where\r\n * p >= 6. Then the following algorithm will produce a nonoverlapping expansion\r\n * x + y such that ab = x + y, where x is an approximation to ab and y\r\n * represents the roundoff error in the calculation of x. Furthermore, if\r\n * round-to-even tiebreaking is used, x and y are non-adjacent.\r\n *\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n * @param a A double\r\n * @param b Another double\r\n */\r\nfunction twoProduct(a, b) {\r\n    let x = a * b;\r\n    let [a_high, a_low] = split_1.split(a);\r\n    let [b_high, b_low] = split_1.split(b);\r\n    let err1 = x - (a_high * b_high);\r\n    let err2 = err1 - (a_low * b_high);\r\n    let err3 = err2 - (a_high * b_low);\r\n    let y = (a_low * b_low) - err3;\r\n    return [y, x];\r\n}\r\nexports.twoProduct = twoProduct;\r\n//# sourceMappingURL=two-product.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/two-product.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/two-sum.js":
/*!****************************************************!*\
  !*** ./node_modules/flo-numerical/node/two-sum.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the exact result of adding two doubles.\r\n *\r\n * Theorem 7 (Knuth): Let a and b be p-bit floating-point numbers. Then the\r\n * following algorithm will produce a nonoverlapping expansion x + y such that\r\n * a + b = x + y, where x is an approximation to a + b and y is the roundoff\r\n * error in the calculation of x.\r\n *\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n */\r\nfunction twoSum(a, b) {\r\n    let x = a + b;\r\n    let bv = x - a;\r\n    let y = (a - (x - bv)) + (b - bv);\r\n    return [y, x];\r\n}\r\nexports.twoSum = twoSum;\r\n//# sourceMappingURL=two-sum.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/two-sum.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/all-roots-recursive.js":
/*!***********************************************************!*\
  !*** ./node_modules/flo-poly/node/all-roots-recursive.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst core_operators_1 = __webpack_require__(/*! ./core-operators */ \"./node_modules/flo-poly/node/core-operators.js\");\r\nconst root_operators_1 = __webpack_require__(/*! ./root-operators */ \"./node_modules/flo-poly/node/root-operators.js\");\r\nconst root_bounds_1 = __webpack_require__(/*! ./root-bounds */ \"./node_modules/flo-poly/node/root-bounds.js\");\r\nconst INF = Number.POSITIVE_INFINITY;\r\n/**\r\n * <p>Finds a near optimal approximation to the real roots (or those\r\n * within a range) of the input polynomial.\r\n * </p>\r\n * <p>\r\n * Only multiple roots of even order that is very close together may be\r\n * missed. (This is rarely a problem in practice - in a geometrical\r\n * application, for instance, this may mean two objects are barely\r\n * touching and returning either, all, or none of the repeated even\r\n * roots should not break the algorithm).\r\n * </p>\r\n * @param p - The polynomial\r\n * @param a - Lower limit of root values that should be returned -\r\n * defaults to -∞\r\n * @param b - Upper limit of root values that should be returned -\r\n * defaults to +∞\r\n * @example\r\n * FloPoly.allRoots([1, -10, 35, -50, 24]); //=> [1, 2.0000000000000036, 3.0000000000000067, 4]\r\n */\r\nfunction allRoots(p, a = -INF, b = +INF) {\r\n    p = core_operators_1.clip0(p);\r\n    let d = p.length - 1;\r\n    let rangeFilter = inRange(a, b);\r\n    if (d === 2) {\r\n        return root_operators_1.quadraticRoots(p)\r\n            .filter(rangeFilter);\r\n        // Investigate if any numerically stable algorithm could be as fast\r\n        // as this algorithm (i.e by finding cubic roots within quadratic\r\n        // root demarcated intervals via Brent's method. The cubicRoots \r\n        // algoritm below has been removed since it was numerically \r\n        // unstable.\r\n        /*} else if (d === 3) {\r\n            return cubicRoots(p)\r\n                .filter(rangeFilter)\r\n                .sort((a,b) => a-b)\r\n        } else if (d > 3) {*/\r\n    }\r\n    else if (d > 2) {\r\n        // TODO The root bounding function below might have an impact on \r\n        // performance - it would probably be better to use \r\n        // positiveRootUpperBound_LMQ or (possibly) even better, the \r\n        // linear version of it (see paper of Viglas, Akritas and \r\n        // Strzebonski) and re-calculate bounds on every iteration.\r\n        let lowerBound;\r\n        let upperBound;\r\n        if (a === -INF || b === +INF) {\r\n            //let magnitudeBound = rootMagnitudeUpperBound_fujiwara(p);\r\n            //lowerBound = a === -INF ? -magnitudeBound : a;\r\n            //upperBound = b === +INF ? +magnitudeBound : b;\r\n            if (a === -INF) {\r\n                lowerBound = root_bounds_1.negativeRootLowerBound_LMQ(p);\r\n            }\r\n            else {\r\n                lowerBound = a;\r\n            }\r\n            if (b === +INF) {\r\n                upperBound = root_bounds_1.positiveRootUpperBound_LMQ(p);\r\n            }\r\n            else {\r\n                upperBound = b;\r\n            }\r\n        }\r\n        else {\r\n            lowerBound = a;\r\n            upperBound = b;\r\n        }\r\n        // If the roots of the differentiated polynomial is out of range \r\n        // then the roots of the polynomial itself will also be out of \r\n        // range.\r\n        let dp = core_operators_1.differentiate(p);\r\n        let roots = allRoots(dp, lowerBound, upperBound)\r\n            .filter(rangeFilter);\r\n        if (roots[0] !== lowerBound) {\r\n            // For code coverage to cover the 'else' case we would need\r\n            // to find a case where the lower bound actually matches the\r\n            // root which would be very rare - needs further \r\n            // investigation.\r\n            // Not an actual root.\r\n            roots.unshift(lowerBound);\r\n        }\r\n        if (roots[roots.length - 1] !== upperBound) {\r\n            // Not an actual root.\r\n            roots.push(upperBound);\r\n        }\r\n        return rootsWithin(p, roots);\r\n    }\r\n    else if (d === 1) {\r\n        // Less likely so put near bottom (micro optimization)\r\n        return [-p[1] / p[0]]\r\n            .filter(rangeFilter);\r\n    }\r\n    else if (d === 0) {\r\n        return []; // y = c -> no roots\t\r\n    }\r\n    // Least likely so put at bottom (micro optimization)\r\n    // d === -1\r\n    // y = 0 -> infinite number of roots\r\n    return [];\r\n}\r\nexports.allRoots = allRoots;\r\n/**\r\n * Returns a function that returns true if x is in the range [a,b].\r\n * @param a\r\n * @param b\r\n * @private\r\n */\r\nfunction inRange(a, b) {\r\n    return x => x >= a && x <= b;\r\n}\r\n/**\r\n * Finds all roots of the given polynomial within the given intervals.\r\n * @private\r\n * @param p\r\n * @param intervals\r\n */\r\nfunction rootsWithin(p, intervals) {\r\n    let roots = [];\r\n    let peval = core_operators_1.evaluate(p);\r\n    let prevRoot;\r\n    let a = intervals[0];\r\n    for (let i = 1; i < intervals.length; i++) {\r\n        let root;\r\n        let b = intervals[i];\r\n        let evA = peval(a);\r\n        let evB = peval(b);\r\n        let k = evA * evB;\r\n        if (k === 0) {\r\n            if (evA === 0) {\r\n                root = a;\r\n            }\r\n            else if (evB === 0 && i === intervals.length - 1) {\r\n                root = b;\r\n            }\r\n        }\r\n        else if (evA * evB < 0) {\r\n            root = root_operators_1.brent(peval, a, b);\r\n        }\r\n        // Add root if it exists and suppress exact duplicates\r\n        if (root !== undefined && root !== prevRoot) {\r\n            roots.push(root);\r\n            prevRoot = root;\r\n        }\r\n        a = b;\r\n    }\r\n    return roots;\r\n}\r\n//# sourceMappingURL=all-roots-recursive.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/all-roots-recursive.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/core-operators.js":
/*!******************************************************!*\
  !*** ./node_modules/flo-poly/node/core-operators.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns true if two polynomials are exactly equal by comparing\r\n * coefficients.\r\n * @param p1 - A polynomial\r\n * @param p2 - Another polynomial\r\n * @example\r\n * FloPoly.equal([1,2,3,4], [1,2,3,4]);   //=> true\r\n * FloPoly.equal([1,2,3,4], [1,2,3,4,5]); //=> false\r\n */\r\nfunction equal(p1, p2) {\r\n    if (p1.length !== p2.length) {\r\n        return false;\r\n    }\r\n    for (let i = 0; i < p1.length; i++) {\r\n        if (p1[i] !== p2[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexports.equal = equal;\r\n/**\r\n * Adds two polynomials.\r\n * @param p1 - The first polynomial\r\n * @param p2 - The second polynomial\r\n * @example\r\n * FloPoly.add([1,2,3],[3,4]); //=> [1,5,7]\r\n */\r\nfunction add(p1, p2) {\r\n    // Initialize result array  \r\n    let d1 = p1.length - 1;\r\n    let d2 = p2.length - 1;\r\n    let Δd = d1 - d2;\r\n    let Δd1 = 0;\r\n    let Δd2 = 0;\r\n    if (Δd > 0) {\r\n        Δd2 = -Δd;\r\n    }\r\n    else if (Δd < 0) {\r\n        Δd1 = +Δd;\r\n    }\r\n    let d = Math.max(d1, d2);\r\n    // Add coefficients\r\n    let result = [];\r\n    for (let i = 0; i < d + 1; i++) {\r\n        let c1 = p1[i + Δd1];\r\n        let c2 = p2[i + Δd2];\r\n        result.push((c1 || 0) + (c2 || 0));\r\n    }\r\n    // Ensure the result is a valid polynomial representation\r\n    return clip0(result);\r\n}\r\nexports.add = add;\r\n/**\r\n * Subtracts the second polynomial from first (p1 - p2).\r\n * @param p1 - The polynomial from which will be subtracted\r\n * @param p2 - The polynomial that will be subtracted\r\n * @example\r\n * FloPoly.subtract([2,3],[4,4]); //=> [-2, -1]\r\n */\r\nfunction subtract(p1, p2) {\r\n    // Initialize result array  \r\n    let d1 = p1.length - 1;\r\n    let d2 = p2.length - 1;\r\n    let Δd = d1 - d2;\r\n    let Δd1 = 0;\r\n    let Δd2 = 0;\r\n    if (Δd > 0) {\r\n        Δd2 = -Δd;\r\n    }\r\n    else if (Δd < 0) {\r\n        Δd1 = +Δd;\r\n    }\r\n    let d = Math.max(d1, d2);\r\n    // Add coefficients\r\n    let result = [];\r\n    for (let i = 0; i < d + 1; i++) {\r\n        let c1 = p1[i + Δd1];\r\n        let c2 = p2[i + Δd2];\r\n        result.push((c1 || 0) - (c2 || 0));\r\n    }\r\n    // Ensure the result is a valid polynomial representation\r\n    return clip0(result);\r\n}\r\nexports.subtract = subtract;\r\n/**\r\n * Negate the given polynomial (p -> -p).\r\n * @param p - The polynomial\r\n * @example\r\n * FloPoly.negate([0.1, -0.2]); //=> [-0.1, 0.2]\r\n */\r\nfunction negate(p) {\r\n    return multiplyByConst(-1, p);\r\n}\r\nexports.negate = negate;\r\n/**\r\n * Differentiates the given polynomial.\r\n * @param p - The polynomial\r\n * @example\r\n * FloPoly.differentiate([5, 4, 3, 2, 1]); //=> [20, 12, 6, 2]\r\n */\r\nfunction differentiate(p) {\r\n    let result = [];\r\n    let d = p.length - 1;\r\n    for (let i = 0; i < d; i++) {\r\n        result.push((d - i) * p[i]);\r\n    }\r\n    return result;\r\n}\r\nexports.differentiate = differentiate;\r\n/**\r\n * <p>\r\n * Multiplies the two given polynomials and returns the result.\r\n * </p>\r\n * <p>\r\n * See <a href=\"https://en.wikipedia.org/wiki/Polynomial_arithmetic\">polynomial arithmetic</a>\r\n * </p>\r\n * <p>\r\n * See <a href=\"https://en.wikipedia.org/wiki/Discrete_Fourier_transform#Polynomial_multiplication\">polynomial multiplication</a>\r\n * </p>\r\n * <p>\r\n * See <a herf=\"http://web.cs.iastate.edu/~cs577/handouts/polymultiply.pdf\">polynomial multiplication (pdf)</a>\r\n * </p>\r\n * @param p1 - The one polynomial.\r\n * @param p2 - The other polynomial.\r\n * @example\r\n * FloPoly.multiply([1,2,3], [2,5,3,5]); //=> [2, 9, 19, 26, 19, 15]\r\n */\r\nfunction multiply(p1, p2) {\r\n    let d1 = p1.length - 1;\r\n    let d2 = p2.length - 1;\r\n    let d = d1 + d2;\r\n    let result = new Array(d + 1).fill(0);\r\n    for (let i = 0; i < d1 + 1; i++) {\r\n        for (let j = 0; j < d2 + 1; j++) {\r\n            result[d - (i + j)] += (p1[d1 - i] * p2[d2 - j]);\r\n        }\r\n    }\r\n    return clip0(result);\r\n}\r\nexports.multiply = multiply;\r\n/**\r\n * Multiplies 2 polynomials by a constant.\r\n * @param c - The constant\r\n * @param p - The polynomial\r\n * @example\r\n * FloPoly.multiplyByConst(0.25, [3,2,1]); //=> [0.75, 0.5, 0.25]\r\n */\r\nfunction multiplyByConst(c, p) {\r\n    if (c === 0) {\r\n        return [];\r\n    }\r\n    let d = p.length - 1;\r\n    let result = [];\r\n    for (let i = 0; i < d + 1; i++) {\r\n        result.push(c * p[i]);\r\n    }\r\n    // We have to clip due to possible floating point underflow\r\n    return clip0(result);\r\n}\r\nexports.multiplyByConst = multiplyByConst;\r\n/**\r\n * Returns the degree of the polynomial.\r\n * @param p - The polynomial\r\n * @example\r\n * FloPoly.degree([9,8,7,6,5,4,3,2,1]); //=> 9\r\n */\r\nfunction degree(p) {\r\n    return p.length - 1;\r\n}\r\nexports.degree = degree;\r\nfunction evaluate(p, a) {\r\n    function f(a) {\r\n        if (p.length === 0) {\r\n            return 0;\r\n        }\r\n        let result = p[0];\r\n        for (let i = 1; i < p.length; i++) {\r\n            result = p[i] + result * a;\r\n        }\r\n        return result;\r\n    }\r\n    // Curry the function\r\n    return a === undefined ? f : f(a);\r\n}\r\nexports.evaluate = evaluate;\r\n/**\r\n * Evaluates the given polynomial at 0 - it is much faster than at an\r\n * arbitrary point.\r\n * @param p - The polynomial\r\n * @example\r\n * FloPoly.evaluateAt0([3,2,99]); //=> 99\r\n */\r\nfunction evaluateAt0(p) {\r\n    return p[p.length - 1];\r\n}\r\nexports.evaluateAt0 = evaluateAt0;\r\n;\r\n/**\r\n * <p>\r\n * Returns the number of sign changes in the polynomial coefficents\r\n * when ordered in descending order; zeros are ignored.\r\n * </p>\r\n * <p>\r\n * Descartes' rule of signs states (quoted from Wikipedia):\r\n * \"if the terms of a polynomial are ordered by descending variable\r\n * exponent, then the number of positive roots of the polynomial is\r\n * either equal to the number of sign differences between consecutive\r\n * nonzero coefficients, or is less than it by an even number. Multiple\r\n * roots of the same value are counted separately.\"\r\n * </p>\r\n * See https://en.wikipedia.org/wiki/Descartes%27_rule_of_signs\r\n * @param p - The polynomial\r\n * @example\r\n * FloPoly.signChanges([1,2,-3,0,0,3,-1]); //=> 3\r\n */\r\nfunction signChanges(p) {\r\n    let d = p.length - 1;\r\n    let result = 0;\r\n    let prevSign = Math.sign(p[0]);\r\n    for (let i = 1; i < d + 1; i++) {\r\n        let sign = Math.sign(p[i]);\r\n        if (sign !== prevSign && sign !== 0) {\r\n            result++;\r\n            prevSign = sign;\r\n        }\r\n    }\r\n    return result;\r\n}\r\nexports.signChanges = signChanges;\r\n/**\r\n * Deflates the given polynomial by removing a factor (x - r), where\r\n * r is a root of the polynomial.\r\n * @param p - The polynomial\r\n * @param root - A pre-calculated root of the polynomial.\r\n * @example\r\n * // The polynomial x^3 - 5x^2 + 8x - 4 has a root at 1 and a double root at 2\r\n * FloPoly.deflate([1, -5, 8, -4], 2); //=> [1, -3, 2]\r\n * FloPoly.deflate([1, -3, 2], 2);     //=> [1,-1]\r\n * FloPoly.deflate([1, -1], 1);        //=> [1]\r\n */\r\nfunction deflate(p, root) {\r\n    let d = p.length - 1;\r\n    let bs = [p[0]];\r\n    for (let i = 1; i < d; i++) {\r\n        bs.push(p[i] + root * bs[i - 1]);\r\n    }\r\n    return bs;\r\n}\r\nexports.deflate = deflate;\r\n/**\r\n * Inverts the given polynomial by reversing the order of the\r\n * coefficients, i.e. p(x) -> x^deg(p) * p(1/x)\r\n * @param p - The polynomial\r\n * @example\r\n * FloPoly.invert([1,2,3,4]); // => [4,3,2,1]\r\n * FloPoly.invert([3,2,-5]);  // => [-5,2,3]\r\n */\r\nfunction invert(p) {\r\n    return p.slice().reverse();\r\n}\r\nexports.invert = invert;\r\n/**\r\n * <p>\r\n * Performs a change of variables of the form: p(x) <- p(ax + b).\r\n * </p>\r\n * <p>\r\n * See <a href=\"http://stackoverflow.com/questions/141422/how-can-a-transform-a-polynomial-to-another-coordinate-system\">this stackoverflow question</a>\r\n * </p>\r\n * @param p - The polynomial\r\n * @param a\r\n * @param b\r\n * @example\r\n * FloPoly.changeVariables([1,2,7], 3, 4); //=> [9, 30, 31]\r\n */\r\nfunction changeVariables(p, a, b) {\r\n    // We let the coefficients of p(ax + b) be denoted by d_i in the \r\n    // code below. \r\n    // d_i is calculated as d = T*c, where c are the original \r\n    // coefficients.\r\n    let d = p.length - 1;\r\n    // Initialize a zero matrix\r\n    let t = [];\r\n    for (let i = 0; i < d + 1; i++) {\r\n        t.push(new Array(d + 1).fill(0));\r\n    }\r\n    // Calculate the triangular matrix T\r\n    t[0][0] = 1;\r\n    for (let j = 1; j <= d; j++) {\r\n        t[0][j] = b * t[0][j - 1];\r\n        for (let i = 1; i <= j; i++) {\r\n            t[i][j] = b * t[i][j - 1] + a * t[i - 1][j - 1];\r\n        }\r\n    }\r\n    // Multiply\r\n    let res = new Array(d + 1).fill(0);\r\n    for (let i = 0; i <= d; i++) {\r\n        res[d - i] = 0;\r\n        for (let j = i; j <= d; j++) {\r\n            let acc = t[i][j] * p[d - j];\r\n            res[d - i] += acc;\r\n        }\r\n    }\r\n    return res;\r\n}\r\nexports.changeVariables = changeVariables;\r\n/**\r\n * Reflects the given polynomial about the Y-axis, i.e. perform the\r\n * change of variables: p(x) <- p(-x).\r\n * @param p - The polynomial to reflect\r\n * @example\r\n * FloPoly.reflectAboutYAxis([5,4,3,2,1]); //=> [5, -4, 3, -2, 1]\r\n */\r\nfunction reflectAboutYAxis(p) {\r\n    let d = p.length - 1;\r\n    let result = p.slice();\r\n    for (let i = 0; i < d + 1; i++) {\r\n        if (i % 2) {\r\n            result[i] = -result[i];\r\n        }\r\n    }\r\n    return result;\r\n}\r\nexports.reflectAboutYAxis = reflectAboutYAxis;\r\n/**\r\n * Generates a sturm chain for the given polynomial.\r\n * See https://en.wikipedia.org/wiki/Sturm%27s_theorem\r\n * @param p - The polynomial\r\n * @example\r\n * FloPoly.sturmChain([-3,4,2,-2]); //=> [[-3, 4, 2, -2], [-9, 8, 2], [-2.5185185185185186, 1.7037037037037037], [-3.2932525951557086]]\r\n */\r\nfunction sturmChain(p) {\r\n    /**\r\n     * Returns the negative of the remainder when dividing the first\r\n     * polynomial (the dividend) by the second (the divisor) provided\r\n     * that deg(p1) - deg(p2) === 1.\r\n     * @private\r\n     * @param p1 - The first polynomial (dividend)\r\n     * @param p2 - The second polynomial (divisor)\r\n     * See https://en.wikipedia.org/wiki/Sturm%27s_theorem\r\n     */\r\n    function negRemainder(p1, p2) {\r\n        let d1 = p1.length - 1;\r\n        let d2 = p2.length - 1;\r\n        let d = d1 - d2;\r\n        let a = p1[1] / p1[0] - p2[1] / p2[0];\r\n        let b = p1[0] / p2[0];\r\n        let p3 = multiply(multiplyByConst(b, p2), [1, a]);\r\n        return subtract(p3, p1);\r\n    }\r\n    let m = []; // Sturm chain\r\n    m.push(p);\r\n    m.push(differentiate(p));\r\n    //const δ = 10 * Number.EPSILON;\r\n    let i = 1;\r\n    while (m[i].length - 1 > 0) {\r\n        let pnext = negRemainder(m[i - 1], m[i]);\r\n        //pnext = clip(pnext, δ);\r\n        // If the polynomial degree was not reduced due to roundoff\r\n        // such that the first 1 or more terms are very small.\r\n        while (m[i].length - pnext.length < 1) {\r\n            pnext.shift();\r\n        }\r\n        /*\r\n        if (pnext.length === 0) {\r\n            break;\r\n        }\r\n        */\r\n        m.push(pnext);\r\n        i++;\r\n    }\r\n    return m;\r\n}\r\nexports.sturmChain = sturmChain;\r\n/**\r\n * If the highest power coefficient is small in the sense that the\r\n * highest power term has a negligible contribution (compared to the\r\n * other terms) at x = 1 then clip() can be called to remove all such\r\n * highest terms. A contribution of less than Number.EPSILON of the\r\n * highest coefficient will be considered negligible by default.\r\n * @param p - The polynomial to be clipped.\r\n * @param δ - The optional contribution tolerence else\r\n *        Number.EPSILON will be used by default.\r\n * @example\r\n * FloPoly.clip([1e-18, 1e-10, 1e-5]); //=> [1e-18, 1e-10, 1e-5]\r\n * FloPoly.clip([1e-18, 1e-10, 1e-1]); //=> [1e-10, 1e-1]\r\n */\r\nfunction clip(p, δ) {\r\n    δ = (δ === undefined) ? Number.EPSILON : δ;\r\n    let c = maxCoefficient(p);\r\n    if (c === 0) {\r\n        return [];\r\n    }\r\n    if (Math.abs(p[0]) > δ * c) {\r\n        return p;\r\n    }\r\n    let p_ = p.slice(1);\r\n    while (Math.abs(p_[0]) < δ * c) {\r\n        p_ = p_.slice(1);\r\n    }\r\n    return clip(p_, δ);\r\n}\r\nexports.clip = clip;\r\n/**\r\n * If the highest power coefficient is 0 then clip() can be called to\r\n * remove all such highest terms so that the array is a valid\r\n * presentation of a polynomial.\r\n * @param p - The polynomial to be clipped.\r\n * @example\r\n * FloPoly.clip0([1e-18, 1e-10, 1e-1]); //=> [1e-18, 1e-10, 1e-1]\r\n * FloPoly.clip0([0, 1e-10, 1e-1]); //=> [1e-10, 1e-1]\r\n */\r\nfunction clip0(p) {\r\n    return p[0] !== 0 ? p : clip0(p.slice(1));\r\n}\r\nexports.clip0 = clip0;\r\n/**\r\n * Returns the absolute value of the highest coefficient of the polynomial.\r\n * @param p - The polynomial.\r\n * @example\r\n * FloPoly.maxCoefficient([-2, 0.1, 0.2]); //=> 2\r\n */\r\nfunction maxCoefficient(p) {\r\n    let max = 0;\r\n    for (let i = 0; i < p.length; i++) {\r\n        let c = Math.abs(p[i]);\r\n        if (c > max) {\r\n            max = c;\r\n        }\r\n    }\r\n    return max;\r\n}\r\nexports.maxCoefficient = maxCoefficient;\r\n/**\r\n * Returns a string representing the given polynomial that is readable\r\n * by a human or a CAS (Computer Algebra System).\r\n * @param p - The polynomial\r\n * @example\r\n * FloPoly.toCasStr([5,4,3,2,1]); //=> \"x^4*5 + x^3*4 + x^2*3 + x*2 + 1\"\r\n */\r\nfunction toCasStr(p) {\r\n    let d = p.length - 1;\r\n    let str = '';\r\n    for (let i = 0; i < d + 1; i++) {\r\n        let cStr = p[i].toString();\r\n        if (i === d) {\r\n            str += cStr;\r\n        }\r\n        else if (i === d - 1) {\r\n            str += 'x*' + cStr + ' + ';\r\n        }\r\n        else {\r\n            str += 'x^' + (d - i).toString() + '*' + cStr + ' + ';\r\n        }\r\n    }\r\n    return str;\r\n}\r\nexports.toCasStr = toCasStr;\r\n//# sourceMappingURL=core-operators.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/core-operators.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/error-analysis.js":
/*!******************************************************!*\
  !*** ./node_modules/flo-poly/node/error-analysis.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Approximate condition number for polynomial evaluation multiplied by the\r\n * exact value of the polynomial evaluation.\r\n * See Compensated Horner Scheme - paragraph 1.1\r\n * http://www-pequan.lip6.fr/~jmc/polycopies/Compensation-horner.pdf\r\n * @ignore\r\n * @param p - The polynomial\r\n * @param x - The evaluation point\r\n */\r\nfunction conditionNumber(p, x) {\r\n    let d = p.length - 1;\r\n    let res = 0;\r\n    for (let i = 0; i < d; i++) {\r\n        res += Math.abs(p[i] * Math.pow(x, d - i));\r\n    }\r\n    return res;\r\n}\r\n/**\r\n * Classic rule of thumb approximate error bound when using Horner's\r\n * method to evaluate polynomials.\r\n * See for instance compensated horner evaluation http://www-pequan.lip6.fr/~jmc/polycopies/Compensation-horner.pdf\"\r\n * @param p - The polynomial\r\n * @param x - Value at which polynomial is evaluated.\r\n  * @example\r\n * hornerErrorBound([1.1,2.2,-3.3], 1.5); //=> 5.1292303737682235e-15\r\n */\r\nfunction hornerErrorBound(p, x) {\r\n    const δ = Number.EPSILON;\r\n    let d = p.length - 1;\r\n    return 2 * d * δ * conditionNumber(p, x);\r\n}\r\nexports.hornerErrorBound = hornerErrorBound;\r\n//# sourceMappingURL=error-analysis.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/error-analysis.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/from-roots.js":
/*!**************************************************!*\
  !*** ./node_modules/flo-poly/node/from-roots.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst core_operators_1 = __webpack_require__(/*! ./core-operators */ \"./node_modules/flo-poly/node/core-operators.js\");\r\n/**\r\n * <p>\r\n * Constructs a polynomial from the given roots by multiplying out the\r\n * factors (x - root1)(x - root2)... Note that the resulting polynomial\r\n * will not have any complex roots.\r\n * </p>\r\n * <p>\r\n * Mostly provided for testing purposes. Note that the real roots of the\r\n * constructed polynomial may not be exactly the same as the roots that\r\n * the polynomial has been constructed from due to floating-point\r\n * round-off.\r\n * </p>\r\n *\r\n * @param roots - The roots\r\n * @example\r\n * FloPoly.fromRoots([1,2,3,3]); //=> [1, -9, 29, -39, 18]\r\n * FloPoly.allRoots([1, -9, 29, -39, 18]); //=> [1.0000000000000007, 2.000000000000004]\r\n * // In the above note the rounding error. Also note the multiple root of 3 that has been missed but as stated previously this does not generally pose a problem for even multiple roots. See the examples below.\r\n * FloPoly.allRoots([1, -9, 29, -39, 17.99999999999999]); //=> [0.9999999999999973, 2.00000000000002, 2.9999999999999982]\r\n * FloPoly.allRoots([1, -9, 29, -39, 17.9999999999999]); //=> [0.999999999999975, 2.0000000000000986, 2.9999997898930832, 3.0000002095475775]\r\n */\r\nfunction fromRoots(roots) {\r\n    let p = [1];\r\n    for (let i = 0; i < roots.length; i++) {\r\n        p = core_operators_1.multiply(p, [1, -roots[i]]);\r\n    }\r\n    return p;\r\n}\r\nexports.fromRoots = fromRoots;\r\n//# sourceMappingURL=from-roots.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/from-roots.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/index.js":
/*!*********************************************!*\
  !*** ./node_modules/flo-poly/node/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst core_operators_1 = __webpack_require__(/*! ./core-operators */ \"./node_modules/flo-poly/node/core-operators.js\");\r\nexports.equal = core_operators_1.equal;\r\nexports.add = core_operators_1.add;\r\nexports.subtract = core_operators_1.subtract;\r\nexports.multiplyByConst = core_operators_1.multiplyByConst;\r\nexports.negate = core_operators_1.negate;\r\nexports.differentiate = core_operators_1.differentiate;\r\nexports.multiply = core_operators_1.multiply;\r\nexports.degree = core_operators_1.degree;\r\nexports.evaluate = core_operators_1.evaluate;\r\nexports.evaluateAt0 = core_operators_1.evaluateAt0;\r\nexports.signChanges = core_operators_1.signChanges;\r\nexports.invert = core_operators_1.invert;\r\nexports.changeVariables = core_operators_1.changeVariables;\r\nexports.reflectAboutYAxis = core_operators_1.reflectAboutYAxis;\r\nexports.sturmChain = core_operators_1.sturmChain;\r\nexports.clip = core_operators_1.clip;\r\nexports.clip0 = core_operators_1.clip0;\r\nexports.deflate = core_operators_1.deflate;\r\nexports.maxCoefficient = core_operators_1.maxCoefficient;\r\nexports.toCasStr = core_operators_1.toCasStr;\r\nconst root_operators_1 = __webpack_require__(/*! ./root-operators */ \"./node_modules/flo-poly/node/root-operators.js\");\r\nexports.quadraticRoots = root_operators_1.quadraticRoots;\r\nexports.numRootsWithin = root_operators_1.numRootsWithin;\r\nexports.brent = root_operators_1.brent;\r\nexports.bisection = root_operators_1.bisection;\r\nconst root_bounds_1 = __webpack_require__(/*! ./root-bounds */ \"./node_modules/flo-poly/node/root-bounds.js\");\r\nexports.rootMagnitudeUpperBound_fujiwara = root_bounds_1.rootMagnitudeUpperBound_fujiwara;\r\nexports.positiveRootUpperBound_LMQ = root_bounds_1.positiveRootUpperBound_LMQ;\r\nexports.positiveRootLowerBound_LMQ = root_bounds_1.positiveRootLowerBound_LMQ;\r\nexports.negativeRootUpperBound_LMQ = root_bounds_1.negativeRootUpperBound_LMQ;\r\nexports.negativeRootLowerBound_LMQ = root_bounds_1.negativeRootLowerBound_LMQ;\r\nexports.rootMagnitudeUpperBound_rouche = root_bounds_1.rootMagnitudeUpperBound_rouche;\r\nconst all_roots_recursive_1 = __webpack_require__(/*! ./all-roots-recursive */ \"./node_modules/flo-poly/node/all-roots-recursive.js\");\r\nexports.allRoots = all_roots_recursive_1.allRoots;\r\nconst random_1 = __webpack_require__(/*! ./random */ \"./node_modules/flo-poly/node/random.js\");\r\nexports.flatRoots = random_1.flatRoots;\r\nexports.flatRootsArr = random_1.flatRootsArr;\r\nexports.flatCoefficients = random_1.flatCoefficients;\r\nexports.flatCoefficientsArr = random_1.flatCoefficientsArr;\r\nexports.predictiveRandom = random_1.predictiveRandom;\r\nconst error_analysis_1 = __webpack_require__(/*! ./error-analysis */ \"./node_modules/flo-poly/node/error-analysis.js\");\r\nexports.hornerErrorBound = error_analysis_1.hornerErrorBound;\r\nconst from_roots_1 = __webpack_require__(/*! ./from-roots */ \"./node_modules/flo-poly/node/from-roots.js\");\r\nexports.fromRoots = from_roots_1.fromRoots;\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/index.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/random.js":
/*!**********************************************!*\
  !*** ./node_modules/flo-poly/node/random.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst from_roots_1 = __webpack_require__(/*! ./from-roots */ \"./node_modules/flo-poly/node/from-roots.js\");\r\n/**\r\n * Some seed value for the simple random number generator.\r\n * @ignore\r\n */\r\nconst SEED = 123456789;\r\n/**\r\n * The range for the simple random number generator, i.e. the generated\r\n * numbers will be in [0,RANGE].\r\n * @ignore\r\n */\r\nconst RANGE = 4294967296;\r\n/**\r\n * Creates a function from the given function with parameters similar\r\n * to flatRoots but with an extra parameter in the beginning indicating\r\n * the length of the array generated by the original function.\r\n * @private\r\n * @param f\r\n */\r\nfunction createArrFunction(f) {\r\n    return function (n, d, a, b, seed = SEED, odds = 0) {\r\n        let res = [];\r\n        for (let i = 0; i < n; i++) {\r\n            let v = f(d, a, b, seed, odds);\r\n            let p = v.p;\r\n            seed = v.seed;\r\n            res.push(p);\r\n        }\r\n        return res;\r\n    };\r\n}\r\n/**\r\n * Generates an array of random polynomials with parameters as specified\r\n * by flatRoots. The exact same polynomials will be created on each\r\n * call to this function if the same seed is used - this is by design to\r\n * improve testability.\r\n * @memberof Random\r\n * @param n - The number of polynomials to generate.\r\n * @param d - The degree of the polynomials\r\n * @param a - The lower bound of the distribution - defaults\r\n * to 0\r\n * @param b - The upper bound of the distribution - defaults\r\n * to 1\r\n * @param seed - A seed value for generating random values (so\r\n * that the results are reproducable)\r\n * @param odds - The odds that a root will be doubled (applied\r\n * recursively so that some roots will be tripled, etc. - defaults to 0\r\n * @example\r\n * FloPoly.Random.flatRootsArr(2,3,0,10); //=> [[1, -17.27247918024659, 97.33487287168995, -179.34094494147305], [1, -14.934967160224915, 57.624514485645406, -14.513933300587215]]\r\n * FloPoly.Random.flatRootsArr(2,3,0,10); //=> [[1, -17.27247918024659, 97.33487287168995, -179.34094494147305], [1, -14.934967160224915, 57.624514485645406, -14.513933300587215]]\r\n */\r\nlet flatRootsArr = createArrFunction(flatRoots);\r\nexports.flatRootsArr = flatRootsArr;\r\n/**\r\n * Generates and returns an array of random polynomials as specified by\r\n * flatCoefficients. The exact same polynomials will be created on each\r\n * call to this function if the same seed is used - this is by design to\r\n * improve testability.\r\n *\r\n * @memberof Random\r\n * @param n The number of polynomials to generate.\r\n * @param d The degree of the polynomials\r\n * @param a The lower bound of the distribution - defaults to 0\r\n * @param b The upper bound of the distribution - defaults to 1\r\n * @param seed - A seed value for generating random values (so\r\n * that the results are reproducable)\r\n * @example\r\n * flatCoefficientsArr(2,3,-2,2); //=> [[0.1749166026711464, -0.20349335670471191, 0.9375684261322021], [1.0617692470550537, -1.8918039798736572, 0.8040215969085693]]\r\n * flatCoefficientsArr(2,3,-2,2); //=> [[0.1749166026711464, -0.20349335670471191, 0.9375684261322021], [1.0617692470550537, -1.8918039798736572, 0.8040215969085693]]\r\n */\r\nlet flatCoefficientsArr = createArrFunction(flatCoefficients);\r\nexports.flatCoefficientsArr = flatCoefficientsArr;\r\n/**\r\n * Returns a quasi-random number to be used as the next input to this function.\r\n * See https://stackoverflow.com/questions/3062746/special-simple-random-number-generator\r\n * @private\r\n * @param seed\r\n */\r\nfunction predictiveRandom(seed) {\r\n    const a = 134775813;\r\n    return (a * seed + 1) % RANGE;\r\n}\r\nexports.predictiveRandom = predictiveRandom;\r\n/**\r\n * Generates a random array of numbers picked from a bounded flat\r\n * distribution (i.e. a rectangular distribution) with specified odds of\r\n * duplication of consecutive values.\r\n *\r\n * @ignore\r\n * @param n - The number of values to generate.\r\n * @param a - The lower bound of the distribution - defaults\r\n * to 0\r\n * @param b - The upper bound of the distribution - defaults\r\n * to 1\r\n * @param seed - A seed value for generating random values (so\r\n * that the results are reproducable)\r\n * @param odds - The odds that a root will be doubled (applied\r\n * recursively so that some roots will be tripled, etc. - defaults to 0\r\n */\r\nfunction randomArray(n, a, b, seed = SEED, odds = 0) {\r\n    let vs = [];\r\n    for (let i = 0; i < n; i++) {\r\n        seed = predictiveRandom(seed);\r\n        let v = ((seed / RANGE) * (b - a)) + a;\r\n        seed = push(seed, vs, v, odds);\r\n    }\r\n    vs = vs.slice(0, n);\r\n    return { vs, seed };\r\n}\r\n/**\r\n * Helper function that will add more numbers to the passed array - modifies the\r\n * values parameter.\r\n * @private\r\n * @param seed\r\n * @param values - An existing array of values - will be modified!\r\n * @param x - The number that will be added (possibly multiple times)\r\n * @param odds - The odds that the number will be added again (recursively).\r\n */\r\nfunction push(seed, values, x, odds) {\r\n    seed = predictiveRandom(seed);\r\n    values.push(x);\r\n    if ((seed / RANGE) < odds) {\r\n        seed = push(seed, values, x, odds);\r\n    }\r\n    return seed;\r\n}\r\n/**\r\n * Generates a random polynomial with roots picked from a bounded flat\r\n * distribution (i.e. a rectangular distribution) with specified odds of\r\n * duplication of consecutive values. Note that the resulting polynomial\r\n * won't have any complex roots.\r\n * @memberof Random\r\n * @param d - The degree of the polynomials\r\n * @param a - The lower bound of the distribution - defaults\r\n * to 0\r\n * @param b - The upper bound of the distribution - defaults\r\n * to 1\r\n * @param seed - A seed value for generating random values (so\r\n * that the results are reproducable)\r\n * @param odds - The odds that a root will be doubled (applied\r\n * recursively so that some roots will be tripled, etc. - defaults to 0\r\n * @example\r\n * FloPoly.Random.flatRoots(3,0,10); //=> { p: [1, -17.27247918024659, 97.33487287168995, -179.34094494147305], seed: 939629312 }\r\n */\r\nfunction flatRoots(d, a = 0, b = 1, seed = SEED, odds = 0) {\r\n    let randArr = randomArray(d, a, b, seed, odds);\r\n    seed = randArr.seed;\r\n    let p = from_roots_1.fromRoots(randArr.vs);\r\n    return { p, seed };\r\n}\r\nexports.flatRoots = flatRoots;\r\n/**\r\n * Generates a random polynomial with coefficients picked from a bounded\r\n * flat distribution (i.e. a rectangular distribution).\r\n * @memberof Random\r\n * @param d - The degree of the polynomials\r\n * @param a - The lower bound of the distribution - defaults to -1\r\n * @param b - The upper bound of the distribution - defaults to 1\r\n * @param seed - A seed value for generating random values (so that the results\r\n * are reproducable)\r\n * @example\r\n * FloPoly.Random.flatCoefficients(3,-5,5); //=> { p: [0.437291506677866, -0.5087333917617798, 2.3439210653305054], seed: 939629312 }\r\n */\r\nfunction flatCoefficients(d, a = -1, b = +1, seed = SEED) {\r\n    a = (a === undefined) ? -1 : a;\r\n    b = (b === undefined) ? +1 : b;\r\n    seed = (seed === undefined) ? SEED : seed;\r\n    let randArr = randomArray(d, a, b, seed);\r\n    seed = randArr.seed;\r\n    let p = randArr.vs;\r\n    return { p, seed };\r\n}\r\nexports.flatCoefficients = flatCoefficients;\r\n//# sourceMappingURL=random.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/random.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/root-bounds.js":
/*!***************************************************!*\
  !*** ./node_modules/flo-poly/node/root-bounds.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst core_operators_1 = __webpack_require__(/*! ./core-operators */ \"./node_modules/flo-poly/node/core-operators.js\");\r\n/**\r\n * Returns the maximum magnitude value within the supplied array of numbers.\r\n * @private\r\n */\r\nfunction maxAbs(ns) {\r\n    return Math.max(...ns.map(n => Math.abs(n)));\r\n}\r\n/**\r\n * Finds an upper bound on the magnitude (absolute value) of the roots\r\n * (including complex roots) of the given polynomial using Rouche's\r\n * Theorem with k = n. This function is fast but the bound is not tight.\r\n * @param p - The polynomial.\r\n */\r\nfunction rootMagnitudeUpperBound_rouche(p) {\r\n    let d = p.length - 1;\r\n    let R = 1 + (1 / p[0]) * maxAbs(p.slice(1));\r\n    return R;\r\n}\r\nexports.rootMagnitudeUpperBound_rouche = rootMagnitudeUpperBound_rouche;\r\n/**\r\n * Finds an upper bound on the magnitude (absolute value) of the roots\r\n * of the given polynomial using the near-optimal Fujiwara bound. Note\r\n * that the bound includes complex roots. The bound is tight but slow\r\n * due to usage of Math.pow().\r\n * See https://en.wikipedia.org/wiki/Properties_of_polynomial_roots#cite_note-Fujiwara1916-4\r\n * @param p - The polynomial.\r\n * @example\r\n * FloPoly.rootMagnitudeUpperBound_fujiwara([2,-3,6,5,-130]); //=> 6.753296750770361\r\n * FloPoly.allRoots([2,-3,6,5,-130]); //=> [-2.397918624065303, 2.8793785310848383]\r\n */\r\nfunction rootMagnitudeUpperBound_fujiwara(p) {\r\n    let d = p.length - 1;\r\n    let an = p[0];\r\n    let bs = [];\r\n    for (let i = 1; i < d; i++) {\r\n        let b = Math.pow(Math.abs(p[i] / an), 1 / i);\r\n        bs.push(b);\r\n    }\r\n    bs.push(Math.pow(Math.abs(p[d] / 2 * an), 1 / d));\r\n    return 2 * Math.max.apply(undefined, bs);\r\n}\r\nexports.rootMagnitudeUpperBound_fujiwara = rootMagnitudeUpperBound_fujiwara;\r\nconst POWERS = [\r\n    1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768,\r\n    65536, 131072, 262144, 524288, 1048576, 2097152\r\n];\r\n/**\r\n * <p>\r\n * Returns an upper bound for the positive real roots of the given\r\n * polynomial.\r\n * </p>\r\n * <p>\r\n * See algoritm 6 of the paper by Vigklas, Akritas and Strzeboński,\r\n * specifically the LocalMaxQuadratic algorithm hence LMQ.\r\n * </p>\r\n * @param p - The polynomial\r\n * @example\r\n * FloPoly.positiveRootUpperBound_LMQ([2,-3,6,5,-130]); //=> 4.015534272870436\r\n * FloPoly.positiveRootUpperBound_LMQ([2,3]);           //=> 0\r\n * FloPoly.positiveRootUpperBound_LMQ([-2,-3,-4]);      //=> 0\r\n */\r\nfunction positiveRootUpperBound_LMQ(p) {\r\n    let deg = p.length - 1;\r\n    if (deg < 1) {\r\n        return 0;\r\n    }\r\n    if (p[0] < 0) {\r\n        p = core_operators_1.negate(p);\r\n    }\r\n    let timesUsed = [];\r\n    for (let i = 0; i < deg; i++) {\r\n        timesUsed.push(1);\r\n    }\r\n    let ub = 0;\r\n    for (let m = 0; m <= deg; m++) {\r\n        if (p[m] >= 0)\r\n            continue;\r\n        let tempub = Number.POSITIVE_INFINITY;\r\n        let any = false;\r\n        for (let k = 0; k < m; k++) {\r\n            if (p[k] <= 0) {\r\n                continue;\r\n            }\r\n            // Table lookup is about 70% faster but both are\r\n            // extemely fast anyway. \r\n            // Result is at https://www.measurethat.net/Benchmarks/ShowResult/6610\r\n            let pow = timesUsed[k];\r\n            let powres;\r\n            if (pow > 20) {\r\n                powres = Math.pow(2, pow);\r\n            }\r\n            else {\r\n                powres = POWERS[pow];\r\n            }\r\n            let temp = Math.pow(-p[m] / (p[k] / powres), 1 / (m - k));\r\n            timesUsed[k]++;\r\n            if (tempub > temp) {\r\n                tempub = temp;\r\n            }\r\n            any = true;\r\n        }\r\n        if (any && ub < tempub)\r\n            ub = tempub;\r\n    }\r\n    return ub;\r\n}\r\nexports.positiveRootUpperBound_LMQ = positiveRootUpperBound_LMQ;\r\n/**\r\n * <p>\r\n * Calculates a lower bound for the positive roots of the given\r\n * polynomial.\r\n * </p>\r\n * <p>\r\n * See algoritm 6 of the paper by Vigklas, Akritas and Strzeboński,\r\n * specifically the LocalMaxQuadratic algorithm hence LMQ.\r\n * </p>\r\n * @param p - The polynomial\r\n * @example\r\n * FloPoly.positiveRootLowerBound_LMQ([2,-3,6,5,-130]); //=> 1.6883241876925903\r\n * FloPoly.positiveRootLowerBound_LMQ([2,3]);           //=> 0\r\n * FloPoly.positiveRootLowerBound_LMQ([-2,-3,-4]);      //=> 0\r\n */\r\nfunction positiveRootLowerBound_LMQ(p) {\r\n    let ub = positiveRootUpperBound_LMQ(core_operators_1.invert(p));\r\n    if (ub === 0) {\r\n        return 0;\r\n    }\r\n    return 1 / ub;\r\n}\r\nexports.positiveRootLowerBound_LMQ = positiveRootLowerBound_LMQ;\r\n/**\r\n * See positiveRootUpperBound_LMQ\r\n *\r\n * @param p - The polynomial\r\n * @returns {number} An upper bound.\r\n */\r\nfunction negativeRootUpperBound_LMQ(p) {\r\n    return -positiveRootLowerBound_LMQ(core_operators_1.reflectAboutYAxis(p));\r\n}\r\nexports.negativeRootUpperBound_LMQ = negativeRootUpperBound_LMQ;\r\n/**\r\n * See positiveRootLowerBound_LMQ\r\n *\r\n * @param p - The polynomial\r\n * @returns A lower bound.\r\n */\r\nfunction negativeRootLowerBound_LMQ(p) {\r\n    return -positiveRootUpperBound_LMQ(core_operators_1.reflectAboutYAxis(p));\r\n}\r\nexports.negativeRootLowerBound_LMQ = negativeRootLowerBound_LMQ;\r\n//# sourceMappingURL=root-bounds.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/root-bounds.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/root-operators.js":
/*!******************************************************!*\
  !*** ./node_modules/flo-poly/node/root-operators.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst core_operators_1 = __webpack_require__(/*! ./core-operators */ \"./node_modules/flo-poly/node/core-operators.js\");\r\n/**\r\n * <p>\r\n * Floating-point-stably calculates and returns the ordered quadratic\r\n * roots of the given quadratic polynomial.\r\n * </p>\r\n * <p>\r\n * This function is included only because it might be slightly faster\r\n * than calling allRoots due to allRoots first checking if the\r\n * polynomial is quadratic and checking if the roots are within the\r\n * given range.\r\n * </p>\r\n * @param p - The 2nd order polynomial\r\n * @example\r\n * FloPoly.quadraticRoots([1, -3, 2]); //=> [1,2]\r\n */\r\nfunction quadraticRoots(p) {\r\n    let [a, b, c] = p;\r\n    let delta = b * b - 4 * a * c;\r\n    if (delta < 0) {\r\n        // No real roots;\r\n        return [];\r\n    }\r\n    if (delta === 0) {\r\n        return [-b / (2 * a)];\r\n    }\r\n    delta = Math.sqrt(delta);\r\n    let root1;\r\n    let root2;\r\n    if (b >= 0) {\r\n        root1 = (-b - delta) / (2 * a);\r\n        root2 = (2 * c) / (-b - delta);\r\n    }\r\n    else {\r\n        root1 = (2 * c) / (-b + delta);\r\n        root2 = (-b + delta) / (2 * a);\r\n    }\r\n    if (root1 < root2) {\r\n        return [root1, root2];\r\n    }\r\n    return [root2, root1];\r\n}\r\nexports.quadraticRoots = quadraticRoots;\r\n/**\r\n * Calculates the roots of the given cubic polynomial.\r\n *\r\n * This code is mostly from the Pomax guide found at\r\n * https://pomax.github.io/bezierinfo/#extremities\r\n *\r\n * @param p - A cubic polynomial.\r\n */\r\n// TODO - This function as it currently stands is very sensitive to\r\n// the first coefficient if it is very small, e.g. compare:\r\n// cubicRoots([1e-5, 1560,-1740,96]) = [1.1903631761670113, -156000001.1153846, -0.07497859001159668] \r\n// vs\r\n// quadraticRoots([1560,-1740,96]) = [0.05821032751613551, 1.0571742878684798]\r\n// It is completely useless in some ranges of its input domain:\r\n// the part of the function 'if (discriminant < 0) {}'\r\n// is highly problematic for numerical stability.\r\n// Simply use allRoots / allRootsRecursive instead.\r\n/*\r\nfunction cubicRoots(p) {\r\n\r\n    function cuberoot(v) {\r\n        return v < 0\r\n            ? -Math.pow(-v, 1/3)\r\n            : +Math.pow(v, 1/3);\r\n    }\r\n    \r\n    let cbrt = Math.cbrt || cuberoot;\r\n    \r\n    let d = p[0];\r\n    let a = p[1] / d;\r\n    let b = p[2] / d;\r\n    let c = p[3] / d;\r\n    \r\n    let s  = (3*b - a*a) / 9;\r\n    let q  = (2*a*a*a - 9*a*b + 27*c) / 54;\r\n    \r\n    let s3 = s*s*s;\r\n    let q2 = q*q;\r\n    \r\n    let discriminant = q2 + s3;\r\n\r\n    if (!Number.isFinite(discriminant)) {\r\n        \r\n        // Overflow occured - in which case one root will be very large.\r\n        // We might want to report such large roots as positive or\r\n        // negative infinity but since they are rarely of interest we\r\n        // report only the smaller roots.\r\n        \r\n        // Here q*q   === (729*c^2 - 486*a*b*c + 108*a^3*c + 81*a^2*b^2 - 36*a^4*b + 4*a^6) / (729*4)\r\n        // and  s*s*s === (27*b^3 - 27*a^2*b^2 + 9*a^4*b - a^6) / (729*1)\r\n        \r\n        return quadraticRoots(p.slice(1));\r\n    }\r\n    \r\n    if (discriminant < 0) {\r\n        // three real roots\r\n        \r\n        let r = Math.sqrt(-s3);\r\n        let t = -q / r;\r\n        \r\n        let cosphi = t < -1 ? -1 : t > 1 ? 1 : t;\r\n        let phi    = Math.acos(cosphi);\r\n        let\tt1     = 2*cbrt(r);\r\n        \r\n        let ao3 = a/3;\r\n        \r\n        return [\r\n            t1*Math.cos((phi            )/3) - ao3,\r\n            t1*Math.cos((phi + 2*Math.PI)/3) - ao3,\r\n            t1*Math.cos((phi + 4*Math.PI)/3) - ao3\r\n        ]\r\n    } else if (discriminant === 0) {\r\n        // three real roots, but two of them are equal\r\n        \r\n        let u1 = q < 0 ? cbrt(-q) : -cbrt(q);\r\n        let ao3 = a/3;\r\n        \r\n        return [\r\n            2*u1 - ao3,\r\n            -u1 - ao3\r\n        ];\r\n    } else {\r\n        // one real root, two complex roots\r\n        \r\n        let sd = Math.sqrt(discriminant);\r\n        let u1 = cbrt(sd - q);\r\n        let v1 = cbrt(sd + q);\r\n        \r\n        return [u1 - v1 - a/3];\r\n    }\r\n}\r\n*/\r\n/**\r\n * Returns the number of real roots in the interval (a,b) of the given\r\n * polynomial.\r\n * @param p - The polynomial\r\n * @param a - The lower bound\r\n * @param b - The upper bound\r\n * @example\r\n * let p = [1, 1, -64, 236, -240];\r\n * FloPoly.numRootsWithin(p,-20,-11); //=> 0\r\n * FloPoly.numRootsWithin(p,-11,-9);  //=> 1\r\n * FloPoly.numRootsWithin(p,-11,3.5); //=> 3\r\n * FloPoly.numRootsWithin(p,-11,5);   //=> 4\r\n */\r\nfunction numRootsWithin(p, a, b) {\r\n    let ps = core_operators_1.sturmChain(p);\r\n    let ev = core_operators_1.evaluate(p);\r\n    let as = ps.map(p => core_operators_1.evaluate(p)(a));\r\n    let bs = ps.map(p => core_operators_1.evaluate(p)(b));\r\n    return core_operators_1.signChanges(as) - core_operators_1.signChanges(bs);\r\n}\r\nexports.numRootsWithin = numRootsWithin;\r\n/**\r\n * <p>\r\n * Searches an interval (a,b) for a root (i.e. zero) of the\r\n * given function with respect to its first argument using the Bisection\r\n * Method root-finding algorithm. Any function can be supplied (it does\r\n * not even have to be continuous) as long as the root is bracketed.\r\n * </p>\r\n * <p>\r\n * Note: This function has no advantages above the Brent method except\r\n * for its simpler implementation and can be much slower. Use brent\r\n * instead.\r\n * </p>\r\n * @param f - The function for which the root is sought.\r\n * @param a - The lower limit of the search interval.\r\n * @param b - The upper limit of the search interval.\r\n * @example\r\n * let p = FloPoly.fromRoots([-10,2,3,4]);  //=> [1, 1, -64, 236, -240]\r\n * let f = FloPoly.evaluate(p);\r\n * FloPoly.bisection(f,2.2,3.8); //=> 3\r\n * FloPoly.bisection(f,2.2,3.1); //=> 3.0000000000000044\r\n */\r\nfunction bisection(f, a, b) {\r\n    if (a === b) {\r\n        // Presumably the root is already found.\r\n        return a;\r\n    }\r\n    else if (b < a) {\r\n        [a, b] = [b, a]; // Swap a and b \r\n    }\r\n    let fa = f(a);\r\n    let fb = f(b);\r\n    if (fa === 0) {\r\n        return a;\r\n    }\r\n    if (fb === 0) {\r\n        return b;\r\n    }\r\n    if (fa * fb > 0) {\r\n        // Root is not bracketed - this is a precondition.\r\n        throw new Error('Root not bracketed');\r\n    }\r\n    while (true) {\r\n        let c = a + (b - a) / 2; // Take midpoint\r\n        let fc = f(c);\r\n        if (fc === 0) {\r\n            return c;\r\n        }\r\n        if (fa * fc < 0) {\r\n            b = c;\r\n        }\r\n        else {\r\n            a = c;\r\n        }\r\n        // We don't add Number.EPSILON in the line below because we want\r\n        // accuracy to improve even below 1.\r\n        let δ = 2 * Number.EPSILON * Math.abs(b) /*+ Number.EPSILON*/;\r\n        if (Math.abs(a - b) <= δ) {\r\n            return b;\r\n        }\r\n    }\r\n}\r\nexports.bisection = bisection;\r\n/**\r\n * <p>\r\n * Searches an interval (a,b) for a root (i.e. zero) of the\r\n * given function with respect to its first argument using the Brent's\r\n * Method root-finding algorithm. Any function can be supplied (it does\r\n * not even have to be continuous) as long as the root is bracketed.\r\n * </p>\r\n * <p>\r\n * Brent's Method is an excellent root-finding choice since it is\r\n * (1) guaranteed to converge (unlike the Newton and other so-called\r\n * single-point methods), (2) converges in a reasonable number of\r\n * iterations even for highly contrived functions (unlike Dekker's\r\n * Method) and (3) nearly always converges extremely fast, i.e. super-\r\n * linearly (unlike the Secant and Regula-Falsi methods).\r\n * </p>\r\n * <p>\r\n * The max error, δ, is set equal to 2*Number.EPSILON*Math.abs(b)\r\n * after each iteration where b is the max of the current 2 best\r\n * guesses.\r\n * </p>\r\n * <p>\r\n * See <a href=\"https://en.wikipedia.org/wiki/Brent%27s_method\">Wikipedia</a>\r\n * </p>\r\n * <p>\r\n * See <a href=\"https://maths-people.anu.edu.au/~brent/pd/rpb011i.pdf\">Brent (page 47)</a>\r\n * </p>\r\n * @param f - The function for which the root is sought.\r\n * @param a - The lower limit of the search interval.\r\n * @param b - The upper limit of the search interval.\r\n * about 1e-15 multiplied by the root magnitued).\r\n * @example\r\n * let p = FloPoly.fromRoots([-10,2,3,4]);  //=> [1, 1, -64, 236, -240]\r\n * let f = FloPoly.evaluate(p);\r\n * FloPoly.brent(f,2.2,3.8); //=> 3.000000000000003\r\n * FloPoly.brent(f,2.2,3.1); //=> 3.000000000000001\r\n */\r\nfunction brent(f, a, b) {\r\n    if (a === b) {\r\n        // Presumably the root is already found.\r\n        return a;\r\n    }\r\n    // We assume on the first iteration f(a) !== 0 && f(b) !== 0. \r\n    let fa = f(a);\r\n    let fb = f(b);\r\n    if (fa * fb > 0) {\r\n        // Root is not bracketed - this is a precondition.\r\n        throw new Error('Root not bracketed');\r\n    }\r\n    let c; // Value of previous guess - set to a initially \r\n    if (Math.abs(fa) < Math.abs(fb)) {\r\n        // Swap a,b\r\n        c = a;\r\n        a = b;\r\n        b = c;\r\n        // Swap fa,fb\r\n        let temp = fa;\r\n        fa = fb;\r\n        fb = temp;\r\n    }\r\n    c = a;\r\n    let mflag = true;\r\n    let d; // Value of guess before previous guess\r\n    while (true) {\r\n        let δ = 2 * Number.EPSILON * Math.abs(b); // + Number.EPSILON;\r\n        let fc = f(c);\r\n        // Calculate provisional interpolation value\r\n        let s;\r\n        if (fa !== fc && fb !== fc) {\r\n            // 3 points available - inverse quadratic interpolation\r\n            let fac = fa - fc;\r\n            let fab = fa - fb;\r\n            let fbc = fb - fc;\r\n            // The below has been multiplied out to speed up the algorithm.\r\n            /*s = ((a * fb * fc) / ( fab * fac)) +\r\n                  ((b * fa * fc) / (-fab * fbc)) +\r\n                  ((c * fa * fb) / ( fac * fbc));*/\r\n            s = ((a * fb * fbc - b * fa * fac) * fc + c * fa * fab * fb) / (fab * fac * fbc);\r\n        }\r\n        else {\r\n            // only 2 points available - secant method\r\n            s = b - (fb * ((b - a) / (fb - fa)));\r\n        }\r\n        let t1 = (3 * a + b) / 4;\r\n        let b_c = Math.abs(b - c);\r\n        let s_b = Math.abs(s - b);\r\n        let c_d = Math.abs(c - d); // c_d will not be used on first iteration\r\n        if ((!( // condition 1\r\n        (s > t1 && s < b) ||\r\n            (s < t1 && s > b))) ||\r\n            (mflag && (\r\n            // condition 2\r\n            (s_b >= b_c / 2) ||\r\n                // condition 4\r\n                (b_c < δ))) ||\r\n            (!mflag && (\r\n            // condition 3\r\n            (s_b >= c_d / 2) ||\r\n                // condition 5\r\n                (c_d < δ)))) {\r\n            // Bisection\r\n            s = (a + b) / 2;\r\n            mflag = true;\r\n        }\r\n        else {\r\n            mflag = false;\r\n        }\r\n        let fs = f(s);\r\n        d = c;\r\n        c = b;\r\n        if (fa * fs < 0) {\r\n            b = s;\r\n        }\r\n        else {\r\n            a = s;\r\n        }\r\n        if (Math.abs(fa) < Math.abs(fb)) {\r\n            // Swap a,b\r\n            let temp = a;\r\n            a = b;\r\n            b = temp;\r\n        }\r\n        if (fb === 0) {\r\n            return b;\r\n        }\r\n        if (fs === 0) {\r\n            return s;\r\n        }\r\n        if (Math.abs(a - b) <= δ) {\r\n            return b;\r\n        }\r\n        fa = f(a);\r\n        fb = f(b);\r\n    }\r\n}\r\nexports.brent = brent;\r\n//# sourceMappingURL=root-operators.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/root-operators.js?");

/***/ }),

/***/ "./node_modules/flo-vector2d/node/index.js":
/*!*************************************************!*\
  !*** ./node_modules/flo-vector2d/node/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\n/**\r\n* Creates a transformation function that operates on multiple points from the\r\n* given arity two function.\r\n* @private\r\n*/\r\nfunction mapCurry2(f) {\r\n    function g(t, us) {\r\n        let h = f(t);\r\n        let hUs = (us) => us.map(h);\r\n        // Curry the function\r\n        return us === undefined ? hUs : hUs(us);\r\n    }\r\n    return g;\r\n}\r\n/**\r\n* Creates a transformation function that operates on multiple points from the\r\n* given arity 3 curried function (keeping the first two parameters uncurried).\r\n* @private\r\n*/\r\nfunction specialMapCurry(f) {\r\n    function g(s, t, us) {\r\n        let h = f(s, t);\r\n        let hUs = (us) => us.map(h);\r\n        // Curry the function\r\n        return us === undefined ? hUs : hUs(us);\r\n    }\r\n    return g;\r\n}\r\n/**\r\n * Returns the dot (inner) product between two 2-vectors.\r\n * @param a the first vector\r\n * @param b the second vector\r\n */\r\nfunction dot(a, b) {\r\n    return a[0] * b[0] + a[1] * b[1];\r\n}\r\nexports.dot = dot;\r\n/**\r\n * Returns the cross product signed magnitude between two 2-vectors.\r\n * @param a - The first vector\r\n * @param b - The second vector\r\n */\r\nfunction cross(a, b) {\r\n    return a[0] * b[1] - a[1] * b[0];\r\n}\r\nexports.cross = cross;\r\n/**\r\n * Three 2d points are a counter-clockwise turn if ccw > 0, clockwise if\r\n * ccw < 0, and colinear if ccw === 0 because ccw is a determinant that gives\r\n * twice the signed area of the triangle formed by the points a, b and c.\r\n * @param a The first point\r\n * @param b The second point\r\n * @param c The third point\r\n */\r\nfunction ccw(a, b, c) {\r\n    return flo_numerical_1.orient2d(a, b, c);\r\n}\r\nexports.ccw = ccw;\r\n/**\r\n* Returns the point where two line segments intersect or undefined if they\r\n* don't intersect or if they intersect at infinitely many points.\r\n* See Geometric primitves http://algs4.cs.princeton.edu/91primitives\r\n* @param ab The first line\r\n* @param cd The second line\r\n*/\r\nfunction segSegIntersection(ab, cd) {\r\n    let [a, b] = ab;\r\n    let [c, d] = cd;\r\n    let [a0, a1] = a;\r\n    let [b0, b1] = b;\r\n    let [c0, c1] = c;\r\n    let [d0, d1] = d;\r\n    //let denom  = (b[0] - a[0])*(d[1] - c[1]) - (b[1] - a[1])*(d[0] - c[0]);\r\n    let denom = flo_numerical_1.expansionDiff(flo_numerical_1.expansionProduct(flo_numerical_1.twoDiff(b0, a0), flo_numerical_1.twoDiff(d1, c1)), flo_numerical_1.expansionProduct(flo_numerical_1.twoDiff(b1, a1), flo_numerical_1.twoDiff(d0, c0)));\r\n    //let rNumer = (a[1] - c[1])*(d[0] - c[0]) - (a[0] - c[0])*(d[1] - c[1]);\r\n    let rNumer = flo_numerical_1.expansionDiff(flo_numerical_1.expansionProduct(flo_numerical_1.twoDiff(a1, c1), flo_numerical_1.twoDiff(d0, c0)), flo_numerical_1.expansionProduct(flo_numerical_1.twoDiff(a0, c0), flo_numerical_1.twoDiff(d1, c1)));\r\n    //let sNumer = (a[1] - c[1]) * (b[0] - a[0]) - (a[0] - c[0]) * (b[1] - a[1]); \r\n    let sNumer = flo_numerical_1.expansionDiff(flo_numerical_1.expansionProduct(flo_numerical_1.twoDiff(a1, c1), flo_numerical_1.twoDiff(b0, a0)), flo_numerical_1.expansionProduct(flo_numerical_1.twoDiff(a0, c0), flo_numerical_1.twoDiff(b1, a1)));\r\n    if (denom[denom.length - 1] === 0) {\r\n        // parallel\r\n        if (rNumer[rNumer.length - 1] === 0) {\r\n            // collinear\r\n            // TODO Check if x-projections and y-projections intersect\r\n            // and return the line of intersection if they do.\r\n            return undefined;\r\n        }\r\n        return undefined;\r\n    }\r\n    //let r = rNumer / denom;\r\n    //let s = sNumer / denom;\r\n    // if (0 <= r && r <= 1 && 0 <= s && s <= 1)\r\n    if (flo_numerical_1.sign(rNumer) * flo_numerical_1.sign(denom) >= 0 && flo_numerical_1.compare(flo_numerical_1.abs(denom), flo_numerical_1.abs(rNumer)) >= 0 &&\r\n        flo_numerical_1.sign(sNumer) * flo_numerical_1.sign(denom) >= 0 && flo_numerical_1.compare(flo_numerical_1.abs(denom), flo_numerical_1.abs(sNumer)) >= 0) {\r\n        let r = flo_numerical_1.estimate(rNumer) / flo_numerical_1.estimate(denom);\r\n        //return [a0 + r*(b0 - a0), a1 + r*(b1 - a1)];\r\n        return [\r\n            flo_numerical_1.estimate(flo_numerical_1.twoSum(flo_numerical_1.estimate(flo_numerical_1.expansionProduct(flo_numerical_1.twoDiff(b0, a0), rNumer)) / flo_numerical_1.estimate(denom), a0)),\r\n            flo_numerical_1.estimate(flo_numerical_1.twoSum(flo_numerical_1.estimate(flo_numerical_1.expansionProduct(flo_numerical_1.twoDiff(b1, a1), rNumer)) / flo_numerical_1.estimate(denom), a1))\r\n        ];\r\n    }\r\n    return undefined;\r\n}\r\nexports.segSegIntersection = segSegIntersection;\r\n/**\r\n * Returns true if the two given 2d line segments intersect, false otherwise.\r\n *\r\n * Robust: uses exact adaptive floating point arithmetic.\r\n *\r\n * @param a A line segment\r\n * @param b Another line segment\r\n */\r\nfunction doesSegSegIntersect(a, b) {\r\n    if ((flo_numerical_1.orient2d(a[0], a[1], b[0]) * flo_numerical_1.orient2d(a[0], a[1], b[1])) > 0) {\r\n        return false;\r\n    }\r\n    if ((flo_numerical_1.orient2d(b[0], b[1], a[0]) * flo_numerical_1.orient2d(b[0], b[1], a[1])) > 0) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\nexports.doesSegSegIntersect = doesSegSegIntersect;\r\n/**\r\n* Returns the squared distance between two 2d points.\r\n* @param p1 A point\r\n* @param p2 Another point\r\n*/\r\nfunction squaredDistanceBetween(p1, p2) {\r\n    let x = p2[0] - p1[0];\r\n    let y = p2[1] - p1[1];\r\n    return x * x + y * y;\r\n}\r\nexports.squaredDistanceBetween = squaredDistanceBetween;\r\n/**\r\n* Returns a scaled version of the given 2-vector.\r\n* @param p - A vector\r\n* @param factor - A scale factor\r\n*/\r\nfunction scale(p, factor) {\r\n    return [p[0] * factor, p[1] * factor];\r\n}\r\nexports.scale = scale;\r\n/**\r\n* Returns the given 2-vector reversed.\r\n* @param p - A vector\r\n*/\r\nfunction reverse(p) {\r\n    return [-p[0], -p[1]];\r\n}\r\nexports.reverse = reverse;\r\n/**\r\n* Returns the given 2-vector scaled to a length of one.\r\n* @param p - A vector\r\n*/\r\nfunction toUnitVector(p) {\r\n    let scaleFactor = 1 / len(p);\r\n    return [p[0] * scaleFactor, p[1] * scaleFactor];\r\n}\r\nexports.toUnitVector = toUnitVector;\r\n/**\r\n* Returns the given 2-vector scaled to the given length.\r\n* @param p - A vector\r\n* @param length - The length to scale to\r\n*/\r\nfunction toLength(p, length) {\r\n    let scaleFactor = length / len(p);\r\n    return [p[0] * scaleFactor, p[1] * scaleFactor];\r\n}\r\nexports.toLength = toLength;\r\n/**\r\n* Returns the second 2-vector minus the first.\r\n* @param p1 - The first vector\r\n* @param p2 - The second vector\r\n*/\r\nfunction fromTo(p1, p2) {\r\n    return [p2[0] - p1[0], p2[1] - p1[1]];\r\n}\r\nexports.fromTo = fromTo;\r\n/**\r\n* Performs linear interpolation between two 2d points and returns the resultant point.\r\n* @param p1 - The first point.\r\n* @param p2 - The second point.\r\n* @param t - The interpolation fraction (often in [0,1]).\r\n*/\r\nfunction interpolate(p1, p2, t) {\r\n    return [\r\n        p1[0] + (p2[0] - p1[0]) * t,\r\n        p1[1] + (p2[1] - p1[1]) * t\r\n    ];\r\n}\r\nexports.interpolate = interpolate;\r\n/**\r\n* Returns the mean of two 2d points.\r\n* @param ps - The two points\r\n*/\r\nfunction mean(ps) {\r\n    let p1 = ps[0];\r\n    let p2 = ps[1];\r\n    return [(p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2];\r\n}\r\nexports.mean = mean;\r\n/**\r\n* Returns the distance between two 2d points.\r\n* @param p1 - A point.\r\n* @param p2 - Another point.\r\n*/\r\nfunction distanceBetween(p1, p2) {\r\n    return Math.sqrt(squaredDistanceBetween(p1, p2));\r\n}\r\nexports.distanceBetween = distanceBetween;\r\n/**\r\n* Returns the length of the given 2-vector.\r\n* @param p - A vector\r\n*/\r\nfunction len(p) {\r\n    return Math.sqrt((p[0] * p[0]) + (p[1] * p[1]));\r\n}\r\nexports.len = len;\r\n/**\r\n* Returns the squared length of the given 2-vector.\r\n* @param p - A vector\r\n*/\r\nfunction lengthSquared(v) {\r\n    return v[0] * v[0] + v[1] * v[1];\r\n}\r\nexports.lengthSquared = lengthSquared;\r\n/**\r\n* Returns the Manhattan distance between two 2d points.\r\n* @param p1 - A point.\r\n* @param p2 - Another point.\r\n*/\r\nfunction manhattanDistanceBetween(p1, p2) {\r\n    return Math.abs(p1[0] - p2[0]) + Math.abs(p1[1] - p2[1]);\r\n}\r\nexports.manhattanDistanceBetween = manhattanDistanceBetween;\r\n/**\r\n* Returns the Manhattan length of the given 2-vector.\r\n* @param p - A vector\r\n*/\r\nfunction manhattanLength(p) {\r\n    return Math.abs(p[0]) + Math.abs(p[1]);\r\n}\r\nexports.manhattanLength = manhattanLength;\r\n/**\r\n* <p>\r\n* Returns the distance between the given point and line.\r\n* </p>\r\n* <p>\r\n* See <a href=\"https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Line_defined_by_two_points\">\r\n* this Wikipedia article</a>\r\n* </p>\r\n* @param p - A point\r\n* @param l - A line\r\n*/\r\nfunction distanceBetweenPointAndLine(p, l) {\r\n    let [x0, y0] = p;\r\n    let [[x1, y1], [x2, y2]] = l;\r\n    let y = y2 - y1;\r\n    let x = x2 - x1;\r\n    let a = (y * x0 - x * y0 + x2 * y1 - y2 * x1);\r\n    let b = Math.sqrt(x * x + y * y);\r\n    return Math.abs(a / b);\r\n}\r\nexports.distanceBetweenPointAndLine = distanceBetweenPointAndLine;\r\n/**\r\n* Returns the squared distance between the given point and line segment.\r\n* @param p - A point\r\n* @param l - A line\r\n*/\r\nfunction squaredDistanceBetweenPointAndLineSegment(p, l) {\r\n    const sqDst = squaredDistanceBetween;\r\n    let v = l[0];\r\n    let w = l[1];\r\n    let l2 = sqDst(v, w);\r\n    if (l2 == 0) {\r\n        return sqDst(p, v);\r\n    }\r\n    let t = ((p[0] - v[0]) * (w[0] - v[0]) + (p[1] - v[1]) * (w[1] - v[1])) / l2;\r\n    t = Math.max(0, Math.min(1, t));\r\n    let d2 = sqDst(p, [v[0] + t * (w[0] - v[0]), v[1] + t * (w[1] - v[1])]);\r\n    return d2;\r\n}\r\nexports.squaredDistanceBetweenPointAndLineSegment = squaredDistanceBetweenPointAndLineSegment;\r\n/**\r\n* Returns the circumcenter of the given 2d triangle.\r\n* @param triangle\r\n*/\r\nfunction circumCenter(triangle) {\r\n    // See wikipedia\r\n    let p1 = triangle[0];\r\n    let p2 = triangle[1];\r\n    let p3 = triangle[2];\r\n    const sqLen = lengthSquared;\r\n    let Sx = 0.5 * det3([sqLen(p1), p1[1], 1], [sqLen(p2), p2[1], 1], [sqLen(p3), p3[1], 1]);\r\n    let Sy = 0.5 * det3([p1[0], sqLen(p1), 1], [p2[0], sqLen(p2), 1], [p3[0], sqLen(p3), 1]);\r\n    let a = det3([p1[0], p1[1], 1], [p2[0], p2[1], 1], [p3[0], p3[1], 1]);\r\n    /*\r\n    let b = det3(\r\n            [p1[0], p1[1], sqLen(p1)],\r\n            [p2[0], p2[1], sqLen(p2)],\r\n            [p3[0], p3[1], sqLen(p3)]\r\n    );\r\n    */\r\n    return [Sx / a, Sy / a];\r\n}\r\nexports.circumCenter = circumCenter;\r\n/**\r\n* <p>\r\n* Returns the incenter of the given triangle.\r\n* </p>\r\n* <p>\r\n* See Wikipedia - https://en.wikipedia.org/wiki/Incenter\r\n* </p>\r\n* @param triangle\r\n*/\r\nfunction inCenter(triangle) {\r\n    const dst = distanceBetween;\r\n    let p1 = triangle[0];\r\n    let p2 = triangle[1];\r\n    let p3 = triangle[2];\r\n    let l1 = dst(p2, p3);\r\n    let l2 = dst(p1, p3);\r\n    let l3 = dst(p1, p2);\r\n    let lengthSum = l1 + l2 + l3;\r\n    return [\r\n        (l1 * p1[0] + l2 * p2[0] + l3 * p3[0]) / lengthSum,\r\n        (l1 * p1[1] + l2 * p2[1] + l3 * p3[1]) / lengthSum\r\n    ];\r\n}\r\nexports.inCenter = inCenter;\r\n/**\r\n* Returns the centroid of the given polygon, e.g. triangle. The polygon\r\n* must be simple, i.e. not self-intersecting.\r\n* @param polygon\r\n*/\r\nfunction centroid(polygon) {\r\n    if (polygon.length === 3) {\r\n        let p1 = polygon[0];\r\n        let p2 = polygon[1];\r\n        let p3 = polygon[2];\r\n        let x = p1[0] + p2[0] + p3[0];\r\n        let y = p1[1] + p2[1] + p3[1];\r\n        return [x / 3, y / 3];\r\n    }\r\n    // polygon.length assumed > 3 and assumed to be non-self-intersecting\r\n    // See wikipedia\r\n    // First calculate the area, A, of the polygon\r\n    let A = 0;\r\n    for (let i = 0; i < polygon.length; i++) {\r\n        let p0 = polygon[i];\r\n        let p1 = (i === polygon.length - 1)\r\n            ? polygon[0]\r\n            : polygon[i + 1];\r\n        A = A + (p0[0] * p1[1] - p1[0] * p0[1]);\r\n    }\r\n    A = A / 2;\r\n    let C = [0, 0];\r\n    for (let i = 0; i < polygon.length; i++) {\r\n        let p0 = polygon[i];\r\n        let p1 = (i === polygon.length - 1)\r\n            ? polygon[0]\r\n            : polygon[i + 1];\r\n        C[0] = C[0] + (p0[0] + p1[0]) * (p0[0] * p1[1] - p1[0] * p0[1]);\r\n        C[1] = C[1] + (p0[1] + p1[1]) * (p0[0] * p1[1] - p1[0] * p0[1]);\r\n    }\r\n    return [C[0] / (6 * A), C[1] / (6 * A)];\r\n}\r\nexports.centroid = centroid;\r\n/**\r\n* Calculate the determinant of three 3d vectors, i.e. 3x3 matrix\r\n* @ignore\r\n* @param x - A 2d vector\r\n* @param y - Another 2d vector\r\n* @param z - Another 2d vector\r\n*/\r\nfunction det3(x, y, z) {\r\n    return (x[0] * (y[1] * z[2] - y[2] * z[1])) -\r\n        (x[1] * (y[0] * z[2] - y[2] * z[0])) +\r\n        (x[2] * (y[0] * z[1] - y[1] * z[0]));\r\n}\r\nexports.det3 = det3;\r\nfunction translate(a, b) {\r\n    function f(b) {\r\n        return [a[0] + b[0], a[1] + b[1]];\r\n    }\r\n    // Curry the function\r\n    return b === undefined ? f : f(b);\r\n}\r\nexports.translate = translate;\r\n/**\r\n* Return the given 2d points translated by the given 2d vector. This\r\n* function is curried.\r\n* @param v\r\n* @param ps\r\n*/\r\nlet translatePs = mapCurry2(translate);\r\nexports.translatePs = translatePs;\r\n/**\r\n* Return the given 2d points translated by the given 2d vector. This function\r\n* is curried.\r\n* @param sinθ\r\n* @param cosθ\r\n* @param ps\r\n*/\r\nlet rotatePs = specialMapCurry(rotate);\r\nexports.rotatePs = rotatePs;\r\nfunction rotate(sinθ, cosθ, p) {\r\n    let a = translatePs([1, 2]);\r\n    function rotateByθ(p) {\r\n        return [\r\n            p[0] * cosθ - p[1] * sinθ,\r\n            p[0] * sinθ + p[1] * cosθ\r\n        ];\r\n    }\r\n    // Curry the function\r\n    return p === undefined ? rotateByθ : rotateByθ(p);\r\n}\r\nexports.rotate = rotate;\r\n/**\r\n* Returns true if two 2-vectors are identical (by value), false otherwise.\r\n* @param a - A 2d vector\r\n* @param b - Another 2d vector\r\n*/\r\nfunction equal(a, b) {\r\n    return (a[0] === b[0] && a[1] === b[1]);\r\n}\r\nexports.equal = equal;\r\n/**\r\n* Returns a anti-clockwise rotated version of the given 2-vector given the\r\n* sine and cosine of the angle.\r\n* @param p - A 2d vector\r\n* @param sinθ\r\n* @param cosθ\r\n*/\r\nfunction reverseRotate(sinθ, cosθ, p) {\r\n    return [\r\n        +p[0] * cosθ + p[1] * sinθ,\r\n        -p[0] * sinθ + p[1] * cosθ\r\n    ];\r\n}\r\nexports.reverseRotate = reverseRotate;\r\n/**\r\n* Returns a 90 degrees rotated version of the given 2-vector.\r\n* @param p - A 2d vector\r\n*/\r\nfunction rotate90Degrees(p) {\r\n    return [-p[1], p[0]];\r\n}\r\nexports.rotate90Degrees = rotate90Degrees;\r\n/**\r\n* Returns a negative 90 degrees rotated version of the given 2-vector.\r\n* @param p - A 2d vector\r\n*/\r\nfunction rotateNeg90Degrees(p) {\r\n    return [p[1], -p[0]];\r\n}\r\nexports.rotateNeg90Degrees = rotateNeg90Degrees;\r\n/**\r\n * Returns the closest point to the array of 2d points or if the array is empty\r\n * returns undefined.\r\n * @param p\r\n * @param ps\r\n */\r\nfunction getClosestTo(p, ps) {\r\n    let closestPoint = undefined;\r\n    let closestDistance = Number.POSITIVE_INFINITY;\r\n    for (let i = 0; i < ps.length; i++) {\r\n        let q = ps[i];\r\n        let d = squaredDistanceBetween(p, q);\r\n        if (d < closestDistance) {\r\n            closestPoint = q;\r\n            closestDistance = d;\r\n        }\r\n    }\r\n    return closestPoint;\r\n}\r\nexports.getClosestTo = getClosestTo;\r\n/**\r\n * Returns the closest point to the array of 2d points by providing a distance\r\n * function. If the given array is empty, returns undefined.\r\n * @param p\r\n * @param ps\r\n * @param f a function that takes the object and returns a point in order to\r\n * apply the Euclidian distance.\r\n */\r\nfunction getObjClosestTo(p, ps, f) {\r\n    let closestObj = undefined; // Closest Point\r\n    let closestDistance = Number.POSITIVE_INFINITY;\r\n    for (let i = 0; i < ps.length; i++) {\r\n        let o = ps[i];\r\n        let d = squaredDistanceBetween(p, f(o));\r\n        if (d < closestDistance) {\r\n            closestObj = o;\r\n            closestDistance = d;\r\n        }\r\n    }\r\n    return closestObj;\r\n}\r\nexports.getObjClosestTo = getObjClosestTo;\r\n/**\r\n* Returns an array of points by applying a translation and then rotation to\r\n* the given points.\r\n* @param v - The translation vector\r\n* @param sinθ\r\n* @param cosθ\r\n* @param ps - The input points\r\n**/\r\nfunction translateThenRotatePs(v, sinθ, cosθ, ps) {\r\n    const f = translate(v);\r\n    return ps.map(p => rotate(sinθ, cosθ, f(p)));\r\n}\r\nexports.translateThenRotatePs = translateThenRotatePs;\r\n/**\r\n* Returns an array of points by applying a rotation and then translation to\r\n* the given points.\r\n* @param sinθ\r\n* @param cosθ\r\n* @param v - The translation vector\r\n* @param ps - The input points\r\n**/\r\nfunction rotateThenTranslatePs(sinθ, cosθ, v, ps) {\r\n    return ps.map(p => translate(v, rotate(sinθ, cosθ, p)));\r\n}\r\nexports.rotateThenTranslatePs = rotateThenTranslatePs;\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-vector2d/node/index.js?");

/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target, parent) {\n  if (parent){\n    return parent.querySelector(target);\n  }\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target, parent) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target, parent);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(/*! ./urls */ \"./node_modules/style-loader/lib/urls.js\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertAt.before, target);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\tif(options.attrs.nonce === undefined) {\n\t\tvar nonce = getNonce();\n\t\tif (nonce) {\n\t\t\toptions.attrs.nonce = nonce;\n\t\t}\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction getNonce() {\n\tif (false) {}\n\n\treturn __webpack_require__.nc;\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = typeof options.transform === 'function'\n\t\t ? options.transform(obj.css) \n\t\t : options.transform.default(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n\n\n//# sourceURL=webpack:///./node_modules/style-loader/lib/addStyles.js?");

/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n\n\n//# sourceURL=webpack:///./node_modules/style-loader/lib/urls.js?");

/***/ }),

/***/ "./style.css":
/*!*******************!*\
  !*** ./style.css ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !./node_modules/css-loader!./style.css */ \"./node_modules/css-loader/index.js!./style.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ./node_modules/style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}\n\n//# sourceURL=webpack:///./style.css?");

/***/ })

/******/ });