/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__webpack_require__(/*! ./style.css */ \"./style.css\"); // Import stylesheets\r\nconst flo_mat_1 = __webpack_require__(/*! flo-mat */ \"./node_modules/flo-mat/node/index.js\");\r\nconst NS = 'http://www.w3.org/2000/svg'; // Svg namespace\r\n/**\r\n * Creates and returns an SVG DOM element.\r\n * @param id The dom id to assign to the SVG element, e.g. 1 -> 'svg-1'\r\n */\r\nfunction createSvg(id) {\r\n    let $e = document.createElementNS(NS, 'svg');\r\n    $e.setAttributeNS(null, 'id', 'svg' + id);\r\n    $e.setAttributeNS(null, 'style', 'width: 100%; display: inline-block');\r\n    $e.setAttributeNS(null, 'viewBox', '75 4 557 502');\r\n    return $e;\r\n}\r\n/**\r\n * Returns an SVG path string of a line.\r\n * @param ps The line endpoints.\r\n */\r\nfunction getLinePathStr(ps) {\r\n    let [[x0, y0], [x1, y1]] = ps;\r\n    return `M${x0} ${y0} L${x1} ${y1}`;\r\n}\r\n/**\r\n * Returns an SVG path string of a quadratic bezier curve.\r\n * @param ps The quadratic bezier control points.\r\n */\r\nfunction getQuadBezierPathStr(ps) {\r\n    let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    return `M${x0} ${y0} Q${x1} ${y1} ${x2} ${y2}`;\r\n}\r\n/**\r\n * Returns an SVG path string of a cubic bezier curve.\r\n * @param ps The cubic bezier control points.\r\n */\r\nfunction getCubicBezierPathStr(ps) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    return `M${x0} ${y0} C${x1} ${y1} ${x2} ${y2} ${x3} ${y3}`;\r\n}\r\n/**\r\n * Returns a function that draws an array of MAT curves on an SVG element.\r\n * @param mats An array of MATs to draw.\r\n * @param svg The SVG element on which to draw.\r\n * @param type The type of MAT to draw. This simply affects the class on the\r\n * path element.\r\n  */\r\nfunction drawMats(mats, svg, type) {\r\n    mats.forEach(f);\r\n    /**\r\n     * Draws a MAT curve on an SVG element.\r\n     */\r\n    function f(mat) {\r\n        let cpNode = mat.cpNode;\r\n        if (!cpNode) {\r\n            return;\r\n        }\r\n        let fs = [, , getLinePathStr, getQuadBezierPathStr, getCubicBezierPathStr];\r\n        flo_mat_1.traverseEdges(cpNode, function (cpNode) {\r\n            if (cpNode.isTerminating()) {\r\n                return;\r\n            }\r\n            let bezier = cpNode.matCurve;\r\n            if (!bezier) {\r\n                return;\r\n            }\r\n            let $path = document.createElementNS(NS, 'path');\r\n            $path.setAttributeNS(null, \"d\", fs[bezier.length](bezier));\r\n            $path.setAttributeNS(null, \"class\", type);\r\n            svg.appendChild($path);\r\n        });\r\n    }\r\n}\r\n/**\r\n * The SVG path string representing our shape.\r\n */\r\nconst svgPathStr = `\r\n        M 144 251\r\n        C 145 169 110 82 227 59 \r\n        C 344 36 429 -46 505 96 \r\n        C 581 238 696 407 554 435 \r\n        C 412 463 191 532 197 442 \r\n        C 203 352 213 363 276 346 \r\n        C 339 329 563 318 437 242 \r\n        C 311 166 302 181 297 314 \r\n        C 292 447 160 585 151 419 \r\n        C 142 253 87.12 312.78 86 314 \r\n        C 87.16 312.74 142.8632 252.2348 144 251 \r\n        z\r\n`;\r\n/**\r\n * Adds a path to the given SVG element and give it a shape-path class.\r\n */\r\nfunction setSvgShapePath($svg, pathStr) {\r\n    let $path = document.createElementNS(NS, 'path'); // Create SVG path elem.\r\n    $path.setAttribute('class', 'shape-path');\r\n    $svg.appendChild($path); // Add the path element to the SVG.\r\n    document.body.appendChild($svg); // Add the SVG to the document body.\r\n    $path.setAttribute('d', svgPathStr);\r\n}\r\nfunction main() {\r\n    // Create and add and SVG element to our HTML page.\r\n    let $svg = createSvg(1); // Create SVG element.\r\n    setSvgShapePath($svg, svgPathStr);\r\n    // Get loops (representing the shape) from some SVG path.\r\n    let bezierLoops = flo_mat_1.Svg.getPathsFromStr(svgPathStr);\r\n    // We could also just give an array of linear, quadratic or cubic beziers as \r\n    // below (all lines in this case). Note that in the below case there is only\r\n    // one array of beziers (forming a single loop shape).\r\n    /*\r\n    bezierLoops = [\r\n        [\r\n            [[50.000, 95.000],[92.797, 63.905]],\r\n            [[92.797, 63.905],[76.450, 13.594]],\r\n            [[76.450, 13.594],[23.549, 13.594]],\r\n            [[23.549, 13.594],[7.202,  63.90]],\r\n            [[7.202,  63.900],[50.000, 95.000]]\r\n        ]\r\n    ];\r\n    */\r\n    // Get MATs from the loops.\r\n    let mats = flo_mat_1.findMats(bezierLoops, 3);\r\n    // Draw the MATs.\r\n    drawMats(mats, $svg, 'mat');\r\n    let sats = mats.map(mat => flo_mat_1.toScaleAxis(mat, 1.5));\r\n    // Get the SAT (at scale 1.5) of the MATs (of which there is only 1)\r\n    drawMats(sats, $svg, 'sat');\r\n}\r\nmain();\r\n\n\n//# sourceURL=webpack:///./index.ts?");

/***/ }),

/***/ "./node_modules/css-loader/index.js!./style.css":
/*!*********************************************!*\
  !*** ./node_modules/css-loader!./style.css ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ./node_modules/css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.i, \"\\r\\n.shape-path {\\r\\n    fill: lightgray;\\r\\n    stroke: darkgray;\\r\\n    stroke-width: 0.1%;\\r\\n}\\r\\n\\r\\n.mat {\\r\\n    fill: none;\\r\\n    stroke: deeppink;\\r\\n    stroke-width: 0.2%;\\r\\n}\\r\\n\\r\\n.sat {\\r\\n    fill: none;\\r\\n    stroke: blue;\\r\\n    stroke-width: 0.2%;\\r\\n}\", \"\"]);\n\n// exports\n\n\n//# sourceURL=webpack:///./style.css?./node_modules/css-loader");

/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n\n\n//# sourceURL=webpack:///./node_modules/css-loader/lib/css-base.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/index.js":
/*!************************************************!*\
  !*** ./node_modules/flo-bezier3/node/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\nconst Vector = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\nconst flo_gauss_quadrature_1 = __webpack_require__(/*! flo-gauss-quadrature */ \"./node_modules/flo-gauss-quadrature/node/index.js\");\nconst flo_graham_scan_1 = __webpack_require__(/*! flo-graham-scan */ \"./node_modules/flo-graham-scan/node/index.js\");\nconst get_x_1 = __webpack_require__(/*! ./src/get-x */ \"./node_modules/flo-bezier3/node/src/get-x.js\");\nexports.getX = get_x_1.getX;\nconst get_y_1 = __webpack_require__(/*! ./src/get-y */ \"./node_modules/flo-bezier3/node/src/get-y.js\");\nexports.getY = get_y_1.getY;\nconst get_dx_1 = __webpack_require__(/*! ./src/get-dx */ \"./node_modules/flo-bezier3/node/src/get-dx.js\");\nexports.getDx = get_dx_1.getDx;\nconst get_dy_1 = __webpack_require__(/*! ./src/get-dy */ \"./node_modules/flo-bezier3/node/src/get-dy.js\");\nexports.getDy = get_dy_1.getDy;\nconst evaluate_x_1 = __webpack_require__(/*! ./src/evaluate-x */ \"./node_modules/flo-bezier3/node/src/evaluate-x.js\");\nexports.evaluateX = evaluate_x_1.evaluateX;\nconst evaluate_y_1 = __webpack_require__(/*! ./src/evaluate-y */ \"./node_modules/flo-bezier3/node/src/evaluate-y.js\");\nexports.evaluateY = evaluate_y_1.evaluateY;\nconst evaluate_1 = __webpack_require__(/*! ./src/evaluate */ \"./node_modules/flo-bezier3/node/src/evaluate.js\");\nexports.evaluate = evaluate_1.evaluate;\nconst evaluate_dx_1 = __webpack_require__(/*! ./src/evaluate-dx */ \"./node_modules/flo-bezier3/node/src/evaluate-dx.js\");\nexports.evaluateDx = evaluate_dx_1.evaluateDx;\nconst evaluate_dy_1 = __webpack_require__(/*! ./src/evaluate-dy */ \"./node_modules/flo-bezier3/node/src/evaluate-dy.js\");\nexports.evaluateDy = evaluate_dy_1.evaluateDy;\nconst evaluate_dx2_1 = __webpack_require__(/*! ./src/evaluate-dx2 */ \"./node_modules/flo-bezier3/node/src/evaluate-dx2.js\");\nconst evaluate_dy2_1 = __webpack_require__(/*! ./src/evaluate-dy2 */ \"./node_modules/flo-bezier3/node/src/evaluate-dy2.js\");\nconst tangent_1 = __webpack_require__(/*! ./src/tangent */ \"./node_modules/flo-bezier3/node/src/tangent.js\");\nexports.tangent = tangent_1.tangent;\nconst normal_1 = __webpack_require__(/*! ./src/normal */ \"./node_modules/flo-bezier3/node/src/normal.js\");\nexports.normal = normal_1.normal;\nconst from_0_to_T_1 = __webpack_require__(/*! ./src/from-0-to-T */ \"./node_modules/flo-bezier3/node/src/from-0-to-T.js\");\nexports.from0ToT = from_0_to_T_1.from0ToT;\nconst from_T_to_1_1 = __webpack_require__(/*! ./src/from-T-to-1 */ \"./node_modules/flo-bezier3/node/src/from-T-to-1.js\");\nexports.fromTTo1 = from_T_to_1_1.fromTTo1;\nconst from_to_1 = __webpack_require__(/*! ./src/from-to */ \"./node_modules/flo-bezier3/node/src/from-to.js\");\nexports.fromTo = from_to_1.fromTo;\nconst to_hybrid_quadratic_1 = __webpack_require__(/*! ./src/to-hybrid-quadratic */ \"./node_modules/flo-bezier3/node/src/to-hybrid-quadratic.js\");\nexports.toHybridQuadratic = to_hybrid_quadratic_1.toHybridQuadratic;\nconst coincident_1 = __webpack_require__(/*! ./src/coincident */ \"./node_modules/flo-bezier3/node/src/coincident.js\");\nexports.coincident = coincident_1.coincident;\nconst line_intersection_1 = __webpack_require__(/*! ./src/line-intersection */ \"./node_modules/flo-bezier3/node/src/line-intersection.js\");\nexports.lineIntersection = line_intersection_1.lineIntersection;\nconst bezier3_intersection_1 = __webpack_require__(/*! ./src/bezier3-intersection/bezier3-intersection */ \"./node_modules/flo-bezier3/node/src/bezier3-intersection/bezier3-intersection.js\");\nexports.bezier3Intersection = bezier3_intersection_1.bezier3Intersection;\nconst bezier3_intersection_sylvester_1 = __webpack_require__(/*! ./src/bezier3-intersection-sylvester/bezier3-intersection-sylvester */ \"./node_modules/flo-bezier3/node/src/bezier3-intersection-sylvester/bezier3-intersection-sylvester.js\");\nexports.bezier3IntersectionSylvester = bezier3_intersection_sylvester_1.bezier3IntersectionSylvester;\nconst ts_at_x_1 = __webpack_require__(/*! ./src/ts-at-x */ \"./node_modules/flo-bezier3/node/src/ts-at-x.js\");\nexports.tsAtX = ts_at_x_1.tsAtX;\nconst ts_at_y_1 = __webpack_require__(/*! ./src/ts-at-y */ \"./node_modules/flo-bezier3/node/src/ts-at-y.js\");\nexports.tsAtY = ts_at_y_1.tsAtY;\nconst debug_1 = __webpack_require__(/*! ./src/debug/debug */ \"./node_modules/flo-bezier3/node/src/debug/debug.js\");\nexports.BezDebug = debug_1.BezDebug;\nconst fat_line_1 = __webpack_require__(/*! ./src/debug/fat-line */ \"./node_modules/flo-bezier3/node/src/debug/fat-line.js\");\nexports.FatLine = fat_line_1.FatLine;\nconst de_casteljau_1 = __webpack_require__(/*! ./src/de-casteljau */ \"./node_modules/flo-bezier3/node/src/de-casteljau.js\");\nexports.deCasteljau = de_casteljau_1.deCasteljau;\nconst eval_de_casteljau_1 = __webpack_require__(/*! ./src/eval-de-casteljau */ \"./node_modules/flo-bezier3/node/src/eval-de-casteljau.js\");\nexports.evalDeCasteljau = eval_de_casteljau_1.evalDeCasteljau;\n// Possibly typescript bug? Below line does not work\n//const { rotatePs: rotate, translatePs: translate } = Vector;\nlet rotate = Vector.rotatePs;\nexports.rotate = rotate;\nlet translate = Vector.translatePs;\nexports.translate = translate;\nconst memoize = flo_memoize_1.default.m1;\n/**\n * Returns the second derivative of the power basis representation of the\n * bezier's x-coordinates. This function is memoized on its points parameter by\n * object reference.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @returns The twice differentiated power basis polynomial from\n * highest power to lowest, e.g. at + b is returned as [a,b]\n */\nlet getDdx = memoize((ps) => flo_poly_1.default.differentiate(get_dx_1.getDx(ps)));\nexports.getDdx = getDdx;\n/**\n * Returns the second derivative of the power basis representation of the\n * bezier's y-coordinates. This function is memoized on its points parameter by\n * object reference.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @returns The twice differentiated power basis polynomial from\n * highest power to lowest, e.g. at + b is returned as [a,b]\n */\nlet getDdy = memoize((ps) => flo_poly_1.default.differentiate(get_dy_1.getDy(ps)));\nexports.getDdy = getDdy;\n/**\n * Returns the third derivative of the power basis representation of the\n * bezier's x-coordinates. This function is memoized on its points parameter by\n * object reference.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @returns The thrice differentiated power basis polynomial (a\n * constant in array from), e.g. a is returned as [a]\n */\nlet getDddx = memoize((ps) => flo_poly_1.default.differentiate(getDdx(ps)));\nexports.getDddx = getDddx;\n/**\n * Returns the third derivative of the power basis representation of the\n * bezier's y-coordinates. This function is memoized on its points parameter by\n * object reference.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @returns The thrice differentiated power basis polynomial (a\n * constant in array from), e.g. a is returned as [a]\n */\nlet getDddy = memoize((ps) => flo_poly_1.default.differentiate(getDdy(ps)));\nexports.getDddy = getDddy;\n/**\n * Returns the convex hull of a bezier's control points. This hull bounds the\n * bezier curve. This function is memoized.\n *\n * The tolerance at which the cross product of two nearly collinear lines of the\n * hull are considered collinear is 1e-12.\n * @param ps - A bezier curve, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @returns An ordered array of convex hull points.\n */\nlet getBoundingHull = memoize(flo_graham_scan_1.default);\nexports.getBoundingHull = getBoundingHull;\n/**\n * Returns a cubic bezier from the given line with evenly spaced control points.\n * @param l - a 2d line represented by two points\n * @returns Control points of the cubic bezier.\n */\nfunction fromLine(l) {\n    let [[x0, y0], [x1, y1]] = l;\n    let xInterval = (x1 - x0) / 3;\n    let yInterval = (y1 - y0) / 3;\n    return [\n        [x0, y0],\n        [x0 + xInterval, y0 + yInterval],\n        [x0 + xInterval * 2, y0 + yInterval * 2],\n        [x1, y1]\n    ];\n}\nexports.fromLine = fromLine;\n/**\n * Returns the given bezier's inflection points.\n **/\nfunction findInflectionPoints(ps) {\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n    // From http://www.caffeineowl.com/graphics/2d/vectorial/cubic-inflexion.html eq. 4\n    let ax = x1 - x0;\n    let ay = y1 - y0;\n    let bx = x2 - x1 - ax;\n    let by = y2 - y1 - ay;\n    let cx = x3 - x2 - ax - (2 * bx);\n    let cy = y3 - y2 - ay - (2 * by);\n    // From http://www.caffeineowl.com/graphics/2d/vectorial/cubic-inflexion.html eq. 6:\n    //   infl(t) := ax*by - ay*bx + t*(ax*cy - ay*cx) + t^2*(bx*cy - by*cx);\n    // We find the roots of the quadratic - a,b,c are the quadratic coefficients\n    let a = bx * cy - by * cx;\n    let b = ax * cy - ay * cx;\n    let c = ax * by - ay * bx;\n    let inflectionTs = flo_poly_1.default.allRoots([a, b, c], 0, 1);\n    const evPs = evaluate_1.evaluate(ps);\n    return inflectionTs.map(evPs);\n}\nfunction κ(ps, t) {\n    const evDx = evaluate_dx_1.evaluateDx(ps);\n    const evDy = evaluate_dy_1.evaluateDy(ps);\n    const evDdx = evaluateDdx(ps);\n    const evDdy = evaluateDdy(ps);\n    function f(t) {\n        let dx = evDx(t);\n        let dy = evDy(t);\n        let ddx = evDdx(t);\n        let ddy = evDdy(t);\n        let a = dx * ddy - dy * ddx;\n        let b = Math.sqrt(Math.pow((dx * dx + dy * dy), 3));\n        return a / b;\n    }\n    // Curry\n    return t === undefined ? f : f(t);\n}\nexports.κ = κ;\n/**\n * Alias of κ.\n */\nlet curvature = κ;\nexports.curvature = curvature;\nfunction κds(ps, t) {\n    const evDx = evaluate_dx_1.evaluateDx(ps);\n    const evDy = evaluate_dy_1.evaluateDy(ps);\n    const evDdx = evaluateDdx(ps);\n    const evDdy = evaluateDdy(ps);\n    function f(t) {\n        let dx = evDx(t);\n        let dy = evDy(t);\n        let ddx = evDdx(t);\n        let ddy = evDdy(t);\n        let a = dx * ddy - dy * ddx;\n        let b = dx * dx + dy * dy;\n        return a / b;\n    }\n    // Curry\n    return t === undefined ? f : f(t);\n}\nfunction dκMod(ps, t) {\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n    function f(t) {\n        let ts = t * t;\n        let omt = 1 - t;\n        let a = ts * x3;\n        let b = ts * y3;\n        let c = 2 * t - 3 * ts;\n        let d = (3 * t - 1) * omt;\n        let e = omt * omt;\n        let f = 3 * (a + c * x2 - d * x1 - e * x0);\n        let g = 3 * (b + c * y2 - d * y1 - e * y0);\n        let h = 6 * (t * y3 - (3 * t - 1) * y2 + (3 * t - 2) * y1 + omt * y0);\n        let i = 6 * (t * x3 - (3 * t - 1) * x2 + (3 * t - 2) * x1 + omt * x0);\n        let j = Math.sqrt(f * f + g * g);\n        return 4 * (f * (y3 - 3 * y2 + 3 * y1 - y0) -\n            g * (x3 - 3 * x2 + 3 * x1 - x0)) * Math.pow(j, 3) -\n            (f * h - i * g) * (2 * h * g + 2 * i * f) * j;\n    }\n    return t === undefined ? f : f(t);\n}\nexports.dκMod = dκMod;\n/**\n * Categorizes the given cubic bezier curve according to whether it has a loop,\n * a cusp, or zero, one or two inflection points all of which are mutually\n * exclusive.\n *\n * See <a href=\"http://graphics.pixar.com/people/derose/publications/CubicClassification/paper.pdf\">\n * this</a> paper.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @returns A value of 'L', 'C', '0', '1', or '2' depending on whether\n * the curve has a loop, a cusp, or zero, one or two inflection points.\n */\nfunction categorize(ps) {\n    // TODO - finish\n}\nfunction totalCurvature(ps, interval) {\n    const tanPs = tangent_1.tangent(ps);\n    function f(interval) {\n        return flo_gauss_quadrature_1.default(κds(ps), interval);\n        // TODO\n        /*\n        let [a,b] = interval;\n        let tangentA = tanPs(a);\n        let tangentB = tanPs(b);\n        let sinθ = Vector.cross(tanA, tanB)\n        */\n    }\n    // Curry\n    return interval === undefined ? f : f(interval);\n}\nexports.totalCurvature = totalCurvature;\nfunction totalAbsoluteCurvature(ps, interval) {\n    function f(interval = [0, 1]) {\n        // Numerically integrate the absolute curvature\n        let result = flo_gauss_quadrature_1.default(t => Math.abs(κds(ps)(t)), interval);\n        return result;\n    }\n    // Curry\n    return interval === undefined ? f : f(interval);\n}\nexports.totalAbsoluteCurvature = totalAbsoluteCurvature;\nfunction len(interval, ps) {\n    function f(ps) {\n        let fs = [, , length1, length2, length3];\n        return fs[ps.length](interval, ps);\n    }\n    // Curry\n    return ps === undefined ? f : f(ps);\n}\nexports.len = len;\n/**\n * Returns the curve length in the specified interval. This function is curried.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @param interval - The paramter interval over which the length is\n * to be calculated (often === [0,1]).\n */\nfunction length3(interval, ps) {\n    if (interval[0] === interval[1]) {\n        return 0;\n    }\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n    // Keep line below to ensure zero length curve returns zero!\n    if (x0 === x1 && x1 === x2 && x2 === x3 &&\n        y0 === y1 && y1 === y2 && y2 === y3) {\n        return 0;\n    }\n    const evDs = ds(ps);\n    return flo_gauss_quadrature_1.default(evDs, interval);\n}\n/**\n * Returns the curve length in the specified interval. This function is curried.\n * Unused because it is not numerically stable in its current form.\n * See https://gist.github.com/tunght13488/6744e77c242cc7a94859\n * @param ps - A quadratic bezier, e.g. [[0,0],[1,1],[2,1]]\n * @param interval - The paramter interval over which the length is\n * to be calculated (often === [0,1]).\n */\n/*\nfunction length2(interval: number[], ps: number[][]) {\n    if (interval[0] === interval[1]) { return 0; }\n\r\n    let [[x0_, y0_], [x1_, y1_], [x2_, y2_]] = ps;\n    // Keep line below to ensure zero length curve returns zero!\n    if (x0_ === x1_ && x1_ === x2_ && y0_ === y1_ && y1_ === y2_) {\n        return 0;\n    }\n\r\n    let [[x0, y0], [x1, y1], [x2, y2]] =\n            fromTo(ps)(interval[0], interval[1]);\n\r\n    let ax = x0 - 2*x1 + x2;\n    let ay = y0 - 2*y1 + y2;\n    let bx = 2*x1 - 2*x0;\n    let by = 2*y1 - 2*y0;\n\r\n    let A = 4 * (ax*ax + ay*ay);\n    let B = 4 * (ax*bx + ay*by);\n    let C = bx*bx + by*by;\n\r\n    let Sabc = 2*Math.sqrt(A+B+C);\n    let A_2 = Math.sqrt(A);\n    let A_32 = 2*A*A_2;\n    let C_2 = 2*Math.sqrt(C);\n    let BA = B/A_2;\n\r\n    return (\n        A_32*Sabc + A_2*B*(Sabc - C_2) +\n        (4*C*A - B*B)*Math.log((2*A_2 + BA + Sabc) / (BA + C_2))\n    ) / (4*A_32);\n}\n*/\nfunction length2(interval, ps) {\n    if (interval[0] === interval[1]) {\n        return 0;\n    }\n    let [[x0, y0], [x1, y1], [x2, y2]] = ps;\n    // Keep line below to ensure zero length curve returns zero!\n    if (x0 === x1 && x1 === x2 && y0 === y1 && y1 === y2) {\n        return 0;\n    }\n    const evDs = ds2(ps);\n    return flo_gauss_quadrature_1.default(evDs, interval);\n}\nfunction length1(interval, ps) {\n    let [t1, t2] = interval;\n    if (t1 === t2) {\n        return 0;\n    }\n    let [[x0, y0], [x1, y1]] = ps;\n    // Keep line below to ensure zero length curve returns zero!\n    if (x0 === x1 && y0 === y1) {\n        return 0;\n    }\n    let p1 = [x0 + t1 * (x1 - x0), y0 + t1 * (y1 - y0)];\n    let p2 = [x0 + t2 * (x1 - x0), y0 + t2 * (y1 - y0)];\n    return Vector.distanceBetween(p1, p2);\n}\nfunction getTAtLength(ps, s) {\n    const lenAtT = (t) => len([0, t], ps);\n    function f(s) {\n        return flo_poly_1.default.brent(t => (lenAtT(t) - s), 0, 1);\n    }\n    // Curry\n    return s === undefined ? f : f(s);\n}\nexports.getTAtLength = getTAtLength;\nfunction ds(ps, t) {\n    const evDx = evaluate_dx_1.evaluateDx(ps);\n    const evDy = evaluate_dy_1.evaluateDy(ps);\n    function f(t) {\n        let dx = evDx(t);\n        let dy = evDy(t);\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n    // Curry\n    return t === undefined ? f : f(t);\n}\nfunction ds2(ps, t) {\n    const evDx = evaluate_dx2_1.evaluateDx2(ps);\n    const evDy = evaluate_dy2_1.evaluateDy2(ps);\n    function f(t) {\n        let dx = evDx(t);\n        let dy = evDy(t);\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n    // Curry\n    return t === undefined ? f : f(t);\n}\nfunction evaluateDdx(ps, t) {\n    const ddPs = getDdx(ps); // Speed optimizing cache\n    const f = flo_poly_1.default.evaluate(ddPs);\n    return t === undefined ? f : f(t); // Curry\n}\nexports.evaluateDdx = evaluateDdx;\nfunction evaluateDdy(ps, t) {\n    const ddPs = getDdy(ps); // Speed optimizing cache\n    const f = flo_poly_1.default.evaluate(ddPs);\n    return t === undefined ? f : f(t); // Curry\n}\nexports.evaluateDdy = evaluateDdy;\nfunction evaluateDddx(ps, t) {\n    const dddPs = getDddx(ps); // Speed optimizing cache\n    const f = flo_poly_1.default.evaluate(dddPs);\n    return t === undefined ? f : f(t); // Curry\n}\nexports.evaluateDddx = evaluateDddx;\nfunction evaluateDddy(ps, t) {\n    const dddPs = getDddy(ps); // Speed optimizing cache\n    const f = flo_poly_1.default.evaluate(dddPs);\n    return t === undefined ? f : f(t); // Curry\n}\nexports.evaluateDddy = evaluateDddy;\n// TODO - refactor getBounds, getBoundingBox, etc.\n/**\n * Helper function. Returns the bounding box of the normalized (i.e. first point\n * moved to origin and rotated so that last point lies on x-axis) given cubic\n * bezier.\n * @ignore\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @param sinθ - Sine of angle made by line from first bezier point to\n * last with x-axis.\n * @param cosθ - Cosine of angle made by line from first bezier point\n * to last with x-axis.\n * @returns Bounding box in the form [[minX, minY], [maxX,maxY]\n */\nfunction getNormalizedBoundingBox(ps, sinθ, cosθ) {\n    let vectorToOrigin = Vector.transform(ps[0], x => -x);\n    let boundingPs = Vector.translateThenRotatePs(vectorToOrigin, -sinθ, cosθ, ps);\n    return getBoundingBox(boundingPs);\n}\n/**\n * Returns the tight bounding box of the given cubic bezier.\n * @returns The tight bounding box of the bezier as four ordered\n * points of a rotated rectangle.\n * TODO - test case of baseLength === 0\n */\nlet getBoundingBoxTight = memoize(function (ps) {\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n    let baseLength = Math.sqrt((x3 - x0) * (x3 - x0) + (y3 - y0) * (y3 - y0));\n    let sinθ = (y3 - y0) / baseLength;\n    let cosθ = (x3 - x0) / baseLength;\n    let box = getNormalizedBoundingBox(ps, sinθ, cosθ);\n    let [[p0x, p0y], [p1x, p1y]] = box;\n    let axisAlignedBox = [\n        box[0], [p1x, p0y],\n        box[1], [p0x, p1y]\n    ];\n    return Vector.rotateThenTranslatePs(sinθ, cosθ, ps[0], axisAlignedBox);\n});\nexports.getBoundingBoxTight = getBoundingBoxTight;\n/**\n * Returns the axis-aligned bounding box of a given bezier.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @returns the axis-aligned bounding box in the form\n * [[minx, miny], [maxx,maxy]\n */\nlet getBoundingBox = memoize(function (ps) {\n    return getBounds(ps).box;\n});\nexports.getBoundingBox = getBoundingBox;\n/**\n * Calculates and returns general bezier bounds.\n * @returns The axis-aligned bounding box together with the t values\n * where the bounds on the bezier are reached.\n */\nlet getBounds = memoize(function (ps) {\n    // Roots of derivative\n    let roots = [get_dx_1.getDx(ps), get_dy_1.getDy(ps)]\n        .map(poly => flo_poly_1.default.allRoots(poly, 0, 1));\n    // Endpoints\n    roots[0].push(0, 1);\n    roots[1].push(0, 1);\n    let minX = Number.POSITIVE_INFINITY;\n    let maxX = Number.NEGATIVE_INFINITY;\n    let minY = Number.POSITIVE_INFINITY;\n    let maxY = Number.NEGATIVE_INFINITY;\n    let tMinX = undefined;\n    let tMinY = undefined;\n    let tMaxX = undefined;\n    let tMaxY = undefined;\n    // Test points\n    for (let i = 0; i < roots[0].length; i++) {\n        let t = roots[0][i];\n        let x = evaluate_x_1.evaluateX(ps, t);\n        if (x < minX) {\n            minX = x;\n            tMinX = t;\n        }\n        if (x > maxX) {\n            maxX = x;\n            tMaxX = t;\n        }\n    }\n    for (let i = 0; i < roots[1].length; i++) {\n        let t = roots[1][i];\n        let y = evaluate_y_1.evaluateY(ps, t);\n        if (y < minY) {\n            minY = y;\n            tMinY = t;\n        }\n        if (y > maxY) {\n            maxY = y;\n            tMaxY = t;\n        }\n    }\n    let ts = [[tMinX, tMinY], [tMaxX, tMaxY]];\n    let box = [[minX, minY], [maxX, maxY]];\n    return { ts, box };\n});\nexports.getBounds = getBounds;\n/**\n * Returns 2 new beziers split at the given t parameter, i.e. for the ranges\n * [0,t] and [t,1]. Uses de Casteljau's algorithm.\n *\n * A loose bound on the accuracy of the resultant points is given by:\n * |δP| = 2n*max_k(|b_k|)η, where n = 3 (cubic), b_k are the control points\n * abd η is Number.EPSILON.\n * @param ps - A cubic bezier curve\n * @param t - The t parameter where the curve should be split\n */\nfunction splitAt(ps, t) {\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n    let s = 1 - t;\n    let t2 = t * t;\n    let t3 = t2 * t;\n    let s2 = s * s;\n    let s3 = s2 * s;\n    let ps1 = [\n        [x0, y0],\n        [t * x1 + s * x0, t * y1 + s * y0],\n        [t2 * x2 + 2 * s * t * x1 + s2 * x0, t2 * y2 + 2 * s * t * y1 + s2 * y0],\n        [t3 * x3 + 3 * s * t2 * x2 + 3 * s2 * t * x1 + s3 * x0,\n            t3 * y3 + 3 * s * t2 * y2 + 3 * s2 * t * y1 + s3 * y0]\n    ];\n    let ps2 = [\n        ps1[3],\n        [t2 * x3 + 2 * t * s * x2 + s2 * x1, t2 * y3 + 2 * t * s * y2 + s2 * y1],\n        [t * x3 + s * x2, t * y3 + s * y2],\n        [x3, y3]\n    ];\n    return [ps1, ps2];\n}\nexports.splitAt = splitAt;\n/**\n * Returns a new bezier from the given bezier by limiting its t range.\n *\n * Uses de Casteljau's algorithm.\n *\n * @param ps A bezier\n * @param tRange A t range\n */\nfunction bezierFromBezierPiece(ps, tRange) {\n    // If tRange = [0,1] then return original bezier.\n    if (tRange[0] === 0 && tRange[1] === 1) {\n        return ps;\n    }\n    // If tRange[0] === tRange[1] then return a single point degenerated bezier.\n    if (tRange[0] === tRange[1]) {\n        let p = evaluate_1.evaluate(ps)(tRange[0]);\n        return [p, p, p, p];\n    }\n    if (tRange[0] === 0) {\n        return from_0_to_T_1.from0ToT(ps, tRange[1]);\n    }\n    if (tRange[1] === 1) {\n        return from_T_to_1_1.fromTTo1(ps, tRange[0]);\n    }\n    // At this stage we know the t range is not degenerate and tRange[0] !== 0 \n    // and tRange[1] !== 1\n    return from_0_to_T_1.from0ToT(from_T_to_1_1.fromTTo1(ps, tRange[0]), (tRange[1] - tRange[0]) / (1 - tRange[0]));\n}\nexports.bezierFromBezierPiece = bezierFromBezierPiece;\n/**\n * Returns a human readable string representation of the given bezier.\n * @param ps - A bezier curve\n */\nfunction toString(ps) {\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n    return `[[${x0},${y0}],[${x1},${y1}],[${x2},${y2}],[${x3},${y3}]]`;\n}\n/**\n * Scales all control points of the given bezier by the given factor.\n * @param ps - A bezier curve\n * @param c - The scale factor\n */\nfunction scale(ps, c) {\n    return ps.map(x => [x[0] * c, x[1] * c]);\n}\nexports.scale = scale;\n/**\n * Returns the best least squares quadratic bezier approximation to the given\n * cubic bezier. Note that the two bezier endpoints differ in general.\n * @param ps - A cubic bezier curve.\n */\nfunction toQuadratic(ps) {\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n    return [\n        [(19 / 20) * x0 + (3 / 20) * x1 + (-3 / 20) * x2 + (1 / 20) * x3,\n            (19 / 20) * y0 + (3 / 20) * y1 + (-3 / 20) * y2 + (1 / 20) * y3],\n        [(-1 / 4) * x0 + (3 / 4) * x1 + (3 / 4) * x2 + (-1 / 4) * x3,\n            (-1 / 4) * y0 + (3 / 4) * y1 + (3 / 4) * y2 + (-1 / 4) * y3],\n        [(1 / 20) * x0 + (-3 / 20) * x1 + (3 / 20) * x2 + (19 / 20) * x3,\n            (1 / 20) * y0 + (-3 / 20) * y1 + (3 / 20) * y2 + (19 / 20) * y3]\n    ];\n}\nexports.toQuadratic = toQuadratic;\n/**\n * Evaluates the given hybrid quadratic at the given t and th parameters. (see\n * toHybridQuadratic for details).\n * @param hq - A hybrid quadratic\n * @param t - The bezier parameter value\n * @param th - The parameter value for the hybrid quadratic point.\n */\nfunction evaluateHybridQuadratic(hq, t, th) {\n    let P0 = hq[0];\n    let P1_ = hq[1];\n    let P2 = hq[2];\n    let P1 = evaluateLinear(hq[1], th);\n    return evaluateQuadratic([P0, P1, P2], t);\n}\nexports.evaluateHybridQuadratic = evaluateHybridQuadratic;\n/**\n * Evaluates the given linear bezier (line) at a specific t value.\n * @param ps - A linear bezier curve.\n * @param t - The value where the bezier should be evaluated\n */\nfunction evaluateLinear(ps, t) {\n    let [[x0, y0], [x1, y1]] = ps;\n    let x = x0 * (1 - t) + x1 * t;\n    let y = y0 * (1 - t) + y1 * t;\n    return [x, y];\n}\nexports.evaluateLinear = evaluateLinear;\n/**\n * Returns a clone of the given cubic bezier. Use sparingly; this is not in the\n * spirit of functional programming.\n * @param ps - A cubic bezier given by its array of control points\n */\nfunction clone(ps) {\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n    return [[x0, y0], [x1, y1], [x2, y2], [x3, y3]];\n}\nexports.clone = clone;\n/**\n * Evaluates the given quadratic bezier at a specific t value.\n * @param ps - A quadratic bezier curve.\n * @param t - The value where the bezier should be evaluated\n */\nfunction evaluateQuadratic(ps, t) {\n    let [[x0, y0], [x1, y1], [x2, y2]] = ps;\n    let x = x0 * Math.pow((1 - t), 2) + x1 * 2 * (1 - t) * t + x2 * Math.pow(t, 2);\n    let y = y0 * Math.pow((1 - t), 2) + y1 * 2 * (1 - t) * t + y2 * Math.pow(t, 2);\n    return [x, y];\n}\nexports.evaluateQuadratic = evaluateQuadratic;\n/**\n * Returns the cubic version of the given quadratic bezier curve. Quadratic\n * bezier curves can always be represented by cubics - the converse is false.\n * @param ps - A quadratic bezier curve.\n */\nfunction toCubic(ps) {\n    let [[x0, y0], [x1, y1], [x2, y2]] = ps;\n    return [\n        [x0, y0],\n        [(1 / 3) * x0 + (2 / 3) * x1, (1 / 3) * y0 + (2 / 3) * y1],\n        [(2 / 3) * x1 + (1 / 3) * x2, (2 / 3) * y1 + (1 / 3) * y2],\n        [x2, y2]\n    ];\n}\nexports.toCubic = toCubic;\n/**\n * Returns the given points (e.g. bezier) in reverse order.\n * @param ps\n */\nfunction reverse(ps) {\n    return ps.slice().reverse();\n}\nexports.reverse = reverse;\nfunction equal(psA, psB) {\n    let [[ax0, ay0], [ax1, ay1], [ax2, ay2], [ax3, ay3]] = psA;\n    let [[bx0, by0], [bx1, by1], [bx2, by2], [bx3, by3]] = psB;\n    return (ax0 === bx0 && ax1 === bx1 && ax2 === bx2 && ax3 === bx3 &&\n        ay0 === by0 && ay1 === by1 && ay2 === by2 && ay3 === by3);\n}\nexports.equal = equal;\n\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/index.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/bezier3-intersection-sylvester/bezier3-intersection-sylvester.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/bezier3-intersection-sylvester/bezier3-intersection-sylvester.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\nconst get_x_1 = __webpack_require__(/*! ../get-x */ \"./node_modules/flo-bezier3/node/src/get-x.js\");\nconst get_y_1 = __webpack_require__(/*! ../get-y */ \"./node_modules/flo-bezier3/node/src/get-y.js\");\nlet DELTA = 10 - 6;\n/**\n * TODO - unfinished\n * Returns the intersection points between two cubic beziers. This function is\n * not numerically stable. Use for experimentation and comparison only. The\n * algorithm may be enhanced to use exact arithmetic in degenerate cases.\n * T-value pairs at intersection of the first and second beziers respectively.\n * @param ps1 - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @param ps2 - Another cubic bezier\n * See http://mat.polsl.pl/sjpam/zeszyty/z6/Silesian_J_Pure_Appl_Math_v6_i1_str_155-176.pdf\n */\nfunction bezier3IntersectionSylvester(ps1, ps2) {\n    let [x1, y1] = ps1[0];\n    let [x2, y2] = ps2[0];\n    // Rotate by θ so that Δx ≡ d_0x - c_0x === 0 (as suggested by the paper)\n    let rotatedPs1;\n    let rotatedPs2;\n    if (Math.abs(x1 - x2) > 1e-12) {\n        let tanθ = (x1 - x2) / (y1 - y2);\n        let tanθ2 = tanθ * tanθ;\n        let sinθ = (tanθ2) / (1 + tanθ2); // Trig. identity\n        let cosθ = sinθ / tanθ;\n        let rotatedPs1_ = flo_vector2d_1.rotatePs(sinθ, cosθ, ps1);\n        let rotatedPs2_ = flo_vector2d_1.rotatePs(sinθ, cosθ, ps2);\n        rotatedPs1 = rotatedPs1_;\n        rotatedPs2 = rotatedPs2_;\n    }\n    else {\n        rotatedPs1 = ps1;\n        rotatedPs2 = ps2;\n    }\n    // Cache\n    let [c_3x, c_2x, c_1x, c_0x] = get_x_1.getX(rotatedPs1);\n    let [c_3y, c_2y, c_1y, c_0y] = get_y_1.getY(rotatedPs1);\n    let [d_3x, d_2x, d_1x, d_0x] = get_x_1.getX(rotatedPs2);\n    let [d_3y, d_2y, d_1y, d_0y] = get_y_1.getY(rotatedPs2);\n    let [a, b, c, d, e, f] = [d_3x, c_3x, d_2x, c_2x, d_1x, c_1x];\n    //let Δx = d_0x - c_0x; // === 0 after rotation\n    let [m, n, p, q, r, s] = [d_3y, c_3y, d_2y, c_2y, d_1y, c_1y];\n    let Δy = d_0y - c_0y;\n    let a2 = a * a;\n    let b2 = b * b;\n    let c2 = c * c;\n    let d2 = d * d;\n    let e2 = e * e;\n    let f2 = f * f;\n    let m2 = m * m;\n    let n2 = n * n;\n    let p2 = p * p;\n    let q2 = q * q;\n    let r2 = r * r;\n    let s2 = s * s;\n    let Δy2 = Δy * Δy;\n    let a3 = a2 * a;\n    let b3 = b2 * b;\n    let c3 = c2 * c;\n    let d3 = d2 * d;\n    let e3 = e2 * e;\n    let f3 = f2 * f;\n    let Δy3 = Δy2 * Δy;\n    let dΔy = d * Δy;\n    let dΔy2 = d * Δy2;\n    let bdΔy = b * dΔy;\n    let bdΔy2 = b * dΔy2;\n    let cΔy = c * Δy;\n    let cΔy2 = c * Δy2;\n    let bΔy = b * Δy;\n    let bΔy2 = b * Δy2;\n    let bΔy3 = b * Δy3;\n    let k9 = -b2 * Δy * f * s2 + bdΔy * f * q * s + 2 * bΔy * f2 * n * s - d2 * Δy * f * n * s -\n        b2 * dΔy2 * s - bΔy * f2 * q2 + dΔy * f2 * n * q - 2 * b2 * Δy2 * f * q +\n        d2 * bΔy2 * q - Δy * f3 * n2 + 3 * bdΔy2 * f * n - d3 * Δy2 * n - b3 * Δy3;\n    let k8 = b2 * Δy * e * s2 + 2 * b2 * Δy * f * r * s - bdΔy * e * q * s - 4 * bΔy * e * f * n * s +\n        d2 * Δy * e * n * s - bdΔy * f * q * r - 2 * bΔy * f2 * n * r + d2 * Δy * f * n * r +\n        b2 * dΔy2 * r + 2 * bΔy * e * f * q2 - 2 * dΔy * e * f * n * q + 2 * b2 * Δy2 * e * q +\n        3 * Δy * e * f2 * n2 - 3 * bdΔy2 * e * n;\n    let k7 = -2 * b2 * Δy * e * r * s - b * cΔy * f * q * s - bdΔy * f * p * s + 2 * c * dΔy * f * n * s +\n        2 * bΔy * e2 * n * s + b2 * cΔy2 * s - b2 * Δy * f * r2 + bdΔy * e * q * r +\n        4 * bΔy * e * f * n * r - d2 * Δy * e * n * r - bΔy * e2 * q2 + 2 * bΔy * f2 * p * q -\n        cΔy * f2 * n * q + dΔy * e2 * n * q - 2 * b * c * dΔy2 * q - dΔy * f2 * n * p +\n        2 * b2 * Δy2 * f * p - b * d2 * Δy2 * p - 3 * Δy * e2 * f * n2 - 3 * b * cΔy2 * f * n +\n        3 * c * d2 * Δy2 * n;\n    let k6 = 2 * a * bΔy * f * s2 - a * dΔy * f * q * s + b * cΔy * e * q * s + bdΔy * e * p * s -\n        2 * a * Δy * f2 * n * s - 2 * c * dΔy * e * n * s - 2 * bΔy * f2 * m * s + d2 * Δy * f * m * s +\n        2 * a * bdΔy2 * s + b2 * Δy * e * r2 + b * cΔy * f * q * r + bdΔy * f * p * r -\n        2 * c * dΔy * f * n * r - 2 * bΔy * e2 * n * r - b2 * cΔy2 * r + a * Δy * f2 * q2 -\n        4 * bΔy * e * f * p * q + 2 * cΔy * e * f * n * q - dΔy * f2 * m * q + 4 * a * bΔy2 * f * q -\n        a * d2 * Δy2 * q + 2 * dΔy * e * f * n * p - 2 * b2 * Δy2 * e * p + Δy * e3 * n2 +\n        2 * Δy * f3 * m * n - 3 * a * dΔy2 * f * n + 3 * b * cΔy2 * e * n - 3 * bdΔy2 * f * m +\n        d3 * Δy2 * m + 3 * a * b2 * Δy3;\n    let k5 = -2 * a * bΔy * e * s2 - 4 * a * bΔy * f * r * s + a * dΔy * e * q * s + b * cΔy * f * p * s +\n        4 * a * Δy * e * f * n * s - c2 * Δy * f * n * s + 4 * bΔy * e * f * m * s - d2 * Δy * e * m * s +\n        a * dΔy * f * q * r - b * cΔy * e * q * r - bdΔy * e * p * r + 2 * a * Δy * f2 * n * r +\n        2 * c * dΔy * e * n * r + 2 * bΔy * f2 * m * r - d2 * Δy * f * m * r - 2 * a * bdΔy2 * r -\n        2 * a * Δy * e * f * q2 + 2 * bΔy * e2 * p * q - cΔy * e2 * n * q + 2 * dΔy * e * f * m * q -\n        4 * a * bΔy2 * e * q + b * c2 * Δy2 * q - bΔy * f2 * p2 + cΔy * f2 * n * p -\n        dΔy * e2 * n * p + 2 * b * c * dΔy2 * p - 6 * Δy * e * f2 * m * n + 3 * a * dΔy2 * e * n -\n        3 * c2 * dΔy2 * n + 3 * bdΔy2 * e * m;\n    let k4 = 4 * a * bΔy * e * r * s + a * cΔy * f * q * s + a * dΔy * f * p * s - b * cΔy * e * p * s -\n        2 * a * Δy * e2 * n * s + c2 * Δy * e * n * s - 2 * c * dΔy * f * m * s - 2 * bΔy * e2 * m * s -\n        2 * a * b * cΔy2 * s + 2 * a * bΔy * f * r2 - a * dΔy * e * q * r - b * cΔy * f * p * r -\n        4 * a * Δy * e * f * n * r + c2 * Δy * f * n * r - 4 * bΔy * e * f * m * r + d2 * Δy * e * m * r +\n        a * Δy * e2 * q2 - 2 * a * Δy * f2 * p * q + cΔy * f2 * m * q - dΔy * e2 * m * q +\n        2 * a * c * dΔy2 * q + 2 * bΔy * e * f * p2 - 2 * cΔy * e * f * n * p + dΔy * f2 * m * p -\n        4 * a * bΔy2 * f * p + a * d2 * Δy2 * p + 6 * Δy * e2 * f * m * n + 3 * a * cΔy2 * f * n +\n        3 * b * cΔy2 * f * m - 3 * c * d2 * Δy2 * m;\n    let k3 = -a2 * Δy * f * s2 - a * cΔy * e * q * s - a * dΔy * e * p * s + 2 * a * Δy * f2 * m * s +\n        2 * c * dΔy * e * m * s - a2 * dΔy2 * s - 2 * a * bΔy * e * r2 - a * cΔy * f * q * r -\n        a * dΔy * f * p * r + b * cΔy * e * p * r + 2 * a * Δy * e2 * n * r - c2 * Δy * e * n * r +\n        2 * c * dΔy * f * m * r + 2 * bΔy * e2 * m * r + 2 * a * b * cΔy2 * r +\n        4 * a * Δy * e * f * p * q - 2 * cΔy * e * f * m * q - 2 * a2 * Δy2 * f * q - bΔy * e2 * p2 +\n        cΔy * e2 * n * p - 2 * dΔy * e * f * m * p + 4 * a * bΔy2 * e * p - b * c2 * Δy2 * p -\n        2 * Δy * e3 * m * n - 3 * a * cΔy2 * e * n + c3 * Δy2 * n - Δy * f3 * m2 +\n        3 * a * dΔy2 * f * m - 3 * b * cΔy2 * e * m - 3 * a2 * bΔy3;\n    let k2 = a2 * Δy * e * s2 + 2 * a2 * Δy * f * r * s - a * cΔy * f * p * s - 4 * a * Δy * e * f * m * s +\n        c2 * Δy * f * m * s + a * cΔy * e * q * r + a * dΔy * e * p * r - 2 * a * Δy * f2 * m * r -\n        2 * c * dΔy * e * m * r + a2 * dΔy2 * r - 2 * a * Δy * e2 * p * q + cΔy * e2 * m * q +\n        2 * a2 * Δy2 * e * q - a * c2 * Δy2 * q + a * Δy * f2 * p2 - cΔy * f2 * m * p +\n        dΔy * e2 * m * p - 2 * a * c * dΔy2 * p + 3 * Δy * e * f2 * m2 - 3 * a * dΔy2 * e * m +\n        3 * c2 * dΔy2 * m;\n    let k1 = -2 * a2 * Δy * e * r * s + a * cΔy * e * p * s + 2 * a * Δy * e2 * m * s - c2 * Δy * e * m * s +\n        a2 * cΔy2 * s - a2 * Δy * f * r2 + a * cΔy * f * p * r + 4 * a * Δy * e * f * m * r -\n        c2 * Δy * f * m * r - 2 * a * Δy * e * f * p2 + 2 * cΔy * e * f * m * p + 2 * a2 * Δy2 * f * p -\n        3 * Δy * e2 * f * m2 - 3 * a * cΔy2 * f * m;\n    let k0 = a2 * Δy * e * r2 - a * cΔy * e * p * r - 2 * a * Δy * e2 * m * r + c2 * Δy * e * m * r -\n        a2 * cΔy2 * r + a * Δy * e2 * p2 - cΔy * e2 * m * p - 2 * a2 * Δy2 * e * p +\n        a * c2 * Δy2 * p + Δy * e3 * m2 + 3 * a * cΔy2 * e * m - c3 * Δy2 * m + a3 * Δy3;\n    let poly = [k9, k8, k7, k6, k5, k4, k3, k2, k1, k0];\n    let roots = flo_poly_1.default.allRoots(poly, 0);\n    let tPairs = [];\n    for (let i = 0; i < roots.length; i++) {\n        let k = roots[i];\n        let k2 = k * k;\n        let k3 = k2 * k;\n        let ps1k = {\n            x: [c_3x * k3, c_2x * k2, c_1x * k, c_0x],\n            y: [c_3y * k3, c_2y * k2, c_1y * k, c_0y]\n        };\n        let ps2k = {\n            x: [d_3x * k3, d_2x * k2, d_1x * k, d_0x],\n            y: [d_3y * k3, d_2y * k2, d_1y * k, d_0y]\n        };\n        let xx = flo_poly_1.default.subtract(get_x_1.getX(rotatedPs2), ps1k.x);\n        let yy = flo_poly_1.default.subtract(get_y_1.getY(rotatedPs2), ps1k.y);\n        let rootsx = flo_poly_1.default.allRoots(xx, 0, 1);\n        let rootsy = flo_poly_1.default.allRoots(yy, 0, 1);\n        for (let j = 0; j < rootsx.length; j++) {\n            let rootx = rootsx[j];\n            for (let l = 0; l < rootsy.length; l++) {\n                let rooty = rootsy[l];\n                if (Math.abs(rootx - rooty) < DELTA) {\n                    let t = (rootx + rooty) / 2;\n                    let tk = t * k;\n                    if (t >= 0 && t <= 1 && tk >= 0 && tk <= 1) {\n                        tPairs.push([tk, t]);\n                    }\n                }\n            }\n        }\n    }\n    return tPairs;\n}\nexports.bezier3IntersectionSylvester = bezier3IntersectionSylvester;\n\n//# sourceMappingURL=bezier3-Intersection-sylvester.js.map\n\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/bezier3-intersection-sylvester/bezier3-intersection-sylvester.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/bezier3-intersection/bezier3-intersection.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/bezier3-intersection/bezier3-intersection.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst coincident_1 = __webpack_require__(/*! ../coincident */ \"./node_modules/flo-bezier3/node/src/coincident.js\");\nconst from_to_1 = __webpack_require__(/*! ../from-to */ \"./node_modules/flo-bezier3/node/src/from-to.js\");\nconst get_distance_to_line_function_1 = __webpack_require__(/*! ./get-distance-to-line-function */ \"./node_modules/flo-bezier3/node/src/bezier3-intersection/get-distance-to-line-function.js\");\nconst calc_other_t_1 = __webpack_require__(/*! ./calc-other-t */ \"./node_modules/flo-bezier3/node/src/bezier3-intersection/calc-other-t.js\");\nconst geo_clip_1 = __webpack_require__(/*! ./geo-clip */ \"./node_modules/flo-bezier3/node/src/bezier3-intersection/geo-clip.js\");\nconst center_1 = __webpack_require__(/*! ./center */ \"./node_modules/flo-bezier3/node/src/bezier3-intersection/center.js\");\nconst evaluate_1 = __webpack_require__(/*! ../evaluate */ \"./node_modules/flo-bezier3/node/src/evaluate.js\");\nconst fat_line_1 = __webpack_require__(/*! ../debug/fat-line */ \"./node_modules/flo-bezier3/node/src/debug/fat-line.js\");\n/**\n * Aaccurate, fast (cubically convergent) algorithm that returns the\n * intersections between two cubic beziers.\n *\n * At stretches where the two curves run extremely close to (or on top of) each\n * other and curve the same direction an interval is returned instead of a\n * point. This tolerance can be set by the Δ parameter.\n *\n * The algorithm is based on a paper at http://scholarsarchive.byu.edu/cgi/viewcontent.cgi?article=2206&context=etd\n * that finds the intersection of a fat line and a so-called geometric interval\n * making it faster than the standard fat-line intersection algorithm. The\n * algorithm has been modified to prevent run-away recursion by checking for\n * coincident pieces at subdivision steps.\n *\n * @param ps1 - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @param ps2 - Another cubic bezier\n * @param δ - An optional tolerance to within which the t parameter\n * should be calculated - defaults to the minimum value of 24*Number.EPSILON or\n * approximately 5e-15. Note that it might not make sense to set this to as\n * large as say 1e-5 since only a single iteration later the maximum accuracy\n * will be attained and not much speed will be gained anyway. Similarly if δ is\n * set to 1e-2 only two iterations will be saved. This is due to the algorithm\n * being cubically convergent (usually converging in about 4 to 8 iterations for\n * typical intersections).\n * @param Δ - A tolerance that indicates how closely a stretch of the\n * beziers can run together before being considered coincident. Defaults to the\n * minimum possible value of 1e-6 if not specified.\n * @returns An array that contains the t-value pairs at intersection\n * of the first and second beziers respectively. The array can also contain t\n * range pairs for coincident pieces that can be either used or ignored\n * depending on the application, e.g. the return value might be [[0.1,0.2],\n * [0.3,0.5],[[0.4,0.5],[0.6,0.7]]] that indicates intersection points at t\n * values of t1=0.1 and t2=0.2 for the first and second bezier respectively as\n * well as at t1=0.3 and t2=0.5 and finally indicates the curves to be nearly\n * coincident from t1=0.4 to t1=0.5 for the first bezier and t2=0.6 to t=0.7 for\n * the second bezier.\n */\nfunction bezier3Intersection(ps1, ps2, δ, Δ) {\n    // The minimum value Δ can be. If it is too small the algorithm may take too\n    // long in cases where the two curves run extremely close to each other for\n    // their entire length and curve the same direction.\n    const ΔMin = 1e-6;\n    // This is an estimate of the relative floating point error during clipping.\n    // A bound is given by |δP| = 2n*max_k(|b_k|)η, where n = 3 (cubic), b_k\n    // are the control points indexed by k=0,1,2,3 and η is machine epsilon, \n    // i.e. Number.EPSILON. We quadruple the bound to be sure.\n    const δMin = 6 * 4 * 8 * Number.EPSILON;\n    // Maximum error - limited to take rounding error into account.\n    if (δ === undefined) {\n        δ = 0;\n    }\n    δ = Math.max(δ, δMin);\n    if (Δ === undefined) {\n        Δ = ΔMin;\n    }\n    Δ = Math.max(Δ, ΔMin);\n    let flip = 0;\n    // Intersection t values for both beziers\n    let tss = [];\n    if (typeof _bez_debug_ !== 'undefined') {\n        _bez_debug_.generated.elems.beziers.push([ps1, ps2]);\n        _bez_debug_.generated.elems.fatLine.push(new fat_line_1.FatLine([[0, 0], [1e-10, 1e-10]], 0, 0) // unused\n        );\n    }\n    let iteration = {\n        ps1,\n        ps2,\n        tRange1: [0, 1],\n        tRange2: [0, 1],\n        idx: 1\n    };\n    /*\n    let tree: IterationTree = {\n        parent: undefined,\n        iteration,\n        children: []\n    };\n    */\n    let stack = [];\n    stack.push(iteration);\n    while (stack.length !== 0) {\n        let toCheck = stack.pop();\n        let { ps1, ps2, tRange1, tRange2, idx } = toCheck;\n        f(ps1, ps2, tRange1, tRange2, idx);\n    }\n    if (typeof _bez_debug_ !== 'undefined') {\n        for (let ts of tss) {\n            _bez_debug_.generated.elems.intersection.push(evaluate_1.evaluate(ps1, ts[0]));\n        }\n    }\n    return tss;\n    // Helper function\n    function f(Q_, P_, qRange, pRange, idx) {\n        let cidx = idx === 0 ? 1 : 0; // Counter flip-flop index\n        // Move intersection toward the origin to prevent floating point issues\n        // that are introduced specifically by the getLineEquation function. \n        // This allows us to get a relative error in the final result usually in \n        // the 10 ULPS or less range.\n        //let [mx, my] = cc(P_, Q_); // TODO - REMOVE! JUST FOR TESTING\n        [P_, Q_] = center_1.center(P_, Q_);\n        if (typeof _bez_debug_ !== 'undefined') {\n            _bez_debug_.generated.elems.beziers.push([P_, Q_]);\n        }\n        let [Q0, , , Q3] = Q_;\n        // Get the implict line equation for the line defined by the first and \n        // last control point of Q. This equation gives the distance between any \n        // point and the line.\n        let dQ;\n        let dMin;\n        let dMax;\n        flip++;\n        let doA = flip === 1 || flip === 2;\n        if (flip === 4) {\n            flip = 0;\n        }\n        //if (doA) {\n        dQ = get_distance_to_line_function_1.getDistanceToLineFunction([Q0, Q3]);\n        // Calculate the distance from the control points of Q to the line \n        let dQi = (i) => dQ(Q_[i]);\n        let [dQ1, dQ2] = [1, 2].map(dQi);\n        // Calculate the fat line of Q.\n        let C = (dQ1 * dQ2 > 0) ? 3 / 4 : 4 / 9;\n        dMin = C * Math.min(0, dQ1, dQ2);\n        dMax = C * Math.max(0, dQ1, dQ2);\n        if (typeof _bez_debug_ !== 'undefined') {\n            _bez_debug_.generated.elems.fatLine.push(new fat_line_1.FatLine([Q0, Q3], dMin, dMax));\n        }\n        /*} else if (!doA) {\n            \r\n            let mid = [(Q0[0] + Q3[0]) / 2, (Q0[1] + Q3[1]) / 2];\n            // Rotate line [Q0,Q3]\n            let l_ = [[-Q0[1], Q0[0]], [-Q3[1], Q3[0]]];\n\r\n            let v = [l_[1][0] - l_[0][0], l_[1][1] - l_[0][1]];\n            let l = [\n                [mid[0], mid[1]],\n                [mid[0] + v[0], mid[1] + v[1]]\n            ];\n            dQ = getDistanceToLineFunction(l);\n\r\n            // Calculate the distance from the control points of Q to the line\n            let dQi = (i: number) => dQ(Q_[i]);\n            let dQs = [0,1,2,3].map(dQi);\n            let [dQ0,dQ1,dQ2,dQ3] = dQs;\n\r\n            // Calculate the fat line of Q.\n            dMin = Math.min(0,dQ0,dQ1,dQ2,dQ3);\n            dMax = Math.max(0,dQ0,dQ1,dQ2,dQ3);\n\r\n            //console.log(dMin, dMax)\n            if (typeof _bez_debug_ !== 'undefined') {\n                _bez_debug_.generated.elems.fatLine.push(\n                    new FatLine(l, dMin, dMax)\n                );\n            }\n        }*/\n        let { tMin, tMax } = geo_clip_1.geoClip(P_, dQ, dMin, dMax);\n        if (tMin === Number.POSITIVE_INFINITY) {\n            return; // No intersection\n        }\n        // The paper calls for a heuristic that if less than 30% will be\n        // clipped, rather split the longest curve and find intersections in the\n        // two halfs seperately.\n        if (tMax - tMin > 0.7) {\n            // Some length measure\n            let pSpan = pRange[1] - pRange[0];\n            let qSpan = qRange[1] - qRange[0];\n            let pq = coincident_1.coincident(P_, Q_);\n            if (pq !== undefined) {\n                return;\n            }\n            // Split the curve in half\n            if (pSpan <= qSpan) {\n                cidx = idx;\n                [P_, Q_] = [Q_, P_];\n                [pRange, qRange] = [qRange, pRange];\n            }\n            // Update t range.\n            let span = pRange[1] - pRange[0];\n            // 1st half\n            let tMinA = pRange[0];\n            let tMaxA = tMinA + span / 2;\n            // 2nd half\n            let tMinB = tMaxA;\n            let tMaxB = pRange[1];\n            let A = from_to_1.fromTo(P_)(0, 0.5);\n            let B = from_to_1.fromTo(P_)(0.5, 1);\n            stack.push({ ps1: A, ps2: Q_, tRange1: [tMinA, tMaxA], tRange2: qRange, idx: cidx });\n            stack.push({ ps1: B, ps2: Q_, tRange1: [tMinB, tMaxB], tRange2: qRange, idx: cidx });\n            //f(A, Q_, [tMinA, tMaxA], qRange, cidx);\n            //f(B, Q_, [tMinB, tMaxB], qRange, cidx);\n            return;\n        }\n        // Update t range.\n        let span = pRange[1] - pRange[0];\n        let tMin_ = (tMin * span + pRange[0]);\n        let tMax_ = (tMax * span + pRange[0]);\n        // Clip\n        P_ = from_to_1.fromTo(P_)(tMin, tMax);\n        if (Math.abs(tMax_ - tMin_) < δ) {\n            let t1 = (tMax_ + tMin_) / 2;\n            let pq = idx === 0 ? [ps1, ps2] : [ps2, ps1];\n            let t2 = calc_other_t_1.calcOtherT(t1, pq[0], pq[1]);\n            if (t2 === undefined) {\n                return undefined;\n            }\n            let ts = idx === 0 ? [t1, t2] : [t2, t1];\n            tss.push(ts);\n            return;\n        }\n        // Swap Q and P and iterate.\n        stack.push({ ps1: P_, ps2: Q_, tRange1: [tMin_, tMax_], tRange2: qRange, idx: cidx });\n    }\n}\nexports.bezier3Intersection = bezier3Intersection;\n\n//# sourceMappingURL=bezier3-intersection.js.map\n\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/bezier3-intersection/bezier3-intersection.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/bezier3-intersection/calc-other-t.js":
/*!********************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/bezier3-intersection/calc-other-t.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\nconst evaluate_1 = __webpack_require__(/*! ../evaluate */ \"./node_modules/flo-bezier3/node/src/evaluate.js\");\nconst ts_at_x_1 = __webpack_require__(/*! ../ts-at-x */ \"./node_modules/flo-bezier3/node/src/ts-at-x.js\");\nconst ts_at_y_1 = __webpack_require__(/*! ../ts-at-y */ \"./node_modules/flo-bezier3/node/src/ts-at-y.js\");\n/**\n * Calculates the t-value of the closest point on Q to P(t).\n * @param δ\n * @param t\n * @param P\n * @param Q\n */\nfunction calcOtherT(t, P, Q) {\n    // Get some length measure on P and Q\n    let max = Math.max(P[0][0], P[0][1], P[1][0], P[1][1], P[2][0], P[2][1], P[3][0], P[3][1], Q[0][0], Q[0][1], Q[1][0], Q[1][1], Q[2][0], Q[2][1], Q[3][0], Q[3][1]);\n    let pp = evaluate_1.evaluate(P)(t);\n    let [x, y] = pp;\n    let tqsh = ts_at_y_1.tsAtY(Q, y);\n    let tqsv = ts_at_x_1.tsAtX(Q, x);\n    if (!tqsh.length && !tqsv.length) {\n        return undefined;\n    }\n    let tqs = [...tqsh, ...tqsv];\n    let bestT = undefined;\n    let bestD = Number.POSITIVE_INFINITY;\n    for (let tq of tqs) {\n        let pq = evaluate_1.evaluate(Q)(tq);\n        let d = flo_vector2d_1.squaredDistanceBetween(pp, pq);\n        if (d < bestD) {\n            bestD = d;\n            bestT = tq;\n        }\n    }\n    // If the best distance > the max allowed tolerance then no intersection\n    // occured - this happens only in special cases where clipping occured at\n    // the endpoint of a curve.\n    let maxTolerance = 256 * 24 * Number.EPSILON * max;\n    if (bestD > maxTolerance * maxTolerance) {\n        return undefined;\n    }\n    return bestT;\n}\nexports.calcOtherT = calcOtherT;\n\n//# sourceMappingURL=calc-other-t.js.map\n\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/bezier3-intersection/calc-other-t.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/bezier3-intersection/center.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/bezier3-intersection/center.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\n/**\n * Return the given two beziers but translated such that the shorter (by\n * some length measure) is closer to the origin.\n * @private\n * @param P\n * @param Q\n */\nfunction center(P, Q) {\n    let [P0, P1, P2, P3] = P;\n    let [Q0, Q1, Q2, Q3] = Q;\n    let lengthP = flo_vector2d_1.squaredDistanceBetween(P0, P1) + flo_vector2d_1.squaredDistanceBetween(P1, P2) + flo_vector2d_1.squaredDistanceBetween(P2, P3);\n    let lengthQ = flo_vector2d_1.squaredDistanceBetween(Q0, Q1) + flo_vector2d_1.squaredDistanceBetween(Q1, Q2) + flo_vector2d_1.squaredDistanceBetween(Q2, Q3);\n    let moveX;\n    let moveY;\n    if (lengthQ < lengthP) {\n        moveX = (Q0[0] + Q1[0] + Q2[0] + Q3[0]) / 4;\n        moveY = (Q0[1] + Q1[1] + Q2[1] + Q3[1]) / 4;\n    }\n    else {\n        moveX = (P0[0] + P1[0] + P2[0] + P3[0]) / 4;\n        moveY = (P0[1] + P1[1] + P2[1] + P3[1]) / 4;\n    }\n    P = P.map(x => [x[0] - moveX, x[1] - moveY]);\n    Q = Q.map(x => [x[0] - moveX, x[1] - moveY]);\n    return [P, Q];\n}\nexports.center = center;\n\n//# sourceMappingURL=center.js.map\n\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/bezier3-intersection/center.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/bezier3-intersection/geo-clip.js":
/*!****************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/bezier3-intersection/geo-clip.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\nconst to_hybrid_quadratic_1 = __webpack_require__(/*! ../to-hybrid-quadratic */ \"./node_modules/flo-bezier3/node/src/to-hybrid-quadratic.js\");\n/**\n * @param P\n * @param dQ\n * @param dMin\n * @param dMax\n */\nfunction geoClip(P, dQ, dMin, dMax) {\n    let hq = to_hybrid_quadratic_1.toHybridQuadratic(P);\n    let dH0 = dQ(hq[0]);\n    let dH2 = dQ(hq[2]);\n    let dH10 = dQ(hq[1][0]);\n    let dH11 = dQ(hq[1][1]);\n    let dHmin = Math.min(dH10, dH11);\n    let dHmax = Math.max(dH10, dH11);\n    let DyMin = [\n        dH0 - 2 * dHmin + dH2,\n        -2 * dH0 + 2 * dHmin,\n        dH0\n    ];\n    let DyMax = [\n        dH0 - 2 * dHmax + dH2,\n        -2 * dH0 + 2 * dHmax,\n        dH0\n    ];\n    let errorBound = 2 * Math.max(flo_poly_1.default.hornerErrorBound(DyMin, 1), flo_poly_1.default.hornerErrorBound(DyMax, 1));\n    dMin = dMin - errorBound;\n    dMax = dMax + errorBound;\n    let DyMinMin = DyMin.slice();\n    DyMinMin[2] = DyMinMin[2] - dMin;\n    let DyMinMax = DyMin.slice();\n    DyMinMax[2] = DyMinMax[2] - dMax;\n    let DyMaxMin = DyMax.slice();\n    DyMaxMin[2] = DyMaxMin[2] - dMin;\n    let DyMaxMax = DyMax.slice();\n    DyMaxMax[2] = DyMaxMax[2] - dMax;\n    let tMin = Number.POSITIVE_INFINITY;\n    let tMax = Number.NEGATIVE_INFINITY;\n    let rootsMinMin = flo_poly_1.default.allRoots(DyMinMin, 0, 1);\n    let rootsMinMax = flo_poly_1.default.allRoots(DyMinMax, 0, 1);\n    let rootsMaxMin = flo_poly_1.default.allRoots(DyMaxMin, 0, 1);\n    let rootsMaxMax = flo_poly_1.default.allRoots(DyMaxMax, 0, 1);\n    tMin = Math.min(...rootsMinMin, ...rootsMinMax, ...rootsMaxMin, ...rootsMaxMax);\n    tMax = Math.max(...rootsMinMin, ...rootsMinMax, ...rootsMaxMin, ...rootsMaxMax);\n    if (dH0 >= dMin && dH0 <= dMax) {\n        tMin = 0;\n    }\n    if (dH2 >= dMin && dH2 <= dMax) {\n        tMax = 1;\n    }\n    if (tMin < 0) {\n        tMin = 0;\n    }\n    if (tMax > 1) {\n        tMax = 1;\n    }\n    return { tMin, tMax };\n}\nexports.geoClip = geoClip;\n\n//# sourceMappingURL=geo-clip.js.map\n\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/bezier3-intersection/geo-clip.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/bezier3-intersection/get-distance-to-line-function.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/bezier3-intersection/get-distance-to-line-function.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst get_line_equation_1 = __webpack_require__(/*! ./get-line-equation */ \"./node_modules/flo-bezier3/node/src/bezier3-intersection/get-line-equation.js\");\n/**\n * @private\n * @param l\n */\nfunction getDistanceToLineFunction(l) {\n    let [a, b, c] = get_line_equation_1.getLineEquation(l);\n    return function (p) {\n        return a * p[0] + b * p[1] + c;\n    };\n}\nexports.getDistanceToLineFunction = getDistanceToLineFunction;\n\n//# sourceMappingURL=get-distance-to-line-function.js.map\n\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/bezier3-intersection/get-distance-to-line-function.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/bezier3-intersection/get-line-equation.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/bezier3-intersection/get-line-equation.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Get the implicit line equation from two 2d points in the form f(x,y) ax + by + c = 0\n * returned as the array [a,b,c].\n * @param l - A line given by two points, e.g. [[2,0],[3,3]]\n */\nfunction getLineEquation(l) {\n    let [[x1, y1], [x2, y2]] = l;\n    let a = y1 - y2;\n    let b = x2 - x1;\n    let c = x1 * y2 - x2 * y1;\n    let d = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n    return [a / d, b / d, c / d];\n}\nexports.getLineEquation = getLineEquation;\n\n//# sourceMappingURL=get-line-equation.js.map\n\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/bezier3-intersection/get-line-equation.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/coincident.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/coincident.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Vector = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\nconst evaluate_1 = __webpack_require__(/*! ./evaluate */ \"./node_modules/flo-bezier3/node/src/evaluate.js\");\nconst line_intersection_1 = __webpack_require__(/*! ./line-intersection */ \"./node_modules/flo-bezier3/node/src/line-intersection.js\");\nconst normal_1 = __webpack_require__(/*! ./normal */ \"./node_modules/flo-bezier3/node/src/normal.js\");\n/**\n * Check if the two given cubic beziers are nearly coincident everywhere along\n * a finite stretch and returns the coincident stretch (if any), otherwise\n * returns undefined.\n * @param P - A cubic bezier curve.\n * @param Q - Another cubic bezier curve.\n * @param δ - An indication of how closely the curves should stay to\n * each other before considered coincident.\n */\nfunction coincident(P, Q, δ = 1e-6) {\n    let PtoQs = [0.01, 0.99].map(i => calcPointAndNeighbor(P, Q, i));\n    let QtoPs = [0.01, 0.99].map(i => calcPointAndNeighbor(Q, P, i));\n    // Check if start and end points are coincident.\n    let tStartQ = 0.01;\n    let tEndQ = 0.99;\n    let tStartP = 0.01;\n    let tEndP = 0.99;\n    if (PtoQs[0].d <= δ) {\n        tStartQ = PtoQs[0].t;\n    }\n    if (PtoQs[1].d <= δ) {\n        tEndQ = PtoQs[1].t;\n    }\n    if (QtoPs[0].d <= δ) {\n        tStartP = QtoPs[0].t;\n    }\n    if (QtoPs[1].d <= δ) {\n        tEndP = QtoPs[1].t;\n    }\n    if (tStartP > tEndP) {\n        [tStartP, tEndP] = [tEndP, tStartP];\n    }\n    if (tStartQ > tEndQ) {\n        [tStartQ, tEndQ] = [tEndQ, tStartQ];\n    }\n    let tSpanP = tEndP - tStartP;\n    let tSpanQ = tEndQ - tStartQ;\n    // We must check at least 10 points to ensure entire curve is coincident, \n    // otherwise we may simply have found intersection points. We cannot simply \n    // check the control points for closeness since well seperated control \n    // points does not necessarily translate into well seperated curves.\n    // If the overlapping part is smaller than 1/10 (a heuristical value) then\n    // do not consider pieces overlapping.\n    if (tSpanP < 0.1 && tSpanQ < 0.1) {\n        return undefined;\n    }\n    let res = true;\n    for (let i = 0; i < 10; i++) {\n        let t = tStartP + tSpanP * (i / 10);\n        let { d } = calcPointAndNeighbor(P, Q, t);\n        if (d > δ) {\n            return undefined;\n        }\n    }\n    return { p: [tStartP, tEndP], q: [tStartQ, tEndQ] };\n}\nexports.coincident = coincident;\nfunction calcPointAndNeighbor(P, Q, t) {\n    // TODO - must also check crossing of normals - for if two curves open\n    // at endpoints and stop essentially at same point.\n    let pp1 = evaluate_1.evaluate(P)(t);\n    let normalVector = normal_1.normal(P)(t);\n    let pp2 = Vector.translate(pp1, normalVector);\n    let ts = line_intersection_1.lineIntersection(Q, [pp1, pp2]);\n    let bestT = undefined;\n    let bestQ = undefined;\n    let bestD = Number.POSITIVE_INFINITY;\n    for (let t of ts) {\n        let q = evaluate_1.evaluate(Q)(t);\n        let d = Vector.distanceBetween(q, pp1);\n        if (d < bestD) {\n            bestT = t;\n            bestQ = q;\n            bestD = d;\n        }\n    }\n    return { t: bestT, p: bestQ, d: bestD };\n}\n\n//# sourceMappingURL=coincident.js.map\n\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/coincident.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/de-casteljau.js":
/*!***********************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/de-casteljau.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction deCasteljau(cs, t) {\n    // See https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm\n    function f(t) {\n        if (t === 0) {\n            return [[cs[0], cs[0], cs[0], cs[0]], cs];\n        }\n        if (t === 1) {\n            return [cs, [cs[3], cs[3], cs[3], cs[3]]];\n        }\n        let t_ = 1 - t;\n        // j === 0, ..., n (with n === 3 -> cubic bezier)\n        let b00 = cs[0]; // i === 0 \n        let b10 = cs[1]; // i === 1 \n        let b20 = cs[2]; // i === 2 \n        let b30 = cs[3]; // i === 3 \n        // j === 1\n        let b01 = (b00 * t_) + (b10 * t); // i === 0\n        let b11 = (b10 * t_) + (b20 * t); // i === 1\n        let b21 = (b20 * t_) + (b30 * t); // i === 2\n        // j === 2\n        let b02 = (b01 * t_) + (b11 * t); // i === 0\n        let b12 = (b11 * t_) + (b21 * t); // i === 1\n        // j === 3\n        let b03 = (b02 * t_) + (b12 * t); // i === 0\n        return [[b00, b01, b02, b03], [b03, b12, b21, b30]];\n    }\n    return t === undefined ? f : f(t); // Curry\n}\nexports.deCasteljau = deCasteljau;\n\n//# sourceMappingURL=de-casteljau.js.map\n\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/de-casteljau.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/debug/debug.js":
/*!**********************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/debug/debug.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n//import * as Vector from 'flo-vector2d';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst draw_elem_1 = __webpack_require__(/*! ./draw-elem/draw-elem */ \"./node_modules/flo-bezier3/node/src/debug/draw-elem/draw-elem.js\");\nclass BezDebug {\n    /**\n     * @param config - configuration settings.\n     * @param fs - some useful functions.\n     * @private\n     */\n    constructor(draw, g) {\n        //(this as any).Bezier3 = Bezier3; // Included only for quick debugging from console\n        //(this as any).Vector2d = Vector; // ...\n        this.draw = draw;\n        this.g = g;\n        //-----------------------------------------------\n        // Generated by debug object for later inspection\n        //-----------------------------------------------\n        this.generated = {\n            elems: {\n                beziers: [],\n                fatLine: [],\n                looseBoundingBox: [],\n                tightBoundingBox: [],\n                extreme: [],\n                boundingHull: [],\n                intersection: [],\n            }\n        };\n        this.fs = {\n            draw,\n            drawElem: draw_elem_1.drawElemFunctions,\n        };\n    }\n}\nexports.BezDebug = BezDebug;\n\n//# sourceMappingURL=debug.js.map\n\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/debug/debug.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/debug/draw-elem/draw-elem.js":
/*!************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/debug/draw-elem/draw-elem.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\nfunction fatLine(g, fatLine) {\n    let draw = _bez_debug_.fs.draw;\n    let { l, minD, maxD } = fatLine;\n    let [lp1, lp2] = l;\n    const E = 1024;\n    let lv = flo_vector2d_1.fromTo(lp1, lp2);\n    let lvTimes10 = [+E * lv[0], +E * lv[1]];\n    let reverseLvTimes10 = [-E * lv[0], -E * lv[1]];\n    let normal = [-lv[1], lv[0]]; // Rotate by -90 degrees\n    let normMin = flo_vector2d_1.toLength(normal, minD);\n    let normMax = flo_vector2d_1.toLength(normal, maxD);\n    let extLp1 = flo_vector2d_1.translate(lp1, reverseLvTimes10);\n    let extLp2 = flo_vector2d_1.translate(lp2, lvTimes10);\n    let nl11 = flo_vector2d_1.translate(extLp1, normMin);\n    let nl12 = flo_vector2d_1.translate(extLp2, normMin);\n    let nl21 = flo_vector2d_1.translate(extLp1, normMax);\n    let nl22 = flo_vector2d_1.translate(extLp2, normMax);\n    let nl1 = [nl11, nl12];\n    let nl2 = [nl21, nl22];\n    let $line1 = draw.line(g, nl1);\n    let $line2 = draw.line(g, nl2);\n    return [...$line1, ...$line2];\n}\nfunction beziers(g, beziers) {\n    let draw = _bez_debug_.fs.draw;\n    let $bezier1 = draw.bezier(g, beziers[0], 'blue thin5 nofill');\n    let $bezier2 = draw.bezier(g, beziers[1], 'green thin5 nofill');\n    let size = getSize([...beziers[0], ...beziers[1]]) / 400;\n    let $dots = [\n        ...draw.dot(g, beziers[0][0], size, 'blue'),\n        ...draw.dot(g, beziers[0][1], size, 'blue'),\n        ...draw.dot(g, beziers[0][2], size, 'blue'),\n        ...draw.dot(g, beziers[0][3], size, 'blue'),\n        ...draw.dot(g, beziers[1][0], size, 'green'),\n        ...draw.dot(g, beziers[1][1], size, 'green'),\n        ...draw.dot(g, beziers[1][2], size, 'green'),\n        ...draw.dot(g, beziers[1][3], size, 'green'),\n    ];\n    return [...$bezier1, ...$bezier2, ...$dots];\n}\nfunction getSize(ps) {\n    let minX = Number.POSITIVE_INFINITY;\n    let minY = Number.POSITIVE_INFINITY;\n    let maxX = Number.NEGATIVE_INFINITY;\n    let maxY = Number.NEGATIVE_INFINITY;\n    for (let p of ps) {\n        if (p[0] < minX) {\n            minX = p[0];\n        }\n        if (p[1] < minY) {\n            minY = p[1];\n        }\n        if (p[0] > maxX) {\n            maxX = p[0];\n        }\n        if (p[1] > maxY) {\n            maxY = p[1];\n        }\n    }\n    let width = maxX - minX;\n    let height = maxY - minY;\n    return Math.max(width, height);\n}\nfunction intersection(g, p) {\n    let $elems = _bez_debug_.fs.draw.crossHair(g, p, 'red thin5 nofill', 0.05);\n    return $elems;\n}\nfunction extreme(g, extreme) {\n    let $elems = _bez_debug_.fs.draw.crossHair(g, extreme.p, 'red thin10 nofill', 0.05);\n    return $elems;\n}\nfunction boundingHull(g, hull) {\n    let $polygon = _bez_debug_.fs.draw.polygon(g, hull, 'thin5 black nofill');\n    return $polygon;\n}\nfunction looseBoundingBox(g, box) {\n    let $box = _bez_debug_.fs.draw.rect(g, box, 'thin5 brown nofill');\n    return $box;\n}\nfunction tightBoundingBox(g, box) {\n    let $box = _bez_debug_.fs.draw.polygon(g, box, 'thin5 black nofill');\n    return $box;\n}\nlet drawElemFunctions = {\n    beziers,\n    intersection,\n    extreme,\n    boundingHull,\n    looseBoundingBox,\n    tightBoundingBox,\n    fatLine\n};\nexports.drawElemFunctions = drawElemFunctions;\n\n//# sourceMappingURL=draw-elem.js.map\n\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/debug/draw-elem/draw-elem.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/debug/fat-line.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/debug/fat-line.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass FatLine {\n    constructor(l, minD, maxD) {\n        this.l = l;\n        this.minD = minD;\n        this.maxD = maxD;\n    }\n}\nexports.FatLine = FatLine;\n\n//# sourceMappingURL=fat-line.js.map\n\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/debug/fat-line.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/eval-de-casteljau.js":
/*!****************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/eval-de-casteljau.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst de_casteljau_1 = __webpack_require__(/*! ./de-casteljau */ \"./node_modules/flo-bezier3/node/src/de-casteljau.js\");\nfunction evalDeCasteljau(ps, t) {\n    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n    let evX = de_casteljau_1.deCasteljau([x0, x1, x2, x3]);\n    let evY = de_casteljau_1.deCasteljau([y0, y1, y2, y3]);\n    function f(t) {\n        if (t === 0) {\n            return [x0, y0];\n        }\n        else if (t === 1) {\n            return [x3, y3];\n        }\n        return [evX(t)[1][0], evY(t)[1][0]];\n    }\n    return t === undefined ? f : f(t);\n}\nexports.evalDeCasteljau = evalDeCasteljau;\n\n//# sourceMappingURL=eval-de-casteljau.js.map\n\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/eval-de-casteljau.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/evaluate-dx.js":
/*!**********************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/evaluate-dx.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\nconst get_dx_1 = __webpack_require__(/*! ./get-dx */ \"./node_modules/flo-bezier3/node/src/get-dx.js\");\nfunction evaluateDx(ps, t) {\n    const dPs = get_dx_1.getDx(ps); // Speed optimizing cache\n    const f = flo_poly_1.default.evaluate(dPs);\n    return t === undefined ? f : f(t); // Curry\n}\nexports.evaluateDx = evaluateDx;\n\n//# sourceMappingURL=evaluate-dx.js.map\n\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/evaluate-dx.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/evaluate-dx2.js":
/*!***********************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/evaluate-dx2.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\nconst get_dx2_1 = __webpack_require__(/*! ./get-dx2 */ \"./node_modules/flo-bezier3/node/src/get-dx2.js\");\nfunction evaluateDx2(ps, t) {\n    const dPs = get_dx2_1.getDx2(ps); // Speed optimizing cache\n    const f = flo_poly_1.default.evaluate(dPs);\n    return t === undefined ? f : f(t); // Curry\n}\nexports.evaluateDx2 = evaluateDx2;\n\n//# sourceMappingURL=evaluate-dx2.js.map\n\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/evaluate-dx2.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/evaluate-dy.js":
/*!**********************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/evaluate-dy.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\nconst get_dy_1 = __webpack_require__(/*! ./get-dy */ \"./node_modules/flo-bezier3/node/src/get-dy.js\");\nfunction evaluateDy(ps, t) {\n    const dPs = get_dy_1.getDy(ps); // Speed optimizing cache\n    const f = flo_poly_1.default.evaluate(dPs);\n    return t === undefined ? f : f(t); // Curry\n}\nexports.evaluateDy = evaluateDy;\n\n//# sourceMappingURL=evaluate-dy.js.map\n\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/evaluate-dy.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/evaluate-dy2.js":
/*!***********************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/evaluate-dy2.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\nconst get_dy2_1 = __webpack_require__(/*! ./get-dy2 */ \"./node_modules/flo-bezier3/node/src/get-dy2.js\");\nfunction evaluateDy2(ps, t) {\n    const dPs = get_dy2_1.getDy2(ps); // Speed optimizing cache\n    const f = flo_poly_1.default.evaluate(dPs);\n    return t === undefined ? f : f(t); // Curry\n}\nexports.evaluateDy2 = evaluateDy2;\n\n//# sourceMappingURL=evaluate-dy2.js.map\n\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/evaluate-dy2.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/evaluate-x.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/evaluate-x.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\nconst get_x_1 = __webpack_require__(/*! ./get-x */ \"./node_modules/flo-bezier3/node/src/get-x.js\");\nfunction evaluateX(ps, t) {\n    const xPs = get_x_1.getX(ps); // Speed optimizing cache\n    const evPs = flo_poly_1.default.evaluate(xPs);\n    function f(t) {\n        if (t === 0) {\n            return ps[0][0];\n        }\n        if (t === 1) {\n            return ps[3][0];\n        }\n        return evPs(t);\n    }\n    return t === undefined ? f : f(t); // Curry\n}\nexports.evaluateX = evaluateX;\n\n//# sourceMappingURL=evaluate-x.js.map\n\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/evaluate-x.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/evaluate-y.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/evaluate-y.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\nconst get_y_1 = __webpack_require__(/*! ./get-y */ \"./node_modules/flo-bezier3/node/src/get-y.js\");\nfunction evaluateY(ps, t) {\n    const yPs = get_y_1.getY(ps); // Speed optimizing cache\n    const evPs = flo_poly_1.default.evaluate(yPs);\n    function f(t) {\n        if (t === 0) {\n            return ps[0][1];\n        }\n        if (t === 1) {\n            return ps[3][1];\n        }\n        return evPs(t);\n    }\n    return t === undefined ? f : f(t); // Curry\n}\nexports.evaluateY = evaluateY;\n\n//# sourceMappingURL=evaluate-y.js.map\n\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/evaluate-y.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/evaluate.js":
/*!*******************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/evaluate.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst evaluate_x_1 = __webpack_require__(/*! ./evaluate-x */ \"./node_modules/flo-bezier3/node/src/evaluate-x.js\");\nconst evaluate_y_1 = __webpack_require__(/*! ./evaluate-y */ \"./node_modules/flo-bezier3/node/src/evaluate-y.js\");\nfunction evaluate(ps, t) {\n    const [[x0, y0], , , [x3, y3]] = ps;\n    const evX = evaluate_x_1.evaluateX(ps);\n    const evY = evaluate_y_1.evaluateY(ps);\n    function f(t) {\n        if (t === 0) {\n            return [x0, y0];\n        }\n        else if (t === 1) {\n            return [x3, y3];\n        }\n        return [evX(t), evY(t)];\n    }\n    return t === undefined ? f : f(t);\n}\nexports.evaluate = evaluate;\n\n//# sourceMappingURL=evaluate.js.map\n\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/evaluate.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/from-0-to-T.js":
/*!**********************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/from-0-to-T.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Returns a cubic bezier curve that starts at the given curve's t=0 and ends\n * at the given t parameter. Uses de Casteljau's algorithm.\n *\n * A loose bound on the accuracy of the resultant points is given by:\n * |δP| = 2n*max_k(|b_k|)η, where n = 3 (cubic), b_k are the control points\n * abd η is Number.EPSILON.\n * @param ps - A cubic bezier curve\n * @param t - The t parameter where the resultant bezier should end\n */\nfunction from0ToT(ps, t) {\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n    let s = 1 - t;\n    let t2 = t * t;\n    let t3 = t2 * t;\n    let s2 = s * s;\n    let s3 = s2 * s;\n    return [\n        [x0, y0],\n        [t * x1 + s * x0, t * y1 + s * y0],\n        [t2 * x2 + 2 * s * t * x1 + s2 * x0, t2 * y2 + 2 * s * t * y1 + s2 * y0],\n        [t3 * x3 + 3 * s * t2 * x2 + 3 * s2 * t * x1 + s3 * x0,\n            t3 * y3 + 3 * s * t2 * y2 + 3 * s2 * t * y1 + s3 * y0]\n    ];\n}\nexports.from0ToT = from0ToT;\n\n//# sourceMappingURL=from-0-to-T.js.map\n\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/from-0-to-T.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/from-T-to-1.js":
/*!**********************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/from-T-to-1.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Returns a cubic bezier curve that starts at the given t parameter and\n * ends at t=1. Uses de Casteljau's algorithm.\n *\n * A loose bound on the accuracy of the resultant points is given by:\n * |δP| = 2n*max_k(|b_k|)η, where n = 3 (cubic), b_k are the control points\n * abd η is Number.EPSILON.\n * @param ps - A cubic bezier curve\n * @param t - The t parameter where the resultant bezier should start\n */\nfunction fromTTo1(ps, t) {\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n    let s = 1 - t;\n    let t2 = t * t;\n    let t3 = t2 * t;\n    let s2 = s * s;\n    let s3 = s2 * s;\n    return [\n        [t3 * x3 + 3 * s * t2 * x2 + 3 * s2 * t * x1 + s3 * x0,\n            t3 * y3 + 3 * s * t2 * y2 + 3 * s2 * t * y1 + s3 * y0],\n        [t2 * x3 + 2 * t * s * x2 + s2 * x1, t2 * y3 + 2 * t * s * y2 + s2 * y1],\n        [t * x3 + s * x2, t * y3 + s * y2],\n        [x3, y3]\n    ];\n}\nexports.fromTTo1 = fromTTo1;\n\n//# sourceMappingURL=from-T-to-1.js.map\n\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/from-T-to-1.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/from-to.js":
/*!******************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/from-to.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst evaluate_1 = __webpack_require__(/*! ./evaluate */ \"./node_modules/flo-bezier3/node/src/evaluate.js\");\nconst from_0_to_T_1 = __webpack_require__(/*! ./from-0-to-T */ \"./node_modules/flo-bezier3/node/src/from-0-to-T.js\");\nconst from_T_to_1_1 = __webpack_require__(/*! ./from-T-to-1 */ \"./node_modules/flo-bezier3/node/src/from-T-to-1.js\");\n/**\n * Returns a cubic bezier curve that starts at the given curve and ends at the\n * given t parameter. Uses de Casteljau's algorithm.\n *\n * A loose bound on the accuracy of the resultant points is given by:\n * |δP| = 2*2n*max_k(|b_k|)η, where n = 3 (cubic), b_k are the control points\n * abd η is Number.EPSILON.\n * @param ps - A cubic bezier curve\n * @param t1 - The t parameter where the resultant bezier should start\n * @param t2 - The t parameter where the resultant bezier should end\n */\nfunction fromTo(ps) {\n    return function (t1, t2) {\n        if (t1 === t2) {\n            // Degenerate case\n            let p = evaluate_1.evaluate(ps, t1);\n            return [p, p, p, p];\n        }\n        else if (t1 === 0 && t2 === 1) {\n            return ps;\n        }\n        else if (t1 === 0) {\n            return from_0_to_T_1.from0ToT(ps, t2);\n        }\n        else if (t2 === 1) {\n            return from_T_to_1_1.fromTTo1(ps, t1);\n        }\n        let t = from_T_to_1_1.fromTTo1(ps, t1);\n        return from_0_to_T_1.from0ToT(t, (t2 - t1) / (1 - t1));\n    };\n}\nexports.fromTo = fromTo;\n\n//# sourceMappingURL=from-to.js.map\n\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/from-to.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/get-dx.js":
/*!*****************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/get-dx.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\nconst get_x_1 = __webpack_require__(/*! ./get-x */ \"./node_modules/flo-bezier3/node/src/get-x.js\");\nconst memoize = flo_memoize_1.default.m1;\n/**\n * Returns the derivative of the power basis representation of the bezier's\n * x-coordinates. This function is memoized on its points parameter by object\n * reference.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n */\nlet getDx = memoize((ps) => flo_poly_1.default.differentiate(get_x_1.getX(ps)));\nexports.getDx = getDx;\n\n//# sourceMappingURL=get-dx.js.map\n\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/get-dx.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/get-dx2.js":
/*!******************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/get-dx2.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\nconst get_x2_1 = __webpack_require__(/*! ./get-x2 */ \"./node_modules/flo-bezier3/node/src/get-x2.js\");\nconst memoize = flo_memoize_1.default.m1;\n/**\n * Returns the derivative of the power basis representation of the bezier's\n * x-coordinates. This function is memoized on its points parameter by object\n * reference.\n * @param ps - A quadratic bezier, e.g. [[0,0],[1,1],[2,1]]\n */\nlet getDx2 = memoize((ps) => flo_poly_1.default.differentiate(get_x2_1.getX2(ps)));\nexports.getDx2 = getDx2;\n\n//# sourceMappingURL=get-dx2.js.map\n\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/get-dx2.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/get-dy.js":
/*!*****************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/get-dy.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\nconst get_y_1 = __webpack_require__(/*! ./get-y */ \"./node_modules/flo-bezier3/node/src/get-y.js\");\nconst memoize = flo_memoize_1.default.m1;\n/**\n * Returns the derivative of the power basis representation of the bezier's\n * y-coordinates. This function is memoized on its points parameter by object\n * reference.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @returns The differentiated power basis polynomial from highest\n * power to lowest, e.g. at^2 + bt + c is returned as [a,b,c]\n */\nlet getDy = memoize((ps) => flo_poly_1.default.differentiate(get_y_1.getY(ps)));\nexports.getDy = getDy;\n\n//# sourceMappingURL=get-dy.js.map\n\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/get-dy.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/get-dy2.js":
/*!******************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/get-dy2.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\nconst get_y2_1 = __webpack_require__(/*! ./get-y2 */ \"./node_modules/flo-bezier3/node/src/get-y2.js\");\nconst memoize = flo_memoize_1.default.m1;\n/**\n * Returns the derivative of the power basis representation of the bezier's\n * y-coordinates. This function is memoized on its points parameter by object\n * reference.\n * @param ps - A quadratic bezier, e.g. [[0,0],[1,1],[2,1]]\n * @returns The differentiated power basis polynomial from highest\n * power to lowest, e.g. at^2 + bt + c is returned as [a,b,c]\n */\nlet getDy2 = memoize((ps) => flo_poly_1.default.differentiate(get_y2_1.getY2(ps)));\nexports.getDy2 = getDy2;\n\n//# sourceMappingURL=get-dy2.js.map\n\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/get-dy2.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/get-x.js":
/*!****************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/get-x.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\nconst memoize = flo_memoize_1.default.m1;\n/**\n * Returns the power basis representation of the bezier's x-coordinates.\n * This function is memoized on its points parameter by object reference.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @returns The power basis polynomial from highest power to lowest,\n * e.g. at^3 + bt^2 + ct + d is returned as [a,b,c,d]\n */\nlet getX = memoize(function (ps) {\n    let [[x0,], [x1,], [x2,], [x3,]] = ps;\n    return [\n        x3 - 3 * x2 + 3 * x1 - x0,\n        3 * x2 - 6 * x1 + 3 * x0,\n        3 * x1 - 3 * x0,\n        x0,\n    ];\n});\nexports.getX = getX;\n\n//# sourceMappingURL=get-x.js.map\n\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/get-x.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/get-x2.js":
/*!*****************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/get-x2.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\nconst memoize = flo_memoize_1.default.m1;\n/**\n * Returns the power basis representation of the bezier's x-coordinates.\n * This function is memoized on its points parameter by object reference.\n * @param ps - A quadratic bezier, e.g. [[0,0],[1,1],[2,1]]\n * @returns The power basis polynomial from highest power to lowest,\n * e.g. at^2 + bt + c is returned as [a,b,c]\n */\nlet getX2 = memoize(function (ps) {\n    let [[x0,], [x1,], [x2,]] = ps;\n    return [\n        x2 - 2 * x1 + x0,\n        2 * x1 - 2 * x0,\n        x0,\n    ];\n});\nexports.getX2 = getX2;\n\n//# sourceMappingURL=get-x2.js.map\n\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/get-x2.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/get-y.js":
/*!****************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/get-y.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\nconst memoize = flo_memoize_1.default.m1;\n/**\n * Returns the power basis representation of the bezier's y-coordinates.\n * This function is memoized on its points parameter by object reference.\n * @param ps - A bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n */\nlet getY = memoize(function (ps) {\n    let [[, y0], [, y1], [, y2], [, y3]] = ps;\n    return [\n        y3 - 3 * y2 + 3 * y1 - y0,\n        3 * y2 - 6 * y1 + 3 * y0,\n        3 * y1 - 3 * y0,\n        y0,\n    ];\n});\nexports.getY = getY;\n\n//# sourceMappingURL=get-y.js.map\n\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/get-y.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/get-y2.js":
/*!*****************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/get-y2.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\nconst memoize = flo_memoize_1.default.m1;\n/**\n * Returns the power basis representation of the bezier's y-coordinates.\n * This function is memoized on its points parameter by object reference.\n * @param ps - A quadratic bezier, e.g. [[0,0],[1,1],[2,1]]\n */\nlet getY2 = memoize(function (ps) {\n    let [[, y0], [, y1], [, y2]] = ps;\n    return [\n        y2 - 2 * y1 + y0,\n        2 * y1 - 2 * y0,\n        y0,\n    ];\n});\nexports.getY2 = getY2;\n\n//# sourceMappingURL=get-y2.js.map\n\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/get-y2.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/line-intersection.js":
/*!****************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/line-intersection.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\nconst get_y_1 = __webpack_require__(/*! ./get-y */ \"./node_modules/flo-bezier3/node/src/get-y.js\");\n/**\n * Returns the bezier t values of the intersection between the given cubic\n * bezier and the given line.\n * @param ps - The bezier curve\n * @param l - The line given as a start and end point\n */\nfunction lineIntersection(ps, l) {\n    let [[x0, y0], [x1, y1]] = l;\n    let [x, y] = [x1 - x0, y1 - y0];\n    if (x === 0 && y === 0) {\n        return [];\n    } // It is not a line, it's a point. \n    // Move the line and the bezier together so the line's first point is on the\n    // origin.\n    ps = flo_vector2d_1.translatePs([-x0, -y0], ps);\n    // Rotate the bezier and line together so the line is y=0.\n    let len = Math.sqrt(x * x + y * y);\n    let sinθ = y / len;\n    let cosθ = x / len;\n    ps = flo_vector2d_1.rotatePs(-sinθ, cosθ, ps);\n    // Find the intersection t values\n    return flo_poly_1.default.allRoots(get_y_1.getY(ps), 0, 1);\n}\nexports.lineIntersection = lineIntersection;\n\n//# sourceMappingURL=line-intersection.js.map\n\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/line-intersection.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/normal.js":
/*!*****************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/normal.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tangent_1 = __webpack_require__(/*! ./tangent */ \"./node_modules/flo-bezier3/node/src/tangent.js\");\nfunction normal(ps, t) {\n    const tanPs = tangent_1.tangent(ps);\n    function f(t) {\n        let v = tanPs(t);\n        return [v[1], -v[0]];\n    }\n    // Curry\n    return t === undefined ? f : f(t);\n}\nexports.normal = normal;\n\n//# sourceMappingURL=normal.js.map\n\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/normal.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/tangent.js":
/*!******************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/tangent.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst evaluate_dx_1 = __webpack_require__(/*! ./evaluate-dx */ \"./node_modules/flo-bezier3/node/src/evaluate-dx.js\");\nconst evaluate_dy_1 = __webpack_require__(/*! ./evaluate-dy */ \"./node_modules/flo-bezier3/node/src/evaluate-dy.js\");\nfunction tangent(ps, t) {\n    const evDx = evaluate_dx_1.evaluateDx(ps);\n    const evDy = evaluate_dy_1.evaluateDy(ps);\n    function f(t) {\n        let dx = evDx(t);\n        let dy = evDy(t);\n        let d = Math.sqrt(dx * dx + dy * dy);\n        return [dx / d, dy / d];\n    }\n    // Curry\n    return t === undefined ? f : f(t);\n}\nexports.tangent = tangent;\n\n//# sourceMappingURL=tangent.js.map\n\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/tangent.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/to-hybrid-quadratic.js":
/*!******************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/to-hybrid-quadratic.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Returns the hybrid quadratic version of the given cubic bezier. For a\n * definition of hybrid quadratic bezier curves see <a href=\"http://scholarsarchive.byu.edu/cgi/viewcontent.cgi?article=2206&context=etd\">\n * this paper</a>.\n * @param ps - A cubic bezier curve.\n * @returns An array of three quadratic bezier points where the\n * middle point is a 'hybrid' point represented as a line (itself represented\n * by two points (a linear bezier curve)) which can be evaluated at a different\n * t value (call it th). If evaluated at the same t value the result is the same\n * as evaluating the original cubic bezier at t. The set generated by evaluating\n * the hybrid quadratic curve for all (t,th) value pairs forms a geometric area\n * bound around the orginal cubic bezier curve. The length of the linear bezier\n * curve mentioned above is a measure of how closely the cubic can be\n * represented as a quadratic bezier curve.\n */\nfunction toHybridQuadratic(ps) {\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n    return [\n        [x0, y0],\n        [[(3 * x1 - x0) / 2, (3 * y1 - y0) / 2],\n            [(3 * x2 - x3) / 2, (3 * y2 - y3) / 2]],\n        [x3, y3] // evaluated at t\n    ];\n}\nexports.toHybridQuadratic = toHybridQuadratic;\n\n//# sourceMappingURL=to-hybrid-quadratic.js.map\n\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/to-hybrid-quadratic.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/ts-at-x.js":
/*!******************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/ts-at-x.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\nconst get_x_1 = __webpack_require__(/*! ./get-x */ \"./node_modules/flo-bezier3/node/src/get-x.js\");\n/**\n * Returns the bezier t values of the intersection between the given cubic\n * bezier and the given vertical line.\n * @param ps - The bezier curve\n * @param y - The y value of the horizontal line\n */\nfunction tsAtX(ps, x) {\n    // Translate ps so that x = 0.\n    ps = ps.map(p => [p[0] - x, p[1]]);\n    // Find the intersection t values\n    return flo_poly_1.default.allRoots(get_x_1.getX(ps), 0, 1);\n}\nexports.tsAtX = tsAtX;\n\n//# sourceMappingURL=ts-at-x.js.map\n\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/ts-at-x.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/ts-at-y.js":
/*!******************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/ts-at-y.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\nconst get_y_1 = __webpack_require__(/*! ./get-y */ \"./node_modules/flo-bezier3/node/src/get-y.js\");\n/**\n * Returns the bezier t values of the intersection between the given cubic\n * bezier and the given horizontal line.\n * @param ps - The bezier curve\n * @param y - The y value of the horizontal line\n */\nfunction tsAtY(ps, y) {\n    // Translate ps so that y = 0.\n    ps = ps.map(p => [p[0], p[1] - y]);\n    // Find the intersection t values\n    return flo_poly_1.default.allRoots(get_y_1.getY(ps), 0, 1);\n}\nexports.tsAtY = tsAtY;\n\n//# sourceMappingURL=ts-at-y.js.map\n\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/ts-at-y.js?");

/***/ }),

/***/ "./node_modules/flo-gauss-quadrature/node/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-gauss-quadrature/node/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// TODO A future improvement can be to use the Gauss–Kronrod rules\n// to estimate the error and thus choose a number of constants based\n// on the error.\n// TODO In future, the constants can be calculated and cached so we can\n// chooce any value for the order.\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Integrates the given function using the Gaussian Quadrature method.\n * See https://en.wikipedia.org/wiki/Gaussian_quadrature\n * See http://pomax.github.io/bezierinfo/#arclength\n * @param f - The univariate function to be integrated\n * @param interval - The integration interval\n * @param order - Can be 2, 4, 8, or 16. Higher values give\n * more accurate results but is slower - defaults to 16.\n */\nfunction gaussQuadrature(f, interval, order = 16) {\n    if (interval[0] === interval[1]) {\n        return 0;\n    }\n    let { weights, abscissas } = GAUSS_CONSTANTS[order];\n    let [a, b] = interval;\n    let result = 0;\n    let m1 = (b - a) / 2;\n    let m2 = (b + a) / 2;\n    for (let i = 0; i <= order - 1; i++) {\n        result += weights[i] * f(m1 * abscissas[i] + m2);\n    }\n    return m1 * result;\n}\n// The Gaussian Legendre Quadrature method constants. \nconst GAUSS_CONSTANTS = {\n    2: {\n        weights: [1, 1],\n        abscissas: [-0.5773502691896257, 0.5773502691896257]\n    },\n    4: {\n        weights: [0.6521451548625461, 0.6521451548625461,\n            0.3478548451374538, 0.3478548451374538],\n        abscissas: [-0.3399810435848563, 0.3399810435848563,\n            -0.8611363115940526, 0.8611363115940526]\n    },\n    8: {\n        weights: [0.3626837833783620, 0.3626837833783620,\n            0.3137066458778873, 0.3137066458778873,\n            0.2223810344533745, 0.2223810344533745,\n            0.1012285362903763, 0.1012285362903763],\n        abscissas: [-0.1834346424956498, 0.1834346424956498,\n            -0.5255324099163290, 0.5255324099163290,\n            -0.7966664774136267, 0.7966664774136267,\n            -0.9602898564975363, 0.9602898564975363]\n    },\n    // Taken from http://keisan.casio.com/exec/system/1330940731\n    16: {\n        abscissas: [-0.989400934991649932596,\n            -0.944575023073232576078,\n            -0.86563120238783174388,\n            -0.7554044083550030338951,\n            -0.6178762444026437484467,\n            -0.4580167776572273863424,\n            -0.28160355077925891323,\n            -0.0950125098376374401853,\n            0.0950125098376374401853,\n            0.28160355077925891323,\n            0.4580167776572273863424,\n            0.617876244402643748447,\n            0.755404408355003033895,\n            0.8656312023878317438805,\n            0.944575023073232576078,\n            0.989400934991649932596\n        ],\n        weights: [\n            0.0271524594117540948518,\n            0.062253523938647892863,\n            0.0951585116824927848099,\n            0.1246289712555338720525,\n            0.1495959888165767320815,\n            0.169156519395002538189,\n            0.182603415044923588867,\n            0.189450610455068496285,\n            0.1894506104550684962854,\n            0.182603415044923588867,\n            0.1691565193950025381893,\n            0.149595988816576732081,\n            0.124628971255533872053,\n            0.095158511682492784809,\n            0.062253523938647892863,\n            0.027152459411754094852\n        ]\n    }\n};\nexports.default = gaussQuadrature;\n\n\n//# sourceURL=webpack:///./node_modules/flo-gauss-quadrature/node/index.js?");

/***/ }),

/***/ "./node_modules/flo-graham-scan/node/index.js":
/*!****************************************************!*\
  !*** ./node_modules/flo-graham-scan/node/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Vector = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\nconst DELTA = 1e-10;\n/**\n * Performs a functional stable sort on the given array and\n * returns the newly sorted array.\n * @ignore\n */\nfunction stableSort(arr, f) {\n    let indxArray = [];\n    for (let i = 0; i < arr.length; i++) {\n        indxArray.push(i);\n    }\n    indxArray.sort(function (a, b) {\n        let res = f(arr[a], arr[b]);\n        if (res !== 0) {\n            return res;\n        }\n        return a - b;\n    });\n    let sorted = [];\n    for (let i = 0; i < arr.length; i++) {\n        sorted.push(arr[indxArray[i]]);\n    }\n    return sorted;\n}\n/**\n * In-place swap two elements in the given array.\n * @ignore\n */\nfunction swap(arr, a, b) {\n    if (a === b) {\n        return;\n    }\n    let temp = arr[a];\n    arr[a] = arr[b];\n    arr[b] = temp;\n}\n/**\n * @private\n */\nfunction getSmallestIndxYThenX(ps) {\n    let smallest = [\n        Number.POSITIVE_INFINITY,\n        Number.POSITIVE_INFINITY\n    ];\n    let smallestI;\n    for (let i = 0; i < ps.length; i++) {\n        let y = ps[i][1];\n        if ((y < smallest[1]) ||\n            (y === smallest[1] && ps[i][0] < smallest[0])) {\n            smallestI = i;\n            smallest = ps[i];\n        }\n    }\n    return smallestI;\n}\n/**\n * <p>\n * Finds the convex hull of the given set of 2d points using the\n * Graham Scan algorithm and returns the hull as an array of points.\n * </p>\n * <p>\n * See https://en.wikipedia.org/wiki/Graham_scan\n * </p>\n * @param ps_ - A set of points\n * @param includeAllBoundaryPoints - Set this to true to if all boundary points\n * should be returned, even redundant ones - defaults to false\n * @param delta - Tolerance at which three points are considered collinear -\n * defaults to 1e-10\n */\nfunction grahamScan(ps_, includeAllBoundaryPoints = false, delta = DELTA) {\n    includeAllBoundaryPoints = !!includeAllBoundaryPoints;\n    function fail(p1, p2, p3) {\n        let res = Vector.ccw(p1, p2, p3, delta);\n        if (includeAllBoundaryPoints) {\n            return res < 0;\n        }\n        return res <= 0;\n    }\n    let ps = ps_.slice();\n    let n = ps.length;\n    let idx = getSmallestIndxYThenX(ps);\n    let [p] = ps.splice(idx, 1);\n    ps = stableSort(ps, function (a, b) {\n        let res = Vector.cross(Vector.fromTo(p, b), Vector.fromTo(p, a));\n        res = Math.abs(res) < delta ? 0 : res;\n        if (res !== 0) {\n            return res;\n        }\n        res = a[1] - b[1];\n        res = Math.abs(res) < delta ? 0 : res;\n        if (res !== 0) {\n            return res;\n        }\n        return a[0] - b[0];\n    });\n    ps.unshift(p);\n    let m = 1;\n    for (let i = 2; i < n; i++) {\n        while (fail(ps[m - 1], ps[m], ps[i])) {\n            if (m > 1) {\n                m -= 1;\n                continue;\n            }\n            else if (i === n - 1) {\n                m -= 1;\n                break;\n            }\n            else {\n                i += 1;\n            }\n        }\n        m += 1;\n        swap(ps, m, i);\n    }\n    return ps.slice(0, m + 1);\n}\nexports.default = grahamScan;\n\n\n//# sourceURL=webpack:///./node_modules/flo-graham-scan/node/index.js?");

/***/ }),

/***/ "./node_modules/flo-ll-rb-tree/node/index.js":
/*!***************************************************!*\
  !*** ./node_modules/flo-ll-rb-tree/node/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Concise, Destructive, Left Leaning Red Black Tree implementation.\n * See: https://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf\n * See: https://en.wikipedia.org/wiki/Left-leaning_red%E2%80%93black_tree\n * See: http://www.teachsolaisgames.com/articles/balanced_left_leaning.html\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tree_node_1 = __webpack_require__(/*! ./src/tree-node */ \"./node_modules/flo-ll-rb-tree/node/src/tree-node.js\");\nconst tree_node_color_1 = __webpack_require__(/*! ./src/tree-node-color */ \"./node_modules/flo-ll-rb-tree/node/src/tree-node-color.js\");\nconst tree_node_direction_1 = __webpack_require__(/*! ./src/tree-node-direction */ \"./node_modules/flo-ll-rb-tree/node/src/tree-node-direction.js\");\nfunction isRed(node) {\n    return node && node.color === tree_node_color_1.default.RED;\n}\n/**\n * @param compare\n * @param datas\n * @param replaceDups - If true then if a duplicate is\n * inserted (as per the equivalence relation induced by the compare)\n * then replace it. If false then keep an array of values at the relevant\n * node.\n */\nclass LlRbTree {\n    constructor(compare, datas, replaceDups) {\n        this.getMinNode = this.getMinOrMaxNode(tree_node_direction_1.default.LEFT);\n        this.getMaxNode = this.getMinOrMaxNode(tree_node_direction_1.default.RIGHT);\n        const tree = this;\n        tree.setComparator(compare, replaceDups);\n        tree.replaceDups = replaceDups;\n        tree.root = null;\n        if (!datas) {\n            return;\n        }\n        for (let data of datas) {\n            tree.insert(data);\n        }\n    }\n    /**\n     * Destructively sets the tree compare. This function can be used for for e.g.\n     * the Bentley Ottmann algorithm.\n     */\n    setComparator(compare, replaceDups) {\n        if (replaceDups) {\n            this.compare = compare;\n        }\n        else {\n            this.compare = (a, b) => compare(a, b[0]);\n        }\n    }\n    isEmpty() { return !this.root; }\n    /**\n     * Find the node in the tree with the given data using the tree compare\n     * function.\n     * @returns {Node} node or null if not found.\n     */\n    find(data) {\n        const tree = this;\n        let node = this.root;\n        while (node) {\n            let c = tree.compare(data, node.data);\n            if (c === 0) {\n                return node;\n            }\n            else {\n                node = node[c > 0 ? tree_node_direction_1.default.RIGHT : tree_node_direction_1.default.LEFT];\n            }\n        }\n        return null;\n    }\n    /**\n     * .\n     */\n    toArrayInOrder() {\n        let nodes = [];\n        f(this.root);\n        function f(node) {\n            if (!node) {\n                return;\n            }\n            f(node[tree_node_direction_1.default.LEFT]);\n            nodes.push(node);\n            f(node[tree_node_direction_1.default.RIGHT]);\n        }\n        return nodes;\n    }\n    /**\n     * Inserts a node with the given data into the tree.\n     */\n    insert(data) {\n        const tree = this;\n        tree.root = f(tree.root, data);\n        tree.root.color = tree_node_color_1.default.BLACK;\n        tree.root.parent = undefined;\n        function f(h, data) {\n            if (!h) {\n                return new tree_node_1.default(data, !tree.replaceDups);\n            }\n            let c = tree.compare(data, h.data);\n            if (c === 0) {\n                if (tree.replaceDups) {\n                    h.data = data;\n                }\n                else {\n                    h.data.push(data);\n                }\n            }\n            else {\n                let dir = c > 0 ? tree_node_direction_1.default.RIGHT : tree_node_direction_1.default.LEFT;\n                h[dir] = f(h[dir], data);\n                h[dir].parent = h;\n            }\n            if (isRed(h[tree_node_direction_1.default.RIGHT]) &&\n                !isRed(h[tree_node_direction_1.default.LEFT])) {\n                h = rotate(tree_node_direction_1.default.LEFT, h);\n            }\n            if (isRed(h[tree_node_direction_1.default.LEFT]) &&\n                isRed(h[tree_node_direction_1.default.LEFT][tree_node_direction_1.default.LEFT])) {\n                h = rotate(tree_node_direction_1.default.RIGHT, h);\n            }\n            if (isRed(h[tree_node_direction_1.default.LEFT]) &&\n                isRed(h[tree_node_direction_1.default.RIGHT])) {\n                flipColors(h);\n            }\n            return h;\n        }\n    }\n    /**\n     * Removes an item from the tree based on the given data.\n     * @param {LlRbTree} tree\n     * @param {*} data\n     * @param {boolean} all - If the data is an array, remove all.\n     */\n    remove(data, all) {\n        const tree = this;\n        tree.root = f(tree.root, data);\n        if (tree.root) {\n            tree.root.color = tree_node_color_1.default.BLACK;\n            tree.root.parent = undefined;\n        }\n        function f(h, data) {\n            //let h = h_;\n            let c = tree.compare(data, h.data);\n            if (!tree.replaceDups && c === 0 && !all && h.data.length > 1) {\n                removeFromArray(data, h.data);\n                return h;\n            }\n            if (c < 0 && !h[tree_node_direction_1.default.LEFT] || c > 0 && !h[tree_node_direction_1.default.RIGHT]) {\n                return h;\n            }\n            if (c < 0) {\n                if (!isRed(h[tree_node_direction_1.default.LEFT]) &&\n                    !isRed(h[tree_node_direction_1.default.LEFT][tree_node_direction_1.default.LEFT])) {\n                    h = moveRedLeft(h);\n                }\n                h[tree_node_direction_1.default.LEFT] = f(h[tree_node_direction_1.default.LEFT], data);\n                if (h[tree_node_direction_1.default.LEFT]) {\n                    h[tree_node_direction_1.default.LEFT].parent = h;\n                }\n                return fixUp(h);\n            }\n            if (isRed(h[tree_node_direction_1.default.LEFT])) {\n                h = rotate(tree_node_direction_1.default.RIGHT, h);\n                c = tree.compare(data, h.data);\n                if (!tree.replaceDups && c === 0 && !all && h.data.length > 1) {\n                    removeFromArray(data, h.data);\n                    return h;\n                }\n            }\n            if (c === 0 && !h[tree_node_direction_1.default.RIGHT]) {\n                return null;\n            }\n            if (!isRed(h[tree_node_direction_1.default.RIGHT]) &&\n                !isRed(h[tree_node_direction_1.default.RIGHT][tree_node_direction_1.default.LEFT])) {\n                h = moveRedRight(h);\n                c = tree.compare(data, h.data);\n                if (!tree.replaceDups && c === 0 && !all && h.data.length > 1) {\n                    removeFromArray(data, h.data);\n                    return h;\n                }\n            }\n            if (c === 0) {\n                h.data = tree.min(h[tree_node_direction_1.default.RIGHT]);\n                h[tree_node_direction_1.default.RIGHT] = removeMin(h[tree_node_direction_1.default.RIGHT]);\n            }\n            else {\n                h[tree_node_direction_1.default.RIGHT] = f(h[tree_node_direction_1.default.RIGHT], data);\n            }\n            if (h[tree_node_direction_1.default.RIGHT]) {\n                h[tree_node_direction_1.default.RIGHT].parent = h;\n            }\n            return fixUp(h);\n        }\n    }\n    /**\n     * Returns the two ordered nodes bounding the data. If the\n     * data falls on a node, that node and the next (to the right) is\n     * returned.\n     * @returns {Node[]}\n     */\n    findBounds(data) {\n        const tree = this;\n        let node = tree.root;\n        let bounds = [undefined, undefined];\n        if (node === null) {\n            return bounds;\n        }\n        while (node) {\n            const c = tree.compare(data, node.data);\n            if (c >= 0) {\n                bounds[0] = node;\n            }\n            else {\n                bounds[1] = node;\n            }\n            node = node[c >= 0 ? tree_node_direction_1.default.RIGHT : tree_node_direction_1.default.LEFT];\n        }\n        return bounds;\n    }\n    /**\n     * @param {LlRbTree} tree\n     * @param {*} data\n     * @returns {Node[]} The two ordered nodes bounding the data. If the\n     * data falls on a node, returns the nodes before and after this one.\n     */\n    findBoundsExcl(data) {\n        const tree = this;\n        let node = tree.root;\n        let bounds = [undefined, undefined];\n        if (node === null) {\n            return bounds;\n        }\n        f(node);\n        function f(node) {\n            while (node) {\n                let c = tree.compare(data, node.data);\n                if (c === 0) {\n                    // Search on both sides\n                    f(node[tree_node_direction_1.default.LEFT]);\n                    f(node[tree_node_direction_1.default.RIGHT]);\n                    return;\n                }\n                if (c > 0) {\n                    bounds[0] = node;\n                }\n                else if (c < 0) {\n                    bounds[1] = node;\n                }\n                node = node[c > 0 ? tree_node_direction_1.default.RIGHT : tree_node_direction_1.default.LEFT];\n            }\n        }\n        return bounds;\n    }\n    /**\n     *\n     */\n    findAllInOrder(data) {\n        const tree = this;\n        let nodes = [];\n        f(tree.root);\n        function f(node) {\n            while (node) {\n                let c = tree.compare(data, node.data);\n                if (c === 0) {\n                    f(node[tree_node_direction_1.default.LEFT]);\n                    nodes.push(node);\n                    f(node[tree_node_direction_1.default.RIGHT]);\n                    return;\n                }\n                node = node[c > 0 ? tree_node_direction_1.default.RIGHT : tree_node_direction_1.default.LEFT];\n            }\n        }\n        return nodes;\n    }\n    getMinOrMaxNode(dir) {\n        return function (node) {\n            if (!node) {\n                return undefined;\n            }\n            while (node[dir]) {\n                node = node[dir];\n            }\n            return node;\n        };\n    }\n    min(node) {\n        return this.getMinNode(node).data;\n    }\n    max(node) {\n        return this.getMaxNode(node).data;\n    }\n}\n/**\n * Removes the data from the tuple using ===.\n * Note this function uses === and not the compare function!\n */\nfunction removeFromArray(elem, arr) {\n    let index = arr.indexOf(elem);\n    if (index !== -1) {\n        arr.splice(index, 1);\n    }\n}\n/**\n * Destructively rotates the given node, say h, in the\n * given direction as far as tree rotations go.\n * @param {boolean} dir true -> right, false -> left\n * @param {Node} h\n * @returns The node that is at the top after the rotation.\n */\nfunction rotate(dir, h) {\n    const otherDir = dir ? tree_node_direction_1.default.LEFT : tree_node_direction_1.default.RIGHT;\n    const x = h[otherDir];\n    h[otherDir] = x[dir];\n    if (x[dir]) {\n        x[dir].parent = h;\n    }\n    x[dir] = h;\n    h.parent = x;\n    x.color = h.color;\n    h.color = tree_node_color_1.default.RED;\n    return x;\n}\nfunction removeMin(h) {\n    if (!h[tree_node_direction_1.default.LEFT]) {\n        return null;\n    }\n    if (!isRed(h[tree_node_direction_1.default.LEFT]) &&\n        !isRed(h[tree_node_direction_1.default.LEFT][tree_node_direction_1.default.LEFT])) {\n        h = moveRedLeft(h);\n    }\n    h[tree_node_direction_1.default.LEFT] = removeMin(h[tree_node_direction_1.default.LEFT]);\n    if (h[tree_node_direction_1.default.LEFT]) {\n        h[tree_node_direction_1.default.LEFT].parent = h;\n    }\n    return fixUp(h);\n}\nfunction flipColor(color) {\n    return color === tree_node_color_1.default.RED ? tree_node_color_1.default.BLACK : tree_node_color_1.default.RED;\n}\n/**\n * Destructively flips the color of the given node and both\n * it's childrens' colors.\n * @param {Node} h\n */\nfunction flipColors(h) {\n    h.color = flipColor(h.color);\n    h[tree_node_direction_1.default.LEFT].color = flipColor(h[tree_node_direction_1.default.LEFT].color);\n    h[tree_node_direction_1.default.RIGHT].color = flipColor(h[tree_node_direction_1.default.RIGHT].color);\n}\n/**\n * @description\n * @param h\n * @returns The node that is at the top after the move.\n */\nfunction moveRedLeft(h) {\n    flipColors(h);\n    if (isRed(h[tree_node_direction_1.default.RIGHT][tree_node_direction_1.default.LEFT])) {\n        let a = rotate(tree_node_direction_1.default.RIGHT, h[tree_node_direction_1.default.RIGHT]);\n        h[tree_node_direction_1.default.RIGHT] = a;\n        a.parent = h;\n        h = rotate(tree_node_direction_1.default.LEFT, h);\n        flipColors(h);\n    }\n    return h;\n}\n/**\n * @description\n * @param h\n * @returns The node that is at the top after the move.\n */\nfunction moveRedRight(h) {\n    flipColors(h);\n    if (isRed(h[tree_node_direction_1.default.LEFT][tree_node_direction_1.default.LEFT])) {\n        h = rotate(tree_node_direction_1.default.RIGHT, h);\n        flipColors(h);\n    }\n    return h;\n}\n/**\n * @description Fix right-leaning red nodes.\n * @returns The node that is at the top after the fix.\n */\nfunction fixUp(h) {\n    if (isRed(h[tree_node_direction_1.default.RIGHT])) {\n        h = rotate(tree_node_direction_1.default.LEFT, h);\n    }\n    if (isRed(h[tree_node_direction_1.default.LEFT]) &&\n        isRed(h[tree_node_direction_1.default.LEFT][tree_node_direction_1.default.LEFT])) {\n        h = rotate(tree_node_direction_1.default.RIGHT, h);\n    }\n    // Split 4-nodes.\n    if (isRed(h[tree_node_direction_1.default.LEFT]) &&\n        isRed(h[tree_node_direction_1.default.RIGHT])) {\n        flipColors(h);\n    }\n    return h;\n}\nexports.default = LlRbTree;\n\n\n//# sourceURL=webpack:///./node_modules/flo-ll-rb-tree/node/index.js?");

/***/ }),

/***/ "./node_modules/flo-ll-rb-tree/node/src/tree-node-color.js":
/*!*****************************************************************!*\
  !*** ./node_modules/flo-ll-rb-tree/node/src/tree-node-color.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar TreeNodeColor;\n(function (TreeNodeColor) {\n    TreeNodeColor[TreeNodeColor[\"BLACK\"] = 0] = \"BLACK\";\n    TreeNodeColor[TreeNodeColor[\"RED\"] = 1] = \"RED\";\n})(TreeNodeColor || (TreeNodeColor = {}));\nexports.default = TreeNodeColor;\n\n\n//# sourceURL=webpack:///./node_modules/flo-ll-rb-tree/node/src/tree-node-color.js?");

/***/ }),

/***/ "./node_modules/flo-ll-rb-tree/node/src/tree-node-direction.js":
/*!*********************************************************************!*\
  !*** ./node_modules/flo-ll-rb-tree/node/src/tree-node-direction.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar TreeNodeDirection;\n(function (TreeNodeDirection) {\n    TreeNodeDirection[TreeNodeDirection[\"LEFT\"] = 0] = \"LEFT\";\n    TreeNodeDirection[TreeNodeDirection[\"RIGHT\"] = 1] = \"RIGHT\";\n})(TreeNodeDirection || (TreeNodeDirection = {}));\nexports.default = TreeNodeDirection;\n\n\n//# sourceURL=webpack:///./node_modules/flo-ll-rb-tree/node/src/tree-node-direction.js?");

/***/ }),

/***/ "./node_modules/flo-ll-rb-tree/node/src/tree-node.js":
/*!***********************************************************!*\
  !*** ./node_modules/flo-ll-rb-tree/node/src/tree-node.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tree_node_color_1 = __webpack_require__(/*! ./tree-node-color */ \"./node_modules/flo-ll-rb-tree/node/src/tree-node-color.js\");\n/**\n * Red Black Tree node.\n * @constructor\n * @param {*} data\n */\nclass TreeNode {\n    constructor(data, asArray) {\n        if (asArray) {\n            this.data = [data];\n        }\n        else {\n            this.data = data;\n        }\n        this.color = tree_node_color_1.default.RED;\n    }\n}\nexports.default = TreeNode;\n\n\n//# sourceURL=webpack:///./node_modules/flo-ll-rb-tree/node/src/tree-node.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/index.js":
/*!********************************************!*\
  !*** ./node_modules/flo-mat/node/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst mat_1 = __webpack_require__(/*! ./src/mat */ \"./node_modules/flo-mat/node/src/mat.js\");\nexports.Mat = mat_1.Mat;\nconst loop_1 = __webpack_require__(/*! ./src/loop */ \"./node_modules/flo-mat/node/src/loop.js\");\nexports.Loop = loop_1.Loop;\nconst curve_1 = __webpack_require__(/*! ./src/curve */ \"./node_modules/flo-mat/node/src/curve.js\");\nexports.Curve = curve_1.Curve;\nconst cp_node_1 = __webpack_require__(/*! ./src/cp-node */ \"./node_modules/flo-mat/node/src/cp-node.js\");\nexports.CpNode = cp_node_1.CpNode;\nconst point_on_shape_1 = __webpack_require__(/*! ./src/point-on-shape */ \"./node_modules/flo-mat/node/src/point-on-shape.js\");\nexports.PointOnShape = point_on_shape_1.PointOnShape;\nconst circle_1 = __webpack_require__(/*! ./src/circle */ \"./node_modules/flo-mat/node/src/circle.js\");\nexports.Circle = circle_1.Circle;\nconst contact_point_1 = __webpack_require__(/*! ./src/contact-point */ \"./node_modules/flo-mat/node/src/contact-point.js\");\nexports.ContactPoint = contact_point_1.ContactPoint;\nconst bezier_piece_1 = __webpack_require__(/*! ./src/bezier-piece */ \"./node_modules/flo-mat/node/src/bezier-piece.js\");\nexports.BezierPiece = bezier_piece_1.BezierPiece;\nconst x_1 = __webpack_require__(/*! ./src/x */ \"./node_modules/flo-mat/node/src/x.js\");\nexports.X = x_1.X;\nconst smoothen_1 = __webpack_require__(/*! ./src/mat/smoothen/smoothen */ \"./node_modules/flo-mat/node/src/mat/smoothen/smoothen.js\");\nexports.smoothen = smoothen_1.smoothen;\nconst find_mats_1 = __webpack_require__(/*! ./src/mat/find-mat/find-mats */ \"./node_modules/flo-mat/node/src/mat/find-mat/find-mats.js\");\nexports.findMats = find_mats_1.findMats;\nconst trim_mat_1 = __webpack_require__(/*! ./src/mat/trim-mat */ \"./node_modules/flo-mat/node/src/mat/trim-mat.js\");\nexports.trimMat = trim_mat_1.trimMat;\nconst to_scale_axis_1 = __webpack_require__(/*! ./src/mat/to-scale-axis/to-scale-axis */ \"./node_modules/flo-mat/node/src/mat/to-scale-axis/to-scale-axis.js\");\nexports.toScaleAxis = to_scale_axis_1.toScaleAxis;\nconst traverse_edges_1 = __webpack_require__(/*! ./src/mat/traverse-edges */ \"./node_modules/flo-mat/node/src/mat/traverse-edges.js\");\nexports.traverseEdges = traverse_edges_1.traverseEdges;\nconst traverse_vertices_1 = __webpack_require__(/*! ./src/mat/traverse-vertices */ \"./node_modules/flo-mat/node/src/mat/traverse-vertices.js\");\nexports.traverseVertices = traverse_vertices_1.traverseVertices;\nconst debug_1 = __webpack_require__(/*! ./src/debug/debug */ \"./node_modules/flo-mat/node/src/debug/debug.js\");\nexports.MatDebug = debug_1.MatDebug;\nconst svg_1 = __webpack_require__(/*! ./src/svg/svg */ \"./node_modules/flo-mat/node/src/svg/svg.js\");\nexports.getPathsFromStr = svg_1.getPathsFromStr;\nconst cp_node_for_debugging_1 = __webpack_require__(/*! ./src/debug/cp-node-for-debugging */ \"./node_modules/flo-mat/node/src/debug/cp-node-for-debugging.js\");\nexports.CpNodeForDebugging = cp_node_for_debugging_1.CpNodeForDebugging;\nconst get_closest_boundary_point_1 = __webpack_require__(/*! ./src/mat/get-closest-boundary-point */ \"./node_modules/flo-mat/node/src/mat/get-closest-boundary-point.js\");\nexports.getClosestBoundaryPoint = get_closest_boundary_point_1.getClosestBoundaryPoint;\nexports.closestPointOnBezier = get_closest_boundary_point_1.closestPointOnBezier;\nconst Svg = __webpack_require__(/*! ./src/svg/svg */ \"./node_modules/flo-mat/node/src/svg/svg.js\");\nexports.Svg = Svg;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/index.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/bezier-piece.js":
/*!*******************************************************!*\
  !*** ./node_modules/flo-mat/node/src/bezier-piece.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass BezierPiece {\n    /**\n     * @param curve\n     * @param ts The start and end t parameter of the original bezier curve\n     */\n    constructor(curve, ts) {\n        this.curve = curve;\n        this.ts = ts;\n    }\n}\nexports.BezierPiece = BezierPiece;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/bezier-piece.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/bounding-box/find-bb-intersections.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/bounding-box/find-bb-intersections.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst EVENT_LEFT = 0;\nconst EVENT_RIGHT = 1;\n/**\n * Find and return axis-aligned open boxes that intersect via a sweepline\n * algorithm.\n */\nfunction findBbIntersections(boxes) {\n    // Initialize event queue to equal all box x-axis endpoints.\n    let events = [];\n    for (let i = 0; i < boxes.length; i++) {\n        let box = boxes[i];\n        let smallerSide = box[0][0] < box[1][0] ? 0 : 1;\n        let largerSide = smallerSide === 0 ? 1 : 0;\n        events.push(new Event(0, box, box[smallerSide]));\n        events.push(new Event(1, box, box[largerSide]));\n    }\n    events.sort(Event.compare);\n    let activeBoxes = new Set();\n    let intersections = [];\n    for (let i = 0; i < events.length; i++) {\n        let event = events[i];\n        let box = event.box;\n        if (event.type === EVENT_LEFT) {\n            for (let activeBox of activeBoxes.values()) {\n                if (areBoxesIntersecting(box, activeBox)) {\n                    intersections.push({\n                        box1: box, box2: activeBox\n                    });\n                }\n            }\n            activeBoxes.add(box);\n        }\n        else if (event.type === EVENT_RIGHT) {\n            activeBoxes.delete(event.box);\n        }\n    }\n    return intersections;\n}\nclass Event {\n    /**\n     * Event class constructor\n     * @param type - 0 -> left side, 1 -> right side\n     * @param box - An axis-aligned 2-box described by 2 points\n     * @param p - A point.\n     */\n    constructor(type, box, p) {\n        this.type = type;\n        this.box = box;\n        this.p = p;\n    }\n    /**\n     * Compare two Events by their x-axis and then by their type. Since it is\n     * open boxes that are compare we must let the right endpoint type come\n     * before the left.\n     * @param a A point (within an object)\n     * @param b A point (within an object)\n     */\n    static compare(a, b) {\n        let res = a.p[0] - b.p[0];\n        if (res !== 0) {\n            return res;\n        }\n        if (a.box === b.box) {\n            return a.type === EVENT_RIGHT ? -1 : +1;\n        }\n        return a.type === EVENT_LEFT ? +1 : -1;\n    }\n}\n/**\n * Returns true if the 2 given (open) boxes intersect. At this stage we already\n * know their x-axis intersect.\n */\nfunction areBoxesIntersecting(a, b) {\n    let [[, a0], [, a1]] = a;\n    let [[, b0], [, b1]] = b;\n    if (a0 > a1) {\n        [a0, a1] = [a1, a0];\n    }\n    ;\n    if (b0 > b1) {\n        [b0, b1] = [b1, b0];\n    }\n    ;\n    if (a0 === b0) {\n        if (a0 === a1 || b0 === b1) {\n            return false;\n        }\n        return true;\n    }\n    if (a0 < b0) {\n        if (a1 <= b0) {\n            return false;\n        }\n        return true;\n    }\n    if (a0 > b0) {\n        if (b1 <= a0) {\n            return false;\n        }\n        return true;\n    }\n}\nexports.default = findBbIntersections;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/bounding-box/find-bb-intersections.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/circle.js":
/*!*************************************************!*\
  !*** ./node_modules/flo-mat/node/src/circle.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\nclass Circle {\n    /**\n    * @param center\n    * @param radius\n    */\n    constructor(center, radius) {\n        this.center = center;\n        this.radius = radius;\n    }\n    /**\n     * Returns a scaled version of the given circle without changing its center.\n     * @param circle\n     * @param s multiplier\n     */\n    static scale(circle, s) {\n        return new Circle(circle.center, circle.radius * s);\n    }\n    /**\n     * Returns true if the first circle engulfs the second.\n     * @param c1\n     * @param c2\n     */\n    static engulfsCircle(c1, c2) {\n        if (c1.radius <= c2.radius) {\n            return false;\n        }\n        let d = flo_vector2d_1.squaredDistanceBetween(c1.center, c2.center);\n        let dr = c1.radius - c2.radius;\n        let δ = dr * dr;\n        return δ > d;\n    }\n    /**\n     * Returns a human-readable string description of the given circle.\n     * @param circle\n     */\n    static toString(circle) {\n        return 'c: ' + circle.center + ' r: ' + circle.radius;\n    }\n}\nexports.Circle = Circle;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/circle.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/contact-point.js":
/*!********************************************************!*\
  !*** ./node_modules/flo-mat/node/src/contact-point.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst point_on_shape_1 = __webpack_require__(/*! ./point-on-shape */ \"./node_modules/flo-mat/node/src/point-on-shape.js\");\nclass ContactPoint {\n    /**\n     * Representation of a point on a loop (or shape).\n     * @param pointOnShape\n     * @param vertex\n     */\n    constructor(pointOnShape, circle, order, order2) {\n        this.pointOnShape = pointOnShape;\n        this.circle = circle;\n        this.order = order;\n        this.order2 = order2;\n    }\n    static compare(a, b) {\n        let res = point_on_shape_1.PointOnShape.compare(a.pointOnShape, b.pointOnShape);\n        if (res === undefined) {\n            return undefined;\n        }\n        if (res !== 0) {\n            return res;\n        }\n        res = a.order - b.order;\n        if (res !== 0) {\n            return res;\n        }\n        return a.order2 - b.order2;\n    }\n}\nexports.ContactPoint = ContactPoint;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/contact-point.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/cp-node.js":
/*!**************************************************!*\
  !*** ./node_modules/flo-mat/node/src/cp-node.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst contact_point_1 = __webpack_require__(/*! ./contact-point */ \"./node_modules/flo-mat/node/src/contact-point.js\");\nconst cp_node_for_debugging_1 = __webpack_require__(/*! ./debug/cp-node-for-debugging */ \"./node_modules/flo-mat/node/src/debug/cp-node-for-debugging.js\");\nconst EDGES = ['prev', 'next', 'prevOnCircle', 'nextOnCircle'];\n/**\n * Representation of a ContactPoint node having various edges, two of which\n * ('prev' and 'next') enforce a cyclic ordering on the CpNodes.\n */\nclass CpNode {\n    /**\n     * @param cp The actual item stored at a node\n     * @param prev The previous contact point on the boundary\n     * @param next The next contact point on the boundary\n     * @param prevOnCircle The previous contact point on the inscribed circle\n     * @param prev The next contact point on the inscribed circle\n     * @param matCurve The actual medial axis curve from this ContactPoint's\n     * circle to the next ContactPoint's circle. It is a bezier curve of order\n     * 1 to 3.\n     * @param isHoleClosing\n     */\n    constructor(cp, isHoleClosing, isIntersection, prev = undefined, next = undefined, prevOnCircle = undefined, nextOnCircle = undefined, matCurve = undefined) {\n        this.cp = cp;\n        this.isHoleClosing = isHoleClosing;\n        this.isIntersection = isIntersection;\n        this.prev = prev;\n        this.next = next;\n        this.prevOnCircle = prevOnCircle;\n        this.nextOnCircle = nextOnCircle;\n        this.matCurve = matCurve;\n    }\n    clone() {\n        // Don't change this function to be recursive, the call stack may \n        // overflow if there are too many CpNodes.\n        let nodeMap = new Map();\n        let cpNode = this;\n        let newCpNode = new CpNode(cpNode.cp, cpNode.isHoleClosing, cpNode.isIntersection);\n        newCpNode.matCurve = cpNode.matCurve;\n        nodeMap.set(cpNode, newCpNode);\n        let cpStack = [{ cpNode, newCpNode }];\n        while (cpStack.length) {\n            let { cpNode, newCpNode } = cpStack.pop();\n            for (let edge of EDGES) {\n                let node = cpNode[edge];\n                let newNode = nodeMap.get(node);\n                if (!newNode) {\n                    newNode = new CpNode(node.cp, node.isHoleClosing, node.isIntersection);\n                    newNode.matCurve = node.matCurve;\n                    nodeMap.set(node, newNode);\n                    cpStack.push({ cpNode: node, newCpNode: newNode });\n                }\n                newCpNode[edge] = newNode;\n            }\n        }\n        return newCpNode;\n    }\n    /**\n     * Insert an item into the linked loop after the specified point and returns\n     * the freshly inserted item.\n     * @param cp - Item to insert\n     * @param prev_ - Inserts the new item right after this item if the loop is\n     * not empty, else insert the new item as the only item in the loop.\n     */\n    static insert(isHoleClosing, isIntersection, cpTree, cp, prev_) {\n        let cpNode = new CpNode(cp, isHoleClosing, isIntersection);\n        if (typeof _debug_ !== 'undefined') {\n            _debug_.generated.elems.cpNode.push(new cp_node_for_debugging_1.CpNodeForDebugging(_debug_.generated, cpNode));\n        }\n        let prev;\n        let next;\n        if (!prev_) {\n            prev = cpNode;\n            next = cpNode;\n        }\n        else {\n            prev = prev_;\n            next = prev.next;\n        }\n        next.prev = cpNode;\n        prev.next = cpNode;\n        cpNode.prev = prev;\n        cpNode.next = next;\n        cpTree.insert(cpNode);\n        return cpNode;\n    }\n    remove(cpTree, cpNode) {\n        let prev = cpNode.prev;\n        let next = cpNode.next;\n        prev.next = next;\n        next.prev = prev;\n        cpTree.remove(cpNode, false);\n    }\n    /**\n     * Return this and the the other CpNodes around the vertex circle in order.\n     */\n    getNodes() {\n        let startCp = this;\n        let cp = startCp;\n        let cps = [];\n        do {\n            cps.push(cp);\n            cp = cp.nextOnCircle;\n        } while (cp !== startCp);\n        return cps;\n    }\n    isTerminating() {\n        let cp = this;\n        return cp === cp.next.prevOnCircle;\n    }\n    isSharp() {\n        let cpNode = this;\n        return cpNode.cp.circle.radius === 0;\n    }\n    /**\n     * Returns true if this ListNode is a one-prong (including\n     * sharp corners).\n     */\n    isOneProng() {\n        let cp = this;\n        if (cp.isSharp()) {\n            return true;\n        }\n        if (cp.isThreeProng()) {\n            return false;\n        }\n        let cp2 = cp.nextOnCircle;\n        let p1 = cp.cp.pointOnShape.p;\n        let p2 = cp2.cp.pointOnShape.p;\n        return (p1[0] === p2[0] && p1[1] === p2[1]);\n    }\n    isThreeProng() {\n        let cp = this;\n        return cp.getNodes().length === 3;\n    }\n    /**\n     * Advances the node by the given number of steps. This is slow ( O(n) );\n     * use mostly for debugging.\n     * @param node - Node to start counting from\n     * @param n - Number of steps to advance\n     */\n    static advanceNSteps(node, n) {\n        for (let i = 0; i < n; i++) {\n            node = node.next;\n        }\n        return node;\n    }\n}\nCpNode.comparator = (a, b) => contact_point_1.ContactPoint.compare(a.cp, b.cp);\nexports.CpNode = CpNode;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/cp-node.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/curve.js":
/*!************************************************!*\
  !*** ./node_modules/flo-mat/node/src/curve.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\nlet memoize = flo_memoize_1.default.m1;\nclass Curve {\n    /**\n     * Representation of a curve in a linked loop (of bezier curves).\n     * @param loop The linked loop this node belongs to.\n     * @param ps The bezier points.\n     * @param prev The previous curve.\n     * @param next The next curve.\n     * @param idx The curve's ordered index in the loop.\n     */\n    constructor(loop, ps, prev, next, idx) {\n        this.loop = loop;\n        this.ps = ps;\n        this.prev = prev;\n        this.next = next;\n        this.idx = idx;\n    }\n    static getCornerAtEnd(curve) {\n        return getCornerAtEnd(curve);\n    }\n}\nexports.Curve = Curve;\n// Angle in degrees\nconst DEGREES = {\n    //'0'    : 0.0000,\n    0.25: 0.0050,\n    1: 0.0167,\n    4: 0.0698,\n    16: 0.2756,\n};\nconst DEGREE_LIMIT = DEGREES[1];\n/**\n * Gets the cross of the unit tangents of the vector at the end of this\n * curve and the start of the next curve.\n */\nlet getCornerAtEnd = memoize(function (curve) {\n    let tans = [\n        flo_bezier3_1.tangent(curve.ps, 1),\n        flo_bezier3_1.tangent(curve.next.ps, 0)\n    ];\n    let crossTangents = flo_vector2d_1.cross(tans[0], tans[1]);\n    return {\n        tans,\n        crossTangents,\n        isSharp: crossTangents < 0,\n        isDull: crossTangents > 0,\n        isQuiteSharp: crossTangents < -DEGREE_LIMIT,\n        isQuiteDull: crossTangents > +DEGREE_LIMIT\n    };\n});\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/curve.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/debug/cp-node-for-debugging.js":
/*!**********************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/debug/cp-node-for-debugging.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Class used for debugging only.\n */\nclass CpNodeForDebugging {\n    constructor(generated, cpNode) {\n        this.generated = generated;\n        this.cpNode = cpNode;\n    }\n}\nexports.CpNodeForDebugging = CpNodeForDebugging;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/debug/cp-node-for-debugging.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/debug/debug.js":
/*!******************************************************!*\
  !*** ./node_modules/flo-mat/node/src/debug/debug.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Vector = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\nconst Bezier3 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\nconst Svg = __webpack_require__(/*! ../svg/svg */ \"./node_modules/flo-mat/node/src/svg/svg.js\");\nconst general_1 = __webpack_require__(/*! ./functions/general */ \"./node_modules/flo-mat/node/src/debug/functions/general.js\");\nconst two_prong_1 = __webpack_require__(/*! ./functions/two-prong */ \"./node_modules/flo-mat/node/src/debug/functions/two-prong.js\");\nconst three_prong_1 = __webpack_require__(/*! ./functions/three-prong */ \"./node_modules/flo-mat/node/src/debug/functions/three-prong.js\");\nconst draw_elem_1 = __webpack_require__(/*! ./functions/draw-elem/draw-elem */ \"./node_modules/flo-mat/node/src/debug/functions/draw-elem/draw-elem.js\");\nclass Generated {\n    constructor(path, g) {\n        this.path = path;\n        this.g = g;\n        this.elems = {\n            twoProng_regular: [],\n            twoProng_failed: [],\n            twoProng_notAdded: [],\n            twoProng_deleted: [],\n            twoProng_holeClosing: [],\n            looseBoundingBox: [],\n            tightBoundingBox: [],\n            oneProng: [],\n            oneProngAtDullCorner: [],\n            sharpCorner: [],\n            dullCorner: [],\n            minY: [],\n            threeProng: [],\n            boundingHull: [],\n            mat: [],\n            sat: [],\n            cpNode: [],\n            loop: [],\n            loops: [],\n            maxVertex: [],\n            leaves: [],\n            culls: [],\n            intersection: [],\n        };\n        this.timing = {\n            simplify: [0, 0],\n            holeClosers: [0, 0],\n            oneAnd2Prongs: [0, 0],\n            threeProngs: [0, 0],\n            mats: [0, 0],\n            sats: [0, 0]\n        };\n    }\n}\nexports.Generated = Generated;\nclass MatDebug {\n    /**\n     * @param fs - some useful functions.\n     */\n    constructor(draw) {\n        /* The current path for which MATs are being found */\n        this.generated = undefined;\n        /* Generated by debug object for later inspection */\n        this.generatedAll = new Map();\n        // These are included only for quick debugging from console\n        this.Bezier3 = Bezier3;\n        this.Vector2d = Vector;\n        this.Svg = Svg;\n        this.directives = {\n            stopAfterHoleClosers: false,\n            stopAfterHoleClosersNum: undefined,\n            stopAfterTwoProngs: false,\n            stopAfterTwoProngsNum: undefined,\n            stopAfterThreeProngs: false,\n        };\n        /**\n         * These functions are meant to be used in the console, e.g. in the\n         * console try typing d.fs.twoProng.traceConvergence(0);\n         */\n        this.fs = Object.assign({ draw }, general_1.generalDebugFunctions, { twoProng: two_prong_1.twoProngDebugFunctions, threeProng: three_prong_1.threeProngDebugFunctions, drawElem: draw_elem_1.drawElemFunctions });\n    }\n    createNewGenerated(loops, path, g) {\n        this.generated = new Generated(path, g);\n        this.generatedAll.set(loops, this.generated);\n    }\n}\nexports.MatDebug = MatDebug;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/debug/debug.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/debug/functions/draw-elem/bounding-hull.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/debug/functions/draw-elem/bounding-hull.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction boundingHull(g, hull, style = 'thin5 black nofill') {\n    let $polygon = _debug_.fs.draw.polygon(g, hull, style);\n    return $polygon;\n}\nexports.boundingHull = boundingHull;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/debug/functions/draw-elem/bounding-hull.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/debug/functions/draw-elem/culls.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/debug/functions/draw-elem/culls.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction culls(g, culls) {\n    let $elems = [];\n    for (let circle of culls) {\n        let p = circle.center;\n        $elems.push(drawCircle(g, p, 0.4, 'cyan thin5 nofill'));\n    }\n    return $elems;\n}\nexports.culls = culls;\nfunction drawCircle(g, center, radiusPercent, classes) {\n    const XMLNS = 'http://www.w3.org/2000/svg';\n    let $circle = document.createElementNS(XMLNS, 'circle');\n    $circle.setAttributeNS(null, \"cx\", center[0].toString());\n    $circle.setAttributeNS(null, \"cy\", center[1].toString());\n    $circle.setAttributeNS(null, \"r\", radiusPercent.toString() + '%');\n    $circle.setAttributeNS(null, \"class\", classes);\n    g.appendChild($circle);\n    return $circle;\n}\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/debug/functions/draw-elem/culls.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/debug/functions/draw-elem/draw-circle-percent.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/debug/functions/draw-elem/draw-circle-percent.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction drawCirclePercent(g, center, radiusPercent, classes) {\n    const XMLNS = 'http://www.w3.org/2000/svg';\n    let $circle = document.createElementNS(XMLNS, 'circle');\n    $circle.setAttributeNS(null, \"cx\", center[0].toString());\n    $circle.setAttributeNS(null, \"cy\", center[1].toString());\n    $circle.setAttributeNS(null, \"r\", radiusPercent.toString() + '%');\n    $circle.setAttributeNS(null, \"class\", classes);\n    g.appendChild($circle);\n    return $circle;\n}\nexports.drawCirclePercent = drawCirclePercent;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/debug/functions/draw-elem/draw-circle-percent.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/debug/functions/draw-elem/draw-elem.js":
/*!******************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/debug/functions/draw-elem/draw-elem.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst one_prong_1 = __webpack_require__(/*! ./one-prong */ \"./node_modules/flo-mat/node/src/debug/functions/draw-elem/one-prong.js\");\nconst two_prong_1 = __webpack_require__(/*! ./two-prong */ \"./node_modules/flo-mat/node/src/debug/functions/draw-elem/two-prong.js\");\nconst three_prong_1 = __webpack_require__(/*! ./three-prong */ \"./node_modules/flo-mat/node/src/debug/functions/draw-elem/three-prong.js\");\nconst vertex_1 = __webpack_require__(/*! ./vertex */ \"./node_modules/flo-mat/node/src/debug/functions/draw-elem/vertex.js\");\nconst min_y_1 = __webpack_require__(/*! ./min-y */ \"./node_modules/flo-mat/node/src/debug/functions/draw-elem/min-y.js\");\nconst bounding_hull_1 = __webpack_require__(/*! ./bounding-hull */ \"./node_modules/flo-mat/node/src/debug/functions/draw-elem/bounding-hull.js\");\nconst loose_bounding_box_1 = __webpack_require__(/*! ./loose-bounding-box */ \"./node_modules/flo-mat/node/src/debug/functions/draw-elem/loose-bounding-box.js\");\nconst tight_bounding_box_1 = __webpack_require__(/*! ./tight-bounding-box */ \"./node_modules/flo-mat/node/src/debug/functions/draw-elem/tight-bounding-box.js\");\nconst sharp_corner_1 = __webpack_require__(/*! ./sharp-corner */ \"./node_modules/flo-mat/node/src/debug/functions/draw-elem/sharp-corner.js\");\nconst dull_corner_1 = __webpack_require__(/*! ./dull-corner */ \"./node_modules/flo-mat/node/src/debug/functions/draw-elem/dull-corner.js\");\nconst mat_1 = __webpack_require__(/*! ./mat */ \"./node_modules/flo-mat/node/src/debug/functions/draw-elem/mat.js\");\nconst loop_1 = __webpack_require__(/*! ./loop */ \"./node_modules/flo-mat/node/src/debug/functions/draw-elem/loop.js\");\nconst loops_1 = __webpack_require__(/*! ./loops */ \"./node_modules/flo-mat/node/src/debug/functions/draw-elem/loops.js\");\nconst max_vertex_1 = __webpack_require__(/*! ./max-vertex */ \"./node_modules/flo-mat/node/src/debug/functions/draw-elem/max-vertex.js\");\nconst leaves_1 = __webpack_require__(/*! ./leaves */ \"./node_modules/flo-mat/node/src/debug/functions/draw-elem/leaves.js\");\nconst culls_1 = __webpack_require__(/*! ./culls */ \"./node_modules/flo-mat/node/src/debug/functions/draw-elem/culls.js\");\nconst intersection_1 = __webpack_require__(/*! ./intersection */ \"./node_modules/flo-mat/node/src/debug/functions/draw-elem/intersection.js\");\nconst one_prong_at_dull_corner_1 = __webpack_require__(/*! ./one-prong-at-dull-corner */ \"./node_modules/flo-mat/node/src/debug/functions/draw-elem/one-prong-at-dull-corner.js\");\nlet drawElemFunctions = {\n    oneProng: one_prong_1.oneProng,\n    oneProngAtDullCorner: one_prong_at_dull_corner_1.oneProngAtDullCorner,\n    twoProng_regular: two_prong_1.twoProng,\n    twoProng_failed: two_prong_1.twoProng,\n    twoProng_notAdded: two_prong_1.twoProng,\n    twoProng_deleted: two_prong_1.twoProng,\n    twoProng_holeClosing: two_prong_1.twoProng,\n    threeProng: three_prong_1.threeProng,\n    minY: min_y_1.minY,\n    boundingHull: bounding_hull_1.boundingHull,\n    looseBoundingBox: loose_bounding_box_1.looseBoundingBox,\n    tightBoundingBox: tight_bounding_box_1.tightBoundingBox,\n    sharpCorner: sharp_corner_1.sharpCorner,\n    dullCorner: dull_corner_1.dullCorner,\n    vertex: vertex_1.vertex,\n    mat: mat_1.mat('mat', true),\n    sat: mat_1.mat('sat', true),\n    loop: loop_1.loop,\n    loops: loops_1.loops,\n    maxVertex: max_vertex_1.maxVertex,\n    leaves: leaves_1.leaves,\n    culls: culls_1.culls,\n    intersection: intersection_1.intersection\n};\nexports.drawElemFunctions = drawElemFunctions;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/debug/functions/draw-elem/draw-elem.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/debug/functions/draw-elem/dull-corner.js":
/*!********************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/debug/functions/draw-elem/dull-corner.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction dullCorner(g, pos) {\n    const scaleFactor = 0.1;\n    let $pos = _debug_.fs.draw.dot(g, pos.p, 0.5 * scaleFactor, 'orange');\n    return $pos;\n}\nexports.dullCorner = dullCorner;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/debug/functions/draw-elem/dull-corner.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/debug/functions/draw-elem/intersection.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/debug/functions/draw-elem/intersection.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst draw_circle_percent_1 = __webpack_require__(/*! ./draw-circle-percent */ \"./node_modules/flo-mat/node/src/debug/functions/draw-elem/draw-circle-percent.js\");\nfunction intersection(g, x) {\n    return [draw_circle_percent_1.drawCirclePercent(g, x.pos.p, 0.7, 'purple thin2 nofill')];\n}\nexports.intersection = intersection;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/debug/functions/draw-elem/intersection.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/debug/functions/draw-elem/leaves.js":
/*!***************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/debug/functions/draw-elem/leaves.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst draw_circle_percent_1 = __webpack_require__(/*! ./draw-circle-percent */ \"./node_modules/flo-mat/node/src/debug/functions/draw-elem/draw-circle-percent.js\");\nfunction leaves(g, leaves) {\n    let $elems = [];\n    for (let cpNode of leaves) {\n        let cp = cpNode.cp;\n        let p = cp.circle.center;\n        $elems.push(draw_circle_percent_1.drawCirclePercent(g, p, 0.5, 'pinker thin5 nofill'));\n    }\n    return $elems;\n}\nexports.leaves = leaves;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/debug/functions/draw-elem/leaves.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/debug/functions/draw-elem/loop.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/debug/functions/draw-elem/loop.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// TODO - finish\nfunction loop(g, loop) {\n    /*\n    for (let curve of loop.curves) {\n        _debug_.fs.draw.bezier(g, curve.ps, undefined, 1000);\n    }\n    */\n    return [];\n}\nexports.loop = loop;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/debug/functions/draw-elem/loop.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/debug/functions/draw-elem/loops.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/debug/functions/draw-elem/loops.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// TODO - finish\nfunction loops(g, loops) {\n    return [];\n}\nexports.loops = loops;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/debug/functions/draw-elem/loops.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/debug/functions/draw-elem/loose-bounding-box.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/debug/functions/draw-elem/loose-bounding-box.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction looseBoundingBox(g, box) {\n    let $box = _debug_.fs.draw.rect(g, box, 'thin5 brown nofill');\n    return $box;\n}\nexports.looseBoundingBox = looseBoundingBox;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/debug/functions/draw-elem/loose-bounding-box.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/debug/functions/draw-elem/mat.js":
/*!************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/debug/functions/draw-elem/mat.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst traverse_edges_1 = __webpack_require__(/*! ../../../mat/traverse-edges */ \"./node_modules/flo-mat/node/src/mat/traverse-edges.js\");\nfunction mat(type, smooth) {\n    let classes = type === 'mat'\n        ? 'thin5 purple nofill'\n        : 'thin10 red nofill';\n    return f;\n    function f(g, mat) {\n        let cpNode = mat.cpNode;\n        if (!cpNode) {\n            return undefined;\n        }\n        let draw = _debug_.fs.draw;\n        let $svgs = [];\n        //const DRAW_CLASS_LINE = 'thin20 blue1 nofill';\n        //const DRAW_CLASS_QUAD = 'thin20 blue2 nofill';\n        //const DRAW_CLASS_CUBE = 'thin20 blue3 nofill';\n        traverse_edges_1.traverseEdges(cpNode, function (cpNode) {\n            if (cpNode.isTerminating()) {\n                return;\n            }\n            if (!smooth) {\n                let p1 = cpNode.cp.circle.center;\n                let p2 = cpNode.next.cp.circle.center;\n                $svgs.push(...draw.line(g, [p1, p2], classes));\n                return;\n            }\n            let bezier = cpNode.matCurve;\n            if (!bezier) {\n                return;\n            }\n            let fs = [, , draw.line, draw.quadBezier, draw.bezier];\n            $svgs.push(...fs[bezier.length](g, bezier, classes));\n        });\n        return $svgs;\n    }\n}\nexports.mat = mat;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/debug/functions/draw-elem/mat.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/debug/functions/draw-elem/max-vertex.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/debug/functions/draw-elem/max-vertex.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction maxVertex(g, cpNode) {\n    let draw = _debug_.fs.draw;\n    let circle = cpNode.cp.circle;\n    let $elems = draw.circle(g, circle, 'brown thin10 nofill');\n    return $elems;\n}\nexports.maxVertex = maxVertex;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/debug/functions/draw-elem/max-vertex.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/debug/functions/draw-elem/min-y.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/debug/functions/draw-elem/min-y.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\nfunction minY(g, pos) {\n    let p = flo_bezier3_1.evaluate(pos.curve.ps, pos.t);\n    let $elems = _debug_.fs.draw.crossHair(g, p, 'red thin10 nofill');\n    return $elems;\n}\nexports.minY = minY;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/debug/functions/draw-elem/min-y.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/debug/functions/draw-elem/one-prong-at-dull-corner.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/debug/functions/draw-elem/one-prong-at-dull-corner.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst point_on_shape_1 = __webpack_require__(/*! ../../../point-on-shape */ \"./node_modules/flo-mat/node/src/point-on-shape.js\");\nfunction oneProngAtDullCorner(g, pos) {\n    let oCircle = point_on_shape_1.PointOnShape.getOsculatingCircle(Number.POSITIVE_INFINITY, pos);\n    let $center = _debug_.fs.draw.dot(g, pos.p, 0.1, 'orange');\n    let $circle = _debug_.fs.draw.dot(g, oCircle.center, 0.25, 'orange');\n    let $pos = _debug_.fs.draw.circle(g, oCircle, 'orange thin10 nofill');\n    return [...$center, ...$circle, ...$pos];\n}\nexports.oneProngAtDullCorner = oneProngAtDullCorner;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/debug/functions/draw-elem/one-prong-at-dull-corner.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/debug/functions/draw-elem/one-prong.js":
/*!******************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/debug/functions/draw-elem/one-prong.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst point_on_shape_1 = __webpack_require__(/*! ../../../point-on-shape */ \"./node_modules/flo-mat/node/src/point-on-shape.js\");\nconst circle_1 = __webpack_require__(/*! ../../../circle */ \"./node_modules/flo-mat/node/src/circle.js\");\nconst scaleFactor = 0.5;\nfunction oneProng(g, pos) {\n    let draw = _debug_.fs.draw;\n    let circle = circle_1.Circle.scale(point_on_shape_1.PointOnShape.getOsculatingCircle(Number.POSITIVE_INFINITY, pos), 1);\n    let $center = draw.dot(g, pos.p, 0.1 * scaleFactor, 'gray');\n    let $circle = draw.dot(g, circle.center, 0.25 * scaleFactor, 'gray');\n    let $pos = draw.circle(g, circle, 'gray thin10 nofill');\n    return [...$center, ...$circle, ...$pos];\n}\nexports.oneProng = oneProng;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/debug/functions/draw-elem/one-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/debug/functions/draw-elem/sharp-corner.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/debug/functions/draw-elem/sharp-corner.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction sharpCorner(g, pos) {\n    const scaleFactor = 0.1;\n    let $pos = _debug_.fs.draw.dot(g, pos.p, 0.6 * scaleFactor, 'green');\n    return $pos;\n}\nexports.sharpCorner = sharpCorner;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/debug/functions/draw-elem/sharp-corner.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/debug/functions/draw-elem/three-prong.js":
/*!********************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/debug/functions/draw-elem/three-prong.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst circle_1 = __webpack_require__(/*! ../../../circle */ \"./node_modules/flo-mat/node/src/circle.js\");\nconst scaleFactor = 0.3;\nfunction threeProng(g, threeProng) {\n    let draw = _debug_.fs.draw;\n    let circle = circle_1.Circle.scale(threeProng.circle, 1);\n    let poss = threeProng.poss;\n    let $cp1 = draw.dot(g, poss[0].p, 0.1 * 1 * scaleFactor, 'blue');\n    let $cp2 = draw.dot(g, poss[1].p, 0.1 * 2 * scaleFactor, 'blue');\n    let $cp3 = draw.dot(g, poss[2].p, 0.1 * 3 * scaleFactor, 'blue');\n    let $center = draw.dot(g, circle.center, 0.3 * scaleFactor, 'blue');\n    let $circle = draw.circle(g, circle, 'blue thin2 nofill');\n    return [...$center, ...$cp1, ...$cp2, ...$cp3, ...$circle];\n}\nexports.threeProng = threeProng;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/debug/functions/draw-elem/three-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/debug/functions/draw-elem/tight-bounding-box.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/debug/functions/draw-elem/tight-bounding-box.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction tightBoundingBox(g, box) {\n    let $box = _debug_.fs.draw.polygon(g, box, 'thin5 black nofill');\n    return $box;\n}\nexports.tightBoundingBox = tightBoundingBox;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/debug/functions/draw-elem/tight-bounding-box.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/debug/functions/draw-elem/two-prong.js":
/*!******************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/debug/functions/draw-elem/two-prong.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst get_two_prong_type_1 = __webpack_require__(/*! ../../../mat/get-two-prong-type */ \"./node_modules/flo-mat/node/src/mat/get-two-prong-type.js\");\nfunction twoProng(g, twoProng) {\n    //let scaleFactor = width/200;\t\t\n    let scaleFactor = 0.3;\n    let $failedDot = [];\n    let $center = [];\n    let $circle = [];\n    let $cp1 = [];\n    let $cp2 = [];\n    let color;\n    let thin;\n    let draw = _debug_.fs.draw;\n    switch (get_two_prong_type_1.getTwoProngType(twoProng)) {\n        case 'twoProng_regular': {\n            color = 'red ';\n            thin = '2';\n            break;\n        }\n        case 'twoProng_failed': {\n            $failedDot = draw.dot(g, twoProng.pos.p, 1 * scaleFactor, 'black');\n            return;\n        }\n        case 'twoProng_notAdded': {\n            color = 'brown ';\n            thin = '10';\n            break;\n        }\n        case 'twoProng_deleted': {\n            color = 'gray ';\n            thin = '2';\n            break;\n        }\n        case 'twoProng_holeClosing': {\n            color = 'cyan ';\n            thin = '10';\n            break;\n        }\n    }\n    if (twoProng.failed) {\n        $failedDot = draw.dot(g, twoProng.pos.p, 1 * scaleFactor, 'black');\n    }\n    else if (!twoProng.failed) {\n        $center = draw.dot(g, twoProng.circle.center, 0.05 * scaleFactor, 'yellow');\n        $circle = draw.circle(g, twoProng.circle, color + 'thin' + thin + ' nofill');\n        $cp1 = draw.dot(g, twoProng.pos.p, 0.035 * scaleFactor, color);\n        $cp2 = draw.dot(g, twoProng.z, 0.07 * scaleFactor, color);\n    }\n    return [...$failedDot, ...$center, ...$circle, ...$cp1, ...$cp2];\n}\nexports.twoProng = twoProng;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/debug/functions/draw-elem/two-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/debug/functions/draw-elem/vertex.js":
/*!***************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/debug/functions/draw-elem/vertex.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction vertex(g, cpNode, visible = true, displayDelay) {\n    let visibleClass = visible ? '' : ' invisible';\n    let circle = cpNode.cp.circle;\n    let draw = _debug_.fs.draw;\n    const THIN = 'thin20';\n    let cps = cpNode.getNodes();\n    console.log(cps);\n    let $svgs = [];\n    let $circle = draw.circle(g, circle, 'red ' + THIN + ' nofill ' + visibleClass, displayDelay);\n    let $crossHair = draw.crossHair(g, circle.center, 'red ' + THIN + ' nofill ' + visibleClass, 3, displayDelay);\n    $svgs = [...$circle, ...$crossHair];\n    for (let i = 0; i < cps.length; i++) {\n        let cp = cps[i];\n        let edgeCircle = cp.next.cp.circle;\n        let $circle = draw.circle(g, edgeCircle, 'pink ' + THIN + ' nofill ' + visibleClass, displayDelay);\n        let $crossHair = draw.crossHair(g, edgeCircle.center, 'pink ' + THIN + ' nofill ' + visibleClass, 3, displayDelay);\n        $svgs.push(...$circle, ...$crossHair);\n        let p1 = circle.center;\n        let p2 = edgeCircle.center;\n        let thin = i === 0 ? 'thin10' : (i === 1 ? 'thin20' : 'thin35');\n        let $line = draw.line(g, [p1, p2], 'yellow ' + thin + ' nofill ' + visibleClass, displayDelay);\n        $svgs.push(...$line);\n    }\n    return $svgs;\n}\nexports.vertex = vertex;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/debug/functions/draw-elem/vertex.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/debug/functions/general.js":
/*!******************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/debug/functions/general.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst point_on_shape_1 = __webpack_require__(/*! ../../point-on-shape */ \"./node_modules/flo-mat/node/src/point-on-shape.js\");\nlet i = 0;\n/** Name the given object - for debugging purposes only */\nfunction nameObj(o, pre = '') {\n    o.name = '' + pre + i++;\n}\n/**\n * Transforms a boundary piece (δ) into a human readable string.\n * @param cpNodes A boundary piece given by two CpNodes.\n */\nfunction δToString(cpNodes) {\n    return cpNodes.map(cpNode => point_on_shape_1.PointOnShape.toHumanString(cpNode.cp.pointOnShape));\n}\n/**\n * Transforms an array of boundary pieces (δs) into a human readable string.\n * @param cpNodes An array of boundary pieces.\n */\nfunction δsToString(cpNodes) {\n    return cpNodes.map(δToString);\n}\n/**\n * Convert the given points into a human readable string.\n * @param ps\n */\nfunction pointsToStr(ps, decimalPlaces = 3) {\n    return ps.map(p => pointToStr(p, decimalPlaces));\n}\n/**\n * Converts the given point into a human readable string.\n * @param p - The point\n * @param decimalPlaces - number of decimal places\n */\nfunction pointToStr(p, decimalPlaces = 3) {\n    return p[0].toFixed(decimalPlaces) + ', ' + p[1].toFixed(decimalPlaces);\n}\nlet generalDebugFunctions = {\n    δToString,\n    δsToString,\n    pointToStr,\n    pointsToStr,\n    nameObj,\n};\nexports.generalDebugFunctions = generalDebugFunctions;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/debug/functions/general.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/debug/functions/three-prong.js":
/*!**********************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/debug/functions/three-prong.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\nconst circle_1 = __webpack_require__(/*! ../../circle */ \"./node_modules/flo-mat/node/src/circle.js\");\n/**\n * Draws 3 lines from the given 3-prong center to its 3 contact points.\n * @param n - The 3-prong's zero-based index.\n */\nfunction drawSpokes(n) {\n    let threeProng = _debug_.generated.elems.threeProng[n];\n    let g = threeProng.generated.g;\n    let cc = threeProng.circle.center;\n    let poss = threeProng.poss;\n    _debug_.fs.draw.line(g, [poss[0].p, cc], 'thin5 red');\n    _debug_.fs.draw.line(g, [poss[1].p, cc], 'thin5 red');\n    _debug_.fs.draw.line(g, [poss[2].p, cc], 'thin5 red');\n}\n/**\n * Shows the circle for each boundary iteration.\n * @param n_ - The 3-prong's zero-based index. If ommitted, all will be shown.\n * @param idx - The specific boundary iteration index to view. If ommitted, all\n * will be shown.\n */\nfunction traceConvergence(n_, idx) {\n    let sIndx;\n    let eIndx;\n    if (n_ === undefined) {\n        sIndx = 0;\n        eIndx = _debug_.generated.elems.threeProng.length;\n    }\n    else {\n        sIndx = n_;\n        eIndx = n_ + 1;\n    }\n    for (let n = sIndx; n < eIndx; n++) {\n        let forDebugging = _debug_.generated.elems.threeProng[n];\n        let g = forDebugging.generated.g;\n        console.log(forDebugging);\n        let candidateThreeProngs = forDebugging.candidateThreeProngs;\n        //-----------------------------\n        //---- Get start and end index\n        //-----------------------------\n        let startIndx;\n        let endIndx;\n        if (n_ === undefined || idx === -1) {\n            startIndx = forDebugging.bestIndx;\n            endIndx = forDebugging.bestIndx + 1;\n        }\n        else {\n            if (idx === undefined) {\n                startIndx = 0;\n                endIndx = candidateThreeProngs.length;\n            }\n            else {\n                startIndx = idx;\n                endIndx = idx + 1;\n            }\n        }\n        //---------------------------------\n        //---- Draw candidate three-prongs\n        //---------------------------------\n        for (let i = startIndx; i < endIndx; i++) {\n            let circle = candidateThreeProngs[i].circle;\n            if (forDebugging.bestIndx === i) {\n                _debug_.fs.draw.dot(g, circle.center, 0.2, 'green');\n                _debug_.fs.draw.circle(g, circle, 'black thin10 nofill');\n            }\n            else {\n                _debug_.fs.draw.dot(g, circle.center, 0.2, 'cyan');\n                _debug_.fs.draw.circle(g, circle, 'cyan thin5 nofill');\n            }\n        }\n    }\n}\n/**\n * Shows the actual boundary for each iteration.\n * @param n The 3-prong's zero-based index.\n * @param idx The specific boundary iteration index to view. If ommitted will\n * show all.\n */\nfunction showBoundary(n, idx) {\n    let debugInfo = _debug_.generated.elems.threeProng[n];\n    let g = debugInfo.generated.g;\n    let candidateThreeProngs = debugInfo.candidateThreeProngs;\n    let startIndx = idx === undefined ? 0 : idx;\n    let endIndx = idx === undefined ? candidateThreeProngs.length : idx;\n    // Draw relevant δs\n    let cpss = debugInfo.cpss;\n    let j = 0;\n    // For each iteration of δ3s (indexed by j)\n    for (let idx = 1; idx < cpss.length - 1; idx++) {\n        if (!(j >= startIndx && j <= endIndx)) {\n            j++;\n            continue;\n        }\n        let δ3s = [\n            cpss[0],\n            cpss[idx],\n            cpss[cpss.length - 1]\n        ];\n        // For each of the 3 δs\n        for (let i = 0; i < 3; i++) {\n            let δ = δ3s[i];\n            let δS = δ[0]; // Delta Start\n            let δE = δ[1]; // Delta End\n            let posS = δS.cp.pointOnShape;\n            let posE = δE.cp.pointOnShape;\n            let pS = posS.p;\n            let pE = posE.p;\n            let r = 1 + (i * 0.5);\n            if (flo_vector2d_1.equal(pS, pE)) {\n                _debug_.fs.draw.crossHair(g, pS, 'red thin10 nofill', r);\n            }\n            else {\n                _debug_.fs.draw.crossHair(g, pS, 'green thin10 nofill', r);\n                _debug_.fs.draw.crossHair(g, pE, 'blue thin10 nofill', r);\n            }\n        }\n        j++;\n    }\n}\n/**\n * @param n The 3-prong's zero-based index.\n */\nfunction logδs(n) {\n    let threeProng = _debug_.generated.elems.threeProng[n];\n    console.log(threeProng.cpss);\n}\n/**\n *\n * @param p\n */\nfunction logNearest(p, inclSpokes = true, inclTrace = true, inclBoundaries = true) {\n    let closestPerLoops = [];\n    _debug_.generatedAll.forEach(function (generated) {\n        let threeProng = flo_vector2d_1.getObjClosestTo(p, generated.elems.threeProng, threeProng => threeProng.circle.center);\n        closestPerLoops.push(threeProng);\n    });\n    let threeProng = flo_vector2d_1.getObjClosestTo(p, closestPerLoops, threeProng => threeProng.circle.center);\n    let circle = threeProng.circle;\n    let g = threeProng.generated.g;\n    console.log(threeProng);\n    let circle2 = new circle_1.Circle(circle.center, circle.radius || 1);\n    let draw = _debug_.fs.draw;\n    draw.circle(g, circle2, 'green thin10 nofill', 1000);\n    // Boundaries\n    let boundaries = threeProng.boundaries;\n    let boundaryS = boundaries[0];\n    let boundaryE = boundaries[boundaries.length - 1];\n    draw.beziers(g, boundaryS, 'red thin5 nofill');\n    for (let i = 1; i < boundaries.length - 1; i++) {\n        let boundary = boundaries[i];\n        draw.beziers(g, boundary, 'green thin5 nofill');\n    }\n    draw.beziers(g, boundaryE, 'blue thin5 nofill');\n    // Trace\n    let traces = threeProng.traces;\n    for (let trace of traces) {\n        draw.polyline(g, trace, 'red thin5 nofill');\n    }\n}\nlet threeProngDebugFunctions = {\n    drawSpokes,\n    traceConvergence,\n    showBoundary,\n    logδs,\n    logNearest\n};\nexports.threeProngDebugFunctions = threeProngDebugFunctions;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/debug/functions/three-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/debug/functions/two-prong.js":
/*!********************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/debug/functions/two-prong.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst circle_1 = __webpack_require__(/*! ../../circle */ \"./node_modules/flo-mat/node/src/circle.js\");\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\n/**\n *\n */\nfunction logδ(n, type = 'twoProng_regular') {\n    let δ = _debug_.generated.elems[type][n].δ;\n    console.log(δ);\n}\n/**\n *\n */\nfunction log(n, type = 'twoProng_regular') {\n    let twoProng = _debug_.generated.elems[type][n];\n    console.log(twoProng);\n}\n/**\n *\n */\nfunction drawNormal(n, type = 'twoProng_regular') {\n    let twoProngs = _debug_.generated.elems[type];\n    // If not specified which, draw all\n    if (n === undefined) {\n        for (let i = 0; i < twoProngs.length; i++) {\n            drawNormal(i);\n        }\n    }\n    let twoProng = twoProngs[n];\n    let g = twoProng.generated.g;\n    if (!twoProng) {\n        return;\n    }\n    _debug_.fs.draw.line(g, [twoProng.pos.p, twoProng.circle.center], 'thin10 blue');\n}\n/**\n *\n */\nfunction logδBasic(n, type = 'twoProng_regular') {\n    let delta = _debug_.generated.elems[type][n].δ;\n    function f(x) {\n        let pos = x.cp.pointOnShape;\n        return {\n            bez: pos.curve.ps,\n            t: pos.t\n        };\n    }\n    console.log(f(delta[0]));\n    console.log(f(delta[1]));\n}\n/**\n *\n */\nfunction logNearest(p, type = 'twoProng_regular') {\n    let closestPerLoops = [];\n    _debug_.generatedAll.forEach(function (generated, loops) {\n        let twoProng = flo_vector2d_1.getObjClosestTo(p, generated.elems[type], twoProng => twoProng.circle.center);\n        closestPerLoops.push(twoProng);\n    });\n    let twoProng = flo_vector2d_1.getObjClosestTo(p, closestPerLoops, twoProng => twoProng.circle.center);\n    let g = twoProng.generated.g;\n    console.log(twoProng);\n    let circle_ = twoProng.circle;\n    let circle = new circle_1.Circle(circle_.center, circle_.radius || 1);\n    _debug_.fs.draw.circle(g, circle, 'green thin10 nofill', 1000);\n    let n;\n    for (let i = 0; i < _debug_.generated.elems[type].length; i++) {\n        let twoProng_ = _debug_.generated.elems[type][i];\n        if (twoProng_ === twoProng) {\n            n = i;\n            break;\n        }\n    }\n    if (n !== undefined) {\n        traceConvergence(n, true);\n    }\n}\n/**\n *\n * @param n - The 2-prong's zero-based index.\n * @param range\n * cascade of convergence)\n */\nfunction traceConvergence(n, finalOnly, range = undefined, type = 'twoProng_regular') {\n    if (n === undefined) {\n        return;\n    }\n    let twoProngInfo = _debug_.generated.elems[type][n];\n    let xs = twoProngInfo.xs;\n    let g = twoProngInfo.generated.g;\n    console.log(twoProngInfo);\n    console.log(twoProngInfo.xs.map(x => ({\n        x: x.x,\n        y: x.y,\n        z: x.z,\n        d: x.z ? flo_vector2d_1.squaredDistanceBetween(x.y.p, x.z.p) : 0,\n        t: x.t,\n    })));\n    for (let i = 0; i < xs.length; i++) {\n        if (range && (i < range[0] || i >= range[1])) {\n            continue;\n        }\n        if (finalOnly && i !== xs.length - 1) {\n            continue;\n        }\n        let x = twoProngInfo.xs[i];\n        let circle = new circle_1.Circle(x.x, flo_vector2d_1.distanceBetween(x.x, x.y.p));\n        _debug_.fs.draw.crossHair(g, x.x, 'red thin10 nofill');\n        _debug_.fs.draw.circle(g, circle, 'blue thin10 nofill');\n        if (x.z !== undefined) {\n            _debug_.fs.draw.crossHair(g, x.z.p, 'yellow thin10 nofill', 2);\n        }\n    }\n    twoProngDebugFunctions.drawNormal(n);\n}\nlet twoProngDebugFunctions = {\n    logδ,\n    log,\n    drawNormal,\n    logδBasic,\n    traceConvergence,\n    logNearest,\n};\nexports.twoProngDebugFunctions = twoProngDebugFunctions;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/debug/functions/two-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/debug/three-prong-for-debugging.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/debug/three-prong-for-debugging.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst point_on_shape_1 = __webpack_require__(/*! ../point-on-shape */ \"./node_modules/flo-mat/node/src/point-on-shape.js\");\n/**\n * Class used in debugging. A three-prong is a maximally inscribed circle that\n * touches the shape boundary (tangentially) at 3 points.\n */\nclass ThreeProngForDebugging {\n    /**\n     * @param circle The best fit circle found for the 3-prong.\n     * @param poss The best fit 3 points found for the 3-prong.\n     * @param cp3ss The 3 boundary pieces on which the three prong points were\n     * found.\n     * @param cpss The boundary pieces that were used to search the three prong\n     * on.\n     * @param bestIndx\n     * @param candidateThreeProngs An array of 3-prongs, each of which may be a\n     * best fit 3-prong.\n     */\n    constructor() { }\n    get cpsSimple() {\n        return this.cpss.map(δ => [point_on_shape_1.PointOnShape.toHumanString(δ[0].cp.pointOnShape),\n            point_on_shape_1.PointOnShape.toHumanString(δ[1].cp.pointOnShape)]);\n    }\n}\nexports.ThreeProngForDebugging = ThreeProngForDebugging;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/debug/three-prong-for-debugging.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/debug/two-prong-for-debugging.js":
/*!************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/debug/two-prong-for-debugging.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass TwoProngForDebugging {\n    constructor(generated, bezierPieces, pos, δ, z, circle, xs, failed, holeClosing, notAdded, deleted) {\n        this.generated = generated;\n        this.bezierPieces = bezierPieces;\n        this.pos = pos;\n        this.δ = δ;\n        this.z = z;\n        this.circle = circle;\n        this.xs = xs;\n        this.failed = failed;\n        this.holeClosing = holeClosing;\n        this.notAdded = notAdded;\n        this.deleted = deleted;\n    }\n}\nexports.TwoProngForDebugging = TwoProngForDebugging;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/debug/two-prong-for-debugging.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/loop.js":
/*!***********************************************!*\
  !*** ./node_modules/flo-mat/node/src/loop.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\nconst curve_1 = __webpack_require__(/*! ./curve */ \"./node_modules/flo-mat/node/src/curve.js\");\n/**\n * Represents a two-way linked loop of Curves.\n */\nclass Loop {\n    /**\n     * @param items - A pre-ordered array of items to add initially\n     */\n    constructor(items = []) {\n        this.items = items;\n        this.curves = [];\n        let loop = this;\n        if (items.length === 0) {\n            return undefined;\n        }\n        let head;\n        let prev = null;\n        let node;\n        for (let i = 0; i < items.length; i++) {\n            node = new curve_1.Curve(loop, items[i], prev, null, i);\n            loop.curves.push(node);\n            if (prev) {\n                prev.next = node;\n            }\n            prev = node;\n            if (i === 0) {\n                head = node;\n            }\n        }\n        // Close loop\n        head.prev = node;\n        node.next = head;\n        this.head = head;\n    }\n    toBeziers() {\n        let beziers = [];\n        for (let curve of this.curves) {\n            beziers.push(curve.ps);\n        }\n        return beziers;\n    }\n    static perturb(loop, x) {\n        if (!x) {\n            return loop;\n        }\n        let seed = 2311; // Just some value\n        let newItems = [];\n        for (let i = 0; i < loop.items.length; i++) {\n            // This gets us a predictable random number between 0 and 1;\n            let rand1 = flo_poly_1.default.random.flatCoefficients(6, -1, 1, seed);\n            let rs = rand1.p;\n            seed = rand1.seed; // Get next seed.\n            let vs = rs.map(r => r * x);\n            console.log(vs);\n            let ps = loop.items[i];\n            let [[x0, y0], [x1, y1], [x2, y2]] = ps;\n            let newPs = [\n                [x0 + vs[0], y0 + vs[1]],\n                [x1 + vs[2], y1 + vs[3]],\n                [x2 + vs[4], y2 + vs[5]],\n                [0, 0]\n            ];\n            if (i !== 0) {\n                let prev = newItems[newItems.length - 1];\n                prev[3][0] = newPs[0][0];\n                prev[3][1] = newPs[0][1];\n            }\n            newItems.push(newPs);\n        }\n        let last = newItems[newItems.length - 1];\n        last[3][0] = newItems[0][0][0];\n        last[3][1] = newItems[0][0][1];\n        return new Loop(newItems);\n    }\n}\nexports.Loop = Loop;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/loop.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat.js":
/*!**********************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n;\n/**\n * Represents a complete Medial Axis Transform (MAT).\n */\nclass Mat {\n    /**\n     * @param cpNode\n     * @param cpTrees\n     */\n    constructor(cpNode, cpTrees) {\n        this.cpNode = cpNode;\n        this.cpTrees = cpTrees;\n    }\n}\nexports.Mat = Mat;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/add-to-cp-graph.js":
/*!**************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/add-to-cp-graph.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst contact_point_1 = __webpack_require__(/*! ../contact-point */ \"./node_modules/flo-mat/node/src/contact-point.js\");\nconst cp_node_1 = __webpack_require__(/*! ../cp-node */ \"./node_modules/flo-mat/node/src/cp-node.js\");\nconst get_neighboring_cps_1 = __webpack_require__(/*! ./get-neighboring-cps */ \"./node_modules/flo-mat/node/src/mat/get-neighboring-cps.js\");\nfunction addToCpGraph(circle, orders, cpTrees, poss, neighbors) {\n    let newCps = poss.map((pos, i) => {\n        let cpTree = cpTrees.get(pos.curve.loop);\n        let newCp_ = new contact_point_1.ContactPoint(pos, circle, orders[i], 0);\n        let neighboringCp = neighbors\n            ? neighbors[i]\n            : get_neighboring_cps_1.getNeighbouringPoints(cpTree, pos, orders[i], 0);\n        let newCp = cp_node_1.CpNode.insert(false, false, cpTree, newCp_, neighboringCp[0]);\n        return newCp;\n    });\n    let len = poss.length;\n    for (let i = 0; i < len; i++) {\n        let indxPrev = i === 0 ? len - 1 : i - 1;\n        let indxNext = i === len - 1 ? 0 : i + 1;\n        newCps[i].prevOnCircle = newCps[indxPrev];\n        newCps[i].nextOnCircle = newCps[indxNext];\n    }\n}\nexports.addToCpGraph = addToCpGraph;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/add-to-cp-graph.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/create-new-cp-tree.js":
/*!*****************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/create-new-cp-tree.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_ll_rb_tree_1 = __webpack_require__(/*! flo-ll-rb-tree */ \"./node_modules/flo-ll-rb-tree/node/index.js\");\nconst cp_node_1 = __webpack_require__(/*! ../cp-node */ \"./node_modules/flo-mat/node/src/cp-node.js\");\nconst traverse_edges_1 = __webpack_require__(/*! ./traverse-edges */ \"./node_modules/flo-mat/node/src/mat/traverse-edges.js\");\nfunction createNewCpTree(cpNode) {\n    let newCpTrees = new Map();\n    traverse_edges_1.traverseEdges(cpNode, function (cpNode) {\n        let loop = cpNode.cp.pointOnShape.curve.loop;\n        let cpTree = newCpTrees.get(loop);\n        if (!cpTree) {\n            cpTree = new flo_ll_rb_tree_1.default(cp_node_1.CpNode.comparator, [], true);\n            newCpTrees.set(loop, cpTree);\n        }\n        cpTree.insert(cpNode);\n    });\n    return newCpTrees;\n}\nexports.createNewCpTree = createNewCpTree;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/create-new-cp-tree.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/find-mat/add-1-prong.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/find-mat/add-1-prong.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst point_on_shape_1 = __webpack_require__(/*! ../../point-on-shape */ \"./node_modules/flo-mat/node/src/point-on-shape.js\");\nconst add_to_cp_graph_1 = __webpack_require__(/*! ../add-to-cp-graph */ \"./node_modules/flo-mat/node/src/mat/add-to-cp-graph.js\");\nconst is_another_cp_closeby_1 = __webpack_require__(/*! ../is-another-cp-closeby */ \"./node_modules/flo-mat/node/src/mat/is-another-cp-closeby.js\");\n/**\n * Add a 1-prong to the MAT.\n * @param cpGraphs\n * @param pos\n */\nfunction add1Prong(maxOsculatingCircleRadius, cpGraphs, pos) {\n    if (point_on_shape_1.PointOnShape.isDullCorner(pos)) {\n        // This is a 1-prong at a dull corner.\n        // TODO IMPORTANT \n        // Remove this line, uncomment piece below it and implement the \n        // following strategy to find the 3-prongs: if deltas are conjoined due \n        // to dull corner, split the conjoinment by inserting successively \n        // closer (binary division) 2-prongs. If a 2-prong actually fails, \n        // simply remove the 1-prong at the dull corner. In this way **all** \n        // terminal points are found, e.g. zoom in on top left leg of ant.\n        // Afterthought: there is a better way - split points by two prongs.\n        //toRemove.push(posNode); // this!\n        if (typeof _debug_ !== 'undefined') {\n            _debug_.generated.elems.oneProngAtDullCorner.push(pos);\n        }\n        return;\n    }\n    let circle = point_on_shape_1.PointOnShape.getOsculatingCircle(maxOsculatingCircleRadius, pos);\n    //console.log(maxOsculatingCircleRadius)\n    let order = point_on_shape_1.PointOnShape.calcOrder(circle, pos);\n    // Make sure there isn't already a ContactPoint close by - it can cause\n    // floating point stability issues.\n    if (is_another_cp_closeby_1.isAnotherCpCloseby(cpGraphs, pos, circle, order, 0, 1000, 'magenta')) {\n        return;\n    }\n    add_to_cp_graph_1.addToCpGraph(circle, [-0.5, +0.5], cpGraphs, [pos, pos]);\n    if (typeof _debug_ !== 'undefined') {\n        _debug_.generated.elems.oneProng.push(pos);\n    }\n}\nexports.add1Prong = add1Prong;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/find-mat/add-1-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/find-mat/add-2-prong.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/find-mat/add-2-prong.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst cp_node_1 = __webpack_require__(/*! ../../cp-node */ \"./node_modules/flo-mat/node/src/cp-node.js\");\nconst contact_point_1 = __webpack_require__(/*! ../../contact-point */ \"./node_modules/flo-mat/node/src/contact-point.js\");\nconst point_on_shape_1 = __webpack_require__(/*! ../../point-on-shape */ \"./node_modules/flo-mat/node/src/point-on-shape.js\");\nconst is_another_cp_closeby_1 = __webpack_require__(/*! ../is-another-cp-closeby */ \"./node_modules/flo-mat/node/src/mat/is-another-cp-closeby.js\");\nconst get_neighboring_cps_1 = __webpack_require__(/*! ../get-neighboring-cps */ \"./node_modules/flo-mat/node/src/mat/get-neighboring-cps.js\");\n/**\n * Adds a 2-prong contact circle to the shape.\n * @param cpGraphs\n * @param circle Circle containing the 2 contact points\n * @param posSource The source point on shape\n * @param posAntipode The found antipodal point on shape\n * @param holeClosing True if this is a hole-closing 2-prong, false otherwise\n * @param extreme The maximum coordinate value used to calculate floating point\n * tolerances.\n */\nfunction add2Prong(cpGraphs, circle, posSource, posAntipode, holeClosing, extreme) {\n    let orderSource = point_on_shape_1.PointOnShape.calcOrder(circle, posSource);\n    let orderAntipode = point_on_shape_1.PointOnShape.calcOrder(circle, posAntipode);\n    let t_s = posSource.t;\n    let curve;\n    if (t_s === 0) {\n        t_s = 1;\n        curve = posSource.curve.prev;\n        posSource = new point_on_shape_1.PointOnShape(curve, t_s);\n    }\n    // Make sure there isn't already a ContactPoint close by - it can cause\n    // floating point stability issues.\n    if (is_another_cp_closeby_1.isAnotherCpCloseby(cpGraphs, posSource, circle, orderSource, 0, extreme, 'red') ||\n        is_another_cp_closeby_1.isAnotherCpCloseby(cpGraphs, posAntipode, circle, orderAntipode, 0, extreme, 'red')) {\n        if (typeof _debug_ !== 'undefined') {\n            if (holeClosing) {\n                _debug_.generated.elems['twoProng_holeClosing'].pop();\n            }\n            else {\n                _debug_.generated.elems['twoProng_regular'].pop();\n            }\n        }\n        return;\n    }\n    // Antipode\n    let cpAntipode = new contact_point_1.ContactPoint(posAntipode, circle, orderAntipode, 0);\n    let loopAntipode = posAntipode.curve.loop;\n    let cpTreeAntipode = cpGraphs.get(loopAntipode);\n    let deltaAntipode = get_neighboring_cps_1.getNeighbouringPoints(cpTreeAntipode, posAntipode, orderAntipode, 0);\n    let newCpAntipode = cp_node_1.CpNode.insert(holeClosing, false, cpTreeAntipode, cpAntipode, deltaAntipode[0]);\n    //console.log(cpAntipode.pointOnShape.t);\n    // Source\n    let cpSource = new contact_point_1.ContactPoint(posSource, circle, orderSource, 0);\n    let loopSource = posSource.curve.loop;\n    let cpTreeSource = cpGraphs.get(loopSource);\n    let deltaSource = get_neighboring_cps_1.getNeighbouringPoints(cpTreeSource, posSource, orderSource, 0);\n    let newCpSource = cp_node_1.CpNode.insert(holeClosing, false, cpTreeSource, cpSource, deltaSource[0]);\n    //console.log(cpSource.pointOnShape.t);\n    // Connect graph\n    newCpSource.prevOnCircle = newCpAntipode;\n    newCpSource.nextOnCircle = newCpAntipode;\n    newCpAntipode.prevOnCircle = newCpSource;\n    newCpAntipode.nextOnCircle = newCpSource;\n    if (holeClosing) {\n        // Duplicate ContactPoints\n        let cpB2 = new contact_point_1.ContactPoint(posAntipode, circle, cpAntipode.order, +1);\n        let newCpB2Node = cp_node_1.CpNode.insert(true, false, cpTreeAntipode, cpB2, newCpAntipode);\n        let cpB1 = new contact_point_1.ContactPoint(posSource, circle, cpSource.order, -1);\n        let newCpB1Node = cp_node_1.CpNode.insert(true, false, cpTreeSource, cpB1, newCpSource.prev);\n        // Connect graph\n        newCpB1Node.prevOnCircle = newCpB2Node;\n        newCpB1Node.nextOnCircle = newCpB2Node;\n        newCpB2Node.prevOnCircle = newCpB1Node;\n        newCpB2Node.nextOnCircle = newCpB1Node;\n        newCpAntipode.next = newCpSource;\n        newCpSource.prev = newCpAntipode;\n        newCpB1Node.next = newCpB2Node;\n        newCpB2Node.prev = newCpB1Node;\n    }\n    return newCpSource;\n}\nexports.add2Prong = add2Prong;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/find-mat/add-2-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/find-mat/add-3-prong.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/find-mat/add-3-prong.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst add_to_cp_graph_1 = __webpack_require__(/*! ../add-to-cp-graph */ \"./node_modules/flo-mat/node/src/mat/add-to-cp-graph.js\");\nconst is_another_cp_closeby_1 = __webpack_require__(/*! ../is-another-cp-closeby */ \"./node_modules/flo-mat/node/src/mat/is-another-cp-closeby.js\");\n/**\n * Adds a 3-prong MAT circle according to the 3 given (previously calculated)\n * points on the shape.\n * @param cpTrees\n * @param orders\n * @param threeProng\n */\nfunction add3Prong(cpTrees, orders, threeProng) {\n    let { circle, ps, δ3s } = threeProng;\n    // Keep for possible future debugging.\t\n    /*\n    if (typeof _debug_ !== 'undefined') {\n        for (let i=0; i<3; i++) {\n            let cpBef = threeProng.δ3s[i][0].cp;\n            let cpAft = threeProng.δ3s[i][1].cp;\n            //let cmpBef = PointOnShape.compareInclOrder(cpBef.pointOnShape, ps[i], cpBef.order, orders[i]);\n            //let cmpAft = PointOnShape.compareInclOrder(cpAft.pointOnShape, ps[i], cpAft.order, orders[i]);\n\r\n            let cmpBef = PointOnShape.compare(cpBef.pointOnShape, ps[i]);\n            let cmpAft = PointOnShape.compare(cpAft.pointOnShape, ps[i]);\n\r\n            // len is used by debug functions to reference a particular\n            // three-prong.\n            let len = _debug_.generated.elems.threeProng.length-1;\n            if (cmpBef > 0) {\n                console.log('----------------------------------------');\n                console.log(`3-prong order is wrong (bef) : i: ${i} - cmp: ${cmpBef} - n: ${len}`);\n                console.log(threeProng);\n                console.log(cpBef);\n                console.log(cpAft);\n                console.log(ps[i]);\n            }\n            if (cmpAft < 0) {\n                console.log('----------------------------------------');\n                console.log(`3-prong order is wrong (aft) : i: ${i} - cmp: ${cmpAft} - n: ${len}`);\n                console.log(threeProng);\n                console.log(cpBef);\n                console.log(cpAft);\n                console.log(ps[i]);\n            }\n        }\n    }\n    */\n    // TODO - replace 1000 below with correct value\n    is_another_cp_closeby_1.isAnotherCpCloseby(cpTrees, ps[0], circle, orders[0], 0, 1000, 'blue');\n    is_another_cp_closeby_1.isAnotherCpCloseby(cpTrees, ps[1], circle, orders[1], 0, 1000, 'blue');\n    is_another_cp_closeby_1.isAnotherCpCloseby(cpTrees, ps[2], circle, orders[2], 0, 1000, 'blue');\n    add_to_cp_graph_1.addToCpGraph(circle, orders, cpTrees, ps, δ3s);\n    return circle;\n}\nexports.add3Prong = add3Prong;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/find-mat/add-3-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/find-mat/add-debug-info.js":
/*!**********************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/find-mat/add-debug-info.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\nconst point_on_shape_1 = __webpack_require__(/*! ../../point-on-shape */ \"./node_modules/flo-mat/node/src/point-on-shape.js\");\nfunction addDebugInfo1(loops) {\n    if (typeof _debug_ === 'undefined') {\n        return;\n    }\n    for (let loop of loops) {\n        _debug_.fs.nameObj(loop, 'l|');\n    }\n    let generated = _debug_.generated;\n    generated.timing.holeClosers[0] = performance.now();\n    generated.elems.loop.push(...loops);\n    generated.elems.loops.push(loops);\n    for (let loop of loops) {\n        let i = 0;\n        loop.curves.forEach(function (curve) {\n            let ps = curve.ps;\n            let hull = flo_bezier3_1.getBoundingHull(ps);\n            generated.elems.boundingHull.push(hull);\n            let looseBoundingBox = flo_bezier3_1.getBoundingBox(ps);\n            generated.elems.looseBoundingBox.push(looseBoundingBox);\n            let tightBoundingBox = flo_bezier3_1.getBoundingBoxTight(ps);\n            generated.elems.tightBoundingBox.push(tightBoundingBox);\n            i++;\n        });\n    }\n}\nexports.addDebugInfo1 = addDebugInfo1;\nfunction addDebugInfo2(pointOnShapeArrPerLoop) {\n    if (typeof _debug_ === 'undefined') {\n        return;\n    }\n    let generated = _debug_.generated;\n    let timing = generated.timing;\n    let now = performance.now();\n    timing.holeClosers[1] += now - timing.holeClosers[0];\n    timing.oneAnd2Prongs[0] = now;\n    for (let pointsOnShape of pointOnShapeArrPerLoop) {\n        for (let pos of pointsOnShape) {\n            if (point_on_shape_1.PointOnShape.isSharpCorner(pos)) {\n                generated.elems.sharpCorner.push(pos);\n            }\n            else {\n                if (point_on_shape_1.PointOnShape.isDullCorner(pos)) {\n                    generated.elems.dullCorner.push(pos);\n                }\n            }\n        }\n    }\n}\nexports.addDebugInfo2 = addDebugInfo2;\nfunction addDebugInfo3() {\n    if (typeof _debug_ === 'undefined') {\n        return;\n    }\n    let generated = _debug_.generated;\n    let timing = generated.timing;\n    let now = performance.now();\n    timing.oneAnd2Prongs[1] += now - timing.oneAnd2Prongs[0];\n    timing.threeProngs[0] = now;\n}\nexports.addDebugInfo3 = addDebugInfo3;\nfunction addDebugInfo4(mat) {\n    if (typeof _debug_ === 'undefined') {\n        return;\n    }\n    let generated = _debug_.generated;\n    let timing = generated.timing;\n    generated.elems.mat.push(mat);\n    timing.threeProngs[1] += performance.now() - timing.threeProngs[0];\n    timing.mats[1] =\n        timing.holeClosers[1] +\n            timing.oneAnd2Prongs[1] +\n            timing.threeProngs[1];\n}\nexports.addDebugInfo4 = addDebugInfo4;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/find-mat/add-debug-info.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/find-mat/create-get-interesting-points-on-loop.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/find-mat/create-get-interesting-points-on-loop.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst get_contact_circles_at_interface_1 = __webpack_require__(/*! ../get-contact-circles-at-interface */ \"./node_modules/flo-mat/node/src/mat/get-contact-circles-at-interface.js\");\nconst get_bezier_curvature_extrema_1 = __webpack_require__(/*! ../get-bezier-curvature-extrema */ \"./node_modules/flo-mat/node/src/mat/get-bezier-curvature-extrema.js\");\nconst point_on_shape_1 = __webpack_require__(/*! ../../point-on-shape */ \"./node_modules/flo-mat/node/src/point-on-shape.js\");\n/**\n * Get useful points on the shape - these incude points of maximum curvature and\n * points at the bezier-bezier interfaces.\n * @param loop\n * @param additionalPointCount\n */\nfunction createGetInterestingPointsOnLoop(additionalPointCount = 3) {\n    return function (loop) {\n        let allPoints = [];\n        for (let i = 0; i < loop.curves.length; i++) {\n            let curve = loop.curves[i];\n            let { maxCurvaturePoss, maxNegativeCurvaturePoss } = get_bezier_curvature_extrema_1.getBezierCurvatureExtrema(curve);\n            allPoints.push(...get_contact_circles_at_interface_1.getContactCirclesAtInterface(curve), ...maxCurvaturePoss, ...maxNegativeCurvaturePoss);\n            let n = additionalPointCount + 1;\n            for (let i = 1; i < n; i++) {\n                allPoints.push(new point_on_shape_1.PointOnShape(curve, i / n));\n            }\n        }\n        allPoints.sort(point_on_shape_1.PointOnShape.compare);\n        return allPoints;\n    };\n}\nexports.createGetInterestingPointsOnLoop = createGetInterestingPointsOnLoop;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/find-mat/create-get-interesting-points-on-loop.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/find-mat/create-initial-cp-graph.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/find-mat/create-initial-cp-graph.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_ll_rb_tree_1 = __webpack_require__(/*! flo-ll-rb-tree */ \"./node_modules/flo-ll-rb-tree/node/index.js\");\nconst circle_1 = __webpack_require__(/*! ../../circle */ \"./node_modules/flo-mat/node/src/circle.js\");\nconst cp_node_1 = __webpack_require__(/*! ../../cp-node */ \"./node_modules/flo-mat/node/src/cp-node.js\");\nconst contact_point_1 = __webpack_require__(/*! ../../contact-point */ \"./node_modules/flo-mat/node/src/contact-point.js\");\n/**\n * Creates the initial ContactPoint loops from the given sharp corners.\n * @param shape\n * @param sharpCornerss\n */\nfunction createInitialCpGraph(loops, cpTrees, sharpCornerss, xMap) {\n    let cpNode;\n    for (let k = 0; k < sharpCornerss.length; k++) {\n        let sharpCorners = sharpCornerss[k];\n        let cpTree = new flo_ll_rb_tree_1.default(cp_node_1.CpNode.comparator, [], true);\n        let cpNode1 = undefined;\n        let cpNode2 = undefined;\n        for (let pos of sharpCorners) {\n            let ps = pos.curve.next.ps;\n            let x = xMap.get(ps);\n            let isIntersection = !!x;\n            let circle = new circle_1.Circle(pos.p, 0);\n            let cp1 = new contact_point_1.ContactPoint(pos, circle, -1, 0);\n            let cp2 = new contact_point_1.ContactPoint(pos, circle, +1, 0);\n            cpNode1 = cp_node_1.CpNode.insert(false, isIntersection, cpTree, cp1, cpNode2);\n            cpNode2 = cp_node_1.CpNode.insert(false, isIntersection, cpTree, cp2, cpNode1);\n            cpNode1.prevOnCircle = cpNode2;\n            cpNode2.prevOnCircle = cpNode1;\n            cpNode1.nextOnCircle = cpNode2;\n            cpNode2.nextOnCircle = cpNode1;\n        }\n        if (!cpNode) {\n            cpNode = cpNode1;\n        }\n        let loop = loops[k];\n        cpTrees.set(loop, cpTree);\n    }\n    return cpNode;\n}\nexports.createInitialCpGraph = createInitialCpGraph;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/find-mat/create-initial-cp-graph.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/find-mat/find-2-prong/add-debug-info.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/find-mat/find-2-prong/add-debug-info.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst two_prong_for_debugging_1 = __webpack_require__(/*! ../../../debug/two-prong-for-debugging */ \"./node_modules/flo-mat/node/src/debug/two-prong-for-debugging.js\");\nconst get_two_prong_type_1 = __webpack_require__(/*! ../../get-two-prong-type */ \"./node_modules/flo-mat/node/src/mat/get-two-prong-type.js\");\nfunction addDebugInfo(bezierPieces, failed, pos, circle, z, δ, xs, holeClosing) {\n    let twoProng = new two_prong_for_debugging_1.TwoProngForDebugging(_debug_.generated, bezierPieces, pos, δ, z ? z.p : undefined, circle, xs, failed, holeClosing, false, false);\n    let twoProngType = get_two_prong_type_1.getTwoProngType(twoProng);\n    _debug_.generated.elems[twoProngType].push(twoProng);\n}\nexports.addDebugInfo = addDebugInfo;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/find-mat/find-2-prong/add-debug-info.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/find-mat/find-2-prong/cull-bezier-pieces.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/find-mat/find-2-prong/cull-bezier-pieces.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\nconst get_closest_square_distance_to_rect_1 = __webpack_require__(/*! ../../geometry/get-closest-square-distance-to-rect */ \"./node_modules/flo-mat/node/src/mat/geometry/get-closest-square-distance-to-rect.js\");\n/**\n * Cull all bezierPieces not within given radius of a given point.\n * @param extreme\n * @param bezierPieces\n * @param p\n * @param rSquared\n */\nfunction cullBezierPieces(bezierPieces, p, rSquared) {\n    const CULL_THRESHOLD = 5;\n    const TOLERANCE = 1 + 1e-3;\n    if (bezierPieces.length <= CULL_THRESHOLD) {\n        return bezierPieces;\n    }\n    let newPieces = [];\n    for (let bezierPiece of bezierPieces) {\n        let ps = bezierPiece.curve.ps;\n        let rect = flo_bezier3_1.getBoundingBox(ps);\n        let bd = get_closest_square_distance_to_rect_1.getClosestSquareDistanceToRect(rect, p);\n        if (bd <= rSquared * TOLERANCE) {\n            newPieces.push(bezierPiece);\n        }\n    }\n    return newPieces;\n}\nexports.cullBezierPieces = cullBezierPieces;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/find-mat/find-2-prong/cull-bezier-pieces.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/find-mat/find-2-prong/find-2-prong.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/find-mat/find-2-prong/find-2-prong.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\nconst line_line_intersection_1 = __webpack_require__(/*! ../../geometry/line-line-intersection */ \"./node_modules/flo-mat/node/src/mat/geometry/line-line-intersection.js\");\nconst get_closest_boundary_point_1 = __webpack_require__(/*! ../../get-closest-boundary-point */ \"./node_modules/flo-mat/node/src/mat/get-closest-boundary-point.js\");\nconst circle_1 = __webpack_require__(/*! ../../../circle */ \"./node_modules/flo-mat/node/src/circle.js\");\nconst point_on_shape_1 = __webpack_require__(/*! ../../../point-on-shape */ \"./node_modules/flo-mat/node/src/point-on-shape.js\");\nconst add_1_prong_1 = __webpack_require__(/*! ../add-1-prong */ \"./node_modules/flo-mat/node/src/mat/find-mat/add-1-prong.js\");\nconst add_debug_info_1 = __webpack_require__(/*! ./add-debug-info */ \"./node_modules/flo-mat/node/src/mat/find-mat/find-2-prong/add-debug-info.js\");\nconst cull_bezier_pieces_1 = __webpack_require__(/*! ./cull-bezier-pieces */ \"./node_modules/flo-mat/node/src/mat/find-mat/find-2-prong/cull-bezier-pieces.js\");\nconst find_equidistant_point_on_line_1 = __webpack_require__(/*! ./find-equidistant-point-on-line */ \"./node_modules/flo-mat/node/src/mat/find-mat/find-2-prong/find-equidistant-point-on-line.js\");\nconst get_initial_bezier_pieces_1 = __webpack_require__(/*! ./get-initial-bezier-pieces */ \"./node_modules/flo-mat/node/src/mat/find-mat/find-2-prong/get-initial-bezier-pieces.js\");\n/**\n * Adds a 2-prong to the MAT. The first point on the shape boundary is given and\n * the second one is found by the algorithm.\n *\n * A 2-prong is defined as a MAT circle that touches the shape at exactly 2\n * points.\n *\n * Before any 2-prongs are added the entire shape is our δΩ (1-prongs do not\n * reduce the boundary).\n *\n * As per the paper by Choi, Choi, Moon and Wee:\n *   \"The starting point of this algorithm is a choice of a circle Br(x)\n *    centered at an interior point x which contains two boundary portions c and\n *    d of dΩ as in Fig. 19.\"\n * In fact, we (and they) start by fixing one point on the boundary beforehand.\n * @param loops A shape represented by path loops\n * @param extreme The extreme coordinate value of the shape\n * @param squaredDiagonalLength The squared diagonal length of the shape\n * bounding box.\n * @param y The source point of the 2-prong to be found\n * @param isHoleClosing True if this is a hole-closing two-prong, false otherwise\n * @param k The loop array index\n */\nfunction find2Prong(loops, extreme, squaredDiagonalLength, cpTrees, y, isHoleClosing, k) {\n    const MAX_ITERATIONS = 25;\n    const squaredSeperationTolerance = Math.pow((1e-6 * extreme), 2);\n    //const oneProngTolerance = 1+1e-4;\n    const oneProngTolerance = Math.pow((1e-4), 2);\n    const squaredErrorTolerance = 1e-2 * squaredSeperationTolerance;\n    const maxOsculatingCircleRadiusSquared = squaredDiagonalLength;\n    // The boundary piece that should contain the other point of \n    // the 2-prong circle. (Defined by start and end points).\n    let { bezierPieces, δ } = get_initial_bezier_pieces_1.getInitialBezierPieces(isHoleClosing, k, loops, cpTrees, y);\n    /** The center of the two-prong (successively refined) */\n    let x;\n    let p;\n    let r;\n    if (isHoleClosing) {\n        p = [y.p[0], y.p[1]];\n        x = [p[0], p[1] - Math.sqrt(maxOsculatingCircleRadiusSquared)];\n        r = maxOsculatingCircleRadiusSquared;\n    }\n    else {\n        p = y.p;\n        x = point_on_shape_1.PointOnShape.getOsculatingCircle(maxOsculatingCircleRadiusSquared, y).center;\n        r = flo_vector2d_1.squaredDistanceBetween(p, x);\n    }\n    // The lines below is an optimization.\n    let r_ = reduceRadius(extreme, bezierPieces, p, x);\n    if (r > r_) {\n        x = flo_vector2d_1.interpolate(p, x, Math.sqrt(r_ / r));\n    }\n    let xs = []; // Trace the convergence (for debugging).\n    let z; // The antipode if the two-prong (successively refined)\n    let i = 0;\n    let done = 0;\n    let failed = false; // The failed flag is set if a 2-prong cannot be found.\n    let bezierPieces_ = bezierPieces;\n    do {\n        i++;\n        let r = flo_vector2d_1.squaredDistanceBetween(x, y.p);\n        bezierPieces_ = cull_bezier_pieces_1.cullBezierPieces(bezierPieces_, x, r);\n        z = get_closest_boundary_point_1.getClosestBoundaryPoint(bezierPieces_, x, y.curve, y.t);\n        /*\n        if (z.t === 0 || z.t === 1) {\n            console.log(z, z.t)\n        }\n        */\n        if (z === undefined) {\n            if (typeof _debug_ !== 'undefined') {\n                let elems = _debug_.generated.elems;\n                let elem = isHoleClosing\n                    ? elems.twoProng_holeClosing\n                    : elems.twoProng_regular;\n                let elemStr = isHoleClosing\n                    ? 'hole-closing: ' + elem.length\n                    : 'regular: ' + elem.length;\n                console.log('failed: no closest point - ' + elemStr);\n            }\n            failed = true;\n            break;\n        }\n        if (typeof _debug_ !== 'undefined') {\n            xs.push({ x, y, z, t: y.t });\n        }\n        let d = flo_vector2d_1.squaredDistanceBetween(x, z.p);\n        //if (i === 1 && d*oneProngTolerance >= r) {\n        if (i === 1 && r < d + oneProngTolerance) {\n            // It is a 1-prong.\n            add_1_prong_1.add1Prong(Math.sqrt(maxOsculatingCircleRadiusSquared), cpTrees, y);\n            return undefined;\n        }\n        // TODO - squaredSeperationTolerance should in future be replaced with\n        // a relative error, i.e. distance between y (or z) / length(y (or z)).\n        if (!isHoleClosing && flo_vector2d_1.squaredDistanceBetween(y.p, z.p) <= squaredSeperationTolerance) {\n            if (typeof _debug_ !== 'undefined') {\n                let elems = _debug_.generated.elems;\n                let elem = isHoleClosing\n                    ? elems.twoProng_holeClosing\n                    : elems.twoProng_regular;\n                let elemStr = isHoleClosing\n                    ? 'hole-closing: ' + elem.length\n                    : 'regular: ' + elem.length;\n                /*\n                console.log(\n                    'failed: two-prong radius too small - ' + elemStr\n                );\n                */\n            }\n            failed = true;\n            break;\n        }\n        // Find the point on the line connecting y with x that is  \n        // equidistant from y and z. This will be our next x.\n        let nextX = find_equidistant_point_on_line_1.findEquidistantPointOnLine(x, y.p, z.p);\n        let squaredError = flo_vector2d_1.squaredDistanceBetween(x, nextX);\n        x = nextX;\n        if (squaredError < squaredErrorTolerance) {\n            done++; // Do one more iteration\n        }\n        else if (i === MAX_ITERATIONS) {\n            // Convergence was too slow.\n            failed = true;\n            break; // We're done\n        }\n    } while (done < 1);\n    let circle;\n    if (z !== undefined) {\n        circle = new circle_1.Circle(x, flo_vector2d_1.distanceBetween(x, z.p));\n    }\n    if (typeof _debug_ !== 'undefined') {\n        xs.push({ x, y, z, t: y.t });\n        add_debug_info_1.addDebugInfo(bezierPieces, failed, y, circle, z, δ, xs, isHoleClosing);\n    }\n    return failed ? undefined : { circle, z };\n}\nexports.find2Prong = find2Prong;\n/**\n * Reduces the circle radius initially as an optimization step.\n */\nfunction reduceRadius(extreme, bezierPieces, p, x) {\n    const TOLERANCE = extreme * 1e-3;\n    let prevP = undefined;\n    let minRadius = Number.POSITIVE_INFINITY;\n    for (let i = 0; i < bezierPieces.length; i++) {\n        let bezierPiece = bezierPieces[i];\n        let ps = bezierPiece.curve.ps;\n        let ev = flo_bezier3_1.evaluate(ps);\n        let p1 = ev(bezierPiece.ts[0]);\n        let r1 = Number.POSITIVE_INFINITY;\n        // Prevent evaluating the same points twice\n        if (!prevP || prevP[0] !== p1[0] || prevP[1] !== p1[1]) {\n            let cc1 = getCircleCenterFrom2PointsAndNormal(extreme, p, x, p1);\n            if (cc1) {\n                r1 = flo_vector2d_1.squaredDistanceBetween(p, cc1);\n            }\n        }\n        let r2 = Number.POSITIVE_INFINITY;\n        let p2 = ev(bezierPiece.ts[1]);\n        let cc2 = getCircleCenterFrom2PointsAndNormal(extreme, p, x, p2);\n        if (cc2) {\n            r2 = flo_vector2d_1.squaredDistanceBetween(p, cc2);\n        }\n        prevP = p2;\n        let d = Math.min(r1, r2);\n        if (d < minRadius) {\n            minRadius = d;\n        }\n    }\n    // The extra bit is to account for floating point precision.\n    return minRadius + TOLERANCE;\n}\n/**\n *\n * @param p A point on the circle with normal pointing to x towards the center\n * of the circle.\n * @param x\n * @param p1 Another point on the circle.\n */\nfunction getCircleCenterFrom2PointsAndNormal(extreme, p, x, p1) {\n    let TOLERANCE = Math.pow((1e-4 * extreme), 2);\n    // Ignore if p and p1 are too close together\n    if (flo_vector2d_1.squaredDistanceBetween(p, p1) < TOLERANCE) {\n        return undefined;\n    }\n    /** The perpindicular bisector between the two given points on the circle */\n    let pb = [\n        (p[0] + p1[0]) / 2,\n        (p[1] + p1[1]) / 2,\n    ];\n    let tangent = [p1[0] - p[0], p1[1] - p[1]];\n    let normal = [-tangent[1], tangent[0]]; // Rotate by 90 degrees\n    let pb2 = [pb[0] + normal[0], pb[1] + normal[1]];\n    let res = line_line_intersection_1.lineLineIntersection([p, x], [pb, pb2]);\n    if (!res) {\n        return undefined;\n    }\n    let resO = [res[0] - p[0], res[1] - p[1]];\n    let xO = [x[0] - p[0], x[1] - p[1]];\n    if (flo_vector2d_1.dot(resO, xO) < 0) {\n        return undefined;\n    }\n    return res;\n}\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/find-mat/find-2-prong/find-2-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/find-mat/find-2-prong/find-equidistant-point-on-line.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/find-mat/find-2-prong/find-equidistant-point-on-line.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n *\n * @param x\n * @param y\n * @param z\n * @returns The point on the line from y to x that is equidistant from y and z.\n */\nfunction findEquidistantPointOnLine(x, y, z) {\n    // Some basic algebra (not shown) finds the required point.\n    // Swap axes if x and y are more aligned to y-axis than to x-axis.\n    let swapAxes = Math.abs((x[1] - y[1]) / (x[0] - y[0])) > 1;\n    // Cache\n    let x1, x2, y1, y2, z1, z2;\n    if (swapAxes) {\n        x1 = x[1];\n        x2 = x[0];\n        y1 = y[1];\n        y2 = y[0];\n        z1 = z[1];\n        z2 = z[0];\n    }\n    else {\n        x1 = x[0];\n        x2 = x[1];\n        y1 = y[0];\n        y2 = y[1];\n        z1 = z[0];\n        z2 = z[1];\n    }\n    // a <= 1 (due to swapped axes)\n    let a = (x2 - y2) / (x1 - y1);\n    let b = y2 - a * y1;\n    let c = (y1 * y1 + y2 * y2 - z1 * z1 - z2 * z2) + 2 * b * (z2 - y2);\n    let d = y1 - z1 + a * (y2 - z2);\n    let t1 = c / (2 * d);\n    let t2 = a * t1 + b;\n    return swapAxes ? [t2, t1] : [t1, t2];\n}\nexports.findEquidistantPointOnLine = findEquidistantPointOnLine;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/find-mat/find-2-prong/find-equidistant-point-on-line.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/find-mat/find-2-prong/get-initial-bezier-pieces.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/find-mat/find-2-prong/get-initial-bezier-pieces.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst get_neighboring_cps_1 = __webpack_require__(/*! ../../get-neighboring-cps */ \"./node_modules/flo-mat/node/src/mat/get-neighboring-cps.js\");\nconst get_boundary_piece_beziers_1 = __webpack_require__(/*! ../../get-boundary-piece-beziers */ \"./node_modules/flo-mat/node/src/mat/get-boundary-piece-beziers.js\");\nconst bezier_piece_1 = __webpack_require__(/*! ../../../bezier-piece */ \"./node_modules/flo-mat/node/src/bezier-piece.js\");\nconst point_on_shape_1 = __webpack_require__(/*! ../../../point-on-shape */ \"./node_modules/flo-mat/node/src/point-on-shape.js\");\nfunction getInitialBezierPieces(isHoleClosing, k, loops, cpTrees, y) {\n    let bezierPieces;\n    let δ;\n    if (isHoleClosing) {\n        bezierPieces = [];\n        for (let k2 = 0; k2 < k; k2++) {\n            //let pieces = getBoundaryBeziers(loops[k2]);\n            let pieces = loops[k2].curves\n                .map(curve => new bezier_piece_1.BezierPiece(curve, [0, 1]));\n            bezierPieces.push(...pieces);\n        }\n    }\n    else {\n        let order = point_on_shape_1.PointOnShape.isDullCorner(y)\n            ? y.t === 1 ? -1 : +1\n            : 0;\n        let loop = loops[k];\n        let cpNode = get_neighboring_cps_1.getNeighbouringPoints(cpTrees.get(loop), y, order, 0)[0];\n        δ = [cpNode, cpNode];\n        if (!cpNode ||\n            // The special case if there is only a single sharp corner or \n            // terminating 2-prong currently in the MAT. Don't remove!\n            (cpNode === cpNode.next.next)) {\n            bezierPieces = loop.curves\n                .map(curve => new bezier_piece_1.BezierPiece(curve, [0, 1]));\n        }\n        else {\n            bezierPieces = get_boundary_piece_beziers_1.getBoundaryPieceBeziers(δ);\n        }\n    }\n    return { bezierPieces, δ };\n}\nexports.getInitialBezierPieces = getInitialBezierPieces;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/find-mat/find-2-prong/get-initial-bezier-pieces.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/find-mat/find-3-prong/calc-better-x.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/find-mat/find-3-prong/calc-better-x.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\nconst get_closest_points_1 = __webpack_require__(/*! ./get-closest-points */ \"./node_modules/flo-mat/node/src/mat/find-mat/find-3-prong/get-closest-points.js\");\n/**\n * Find new x and ps that are a better estimate of the 3-prong circle.\n * The potential function, V, is defined as the distance to the actual 3 prong\n * circle center.\n * @param bezierPiece3s The three boundary pieces, each of which should contain\n * a point of the 3-prong to be found.\n * @param x The currently best guess at the center of the 3-prong circle.\n * @param vectorToZeroV\n * @param extreme\n */\nfunction calcBetterX(bezierPiece3s, x, vectorToZeroV) {\n    let V = flo_vector2d_1.len(vectorToZeroV);\n    let nu = 1;\n    let better;\n    let newX;\n    let newPs;\n    let newV;\n    let i = 0; // Safeguard\n    do {\n        let shift = flo_vector2d_1.scale(vectorToZeroV, nu);\n        newX = flo_vector2d_1.translate(shift, x);\n        newPs = get_closest_points_1.getClosestPoints(newX, bezierPiece3s);\n        //console.log(newPs.map(pos => '' + pos.p[0] + ' ' + pos.p[1]))\n        // Point of zero V\n        let newCircleCenter = flo_vector2d_1.circumCenter(newPs.map(pos => pos.p));\n        let newVectorToZeroV = flo_vector2d_1.fromTo(newX, newCircleCenter);\n        newV = flo_vector2d_1.len(newVectorToZeroV);\n        better = newV < V;\n        nu = nu / 2;\n        i++;\n    } while (!better && i < 3);\n    return { newX, newV, newPs };\n}\nexports.calcBetterX = calcBetterX;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/find-mat/find-3-prong/calc-better-x.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/find-mat/find-3-prong/calc-initial-3-prong-center.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/find-mat/find-3-prong/calc-initial-3-prong-center.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\nconst get_closest_boundary_point_1 = __webpack_require__(/*! ../../get-closest-boundary-point */ \"./node_modules/flo-mat/node/src/mat/get-closest-boundary-point.js\");\n/**\n * Finds an initial 3-prong circle center point from which to iterate. The point\n * must be within the shape.\n * @param δ3s - The three boundary pieces of which we need to find the three\n * 3-prong points.\n * @param bezierPiece3s\n * @param extreme\n */\nfunction calcInitial3ProngCenter(δ3s, bezierPiece3s) {\n    let twoProngCircleCenter = δ3s[0][0].cp.circle.center;\n    /*\n    let twoProngCircleCenter =\n        mean([\n            δ3s[0][0].cp.pointOnShape.p,\n            δ3s[2][1].cp.pointOnShape.p\n        ]);\n        */\n    //_debug_.fs.draw.dot(_debug_.generated.g, twoProngCircleCenter, 0.05, 'blue');\n    let pos = get_closest_boundary_point_1.getClosestBoundaryPoint(bezierPiece3s[1], twoProngCircleCenter, undefined, // curve\n    undefined // t\n    );\n    let meanPoints = [\n        δ3s[0][0].cp.pointOnShape.p,\n        pos.p,\n        δ3s[2][1].cp.pointOnShape.p,\n    ];\n    return flo_vector2d_1.circumCenter(meanPoints);\n}\nexports.calcInitial3ProngCenter = calcInitial3ProngCenter;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/find-mat/find-3-prong/calc-initial-3-prong-center.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/find-mat/find-3-prong/find-3-prong-for-delta3s.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/find-mat/find-3-prong/find-3-prong-for-delta3s.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\nconst circle_1 = __webpack_require__(/*! ../../../circle */ \"./node_modules/flo-mat/node/src/circle.js\");\nconst point_on_shape_1 = __webpack_require__(/*! ../../../point-on-shape */ \"./node_modules/flo-mat/node/src/point-on-shape.js\");\nconst get_closest_boundary_point_1 = __webpack_require__(/*! ../../get-closest-boundary-point */ \"./node_modules/flo-mat/node/src/mat/get-closest-boundary-point.js\");\nconst calc_initial_3_prong_center_1 = __webpack_require__(/*! ./calc-initial-3-prong-center */ \"./node_modules/flo-mat/node/src/mat/find-mat/find-3-prong/calc-initial-3-prong-center.js\");\nconst get_closest_points_1 = __webpack_require__(/*! ./get-closest-points */ \"./node_modules/flo-mat/node/src/mat/find-mat/find-3-prong/get-closest-points.js\");\nconst calc_better_x_1 = __webpack_require__(/*! ./calc-better-x */ \"./node_modules/flo-mat/node/src/mat/find-mat/find-3-prong/calc-better-x.js\");\nconst curve_1 = __webpack_require__(/*! ../../../curve */ \"./node_modules/flo-mat/node/src/curve.js\");\nconst calcVectorToZeroV_StraightToIt = flo_vector2d_1.fromTo;\n/**\n * Finds a 3-prong using only the 3 given δs.\n * @param δs The boundary pieces\n * @param idx δ identifier\n * @param bezierPiecess\n * @param extreme The maximum coordinate value used to calculate floating point\n * tolerances.\n */\nfunction find3ProngForDelta3s(δs, idx, k, bezierPiecess, extreme) {\n    const TOLERANCE = extreme * 1e-10;\n    const MAX_ITERATIONS = 10;\n    //k = 0;\n    /*\n    let δ3s = [\n        δs[0],\n        δs[idx],\n        δs[δs.length-1]\n    ];\n    */\n    let δs_ = [\n        δs[0],\n        δs[idx],\n        δs[δs.length - 1]\n    ];\n    /*\n    let bezierPiece3s = [\n        bezierPiecess[0],\n        bezierPiecess[idx],\n        bezierPiecess[δs.length-1]\n    ];\n    */\n    let bezierPieces_ = [\n        bezierPiecess[0],\n        bezierPiecess[idx],\n        bezierPiecess[δs.length - 1]\n    ];\n    let δ3ss = [\n        [δs_[0], δs_[1], δs_[2]],\n        [δs_[1], δs_[2], δs_[0]],\n        [δs_[2], δs_[0], δs_[1]],\n    ];\n    let bezierPiecess_ = [\n        [bezierPieces_[0], bezierPieces_[1], bezierPieces_[2]],\n        [bezierPieces_[1], bezierPieces_[2], bezierPieces_[0]],\n        [bezierPieces_[2], bezierPieces_[0], bezierPieces_[1]],\n    ];\n    let δ3s = δ3ss[k];\n    let bezierPiece3s = bezierPiecess_[k];\n    if (δ3s[0][0].isSharp()) {\n        return undefined;\n    }\n    let ps;\n    let circumCenter_;\n    let j = 0; // Safeguard for slow convergence\n    let x = calc_initial_3_prong_center_1.calcInitial3ProngCenter(δ3s, bezierPiece3s);\n    if (typeof _debug_ !== 'undefined') {\n        let threeProngs = _debug_.generated.elems.threeProng;\n        let d = threeProngs[threeProngs.length - 1];\n        let trace = d.traces[d.traces.length - 1];\n        trace.push(x);\n    }\n    let tolerance = Number.POSITIVE_INFINITY;\n    while (tolerance > TOLERANCE && j < MAX_ITERATIONS) {\n        j++;\n        ps = get_closest_points_1.getClosestPoints(x, bezierPiece3s);\n        if (!Number.isFinite(x[0]) || !Number.isFinite(x[1])) {\n            // TODO - the code can be cleaned up and sped up a lot if we don't\n            // use this function as is but instead use δs[0] and δs[2] as is\n            // and make δs[1] include all the rest of the beziers around the \n            // loop. This check, for instance, would be eliminated completely.\n            return undefined;\n        }\n        circumCenter_ = flo_vector2d_1.circumCenter(ps.map(x => x.p));\n        let vectorToZeroV = calcVectorToZeroV_StraightToIt(x, circumCenter_);\n        //console.log('' + x[0] + ' ' + x[1])\n        //console.log('' + vectorToZeroV[0] + ' ' + vectorToZeroV[1]);\n        if (!Number.isFinite(vectorToZeroV[0]) || !Number.isFinite(vectorToZeroV[1])) {\n            // TODO - the code can be cleaned up and sped up a lot if we don't\n            // use this function as is but instead use δs[0] and δs[2] as is\n            // and make δs[1] include all the rest of the beziers around the \n            // loop. This check, for instance, would be eliminated completely.\n            return undefined;\n        }\n        let upds = calc_better_x_1.calcBetterX(bezierPiece3s, x, vectorToZeroV);\n        x = upds.newX;\n        ps = upds.newPs;\n        if (typeof _debug_ !== 'undefined') {\n            let threeProngs = _debug_.generated.elems.threeProng;\n            let d = threeProngs[threeProngs.length - 1];\n            let trace = d.traces[d.traces.length - 1];\n            trace.push(x);\n        }\n        let V = flo_vector2d_1.len(vectorToZeroV); // The 'potential'\n        tolerance = Math.abs(V - upds.newV);\n    }\n    //_debug_.fs.draw.dot(_debug_.generated.g, x, 0.05);\n    let radius = (flo_vector2d_1.distanceBetween(x, ps[0].p) +\n        flo_vector2d_1.distanceBetween(x, ps[1].p) +\n        flo_vector2d_1.distanceBetween(x, ps[2].p)) / 3;\n    let circle = new circle_1.Circle(x, radius);\n    //-------------------------------------------------------------------------\n    // Calculate the unit tangent vector at 3-prong circle points - they should \n    // be very close to tangent to the boundary piece tangents at those points \n    // (up to sign). Sharp corners are a common special case.\n    //-------------------------------------------------------------------------\n    let totalAngleError = 0;\n    for (let i = 0; i < 3; i++) {\n        let p = ps[i];\n        //----------------------------\n        // Tangent of circle at point\n        //----------------------------\n        let v = flo_vector2d_1.toUnitVector(flo_vector2d_1.fromTo(p.p, x));\n        let v1 = flo_vector2d_1.rotate90Degrees(v);\n        //-----------------------------------\n        // Check if point is on dull crorner\n        //-----------------------------------\n        if (point_on_shape_1.PointOnShape.isDullCorner(p)) {\n            let corner = curve_1.Curve.getCornerAtEnd(p.curve);\n            let tans = corner.tans;\n            let perps = tans.map(flo_vector2d_1.rotate90Degrees);\n            let angleError1 = Math.asin(flo_vector2d_1.cross(perps[0], v));\n            let angleError2 = Math.asin(flo_vector2d_1.cross(v, perps[1]));\n            let angleError = 0;\n            if (angleError1 > 0) {\n                angleError += angleError1;\n            }\n            if (angleError2 > 0) {\n                angleError += angleError2;\n            }\n            totalAngleError += angleError;\n        }\n        else {\n            //---------------------------\n            // Tangent of curve at point\n            //---------------------------\n            let v2 = flo_vector2d_1.toUnitVector(flo_bezier3_1.tangent(p.curve.ps, p.t));\n            // Cross is more numerically stable than Vector.dot at angles a\n            // multiple of Math.PI **and** is close to the actual angle value\n            // and can thus just be added to cone method of looking at \n            // tolerance.\n            // Should be close to zero and is close to the actual angle.\n            let cross_ = Math.abs(Math.asin(flo_vector2d_1.cross(v1, v2)));\n            totalAngleError += cross_;\n        }\n    }\n    //-------------------------------------------------------------------------\n    // Calculate radiusDelta, the difference between the radius and the closest\n    // point to the 3-prong. It should be around 0. If not, this is not a good \n    // candidate for the 3-prong.\n    //-------------------------------------------------------------------------\n    let closestDs = [];\n    for (let i = 0; i < bezierPiecess.length; i++) {\n        let p = get_closest_boundary_point_1.getClosestBoundaryPoint(bezierPiecess[i], x, undefined, undefined);\n        closestDs.push(flo_vector2d_1.distanceBetween(p.p, x));\n    }\n    let closestD = Math.min(...closestDs);\n    let radiusDelta = Math.abs(radius - closestD);\n    // Weights below still need to be optimized.\n    let W1 = 1;\n    let W2 = 1;\n    let error = W1 * radiusDelta + W2 * totalAngleError;\n    return { ps, circle, error, δ3s };\n}\nexports.find3ProngForDelta3s = find3ProngForDelta3s;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/find-mat/find-3-prong/find-3-prong-for-delta3s.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/find-mat/find-3-prong/find-3-prong.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/find-mat/find-3-prong/find-3-prong.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\nconst three_prong_for_debugging_1 = __webpack_require__(/*! ../../../debug/three-prong-for-debugging */ \"./node_modules/flo-mat/node/src/debug/three-prong-for-debugging.js\");\nconst find_3_prong_for_delta3s_1 = __webpack_require__(/*! ./find-3-prong-for-delta3s */ \"./node_modules/flo-mat/node/src/mat/find-mat/find-3-prong/find-3-prong-for-delta3s.js\");\nconst get_boundary_piece_beziers_1 = __webpack_require__(/*! ../../get-boundary-piece-beziers */ \"./node_modules/flo-mat/node/src/mat/get-boundary-piece-beziers.js\");\n/**\n * Find and return a 3-prong from the given boundary piece.\n * @param δs A boundary piece\n * @param extreme The maximum coordinate value used to calculate floating point\n * tolerances.\n */\nfunction find3Prong(δs, extreme) {\n    let bezierPiecess = δs.map(get_boundary_piece_beziers_1.getBoundaryPieceBeziers);\n    if (typeof _debug_ !== 'undefined') {\n        let threeProngs = _debug_.generated.elems.threeProng;\n        threeProngs.push(new three_prong_for_debugging_1.ThreeProngForDebugging());\n        let d = threeProngs[threeProngs.length - 1];\n        d.boundaries = [];\n        for (let bezierPieces of bezierPiecess) {\n            let boundary = [];\n            d.boundaries.push(boundary);\n            for (let bezierPiece of bezierPieces) {\n                let bezier = flo_bezier3_1.fromTo(bezierPiece.curve.ps)(bezierPiece.ts[0], bezierPiece.ts[1]);\n                boundary.push(bezier);\n            }\n        }\n        d.traces = [];\n    }\n    let candidateThreeProngs = [];\n    // The best candidate amongst the different 'permutations' of the given δs.\n    let threeProng;\n    let bestIndx = undefined;\n    let smallestError = Number.POSITIVE_INFINITY;\n    for (let i = 1; i < δs.length - 1; i++) {\n        for (let k = 0; k < 3; k++) {\n            //let k = 0;\n            if (typeof _debug_ !== 'undefined') {\n                let threeProngs = _debug_.generated.elems.threeProng;\n                let d = threeProngs[threeProngs.length - 1];\n                let trace = [];\n                d.traces.push(trace);\n            }\n            let threeProngInfo = find_3_prong_for_delta3s_1.find3ProngForDelta3s(δs, i, k, bezierPiecess, extreme);\n            if (!threeProngInfo) {\n                continue;\n            }\n            let { circle, ps, error, δ3s } = threeProngInfo;\n            if (typeof _debug_ !== 'undefined') {\n                candidateThreeProngs.push({ circle, ps });\n            }\n            if (error < smallestError) {\n                smallestError = error;\n                bestIndx = i - 1;\n                threeProng = { circle, ps, δ3s };\n            }\n        }\n    }\n    //threeProng.δ3s = [δs[0], δs[bestIndx+1], δs[δs.length-1]];\n    if (typeof _debug_ !== 'undefined') {\n        let threeProngs = _debug_.generated.elems.threeProng;\n        let d = threeProngs[threeProngs.length - 1];\n        d.generated = _debug_.generated;\n        d.circle = threeProng.circle,\n            d.poss = threeProng.ps;\n        d.cp3ss = threeProng.δ3s;\n        d.cpss = δs;\n        d.bestIndx = bestIndx;\n        d.candidateThreeProngs = candidateThreeProngs;\n    }\n    return threeProng;\n}\nexports.find3Prong = find3Prong;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/find-mat/find-3-prong/find-3-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/find-mat/find-3-prong/get-closest-points.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/find-mat/find-3-prong/get-closest-points.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst get_closest_boundary_point_1 = __webpack_require__(/*! ../../get-closest-boundary-point */ \"./node_modules/flo-mat/node/src/mat/get-closest-boundary-point.js\");\n/**\n *\n * @param x\n * @param bezierPiece3s\n * @param extreme\n */\nfunction getClosestPoints(x, bezierPiece3s) {\n    return bezierPiece3s.map(bezierPieces => {\n        return get_closest_boundary_point_1.getClosestBoundaryPoint(bezierPieces, x, undefined, // curve\n        undefined // t\n        );\n    });\n}\nexports.getClosestPoints = getClosestPoints;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/find-mat/find-3-prong/get-closest-points.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/find-mat/find-and-add-2-prongs-on-all-paths.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/find-mat/find-and-add-2-prongs-on-all-paths.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst find_and_add_2_prongs_1 = __webpack_require__(/*! ./find-and-add-2-prongs */ \"./node_modules/flo-mat/node/src/mat/find-mat/find-and-add-2-prongs.js\");\n/**\n * Add 2 prongs. See comments on the add2Prong function.\n * @param loops\n * @param cpGraphs\n * @param for2Prongss\n * @param extreme The maximum coordinate value used to calculate floating point\n * tolerances.\n */\nfunction findAndAdd2ProngsOnAllPaths(loops, cpGraphs, for2Prongss, extreme) {\n    let cpNode;\n    for (let k = 0; k < for2Prongss.length; k++) {\n        let for2Prongs = for2Prongss[k];\n        cpNode = find_and_add_2_prongs_1.findAndAdd2Prongs(loops, cpGraphs, k, for2Prongs, extreme);\n    }\n    return cpNode;\n}\nexports.findAndAdd2ProngsOnAllPaths = findAndAdd2ProngsOnAllPaths;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/find-mat/find-and-add-2-prongs-on-all-paths.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/find-mat/find-and-add-2-prongs.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/find-mat/find-and-add-2-prongs.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst svg_1 = __webpack_require__(/*! ../../svg/svg */ \"./node_modules/flo-mat/node/src/svg/svg.js\");\nconst find_2_prong_1 = __webpack_require__(/*! ./find-2-prong/find-2-prong */ \"./node_modules/flo-mat/node/src/mat/find-mat/find-2-prong/find-2-prong.js\");\nconst add_2_prong_1 = __webpack_require__(/*! ./add-2-prong */ \"./node_modules/flo-mat/node/src/mat/find-mat/add-2-prong.js\");\n/**\n * Find and add two-prongs.\n * @param loops\n * @param cpGraphs\n * @param k\n * @param for2Prongs\n * @param extreme The maximum coordinate value used to calculate floating point\n * tolerances.\n */\nfunction findAndAdd2Prongs(loops, cpGraphs, k, for2Prongs, extreme) {\n    let len = for2Prongs.length;\n    let index = indexLinear(len); // Keep for possible future use.\n    //let index = indexInterlaced(len);\n    let cpNode_;\n    let bounds = svg_1.getShapeBounds(loops);\n    let squaredDiagonalLength = Math.pow((bounds.maxX.p[0] - bounds.minX.p[0]), 2) +\n        Math.pow((bounds.maxY.p[1] - bounds.minY.p[1]), 2);\n    //console.log(Math.sqrt(squaredDiagonalLength));\n    for (let i = 0; i < len; i++) {\n        let pos = for2Prongs[index[i]];\n        let twoProngInfo;\n        twoProngInfo = find_2_prong_1.find2Prong(loops, extreme, squaredDiagonalLength, cpGraphs, pos, false, k);\n        if (twoProngInfo) {\n            let { circle, z } = twoProngInfo;\n            let cpNode = add_2_prong_1.add2Prong(cpGraphs, circle, pos, z, false, extreme);\n            if (!cpNode_ && cpNode) {\n                cpNode_ = cpNode;\n            }\n        }\n    }\n    return cpNode_;\n}\nexports.findAndAdd2Prongs = findAndAdd2Prongs;\n/**\n * Simple linear array indexing.\n * @param n\n */\nfunction indexLinear(n) {\n    let arr = [];\n    for (let i = 0; i < n; i++) {\n        arr.push(i);\n    }\n    return arr;\n}\n/**\n * Creates a kind of interlaced index vector.\n * @param n\n*/\nfunction indexInterlaced(n) {\n    let source = {};\n    let arr = [];\n    // l is the lowest power of 2 so that 2^l > n\n    let l = Math.pow(2, Math.floor(Math.log2(n)));\n    while (l >= 1) {\n        let k = 0;\n        while (k < n) {\n            if (!source[k]) {\n                arr.push(k);\n                source[k] = true;\n            }\n            k = k + l;\n        }\n        l = l / 2;\n    }\n    return arr;\n}\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/find-mat/find-and-add-2-prongs.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/find-mat/find-and-add-3-prongs.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/find-mat/find-and-add-3-prongs.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst point_on_shape_1 = __webpack_require__(/*! ../../point-on-shape */ \"./node_modules/flo-mat/node/src/point-on-shape.js\");\nconst find_3_prong_1 = __webpack_require__(/*! ./find-3-prong/find-3-prong */ \"./node_modules/flo-mat/node/src/mat/find-mat/find-3-prong/find-3-prong.js\");\nconst add_3_prong_1 = __webpack_require__(/*! ../find-mat/add-3-prong */ \"./node_modules/flo-mat/node/src/mat/find-mat/add-3-prong.js\");\n/**\n * Finds and adds all 3-prongs.\n * @param cpGraphs\n * @param cpStart The CpNode to start traversing from.\n * @param extreme The maximum coordinate value used to calculate floating point\n * tolerances.\n */\nfunction findAndAddAll3Prongs(cpGraphs, cpStart, extreme) {\n    // Don't change this function to be recursive, the call stack may overflow \n    // if there are too many two-prongs.\n    let visitedEdges = new Map();\n    let edgesToCheck = [{ fromCpNode: undefined, cpStart }];\n    while (edgesToCheck.length) {\n        let { fromCpNode, cpStart } = edgesToCheck.shift();\n        markEdgeAsTaken(visitedEdges, fromCpNode, cpStart);\n        for (let cpNode of cpStart.getNodes()) {\n            if (!point_on_shape_1.PointOnShape.isSharpCorner(cpNode.cp.pointOnShape)) {\n                findAndAdd3Prongs(cpGraphs, cpNode, extreme);\n            }\n            if (hasEdgeBeenTaken(visitedEdges, cpNode, cpNode.next)) {\n                continue; // We already visited this edge\n            }\n            edgesToCheck.push({ fromCpNode: cpStart, cpStart: cpNode.next });\n        }\n    }\n}\nexports.findAndAddAll3Prongs = findAndAddAll3Prongs;\n/**\n * Marks the given edge as already taken.\n */\nfunction markEdgeAsTaken(visitedEdges, cp1, cp2) {\n    if (cp1 === undefined) {\n        return;\n    }\n    f(cp1, cp2);\n    f(cp2, cp1);\n    function f(cp1, cp2) {\n        let visited = visitedEdges.get(cp1);\n        if (!visited) {\n            visited = new Set();\n            visitedEdges.set(cp1, visited);\n        }\n        visited.add(cp2);\n    }\n}\nfunction hasEdgeBeenTaken(visitedEdges, cp1, cp2) {\n    let cps;\n    cps = visitedEdges.get(cp1);\n    let takenForward = cps && cps.has(cp2);\n    cps = visitedEdges.get(cp2);\n    let takenBackwards = cps && cps.has(cp1);\n    return takenForward || takenBackwards;\n}\n/**\n * Traverses the shape from the given ContactPoint going around contact circles\n * so that only a piece of the shape is traversed and returns the visited\n * CpNodes (starting from the given CpNode).\n * @param cpStart The ContactPoint from where to start the traversal.\n */\nfunction traverseShape(cpStart) {\n    let cpNode = cpStart;\n    if (cpNode === cpNode.next.prevOnCircle) {\n        return [cpNode];\n    }\n    let visitedCps = [];\n    do {\n        visitedCps.push(cpNode);\n        let next = cpNode.next.prevOnCircle;\n        cpNode = cpNode === next\n            ? cpNode = cpNode.next.next // Terminal vertex\n            : cpNode = next; // Take last exit\n    } while (cpNode !== cpStart);\n    return visitedCps;\n}\n/**\n * Starting from some ContactPoint, traverses the shape going around Vertices\n * and if more than two Vertices have been visited in total then recursively\n * adds 3-prongs until only one or two Vertices have been visited.\n *\n * This process further subdivides the shape.\n * @param cpGraphs\n * @param cpStart The ContactPoint from where to start the process.\n * @param extreme The maximum coordinate value used to calculate floating point\n * tolerances.\n */\nfunction findAndAdd3Prongs(cpGraphs, cpStart, extreme) {\n    let visitedCps;\n    do {\n        visitedCps = traverseShape(cpStart);\n        if (visitedCps.length > 2) {\n            findAndAdd3Prong(cpGraphs, visitedCps, extreme);\n        }\n    } while (visitedCps.length > 2);\n    return visitedCps;\n}\n/**\n * Finds and add a 3-prong MAT circle to the given shape.\n * @param cpGraphs\n * @param visitedCps\n * @param extreme The maximum coordinate value used to calculate floating point\n * tolerances.\n */\nfunction findAndAdd3Prong(cpGraphs, visitedCps, extreme) {\n    let δs = [];\n    for (let visitedCp of visitedCps) {\n        δs.push([visitedCp, visitedCp.next]);\n    }\n    let threeProng = find_3_prong_1.find3Prong(δs, extreme);\n    let orders = [];\n    for (let i = 0; i < 3; i++) {\n        orders.push(point_on_shape_1.PointOnShape.calcOrder(threeProng.circle, threeProng.ps[i]));\n    }\n    let circle = add_3_prong_1.add3Prong(cpGraphs, orders, threeProng);\n    if (typeof _debug_ !== 'undefined') {\n        add3ProngDebugInfo(circle, visitedCps);\n    }\n}\nfunction add3ProngDebugInfo(circle, visitedCps) {\n    let threeProngs = _debug_.generated.elems.threeProng;\n    let len = threeProngs.length;\n    let data = threeProngs[len - 1];\n    data.visitedCps = visitedCps;\n    data.circle = circle;\n}\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/find-mat/find-and-add-3-prongs.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/find-mat/find-and-add-hole-closing-2-prongs.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/find-mat/find-and-add-hole-closing-2-prongs.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst svg_1 = __webpack_require__(/*! ../../svg/svg */ \"./node_modules/flo-mat/node/src/svg/svg.js\");\nconst find_2_prong_1 = __webpack_require__(/*! ./find-2-prong/find-2-prong */ \"./node_modules/flo-mat/node/src/mat/find-mat/find-2-prong/find-2-prong.js\");\nconst add_2_prong_1 = __webpack_require__(/*! ./add-2-prong */ \"./node_modules/flo-mat/node/src/mat/find-mat/add-2-prong.js\");\n/**\n * Find and add two-prongs that remove any holes in the shape.\n * @param loops\n * @param cpTrees\n * @param extreme The maximum coordinate value used to calculate floating point\n * tolerances.\n */\nfunction findAndAddHoleClosing2Prongs(loops, cpTrees, extreme) {\n    let bounds = svg_1.getShapeBounds(loops);\n    let squaredDiagonalLength = Math.pow((bounds.maxX.p[0] - bounds.minX.p[0]), 2) +\n        Math.pow((bounds.maxY.p[1] - bounds.minY.p[1]), 2);\n    // Find the topmost points on each loop.\n    let minYs = loops.map(svg_1.getMinYPos);\n    for (let k = 1; k < minYs.length; k++) {\n        let posSource = minYs[k];\n        //console.log(posSource.t);\n        //console.log(posSource.p[1]);\n        let holeClosingTwoProng = find_2_prong_1.find2Prong(loops, extreme, squaredDiagonalLength, cpTrees, posSource, true, k);\n        if (!holeClosingTwoProng) {\n            throw 'unable to find hole-closing 2-prong';\n        }\n        if (holeClosingTwoProng) {\n            let { circle, z: posAntipode } = holeClosingTwoProng;\n            add_2_prong_1.add2Prong(cpTrees, circle, posSource, posAntipode, true, extreme);\n        }\n    }\n}\nexports.findAndAddHoleClosing2Prongs = findAndAddHoleClosing2Prongs;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/find-mat/find-and-add-hole-closing-2-prongs.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/find-mat/find-mats.js":
/*!*****************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/find-mat/find-mats.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\nconst mat_1 = __webpack_require__(/*! ../../mat */ \"./node_modules/flo-mat/node/src/mat.js\");\nconst get_loop_bounds_1 = __webpack_require__(/*! ../../svg/fs/get-loop-bounds */ \"./node_modules/flo-mat/node/src/svg/fs/get-loop-bounds.js\");\nconst simplify_paths_1 = __webpack_require__(/*! ../../svg/fs/simplify-paths/simplify-paths */ \"./node_modules/flo-mat/node/src/svg/fs/simplify-paths/simplify-paths.js\");\nconst find_and_add_3_prongs_1 = __webpack_require__(/*! ../find-mat/find-and-add-3-prongs */ \"./node_modules/flo-mat/node/src/mat/find-mat/find-and-add-3-prongs.js\");\nconst create_initial_cp_graph_1 = __webpack_require__(/*! ../find-mat/create-initial-cp-graph */ \"./node_modules/flo-mat/node/src/mat/find-mat/create-initial-cp-graph.js\");\n;\nconst add_debug_info_1 = __webpack_require__(/*! ../find-mat/add-debug-info */ \"./node_modules/flo-mat/node/src/mat/find-mat/add-debug-info.js\");\nconst get_potential_2_prongs_1 = __webpack_require__(/*! ../find-mat/get-potential-2-prongs */ \"./node_modules/flo-mat/node/src/mat/find-mat/get-potential-2-prongs.js\");\nconst create_get_interesting_points_on_loop_1 = __webpack_require__(/*! ./create-get-interesting-points-on-loop */ \"./node_modules/flo-mat/node/src/mat/find-mat/create-get-interesting-points-on-loop.js\");\nconst get_sharp_corners_1 = __webpack_require__(/*! ../find-mat/get-sharp-corners */ \"./node_modules/flo-mat/node/src/mat/find-mat/get-sharp-corners.js\");\nconst get_extreme_1 = __webpack_require__(/*! ../../svg/fs/get-extreme */ \"./node_modules/flo-mat/node/src/svg/fs/get-extreme.js\");\nconst smoothen_1 = __webpack_require__(/*! ../smoothen/smoothen */ \"./node_modules/flo-mat/node/src/mat/smoothen/smoothen.js\");\nconst find_and_add_2_prongs_on_all_paths_1 = __webpack_require__(/*! ./find-and-add-2-prongs-on-all-paths */ \"./node_modules/flo-mat/node/src/mat/find-mat/find-and-add-2-prongs-on-all-paths.js\");\nconst find_and_add_hole_closing_2_prongs_1 = __webpack_require__(/*! ./find-and-add-hole-closing-2-prongs */ \"./node_modules/flo-mat/node/src/mat/find-mat/find-and-add-hole-closing-2-prongs.js\");\nlet { m1: memoize } = flo_memoize_1.default;\n/**\n * Find the MAT from the given Shape.\n * @param loops An array of (possibly intersecting) Loops representing one or\n * more closed curves (i.e. shapes)\n * @param additionalPointCount Additional points per bezier where a MAT circle\n * will be added. Defaults to 3.\n */\nfunction findMats(loops, additionalPointCount = 3) {\n    if (typeof _debug_ !== 'undefined') {\n        let timing = _debug_.generated.timing;\n        timing.simplify[0] = performance.now();\n    }\n    //let loops_ = loops.map(loop => Loop.perturb(loop, 10))\n    let { loopss, xMap } = simplify_paths_1.simplifyPaths(loops);\n    if (typeof _debug_ !== 'undefined') {\n        let timing = _debug_.generated.timing;\n        timing.simplify[1] += performance.now() - timing.simplify[0];\n    }\n    let mats = [];\n    for (let loops of loopss) {\n        loops.sort(ascendingByTopmostPoint);\n        //loops = orient(loops);\n        let mat = findPartialMat(loops, xMap, additionalPointCount);\n        if (mat) {\n            mats.push(mat);\n        }\n    }\n    return mats;\n}\nexports.findMats = findMats;\nfunction findPartialMat(loops, xMap, additionalPointCount = 3) {\n    let extreme = get_extreme_1.getExtreme(loops);\n    add_debug_info_1.addDebugInfo1(loops);\n    // Gets interesting points on the shape, i.e. those that makes sense to use \n    // for the 2-prong procedure.\n    let f = create_get_interesting_points_on_loop_1.createGetInterestingPointsOnLoop(additionalPointCount);\n    let pointsPerLoop = loops.map(f);\n    let for2ProngsPerLoop = get_potential_2_prongs_1.getPotential2Prongs(pointsPerLoop);\n    let sharpCornersPerLoop = get_sharp_corners_1.getSharpCorners(pointsPerLoop);\n    let cpTrees = new Map();\n    let cpNode = create_initial_cp_graph_1.createInitialCpGraph(loops, cpTrees, sharpCornersPerLoop, xMap);\n    find_and_add_hole_closing_2_prongs_1.findAndAddHoleClosing2Prongs(loops, cpTrees, extreme);\n    if (typeof _debug_ !== 'undefined') {\n        if (_debug_.directives.stopAfterHoleClosers) {\n            return undefined;\n        }\n    }\n    add_debug_info_1.addDebugInfo2(pointsPerLoop);\n    cpNode = find_and_add_2_prongs_on_all_paths_1.findAndAdd2ProngsOnAllPaths(loops, cpTrees, for2ProngsPerLoop, extreme);\n    if (typeof _debug_ !== 'undefined') {\n        if (_debug_.directives.stopAfterTwoProngs) {\n            return undefined;\n        }\n    }\n    add_debug_info_1.addDebugInfo3();\n    if (cpNode === undefined) {\n        return undefined;\n    }\n    find_and_add_3_prongs_1.findAndAddAll3Prongs(cpTrees, cpNode, extreme);\n    if (typeof _debug_ !== 'undefined') {\n        if (_debug_.directives.stopAfterThreeProngs) {\n            return undefined;\n        }\n    }\n    let mat = new mat_1.Mat(cpNode, cpTrees);\n    smoothen_1.smoothen(mat.cpNode);\n    add_debug_info_1.addDebugInfo4(mat);\n    return mat;\n}\n/**\n *\n * @param loopA\n * @param loopB\n */\nfunction ascendingByTopmostPoint(loopA, loopB) {\n    let boundsA = get_loop_bounds_1.getLoopBounds(loopA);\n    let boundsB = get_loop_bounds_1.getLoopBounds(loopB);\n    let a = boundsA.minY.p[1];\n    let b = boundsB.minY.p[1];\n    return a - b;\n}\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/find-mat/find-mats.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/find-mat/get-potential-2-prongs.js":
/*!******************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/find-mat/get-potential-2-prongs.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst point_on_shape_1 = __webpack_require__(/*! ../../point-on-shape */ \"./node_modules/flo-mat/node/src/point-on-shape.js\");\nfunction getPotential2Prongs(possPerLoop) {\n    let for2ProngsArray = [];\n    for (let poss of possPerLoop) {\n        let for2Prongs = [];\n        for (let pos of poss) {\n            if (!point_on_shape_1.PointOnShape.isQuiteSharpCorner(pos)) {\n                for2Prongs.push(pos);\n            }\n        }\n        for2ProngsArray.push(for2Prongs);\n    }\n    return for2ProngsArray;\n}\nexports.getPotential2Prongs = getPotential2Prongs;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/find-mat/get-potential-2-prongs.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/find-mat/get-sharp-corners.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/find-mat/get-sharp-corners.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst point_on_shape_1 = __webpack_require__(/*! ../../point-on-shape */ \"./node_modules/flo-mat/node/src/point-on-shape.js\");\nfunction getSharpCorners(possPerLoop) {\n    let sharpCornersPerLoop = [];\n    for (let poss of possPerLoop) {\n        let sharpCorners = [];\n        for (let pos of poss) {\n            if (point_on_shape_1.PointOnShape.isQuiteSharpCorner(pos)) {\n                sharpCorners.push(pos);\n            }\n        }\n        sharpCornersPerLoop.push(sharpCorners);\n    }\n    return sharpCornersPerLoop;\n}\nexports.getSharpCorners = getSharpCorners;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/find-mat/get-sharp-corners.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/geometry/get-closest-square-distance-to-rect.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/geometry/get-closest-square-distance-to-rect.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\n/**\n *\n */\nfunction getClosestSquareDistanceToRect(box, p) {\n    let [[x0, y0], [x1, y1]] = box;\n    let [xp, yp] = p;\n    if (xp < x0) {\n        if (yp < y0) {\n            return flo_vector2d_1.squaredDistanceBetween(box[0], p);\n        }\n        else if (yp > y1) {\n            return flo_vector2d_1.squaredDistanceBetween([x0, y1], p);\n        }\n        else {\n            let d = x0 - xp;\n            return d * d;\n        }\n    }\n    else if (xp > x1) {\n        if (yp < y0) {\n            return flo_vector2d_1.squaredDistanceBetween([x1, y0], p);\n        }\n        else if (yp > y1) {\n            return flo_vector2d_1.squaredDistanceBetween(box[1], p);\n        }\n        else {\n            let d = xp - x1;\n            return d * d;\n        }\n    }\n    else {\n        if (yp < y0) {\n            let d = y0 - yp;\n            return d * d;\n        }\n        else if (yp > y1) {\n            let d = yp - y1;\n            return d * d;\n        }\n        else {\n            return 0;\n        }\n    }\n}\nexports.getClosestSquareDistanceToRect = getClosestSquareDistanceToRect;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/geometry/get-closest-square-distance-to-rect.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/geometry/get-closest-squared-distance-to-rotated-rect.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/geometry/get-closest-squared-distance-to-rotated-rect.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\n/**\n *\n */\nfunction getClosestSquaredDistanceToRotatedRect(ps, p) {\n    let ds = [0, 1, 2, 3].map(i => flo_vector2d_1.squaredDistanceBetweenPointAndLineSegment(p, [ps[i], ps[(i + 1) % 4]]));\n    let width = flo_vector2d_1.squaredDistanceBetween(ps[0], ps[1]);\n    let height = flo_vector2d_1.squaredDistanceBetween(ps[0], ps[3]);\n    if (ds[0] <= height && ds[2] <= height &&\n        ds[1] <= width && ds[3] <= width) {\n        return 0; // Inside rotated rect\n    }\n    return Math.min(...ds);\n}\nexports.getClosestSquaredDistanceToRotatedRect = getClosestSquaredDistanceToRotatedRect;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/geometry/get-closest-squared-distance-to-rotated-rect.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/geometry/line-line-intersection.js":
/*!******************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/geometry/line-line-intersection.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Find point where two lines intersect. Returns he point where the two lines\n * intersect or undefined if they don't intersect or are the same line.\n * @param l1 - A line\n * @param l2 - Another line\n */\nfunction lineLineIntersection(l1, l2) {\n    let [[p1x, p1y], [p2x, p2y]] = l1;\n    let [[p3x, p3y], [p4x, p4y]] = l2;\n    let v1x = p2x - p1x;\n    let v1y = p2y - p1y;\n    let v2x = p4x - p3x;\n    let v2y = p4y - p3y;\n    let cross = v2x * v1y - v2y * v1x;\n    if (cross === 0) {\n        // parallel\n        return undefined;\n    }\n    let b = ((p3y - p1y) * v1x - (p3x - p1x) * v1y) / cross;\n    return [p3x + b * v2x, p3y + b * v2y];\n}\nexports.lineLineIntersection = lineLineIntersection;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/geometry/line-line-intersection.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/get-bezier-curvature-extrema-brackets.js":
/*!************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/get-bezier-curvature-extrema-brackets.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst DELTA = 1e-6;\n/**\n * Calculates the curvature extrema brackets of the given cubic bezier.\n * See the paper at http://ac.els-cdn.com/S037704270000529X/1-s2.0-S037704270000529X-main.pdf?_tid=0b25a2cc-ad35-11e5-a728-00000aacb362&acdnat=1451288083_86359fc83af9dec3232c90a6d2e71031\n * Note that naming conventions is roughly as in the paper above.\n * @param ps\n */\nfunction calcBezierCurvatureExtremaBrackets(ps) {\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n    let brackets = [];\n    // Bezier points translated to origin;\n    let P_1x = x1 - x0;\n    let P_1y = y1 - y0;\n    let P_2x = x2 - x0;\n    let P_2y = y2 - y0;\n    let P_3x = x3 - x0;\n    let P_3y = y3 - y0;\n    // Distance to consecutive points\n    let W_0x = P_1x;\n    let W_1x = P_2x - P_1x;\n    let W_2x = P_3x - P_2x;\n    let W_0y = P_1y;\n    let W_1y = P_2y - P_1y;\n    let W_2y = P_3y - P_2y;\n    // Check for degenerate case in which cubic curve becomes quadratic. \n    if ((Math.abs(W_0x - 2 * W_1x + W_2x) < DELTA) &&\n        (Math.abs(W_0y - 2 * W_1y + W_2y) < DELTA)) {\n        // TODO - This case is simpler due to being quadratic - still needs to\n        // be implemented!. \n    }\n    // See http://ac.els-cdn.com/S037704270000529X/1-s2.0-S037704270000529X-main.pdf?_tid=0b25a2cc-ad35-11e5-a728-00000aacb362&acdnat=1451288083_86359fc83af9dec3232c90a6d2e71031\n    // Rotate curve so that W0 - 2W1 + W2 = (0, (1/3)a), a != 0\n    let atan_numer = P_3x - 3 * P_2x + 3 * P_1x;\n    let atan_denom = P_3y - 3 * P_2y + 3 * P_1y;\n    let atan_numer_squared = atan_numer * atan_numer;\n    let atan_denom_squared = atan_denom * atan_denom;\n    let rad = Math.sqrt((atan_numer_squared / atan_denom_squared) + 1);\n    let cos_theta = 1 / rad;\n    let sin_theta;\n    if (cos_theta === 0) {\n        sin_theta = 1;\n    }\n    else {\n        sin_theta = atan_numer / (atan_denom * rad);\n    }\n    // Here we skip expensive trig evaluations\n    let R_1x = P_1x * cos_theta - P_1y * sin_theta;\n    let R_1y = P_1x * sin_theta + P_1y * cos_theta;\n    let R_2x = P_2x * cos_theta - P_2y * sin_theta;\n    let R_2y = P_2x * sin_theta + P_2y * cos_theta;\n    let R_3x = P_3x * cos_theta - P_3y * sin_theta;\n    let R_3y = P_3x * sin_theta + P_3y * cos_theta;\n    // Modify W_0x, etc. to be correct for new rotated curve \n    W_0x = R_1x;\n    W_1x = R_2x - R_1x;\n    W_2x = R_3x - R_2x;\n    W_0y = R_1y;\n    W_1y = R_2y - R_1y;\n    W_2y = R_3y - R_2y;\n    let a = 3 * (W_0y - 2 * W_1y + W_2y);\n    let dif = R_2x - 2 * R_1x; // which = W_1x - W_0x;\n    if (dif === 0) {\n        // Case 1 (special) - W_1x - W_0x === 0\n        // Degenerate to cubic function\t\n        if (W_0x !== 0) {\n            // TODO - finish!\n            // TODO - we also still need to check for degenerate cubic (see \n            // beginning of paper)\n        }\n        else {\n            // We have a straight line x=0!\n            return [];\n        }\n    }\n    else {\n        // Case 2 (usual) - W_1x - W_0x !== 0\n        if (dif < 0) {\n            // Reflect curve accross y-axis to make dif > 0\n            R_1x = -R_1x;\n            R_2x = -R_2x;\n            R_3x = -R_3x;\n            // Modify W_0x, etc. to be correct for new reflected \n            W_0x = -W_0x;\n            W_1x = -W_1x;\n            W_2x = -W_2x;\n            dif = -dif;\n        }\n        // From the paper:\n        // ---------------\n        // All curves has exactly one of 4 cases:\n        //\n        // 1. It has a single inflection point and exactly 2 curvature maxima \n        //    (symmetrically positioned about inflection point). This is the \n        //    case if dif === 0 in above code.\n        // 2. TODO - It has a single cusp - ignored for now!\n        // 3. It has a point of self-intersection - occurs if d < 0 in paper.\n        // 4. It has 2 inflection points, no cusps, no self-intersections.\n        //    It can have either 3 or 5 curvature extrema\n        //    a. The case of 5 curvature extrema is ignored for now - in the \n        //       paper it is mentioned to even find such a curve is difficult \n        //       and it seems such curves have very sharp curvature at one point \n        //       which does not usually occur in an SVG shape. But this case \n        //       should later be included or we'll miss some points.\n        //    b. There are 3 curvature extrema:\n        //       Extrema occur in the range (-inf, -sqrt(d)), \n        //       (-sqrt(d), sqrt(d)), (sqrt(d), inf). \n        //       Since we dont know how to select -inf and inf we will just \n        //       choose them to be -10 and 11 (remember bezier runs from t=0 to \n        //       t=1). If Brent's method runs out of the (0,1) interval we stop \n        //       and use 0 or 1 as the extremum? Remember extrema can also occur \n        //       at t=0 and t=1!\n        //\n        // TODO - At the moment we only test for case 1 and 4b, but in future \n        // we must test and eliminate the other cases.\n        let μ = 6 * dif;\n        let λ = (3 * a * W_0x) / (μ * μ);\n        let γ1 = (3 * a * W_0y) / (μ * μ);\n        let γ2 = (3 * (W_1y - W_0y)) / (μ);\n        let d = λ * λ - 2 * γ2 * λ + γ1;\n        let b = 2 * (γ2 - λ);\n        let deParamBoundary = deParameterizeBoundary(λ, μ, a);\n        if (d > 0) {\n            let ssigd_ = Math.sqrt(d);\n            // de-reparametize\n            // Note: the sda and sdb here are the inflection points forcase iv! \n            // there are easier ways to calculate these\n            let sda = -ssigd_;\n            let sdb = ssigd_;\n            brackets =\n                [\n                    [Number.NEGATIVE_INFINITY, sda],\n                    [sda, sdb],\n                    [sdb, Number.POSITIVE_INFINITY]\n                ]\n                    .map(deParamBoundary)\n                    .map(clipBoundary);\n        }\n        else if (d < 0) {\n            // It is a loop \n            // Note: The loop intersection may be outside t=[0,1] but curvature \n            // maxima may still occur inside t=[0,1] of course.\n            // There can be 1 or 3 maxima of curvature.\n            let ξ1_ = 2 * b * b - 8 * d - 3;\n            if (ξ1_ < 0) {\n                brackets = [[0, Math.sqrt(-3 * d)]]\n                    .map(deParamBoundary)\n                    .map(clipBoundary);\n            }\n            else {\n                let ξ2_ = Math.sqrt(5 * ξ1_);\n                let ξ1 = (-5 * b - ξ2_) / 10;\n                let ξ2 = (-5 * b + ξ2_) / 10;\n                brackets = [\n                    [Number.NEGATIVE_INFINITY, ξ1],\n                    [ξ1, Math.min(0, ξ2)],\n                    [Math.max(0, ξ2), Math.sqrt(-3 * d)]\n                ]\n                    .map(deParamBoundary)\n                    .map(clipBoundary);\n            }\n        }\n        else if (d === 0) {\n            // TODO - It is a cusp - still to implement!\n        }\n    }\n    return brackets;\n}\nexports.calcBezierCurvatureExtremaBrackets = calcBezierCurvatureExtremaBrackets;\n/**\n * Clips to [0,1] or returns undefined if not within [0,1].\n * @param range\n */\nfunction clipBoundary(range) {\n    let [a, b] = range;\n    if ((a < 0 && b < 0) || (a > 1 && b > 1)) {\n        return undefined;\n    }\n    if (a < 0) {\n        a = 0;\n    }\n    if (a > 1) {\n        a = 1;\n    }\n    if (b < 0) {\n        b = 0;\n    }\n    if (b > 1) {\n        b = 1;\n    }\n    return [a, b];\n}\n/**\n *\n * @param λ\n * @param μ\n * @param a\n */\nfunction deParameterize(λ, μ, a) {\n    return (σ) => (σ - λ) * (μ / a);\n}\n/**\n *\n * @param λ\n * @param μ\n * @param a\n */\nfunction deParameterizeBoundary(λ, μ, a) {\n    return (boundary) => boundary.map(deParameterize(λ, μ, a));\n}\n;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/get-bezier-curvature-extrema-brackets.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/get-bezier-curvature-extrema.js":
/*!***************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/get-bezier-curvature-extrema.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\nconst point_on_shape_1 = __webpack_require__(/*! ../point-on-shape */ \"./node_modules/flo-mat/node/src/point-on-shape.js\");\nconst get_bezier_curvature_extrema_brackets_1 = __webpack_require__(/*! ./get-bezier-curvature-extrema-brackets */ \"./node_modules/flo-mat/node/src/mat/get-bezier-curvature-extrema-brackets.js\");\n/**\n * Finds the osculating circles and inflection points for the given bezier.\n * @param curve\n */\nfunction getBezierCurvatureExtrema(curve) {\n    let maxCurvaturePoss = [];\n    let maxNegativeCurvaturePoss = [];\n    let ps = curve.ps;\n    let brackets = get_bezier_curvature_extrema_brackets_1.calcBezierCurvatureExtremaBrackets(ps);\n    let κPs = flo_bezier3_1.κ(ps); // The curvature function\n    let lenb = brackets.length;\n    for (let k = 0; k < lenb; k++) {\n        let bracket = brackets[k];\n        if (!bracket) {\n            continue;\n        }\n        let root = lookForRoot(ps, bracket);\n        if (!root) {\n            continue;\n        }\n        let κ_ = -κPs(root);\n        // Check if local extrema is a maximum or minimum.\n        let κAtMinsd = -κPs(bracket[0]);\n        let κAtMaxsd = -κPs(bracket[1]);\n        if (κ_ > κAtMinsd && κ_ > κAtMaxsd) {\n            // maximum\n            if (κ_ > 0) {\n                maxCurvaturePoss.push(new point_on_shape_1.PointOnShape(curve, root));\n            }\n            //_debug_.fs.draw.crossHair((new PointOnShape(curve, root).p), 'blue thin2 nofill')\n        }\n        else if (κ_ <= κAtMinsd && κ_ <= κAtMaxsd) {\n            // minimum\n            if (κ_ < 0) {\n                maxNegativeCurvaturePoss.push(new point_on_shape_1.PointOnShape(curve, root));\n                //_debug_.fs.draw.crossHair((new PointOnShape(curve, root).p), 'red thin2 nofill')\n            }\n        }\n    }\n    return { maxCurvaturePoss, maxNegativeCurvaturePoss };\n}\nexports.getBezierCurvatureExtrema = getBezierCurvatureExtrema;\nfunction lookForRoot(ps, [minsd, maxsd]) {\n    // At this point there can be exactly 0 or 1 roots within \n    // [minsd, maxsd]\n    let dκMod_ = flo_bezier3_1.dκMod(ps);\n    let c0 = dκMod_(minsd);\n    let c1 = dκMod_(maxsd);\n    if (c0 * c1 >= 0) {\n        return;\n    }\n    // There is exactly one root in the interval.\n    let root = flo_poly_1.default.brent(dκMod_, minsd, maxsd);\n    return root;\n}\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/get-bezier-curvature-extrema.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/get-boundary-piece-beziers.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/get-boundary-piece-beziers.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst bezier_piece_1 = __webpack_require__(/*! ../bezier-piece */ \"./node_modules/flo-mat/node/src/bezier-piece.js\");\nconst point_on_shape_1 = __webpack_require__(/*! ../point-on-shape */ \"./node_modules/flo-mat/node/src/point-on-shape.js\");\nconst contact_point_1 = __webpack_require__(/*! ../contact-point */ \"./node_modules/flo-mat/node/src/contact-point.js\");\n/**\n* Returns the ordered cubic bezier pieces (i.e a bezier with a t range)\n* from the given boundary piece.\n* @param cpNode - An ordered pair that represents the start and end points of\n* the boundary piece\n*/\nfunction getBoundaryPieceBeziers(cpNode) {\n    let cpThis = cpNode[0];\n    let cpEnd = cpNode[1];\n    let bezierPieces = [];\n    // As opposed to going around the circle and taking the last exit\n    let goStraight = true;\n    do {\n        if (!goStraight) {\n            goStraight = true;\n            cpThis = cpThis.prevOnCircle; // take last exit\n            continue;\n        }\n        goStraight = false;\n        let posThis = cpThis.cp.pointOnShape;\n        let posNext = cpThis.next.cp.pointOnShape;\n        if (posNext.curve === posThis.curve &&\n            point_on_shape_1.PointOnShape.isQuiteSharpCorner(posThis) &&\n            point_on_shape_1.PointOnShape.isQuiteSharpCorner(posNext)) {\n            // Do nothing\n        }\n        else if (posNext.curve === posThis.curve &&\n            contact_point_1.ContactPoint.compare(cpThis.next.cp, cpThis.cp) > 0) {\n            bezierPieces.push(new bezier_piece_1.BezierPiece(posThis.curve, [posThis.t, posNext.t]));\n        }\n        else {\n            bezierPieces.push(new bezier_piece_1.BezierPiece(posThis.curve, [posThis.t, 1]));\n            addSkippedBeziers(bezierPieces, posThis.curve, posNext.curve, posNext.t);\n        }\n        cpThis = cpThis.next;\n    } while (cpThis !== cpEnd);\n    return bezierPieces;\n}\nexports.getBoundaryPieceBeziers = getBoundaryPieceBeziers;\n/**\n * Adds pieces of skipped beziers\n */\nfunction addSkippedBeziers(bezierPieces, curveStart, curveEnd, t1) {\n    let curveThis = curveStart;\n    do {\n        curveThis = curveThis.next;\n        let tEnd = curveThis === curveEnd ? t1 : 1;\n        bezierPieces.push(new bezier_piece_1.BezierPiece(curveThis, [0, tEnd]));\n    } while (curveThis !== curveEnd);\n}\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/get-boundary-piece-beziers.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/get-closest-boundary-point.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/get-closest-boundary-point.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\nconst point_on_shape_1 = __webpack_require__(/*! ../point-on-shape */ \"./node_modules/flo-mat/node/src/point-on-shape.js\");\nconst get_closest_squared_distance_to_rotated_rect_1 = __webpack_require__(/*! ./geometry/get-closest-squared-distance-to-rotated-rect */ \"./node_modules/flo-mat/node/src/mat/geometry/get-closest-squared-distance-to-rotated-rect.js\");\nconst get_closest_square_distance_to_rect_1 = __webpack_require__(/*! ./geometry/get-closest-square-distance-to-rect */ \"./node_modules/flo-mat/node/src/mat/geometry/get-closest-square-distance-to-rect.js\");\n/**\n * Returns the closest boundary point to the given point, limited to the given\n * bezier pieces, including the beziers actually checked after culling.\n * @param bezierPieces\n * @param point\n * @param touchedCurve\n * @param t\n * @param extreme\n */\nfunction getClosestBoundaryPoint(bezierPieces, point, touchedCurve, t) {\n    bezierPieces = cullBezierPieces(bezierPieces, point);\n    let bestDistance = Number.POSITIVE_INFINITY;\n    let pos;\n    for (let i = 0; i < bezierPieces.length; i++) {\n        let bezierPiece = bezierPieces[i];\n        let p = closestPointOnBezier(bezierPiece.curve, point, bezierPiece.ts, touchedCurve, t);\n        if (p === undefined) {\n            continue;\n        }\n        let d = flo_vector2d_1.distanceBetween(p.p, point);\n        let curve = bezierPiece.curve;\n        let t_ = p.t;\n        if (d < bestDistance) {\n            if (t_ === 0) {\n                t_ = 1;\n                curve = bezierPiece.curve.prev;\n            }\n            pos = new point_on_shape_1.PointOnShape(curve, t_);\n            bestDistance = d;\n        }\n    }\n    return pos;\n}\nexports.getClosestBoundaryPoint = getClosestBoundaryPoint;\n/**\n *\n * @param bezierPieces\n * @param p\n * @param extreme\n */\nfunction cullBezierPieces(bezierPieces, p) {\n    const CULL_THRESHOLD = 0;\n    if (bezierPieces.length > CULL_THRESHOLD) {\n        let bestSquaredDistance = getBestDistanceSquared(bezierPieces, p);\n        bezierPieces = cullByLooseBoundingBox(bezierPieces, p, bestSquaredDistance);\n        bezierPieces = cullByTightBoundingBox(bezierPieces, p, bestSquaredDistance);\n    }\n    return bezierPieces;\n}\n/**\n * Finds an initial distance such that the closest point can not be further than\n * this distance away.\n */\nfunction getBestDistanceSquared(bezierPieces, p) {\n    let bestSquaredDistance = Number.POSITIVE_INFINITY;\n    for (let i = 0; i < bezierPieces.length; i++) {\n        let bezierPiece = bezierPieces[i];\n        let ps = bezierPiece.curve.ps;\n        let evPs = flo_bezier3_1.evaluate(ps);\n        let p1 = evPs(bezierPiece.ts[0]);\n        let p2 = evPs(bezierPiece.ts[1]);\n        let d = Math.min(flo_vector2d_1.squaredDistanceBetween(p, p1), flo_vector2d_1.squaredDistanceBetween(p, p2));\n        if (d < bestSquaredDistance) {\n            bestSquaredDistance = d;\n        }\n    }\n    // The extra multiplier is to account for floating point precision.\n    return bestSquaredDistance * 1.01;\n}\n/**\n * When checking distances, ignore all those with closest possible distance\n * further than 'bestSquaredDistance', i.e. cull them.\n * @param bezierPieces\n * @param p\n * @param dSquared\n */\nfunction cullByLooseBoundingBox(bezierPieces, p, dSquared) {\n    let candidateBezierPieces = [];\n    for (let i = 0; i < bezierPieces.length; i++) {\n        let bezierPiece = bezierPieces[i];\n        let ps = bezierPiece.curve.ps;\n        let boundingBox = flo_bezier3_1.getBoundingBox(ps);\n        let d = get_closest_square_distance_to_rect_1.getClosestSquareDistanceToRect(boundingBox, p);\n        if (d <= dSquared) {\n            candidateBezierPieces.push(bezierPiece);\n        }\n    }\n    return candidateBezierPieces;\n}\n/**\n * When checking distances, ignore all those with closest possible distance\n * further than 'bestSquaredDistance', i.e. cull them.\n * @param bezierPieces\n * @param p\n * @param bestSquaredDistance\n */\nfunction cullByTightBoundingBox(bezierPieces, p, bestSquaredDistance) {\n    let candidateBezierPieces = [];\n    for (let i = 0; i < bezierPieces.length; i++) {\n        let bezierPiece = bezierPieces[i];\n        let ps = bezierPiece.curve.ps;\n        let tightBoundingBox = flo_bezier3_1.getBoundingBoxTight(ps);\n        let d = get_closest_squared_distance_to_rotated_rect_1.getClosestSquaredDistanceToRotatedRect(tightBoundingBox, p);\n        if (d <= bestSquaredDistance) {\n            candidateBezierPieces.push(bezierPiece);\n        }\n    }\n    return candidateBezierPieces;\n}\n/**\n *\n * @param curve The bezier\n * @param p The point from which to check\n * @param tRange The allowed t range\n * @param touchedCurve The bezier on which p is located\n * @param t The t value of the bezier that locates p\n */\nfunction closestPointOnBezier(curve, p, tRange = [0, 1], touchedCurve, t) {\n    // TODO The site at http://jazzros.blogspot.ca/2011/03/projecting-point-on-bezier-curve.html\n    // may hint at requiring much fewer assignments?\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = curve.ps;\n    let [xp, yp] = p;\n    let xx0 = x0 - xp;\n    let xx1 = x1 - xp;\n    let xx2 = x2 - xp;\n    let xx3 = x3 - xp;\n    let yy0 = y0 - yp;\n    let yy1 = y1 - yp;\n    let yy2 = y2 - yp;\n    let yy3 = y3 - yp;\n    let x00 = xx0 * xx0;\n    let x01 = 6 * xx0 * xx1;\n    let x02 = 6 * xx0 * xx2;\n    let x03 = 2 * xx0 * xx3;\n    let x11 = 9 * xx1 * xx1;\n    let x12 = 18 * xx1 * xx2;\n    let x13 = 6 * xx1 * xx3;\n    let x22 = 9 * xx2 * xx2;\n    let x23 = 6 * xx2 * xx3;\n    let x33 = xx3 * xx3;\n    let y00 = yy0 * yy0;\n    let y01 = 6 * yy0 * yy1;\n    let y02 = 6 * yy0 * yy2;\n    let y03 = 2 * yy0 * yy3;\n    let y11 = 9 * yy1 * yy1;\n    let y12 = 18 * yy1 * yy2;\n    let y13 = 6 * yy1 * yy3;\n    let y22 = 9 * yy2 * yy2;\n    let y23 = 6 * yy2 * yy3;\n    let y33 = yy3 * yy3;\n    let t5 = 6 * ((x33 - x23 + x13 - x03 + x22 - x12 + x02 + x11 - x01 + x00) +\n        (y33 - y23 + y13 - y03 + y22 - y12 + y02 + y11 - y01 + y00));\n    let t4 = 5 * ((x23 - 2 * x13 + 3 * x03 - 2 * x22 + 3 * x12 - 4 * x02 - 4 * x11 + 5 * x01 - 6 * x00) +\n        (y23 - 2 * y13 + 3 * y03 - 2 * y22 + 3 * y12 - 4 * y02 - 4 * y11 + 5 * y01 - 6 * y00));\n    let t3 = 4 * ((x13 - 3 * x03 + x22 - 3 * x12 + 6 * x02 + 6 * x11 - 10 * x01 + 15 * x00) +\n        (y13 - 3 * y03 + y22 - 3 * y12 + 6 * y02 + 6 * y11 - 10 * y01 + 15 * y00));\n    let t2 = 3 * ((x03 + x12 - 4 * x02 - 4 * x11 + 10 * x01 - 20 * x00) +\n        (y03 + y12 - 4 * y02 - 4 * y11 + 10 * y01 - 20 * y00));\n    let t1 = 2 * ((x02 + x11 - 5 * x01 + 15 * x00) +\n        (y02 + y11 - 5 * y01 + 15 * y00));\n    let t0 = ((x01 - 6 * x00) +\n        (y01 - 6 * y00));\n    let poly = [t5, t4, t3, t2, t1, t0];\n    if (curve === touchedCurve) {\n        poly = flo_poly_1.default.deflate(poly, t);\n    }\n    let roots = flo_poly_1.default.allRoots(poly, tRange[0], tRange[1]);\n    // Also test the endpoints\n    let push0 = true;\n    let push1 = true;\n    if ((t === 1 && curve === touchedCurve.next) ||\n        (curve === touchedCurve && t === 0)) {\n        push0 = false;\n    }\n    if ((t === 0 && curve === touchedCurve.prev) ||\n        (curve === touchedCurve && t === 1)) {\n        push1 = false;\n    }\n    if (tRange[0] === 0) {\n        if (push0) {\n            roots.push(tRange[0]);\n        }\n    }\n    else if (tRange[0] === 1) {\n        if (push1) {\n            roots.push(tRange[0]);\n        }\n    }\n    else {\n        roots.push(tRange[0]);\n    }\n    if (tRange[1] === 0) {\n        if (push0) {\n            roots.push(tRange[1]);\n        }\n    }\n    else if (tRange[1] === 1) {\n        if (push1) {\n            roots.push(tRange[1]);\n        }\n    }\n    else {\n        roots.push(tRange[1]);\n    }\n    let ev = flo_bezier3_1.evaluate(curve.ps);\n    let ps = roots.map(root => ({ p: ev(root), t: root }));\n    return flo_vector2d_1.getObjClosestTo(p, ps, p => p.p);\n}\nexports.closestPointOnBezier = closestPointOnBezier;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/get-closest-boundary-point.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/get-contact-circles-at-interface.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/get-contact-circles-at-interface.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst curve_1 = __webpack_require__(/*! ../curve */ \"./node_modules/flo-mat/node/src/curve.js\");\nconst point_on_shape_1 = __webpack_require__(/*! ../point-on-shape */ \"./node_modules/flo-mat/node/src/point-on-shape.js\");\nfunction getContactCirclesAtInterface(curve) {\n    let { isQuiteSharp, isDull, isQuiteDull } = curve_1.Curve.getCornerAtEnd(curve);\n    if (isQuiteSharp) {\n        return [new point_on_shape_1.PointOnShape(curve, 1)];\n    }\n    else if (isQuiteDull) {\n        return [\n            new point_on_shape_1.PointOnShape(curve, 1),\n            new point_on_shape_1.PointOnShape(curve.next, 0)\n        ];\n    }\n    else if (isDull) {\n    }\n    return [];\n}\nexports.getContactCirclesAtInterface = getContactCirclesAtInterface;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/get-contact-circles-at-interface.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/get-largest-vertex.js":
/*!*****************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/get-largest-vertex.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction getLargestVertex(cpNodes) {\n    return cpNodes.reduce(function (maxCpNode, cpNode) {\n        return maxCpNode.cp.circle.radius >= cpNode.cp.circle.radius\n            ? maxCpNode\n            : cpNode;\n    }, cpNodes[0]);\n}\nexports.getLargestVertex = getLargestVertex;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/get-largest-vertex.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/get-leaves.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/get-leaves.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst traverse_edges_1 = __webpack_require__(/*! ./traverse-edges */ \"./node_modules/flo-mat/node/src/mat/traverse-edges.js\");\nfunction getLeaves(cpNode) {\n    let leaves = [];\n    traverse_edges_1.traverseEdges(cpNode, f, true);\n    function f(cp, isLeaf) {\n        if (isLeaf) {\n            leaves.push(cp);\n        }\n    }\n    return leaves;\n}\nexports.getLeaves = getLeaves;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/get-leaves.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/get-neighboring-cps.js":
/*!******************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/get-neighboring-cps.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst cp_node_1 = __webpack_require__(/*! ../cp-node */ \"./node_modules/flo-mat/node/src/cp-node.js\");\nconst contact_point_1 = __webpack_require__(/*! ../contact-point */ \"./node_modules/flo-mat/node/src/contact-point.js\");\n/**\n * Returns the boundary piece that starts at the immediate previous point on the\n * shape and ends at the immediate next point.\n * @param cpTree\n * @param pos\n * @param order\n * @param order2\n */\nfunction getNeighbouringPoints(cpTree, pos, order, order2) {\n    let cps = cpTree.findBounds(new cp_node_1.CpNode(new contact_point_1.ContactPoint(pos, undefined, order, order2), false, false));\n    if (!cps[0] && !cps[1]) {\n        // The tree is still empty\n        return [undefined, undefined];\n    }\n    if (!cps[0] || !cps[1]) {\n        // Smaller than all -> cptree.min() === cps[1].data OR\n        // Larger  than all -> cptree.max() === cps[0].data\n        return [\n            cpTree.max(cpTree.root),\n            cpTree.min(cpTree.root)\n        ];\n    }\n    return [\n        cps[0].data,\n        cps[1].data\n    ];\n}\nexports.getNeighbouringPoints = getNeighbouringPoints;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/get-neighboring-cps.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/get-two-prong-type.js":
/*!*****************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/get-two-prong-type.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction getTwoProngType(e) {\n    if (e.failed) {\n        return 'twoProng_failed';\n    }\n    if (e.notAdded) {\n        return 'twoProng_notAdded';\n    }\n    if (e.deleted) {\n        return 'twoProng_deleted';\n    }\n    if (e.holeClosing) {\n        return 'twoProng_holeClosing';\n    }\n    return 'twoProng_regular';\n}\nexports.getTwoProngType = getTwoProngType;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/get-two-prong-type.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/is-another-cp-closeby.js":
/*!********************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/is-another-cp-closeby.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\nconst get_neighboring_cps_1 = __webpack_require__(/*! ./get-neighboring-cps */ \"./node_modules/flo-mat/node/src/mat/get-neighboring-cps.js\");\n//const ANGLE_THRESHOLD = Math.cos(3 * (Math.PI / 180)); // 3 degrees\nconst ANGLE_THRESHOLD = 0.9986295347545738; // === Math.cos(3  degrees)\n//const ANGLE_THRESHOLD = 0.9848077530122080; // === Math.cos(10 degrees)\n//const ANGLE_THRESHOLD = 0.9998476951563913; // === Math.cos(1 degrees)\n//const ANGLE_THRESHOLD = 0.9999984769132877; // === Math.cos(0.1 degrees)   \n//const ANGLE_THRESHOLD = 0.9999999847691291  // === Math.cos(0.01 degrees)   \n/**\n * Returns true if another CpNode is close to the given implied (via pos, order\n * and order2) CpNode.\n * @param cpTrees\n * @param pos\n * @param circle\n * @param order\n * @param order2\n * @param extreme The maximum coordinate value used to calculate floating point\n * tolerances.\n * @param color Used for debugging only\n */\nfunction isAnotherCpCloseby(cpTrees, pos, circle, order, order2, extreme, color) {\n    const DISTANCE_THRESHOLD = extreme * 1e-4;\n    //const DISTANCE_THRESHOLD = extreme * 1e-3; \n    //const DISTANCE_THRESHOLD = extreme * 1e-1; \n    let cpTree = cpTrees.get(pos.curve.loop);\n    let cpNodes = get_neighboring_cps_1.getNeighbouringPoints(cpTree, pos, order, order2);\n    if (!cpNodes[0]) {\n        return false;\n    }\n    for (let cpNode of cpNodes) {\n        let pos2 = cpNode.cp.pointOnShape;\n        let p1 = pos.p;\n        let p2 = pos2.p;\n        if (flo_vector2d_1.distanceBetween(p1, p2) > DISTANCE_THRESHOLD) {\n            continue;\n        }\n        let v1 = flo_vector2d_1.toUnitVector(flo_vector2d_1.fromTo(cpNode.cp.pointOnShape.p, cpNode.cp.circle.center));\n        let v2 = flo_vector2d_1.toUnitVector(flo_vector2d_1.fromTo(p1, circle.center));\n        let cosTheta = flo_vector2d_1.dot(v1, v2);\n        if (cosTheta > ANGLE_THRESHOLD) {\n            //console.log(`%c${cosTheta}`, `color: ${color}`);\n            return true;\n        }\n    }\n    return false;\n}\nexports.isAnotherCpCloseby = isAnotherCpCloseby;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/is-another-cp-closeby.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/smoothen/get-edge-direction.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/smoothen/get-edge-direction.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\nconst point_on_shape_1 = __webpack_require__(/*! ../../point-on-shape */ \"./node_modules/flo-mat/node/src/point-on-shape.js\");\n/**\n * Returns a line segment of unit length starting in the given Vertex center and\n * pointing in the direction of the medial axis (viewed as a rooted tree).\n * @param cpNode\n */\nfunction getEdgeDirection(cpNode) {\n    let circleCenter = cpNode.cp.circle.center;\n    let cp1 = cpNode;\n    let cp2 = cpNode.nextOnCircle;\n    let pos1 = cp1.cp.pointOnShape;\n    let pos2 = cp2.cp.pointOnShape;\n    let p1 = pos1.p;\n    let p2 = pos2.p;\n    let vDir;\n    if (!point_on_shape_1.PointOnShape.isSharpCorner(pos1)) {\n        if (p1[0] === p2[0] && p1[1] === p2[1]) {\n            vDir = flo_vector2d_1.fromTo(p1, circleCenter); // A 1-prong\n        }\n        else {\n            vDir = flo_vector2d_1.rotate90Degrees(flo_vector2d_1.fromTo(p1, p2)); // not a 1-prong.\n        }\n    }\n    else {\n        let curve1;\n        let curve2;\n        // TODO - test if pos1.t can ever be 0 - it is terminating\n        if (pos1.t === 0) {\n            curve1 = pos1.curve;\n            curve2 = pos1.curve.prev;\n        }\n        else if (pos1.t === 1) {\n            curve1 = pos1.curve.next;\n            curve2 = pos1.curve;\n        }\n        let tan1 = flo_bezier3_1.tangent(curve1.ps)(0);\n        let tan2 = flo_vector2d_1.reverse(flo_bezier3_1.tangent(curve2.ps)(1));\n        let x = flo_vector2d_1.dot(tan1, tan2);\n        // Recall the identities sin(acos(x)) = sqrt(1-x^2), etc. Also \n        // recall the half angle formulas. Then the rotation matrix, R, can \n        // be calculated.\n        let cosθ = Math.sqrt((1 + x) / 2);\n        let sinθ = Math.sqrt((1 - x) / 2);\n        vDir = flo_vector2d_1.rotate(sinθ, cosθ, tan2);\n    }\n    let v = flo_vector2d_1.translate(flo_vector2d_1.toUnitVector(vDir), circleCenter);\n    return [circleCenter, v];\n}\nexports.getEdgeDirection = getEdgeDirection;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/smoothen/get-edge-direction.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/smoothen/smoothen.js":
/*!****************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/smoothen/smoothen.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\nconst line_line_intersection_1 = __webpack_require__(/*! ../geometry/line-line-intersection */ \"./node_modules/flo-mat/node/src/mat/geometry/line-line-intersection.js\");\nconst traverse_edges_1 = __webpack_require__(/*! ../traverse-edges */ \"./node_modules/flo-mat/node/src/mat/traverse-edges.js\");\nconst get_edge_direction_1 = __webpack_require__(/*! ./get-edge-direction */ \"./node_modules/flo-mat/node/src/mat/smoothen/get-edge-direction.js\");\nconst TOLERANCE_ADD_2PRONG = 0.01;\nconst TOLERANCE_USE_LINE = 0.0001; // else cubic\n/**\n * Smoothens the given MAT by fitting consecutive mat lines with either lines or\n * quadratic or cubic beziers.\n */\nfunction smoothen(cpNode) {\n    traverse_edges_1.traverseEdges(cpNode, f);\n    function f(cpNode) {\n        let fromCc = cpNode.cp.circle.center;\n        let fromL = get_edge_direction_1.getEdgeDirection(cpNode);\n        let toCc = cpNode.next.cp.circle.center;\n        let toL = get_edge_direction_1.getEdgeDirection(cpNode.next.prevOnCircle);\n        let mid = line_line_intersection_1.lineLineIntersection(fromL, toL);\n        let c = flo_vector2d_1.fromTo(fromCc, toCc);\n        let twisted;\n        if (!mid) {\n            twisted = true;\n        }\n        else {\n            let a = flo_vector2d_1.fromTo(fromCc, mid);\n            let b = flo_vector2d_1.fromTo(toCc, mid);\n            twisted = flo_vector2d_1.dot(a, c) < 0 || flo_vector2d_1.dot(b, c) > 0;\n        }\n        if (!twisted) {\n            cpNode.matCurve = [fromCc, mid, toCc];\n            cpNode.next.prevOnCircle.matCurve = [toCc, mid, fromCc];\n            return;\n        }\n        let r = flo_vector2d_1.rotate90Degrees(c);\n        let w1 = flo_vector2d_1.fromTo(fromL[0], fromL[1]); // This is a unit vector\n        let w2 = flo_vector2d_1.fromTo(toL[0], toL[1]); // This is a unit vector\n        let d1 = Math.abs(flo_vector2d_1.cross(c, w1)) / (3 * 3);\n        let d2 = Math.abs(flo_vector2d_1.cross(c, w2)) / (3 * 3);\n        if (d1 > TOLERANCE_ADD_2PRONG || d2 > TOLERANCE_ADD_2PRONG) {\n            // TODO - not within tolerance - must add additional 2-prong\n            cpNode.matCurve = [fromCc, toCc];\n            cpNode.next.prevOnCircle.matCurve = [toCc, fromCc];\n            return;\n        }\n        if (d1 > TOLERANCE_USE_LINE || d2 > TOLERANCE_USE_LINE) {\n            // approximate with cubic bezier\n            let m1 = flo_vector2d_1.interpolate(fromCc, toCc, 1 / 3);\n            let m2 = flo_vector2d_1.interpolate(fromCc, toCc, 2 / 3);\n            let v1 = flo_vector2d_1.translate(r, m1);\n            let v2 = flo_vector2d_1.translate(r, m2);\n            let l1 = [m1, v1];\n            let l2 = [m2, v2];\n            let mid1 = line_line_intersection_1.lineLineIntersection(fromL, l1);\n            let mid2 = line_line_intersection_1.lineLineIntersection(toL, l2);\n            cpNode.matCurve = [fromCc, mid1, mid2, toCc];\n            cpNode.next.prevOnCircle.matCurve = [toCc, mid2, mid1, fromCc];\n            return;\n        }\n        // Within tolerance - approximate with a straight line.\n        cpNode.matCurve = [fromCc, toCc];\n        cpNode.next.prevOnCircle.matCurve = [toCc, fromCc];\n    }\n}\nexports.smoothen = smoothen;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/smoothen/smoothen.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/to-scale-axis/add-debug-info.js":
/*!***************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/to-scale-axis/add-debug-info.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction addDebugInfo(sat) {\n    if (typeof _debug_ === 'undefined') {\n        return;\n    }\n    let generated = _debug_.generated;\n    generated.elems.sat.push(sat);\n    let timing = generated.timing;\n    timing.sats[1] += performance.now() - timing.sats[0];\n}\nexports.addDebugInfo = addDebugInfo;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/to-scale-axis/add-debug-info.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/to-scale-axis/cull-non-cycles.js":
/*!****************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/to-scale-axis/cull-non-cycles.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst get_leaves_1 = __webpack_require__(/*! ../get-leaves */ \"./node_modules/flo-mat/node/src/mat/get-leaves.js\");\n/**\n * Cull all edges not part of a cycle in the MAT planar graph.\n * @param cpStart The start CpNode which must reprsesent the maximal 3-prong\n * vertex.\n */\nfunction cullNonCycles(cpStart) {\n    let cpNodeKept = cpStart;\n    let leaves = get_leaves_1.getLeaves(cpStart);\n    while (leaves.length) {\n        let leaf = leaves.pop();\n        // Preserve topology - keep cycles.\n        if (leaf.isHoleClosing || leaf.isIntersection) {\n            continue;\n        }\n        let cpNode = leaf.next; // Turn around\n        while (true) {\n            cpNode = cpNode.next;\n            let cut = false;\n            let cp1 = cpNode.prevOnCircle;\n            if (cpNode.isThreeProng()) {\n                let cp2 = cp1.prevOnCircle;\n                if (cpStart === cpNode || cpStart === cp1 || cpStart === cp2) {\n                    cut = true; // We are at the max disk - cut whole edge\n                }\n                else if (cpNode.next === cp2) {\n                    cpNode = cp2;\n                }\n                else if (cp2.next !== cp1) {\n                    cut = true; // Cut whole edge\n                }\n            }\n            else if (cpNode.isTerminating() && !cpNode.isIntersection) {\n                cpNodeKept = cpNode;\n                return undefined;\n            }\n            if (cut) {\n                cp1.next = cpNode;\n                cpNode.prev = cp1;\n                cpNodeKept = cpNode;\n                break;\n            }\n        }\n    }\n    return cpNodeKept;\n}\nexports.cullNonCycles = cullNonCycles;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/to-scale-axis/cull-non-cycles.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/to-scale-axis/cull.js":
/*!*****************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/to-scale-axis/cull.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst get_leaves_1 = __webpack_require__(/*! ../get-leaves */ \"./node_modules/flo-mat/node/src/mat/get-leaves.js\");\n/**\n * Returns the set of Vertices passing the following test: walk the MAT tree and\n * keep all Vertices not in the current cull set and any Vertices that have a\n * non-culled node further down the line toward the tree leaves.\n * @param culls The CpNodes (referred to by circles) that should be culled.\n * @param cpStart The start CpNode which must reprsesent the maximal vertex.\n */\nfunction cull(culls, cpStart) {\n    let leaves = get_leaves_1.getLeaves(cpStart);\n    while (leaves.length) {\n        let leaf = leaves.pop();\n        // Preserve topology.\n        if (leaf.isHoleClosing || leaf.isIntersection) {\n            continue;\n        }\n        if (!culls.has(leaf.cp.circle)) {\n            continue;\n        }\n        let cpNode = leaf.next; // Turn around\n        while (true) {\n            cpNode = cpNode.next;\n            let cut = false;\n            let cp1 = cpNode.prevOnCircle;\n            if (!culls.has(cpNode.cp.circle)) {\n                cut = true;\n            }\n            else if (cpNode.isThreeProng()) {\n                let cp2 = cp1.prevOnCircle;\n                if (cpStart === cpNode || cpStart === cp1 || cpStart === cp2) {\n                    cut = true; // We are at the max disk - cut whole edge\n                }\n                else if (cpNode.next === cp2) {\n                    cpNode = cp2;\n                }\n                else if (cp2.next !== cp1) {\n                    cut = true; // Cut whole edge\n                }\n            }\n            if (cut) {\n                cp1.next = cpNode;\n                cpNode.prev = cp1;\n                break;\n            }\n        }\n    }\n}\nexports.cull = cull;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/to-scale-axis/cull.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/to-scale-axis/to-scale-axis.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/to-scale-axis/to-scale-axis.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\nconst mat_1 = __webpack_require__(/*! ../../mat */ \"./node_modules/flo-mat/node/src/mat.js\");\nconst traverse_edges_1 = __webpack_require__(/*! ../traverse-edges */ \"./node_modules/flo-mat/node/src/mat/traverse-edges.js\");\nconst traverse_vertices_1 = __webpack_require__(/*! ../traverse-vertices */ \"./node_modules/flo-mat/node/src/mat/traverse-vertices.js\");\nconst smoothen_1 = __webpack_require__(/*! ../smoothen/smoothen */ \"./node_modules/flo-mat/node/src/mat/smoothen/smoothen.js\");\nconst get_largest_vertex_1 = __webpack_require__(/*! ../get-largest-vertex */ \"./node_modules/flo-mat/node/src/mat/get-largest-vertex.js\");\nconst cull_1 = __webpack_require__(/*! ./cull */ \"./node_modules/flo-mat/node/src/mat/to-scale-axis/cull.js\");\nconst create_new_cp_tree_1 = __webpack_require__(/*! ../create-new-cp-tree */ \"./node_modules/flo-mat/node/src/mat/create-new-cp-tree.js\");\nconst add_debug_info_1 = __webpack_require__(/*! ./add-debug-info */ \"./node_modules/flo-mat/node/src/mat/to-scale-axis/add-debug-info.js\");\nconst get_leaves_1 = __webpack_require__(/*! ../get-leaves */ \"./node_modules/flo-mat/node/src/mat/get-leaves.js\");\n/**\n * Apply an enhanced version of the Scale Axis Transform (SAT) to the MAT.\n * @param mat - The Medial Axis Transform (MAT) on which to apply the SAT.\n * @param s - The scale factor >= 1 (e.g. 1.3)\n */\nfunction toScaleAxis(mat, s) {\n    if (typeof _debug_ !== 'undefined') {\n        _debug_.generated.timing.sats[0] = performance.now();\n        let leaves = get_leaves_1.getLeaves(mat.cpNode);\n        _debug_.generated.elems.leaves.push(leaves);\n    }\n    /** The largest vertex (as measured by its inscribed disk) */\n    let cpNode = get_largest_vertex_1.getLargestVertex(traverse_vertices_1.traverseVertices(mat.cpNode.clone()));\n    if (typeof _debug_ !== 'undefined') {\n        _debug_.generated.elems.maxVertex.push(cpNode);\n    }\n    /**\n     * All vertices that are set to be culled initially. This may change to\n     * preserve topology.\n     */\n    let culls = new Set();\n    let rMap = new Map();\n    traverse_edges_1.traverseEdges(cpNode, function (cpNode) {\n        /** The occulating radius stored with this vertex. */\n        let R = rMap.get(cpNode) || s * cpNode.cp.circle.radius;\n        let cpNode_ = cpNode.next;\n        //let c  = cpNode .cp.circle.center;\n        //let c_ = cpNode_.cp.circle.center;\n        /** Distance between this vertex and the next. */\n        //let l = distanceBetween(c, c_); // Almost always precise enough\n        let l = flo_bezier3_1.len([0, 1], cpNode.matCurve);\n        let r_ = s * cpNode_.cp.circle.radius;\n        if (R - l > r_) {\n            for (let cpNode of cpNode_.getNodes()) {\n                rMap.set(cpNode, R - l); // Update occulating radii\n            }\n            culls.add(cpNode_.cp.circle);\n        }\n    });\n    cull_1.cull(culls, cpNode);\n    if (typeof _debug_ !== 'undefined') {\n        _debug_.generated.elems.culls.push(Array.from(culls));\n    }\n    smoothen_1.smoothen(cpNode);\n    let sat = new mat_1.Mat(cpNode, create_new_cp_tree_1.createNewCpTree(cpNode));\n    add_debug_info_1.addDebugInfo(sat);\n    return sat;\n}\nexports.toScaleAxis = toScaleAxis;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/to-scale-axis/to-scale-axis.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/traverse-edges.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/traverse-edges.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Traverses all edges (depth first) of a MAT starting at the given vertex (\n * represented by a CpNode). The traversal always progresses towards the leave\n * nodes.\n * @param cpNode The CpNode representing the start vertex\n * @param f A callback function for each CpNode representing the vertex at the\n * start of an edge.\n * @param inclLeaves If truthy then include the leaves, otherwise don't.\n */\nfunction traverseEdges(cpNode, f, inclLeaves = false) {\n    let cps = cpNode.getNodes();\n    while (cps.length) {\n        let cp = cps.pop();\n        while (!cp.isTerminating()) {\n            f(cp, false);\n            cp = cp.next;\n            if (cp.isThreeProng()) {\n                cps.push(cp.nextOnCircle);\n            }\n        }\n        if (inclLeaves) {\n            f(cp, true);\n        }\n    }\n}\nexports.traverseEdges = traverseEdges;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/traverse-edges.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/traverse-vertices.js":
/*!****************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/traverse-vertices.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Traverses the MAT tree and finds and returns the first CpNode (representing\n * a vertex) as an array with one element (or all) with a specified property\n * defined by the given predicate function. Returns [] if no CpNode with the\n * specified property has been found.\n * @param cpNode any CpNode of the MAT tree\n * @param f A function that should return true if the CpNode passes the criteria\n * necessary to be returned or falsy otherwise.\n * @param returnFirst If true, returns as soon as the first CpNode passing\n * f(cpNode) was found as [CpNode]. False by default.\n */\nfunction traverseVertices(cpNode, f = cpNode => true, returnFirst = false) {\n    let cpNodes = [];\n    if (f(cpNode)) {\n        cpNodes.push(cpNode);\n        if (returnFirst) {\n            return cpNodes;\n        }\n    }\n    ;\n    let cps = cpNode.getNodes();\n    while (cps.length) {\n        let cpNode = cps.pop();\n        while (!cpNode.isTerminating()) {\n            cpNode = cpNode.next;\n            if (f(cpNode)) {\n                cpNodes.push(cpNode);\n                if (returnFirst) {\n                    return cpNodes;\n                }\n            }\n            ;\n            if (cpNode.isThreeProng()) {\n                cps.push(cpNode.nextOnCircle);\n            }\n        }\n    }\n    return cpNodes;\n}\nexports.traverseVertices = traverseVertices;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/traverse-vertices.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/mat/trim-mat.js":
/*!*******************************************************!*\
  !*** ./node_modules/flo-mat/node/src/mat/trim-mat.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst mat_1 = __webpack_require__(/*! ../mat */ \"./node_modules/flo-mat/node/src/mat.js\");\nconst smoothen_1 = __webpack_require__(/*! ./smoothen/smoothen */ \"./node_modules/flo-mat/node/src/mat/smoothen/smoothen.js\");\nconst create_new_cp_tree_1 = __webpack_require__(/*! ./create-new-cp-tree */ \"./node_modules/flo-mat/node/src/mat/create-new-cp-tree.js\");\nconst cull_non_cycles_1 = __webpack_require__(/*! ./to-scale-axis/cull-non-cycles */ \"./node_modules/flo-mat/node/src/mat/to-scale-axis/cull-non-cycles.js\");\n/**\n * Trims the given Medial Axis Transform so that only cycles remain. Similar to\n * toScaleAxis(mat, Number.POSITIVE_INFINITY).\n * @param mat The MAT to trim.\n */\nfunction trimMat(mat) {\n    let cpNode = cull_non_cycles_1.cullNonCycles(mat.cpNode.clone());\n    if (!cpNode) {\n        return undefined;\n    }\n    smoothen_1.smoothen(cpNode);\n    let mat_ = new mat_1.Mat(cpNode, create_new_cp_tree_1.createNewCpTree(cpNode));\n    /*\n    if (typeof _debug_ !== 'undefined') {\n        let generated = _debug_.generated;\n        generated.elems.sat.push(mat_);\n    }\n    */\n    return mat_;\n}\nexports.trimMat = trimMat;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/mat/trim-mat.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/point-on-shape.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-mat/node/src/point-on-shape.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\nconst curve_1 = __webpack_require__(/*! ./curve */ \"./node_modules/flo-mat/node/src/curve.js\");\nconst circle_1 = __webpack_require__(/*! ./circle */ \"./node_modules/flo-mat/node/src/circle.js\");\nlet memoize = flo_memoize_1.default.m1;\nclass PointOnShape {\n    /**\n     * @param curve\n     * @param t - The bezier parameter value\n     */\n    constructor(curve, t) {\n        // Cache\n        this.p_ = undefined;\n        this.curve = curve;\n        this.t = t;\n    }\n    get p() {\n        return this.p_ === undefined\n            ? this.p_ = flo_bezier3_1.evaluate(this.curve.ps, this.t)\n            : this.p_;\n    }\n    static getOsculatingCircle(maxOsculatingCircleRadius, pos) {\n        if (PointOnShape.isSharpCorner(pos)) {\n            return new circle_1.Circle(pos.p, 0);\n        }\n        let radius = PointOnShape.calcOsculatingCircleRadius(pos);\n        if (radius < 0) {\n            radius = Number.POSITIVE_INFINITY;\n        }\n        radius = Math.min(radius, maxOsculatingCircleRadius);\n        let ps = pos.curve.ps;\n        let t = pos.t;\n        let normal_ = flo_bezier3_1.normal(ps, t);\n        let p = flo_bezier3_1.evaluate(ps, t);\n        let circleCenter = [\n            p[0] + normal_[0] * radius,\n            p[1] + normal_[1] * radius\n        ];\n        return new circle_1.Circle(circleCenter, radius);\n    }\n    /**\n     * Calculates the order (to distinguish between points lying on top of each\n     * other) of the contact point if it is a dull corner.\n     * @param pos\n     */\n    static calcOrder(circle, pos) {\n        if (!PointOnShape.isDullCorner(pos)) {\n            return 0;\n        }\n        //let corner = Curve.getCornerAtEnd(pos.curve);\n        let corner = PointOnShape.getCorner(pos);\n        let n = flo_vector2d_1.rotateNeg90Degrees(corner.tans[0]);\n        let v = flo_vector2d_1.toUnitVector(flo_vector2d_1.fromTo(pos.p, circle.center));\n        /*\n        console.log('------------------------------');\n        console.log('circle.center: ', circle.center);\n        console.log('pos.p: ', pos.p);\n        console.log('corner: ', corner);\n        console.log('tans[0]: ', corner.tans[0]);\n        console.log('n: ', n);\n        console.log('v: ', v);\n        console.log('-dot(n, v): ', -dot(n, v));\n        */\n        return -flo_vector2d_1.dot(n, v);\n    }\n}\n/**\n * Calculates the osculating circle of the bezier at a\n * specific t. If it is found to have negative or nearly zero radius\n * it is clipped to have positive radius so it can point into the shape.\n * @param ps\n * @param t\n */\nPointOnShape.calcOsculatingCircleRadius = memoize(function (pos) {\n    let ps = pos.curve.ps;\n    let t = pos.t;\n    let κ = -flo_bezier3_1.κ(ps, t);\n    // κ > 0 => bending inwards\n    return 1 / κ;\n});\nPointOnShape.compare = function (a, b) {\n    if (a === undefined || b === undefined) {\n        return undefined;\n    }\n    let res;\n    res = a.curve.idx - b.curve.idx;\n    if (res !== 0) {\n        return res;\n    }\n    res = a.t - b.t;\n    return res;\n};\n/**\n * Ignores order2 (used in hole-closing two-prongs only)\n */\nPointOnShape.compareInclOrder = function (a, b, aOrder, bOrder) {\n    let res = PointOnShape.compare(a, b);\n    if (res === undefined) {\n        return undefined;\n    }\n    if (res !== 0) {\n        return res;\n    }\n    res = aOrder - bOrder;\n    //if (res !== 0) { return res; }\n    //return a.order2 - b.order2;\n    return res;\n};\nPointOnShape.getCorner = memoize(function (pos) {\n    if (pos.t !== 0 && pos.t !== 1) {\n        return undefined;\n    }\n    return curve_1.Curve.getCornerAtEnd(pos.t === 1 ? pos.curve : pos.curve.prev);\n});\nPointOnShape.isSharpCorner = memoize(function (pos) {\n    let corner = PointOnShape.getCorner(pos);\n    return corner && corner.isSharp;\n});\nPointOnShape.isDullCorner = memoize(function (pos) {\n    let corner = PointOnShape.getCorner(pos);\n    return corner && corner.isDull;\n});\nPointOnShape.isQuiteSharpCorner = memoize(function (pos) {\n    let corner = PointOnShape.getCorner(pos);\n    return corner && corner.isQuiteSharp;\n});\nPointOnShape.isQuiteDullCorner = memoize(function (pos) {\n    let corner = PointOnShape.getCorner(pos);\n    return corner && corner.isQuiteDull;\n});\n/**\n * Returns a human-readable string of the given PointOnShape.\n * For debugging only.\n */\nPointOnShape.toHumanString = function (pos) {\n    return '' + pos.p[0] + ', ' + pos.p[1] +\n        ' | bz: ' + pos.curve.idx +\n        ' | t: ' + pos.t;\n};\nexports.PointOnShape = PointOnShape;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/point-on-shape.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/svg/fs/beziers-to-svg-path-str.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/svg/fs/beziers-to-svg-path-str.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Returns an SVG string representation of the given loop.\n * @param loop\n * @param decimalPlaces\n */\nfunction beziersToSvgPathStr(beziers, decimalPlaces = 10) {\n    const D = decimalPlaces;\n    let str = '';\n    for (let i = 0; i < beziers.length; i++) {\n        let ps = beziers[i];\n        if (i === 0) {\n            str = 'M ' +\n                ps[0][0].toFixed(D) + ' ' +\n                ps[0][1].toFixed(D) + '\\n';\n        }\n        str += 'C ' +\n            ps[1][0].toFixed(D) + ' ' +\n            ps[1][1].toFixed(D) + ' ' +\n            ps[2][0].toFixed(D) + ' ' +\n            ps[2][1].toFixed(D) + ' ' +\n            ps[3][0].toFixed(D) + ' ' +\n            ps[3][1].toFixed(D) + ' ' + '\\n';\n    }\n    return str + ' z' + '\\n';\n}\nexports.beziersToSvgPathStr = beziersToSvgPathStr;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/svg/fs/beziers-to-svg-path-str.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/svg/fs/circle-to-cubic-beziers.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/svg/fs/circle-to-cubic-beziers.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst C = 0.55191502449;\nfunction circleToCubicBeziers(center = [0, 0], radius, clockwise = false) {\n    let x = center[0];\n    let y = center[1];\n    let r = radius;\n    let c = r * C;\n    let pss = [\n        [[x, y + r], [x + c, y + r], [x + r, y + c], [x + r, y]],\n        [[x + r, y], [x + r, y - c], [x + c, y - r], [x, y - r]],\n        [[x, y - r], [x - c, y - r], [x - r, y - c], [x - r, y]],\n        [[x - r, y], [x - r, y + c], [x - c, y + r], [x, y + r]]\n    ];\n    if (!clockwise) {\n        return pss;\n    }\n    return (pss.map(ps => ps.slice().reverse()).slice().reverse());\n}\nexports.circleToCubicBeziers = circleToCubicBeziers;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/svg/fs/circle-to-cubic-beziers.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/svg/fs/de-pathologify.js":
/*!****************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/svg/fs/de-pathologify.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\n/**\n * Possibly changes the curve into one that is as close to the original as\n * possible but does not have pathological properties (i.e. does not have near\n * infinitely sharp corners, etc) or if that is not possible remove the curve in\n * some circumstances (e.g. if it is of extreme short length, etc.).\n * @param ps Cubic bezier curve points.\n */\nfunction dePathologify(ps_, max) {\n    // TODO \n    // We check if any of the ps are coincident and thus\n    // that the bezier is degenerate in some sense. If that is the\n    // case we apply a heuristic to get a new similar bezier by \n    // respacing the points. This entire function is very \n    // convoluted.\n    // We should investigate a better mathematical solution.\n    // Currently if the bezier degenerates more or less into a point\n    // we make the next bezier start at the previous bezier's end\n    // point else we adjust the bezier to be less pathological.\n    let delta = max / 1e4;\n    let ds = [\n        [\n            0,\n            flo_vector2d_1.manhattanDistanceBetween(ps_[0], ps_[1]),\n            flo_vector2d_1.manhattanDistanceBetween(ps_[0], ps_[2]),\n            flo_vector2d_1.manhattanDistanceBetween(ps_[0], ps_[3])\n        ],\n        [\n            flo_vector2d_1.manhattanDistanceBetween(ps_[1], ps_[0]),\n            0,\n            flo_vector2d_1.manhattanDistanceBetween(ps_[1], ps_[2]),\n            flo_vector2d_1.manhattanDistanceBetween(ps_[1], ps_[3]),\n        ],\n        [\n            flo_vector2d_1.manhattanDistanceBetween(ps_[2], ps_[0]),\n            flo_vector2d_1.manhattanDistanceBetween(ps_[2], ps_[1]),\n            0,\n            flo_vector2d_1.manhattanDistanceBetween(ps_[2], ps_[3]),\n        ],\n        [\n            flo_vector2d_1.manhattanDistanceBetween(ps_[3], ps_[0]),\n            flo_vector2d_1.manhattanDistanceBetween(ps_[3], ps_[1]),\n            flo_vector2d_1.manhattanDistanceBetween(ps_[3], ps_[2]),\n            0,\n        ]\n    ];\n    let ps = ps_;\n    const SHIFT = 0.02;\n    // Check if first or last 3 points are coincident\n    if (ds[0][1] < delta && ds[1][2] < delta ||\n        ds[1][2] < delta && ds[2][3] < delta) {\n        ps = [\n            ps_[0],\n            flo_vector2d_1.interpolate(ps_[0], ps_[3], 1 / 3),\n            flo_vector2d_1.interpolate(ps_[0], ps_[3], 2 / 3),\n            ps_[3]\n        ];\n    }\n    // Check if first 2 points are coincident\n    if (ds[0][1] < delta) {\n        ps[1] = flo_vector2d_1.interpolate(ps_[0], ps_[2], SHIFT);\n    }\n    // Check if last 2 points are coincident\n    if (ds[2][3] < delta) {\n        ps[2] = flo_vector2d_1.interpolate(ps_[1], ps_[3], 1 - SHIFT);\n    }\n    // Check if middle 2 points are coincident\n    if (ds[1][2] < delta) {\n        ps[1] = flo_vector2d_1.interpolate(ps_[0], ps_[1], 1 - SHIFT);\n        ps[2] = flo_vector2d_1.interpolate(ps_[2], ps_[3], SHIFT);\n    }\n    return ps;\n}\nexports.dePathologify = dePathologify;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/svg/fs/de-pathologify.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/svg/fs/get-beziers-from-raw-paths.js":
/*!****************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/svg/fs/get-beziers-from-raw-paths.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst push_bezier_1 = __webpack_require__(/*! ../fs/push-bezier */ \"./node_modules/flo-mat/node/src/svg/fs/push-bezier.js\");\nconst path_state_1 = __webpack_require__(/*! ../path-state */ \"./node_modules/flo-mat/node/src/svg/path-state.js\");\nconst z_1 = __webpack_require__(/*! ../path-segment/z */ \"./node_modules/flo-mat/node/src/svg/path-segment/z.js\");\nconst c_1 = __webpack_require__(/*! ../path-segment/c */ \"./node_modules/flo-mat/node/src/svg/path-segment/c.js\");\nconst s_1 = __webpack_require__(/*! ../path-segment/s */ \"./node_modules/flo-mat/node/src/svg/path-segment/s.js\");\nconst l_1 = __webpack_require__(/*! ../path-segment/l */ \"./node_modules/flo-mat/node/src/svg/path-segment/l.js\");\nconst h_1 = __webpack_require__(/*! ../path-segment/h */ \"./node_modules/flo-mat/node/src/svg/path-segment/h.js\");\nconst v_1 = __webpack_require__(/*! ../path-segment/v */ \"./node_modules/flo-mat/node/src/svg/path-segment/v.js\");\nconst q_1 = __webpack_require__(/*! ../path-segment/q */ \"./node_modules/flo-mat/node/src/svg/path-segment/q.js\");\nconst t_1 = __webpack_require__(/*! ../path-segment/t */ \"./node_modules/flo-mat/node/src/svg/path-segment/t.js\");\nconst a_1 = __webpack_require__(/*! ../path-segment/a */ \"./node_modules/flo-mat/node/src/svg/path-segment/a.js\");\nconst pathFs = { a: a_1.a, c: c_1.c, h: h_1.h, l: l_1.l, q: q_1.q, s: s_1.s, t: t_1.t, v: v_1.v, z: z_1.z };\n/**\n * Get the cubic beziers from the given SVG DOM element. If a path\n * data tag is not \"C\", i.e. if it is not an absolute cubic bezier\n * coordinate then it is converted into one.\n * @param elem - An SVG element\n * @returns aaa\n */\nfunction getBeziersFromRawPaths(paths) {\n    if (paths.length === 0) {\n        return []; // A shape is not described   \n    }\n    if (paths[0].type.toLowerCase() !== 'm') {\n        throw new Error('Invalid SVG - every new path must start with an M or m.');\n    }\n    let s = new path_state_1.PathState();\n    let beziersArrays = [];\n    let beziers = [];\n    let max = Number.NEGATIVE_INFINITY;\n    for (let i = 0; i < paths.length; i++) {\n        let path = paths[i];\n        for (let j = 0; j < path.values.length; j++) {\n            let v = path.values[j];\n            if (max < v) {\n                max = v;\n            }\n        }\n    }\n    let type = undefined;\n    let prevType;\n    for (let i = 0; i < paths.length; i++) {\n        prevType = type;\n        let pathSeg = paths[i];\n        type = pathSeg.type.toLowerCase();\n        s.vals = pathSeg.values;\n        /*\n        if (pathSeg.values[0] === 109.637) {\n            console.log('109')\n        }\n        */\n        if (pathSeg.type === pathSeg.type.toLowerCase()) {\n            if (type === 'v') {\n                s.vals[0] += s.p[1];\n            }\n            else if (type === 'a') {\n                s.vals[5] += s.p[0];\n                s.vals[6] += s.p[1];\n            }\n            else {\n                for (let i = 0; i < s.vals.length; i++) {\n                    s.vals[i] += s.p[i % 2];\n                }\n            }\n        }\n        if (type === 'm') {\n            if (beziers.length) {\n                // This is a subpath, close as if the previous command was a \n                // Z or z.\n                if (prevType !== 'z') {\n                    push_bezier_1.pushBezier(beziers, z_1.z(s), s, max);\n                }\n                // Start new path\n                beziersArrays.push(beziers);\n                beziers = [];\n            }\n            s.initialPoint = s.p = s.vals;\n            continue;\n        }\n        let f = pathFs[type];\n        if (!f) {\n            throw new Error('Invalid SVG - command not recognized.');\n        }\n        let ps = f(s);\n        s.p = ps[3]; // Update current point\n        push_bezier_1.pushBezier(beziers, ps, s, max);\n    }\n    if (beziers.length) {\n        //beziersArrays.push(beziers);\n        // This is a subpath, close as if the previous command was a \n        // Z or z.\n        if (prevType !== 'z') {\n            push_bezier_1.pushBezier(beziers, z_1.z(s), s, max);\n        }\n        // Start new path\n        beziersArrays.push(beziers);\n    }\n    return beziersArrays;\n}\nexports.getBeziersFromRawPaths = getBeziersFromRawPaths;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/svg/fs/get-beziers-from-raw-paths.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/svg/fs/get-curvature-at-interface.js":
/*!****************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/svg/fs/get-curvature-at-interface.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Bezier3 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\nconst Vector = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\n/**\n * Get the angle between the given bezier endpoint and the\n * startpoint of the next bezier.\n * @param curve\n */\nfunction getCurvatureAtInterface(curve) {\n    const ts = [1, 0];\n    let pss = [\n        curve.ps,\n        curve.next.ps\n    ];\n    let tans = [\n        Bezier3.tangent(pss[0])(1),\n        Bezier3.tangent(pss[0])(0)\n    ];\n    // The integral of a kind of Dirac Delta function.\n    let cosθ = Vector.dot(tans[0], tans[1]);\n    let sinθ = Vector.cross(tans[0], tans[1]);\n    let θ = acos(cosθ);\n    let result = sinθ >= 0 ? θ : -θ;\n    return result;\n}\nexports.getCurvatureAtInterface = getCurvatureAtInterface;\n/**\n * Floating-point 'safer' version of acos. If x is larger than 1 (or smaller\n * than -1), still returns 0 (or Math.PI) instead of NAN.\n * @param x\n * @example\n * \t\tacos(1);  //=> 0\n *      acos(2);  //=> 0\n */\nfunction acos(x) {\n    if (x > 1) {\n        return 0;\n    }\n    else if (x < -1) {\n        return Math.PI;\n    }\n    return Math.acos(x);\n}\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/svg/fs/get-curvature-at-interface.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/svg/fs/get-extreme.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/svg/fs/get-extreme.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst get_shape_bounds_1 = __webpack_require__(/*! ./get-shape-bounds */ \"./node_modules/flo-mat/node/src/svg/fs/get-shape-bounds.js\");\n/**\n * Returns the max extreme point coordinate value for the given shape. This is\n * used for floating point tolerance calculations.\n * @param loops\n */\nfunction getExtreme(loops) {\n    let bounds = get_shape_bounds_1.getShapeBounds(loops);\n    return Math.max(Math.abs(bounds.minX.p[0]), Math.abs(bounds.minY.p[1]), Math.abs(bounds.maxX.p[0]), Math.abs(bounds.maxY.p[1]));\n}\nexports.getExtreme = getExtreme;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/svg/fs/get-extreme.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/svg/fs/get-loop-bounds.js":
/*!*****************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/svg/fs/get-loop-bounds.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\nconst point_on_shape_1 = __webpack_require__(/*! ../../point-on-shape */ \"./node_modules/flo-mat/node/src/point-on-shape.js\");\nlet { m1: memoize } = flo_memoize_1.default;\nconst INF = Number.POSITIVE_INFINITY;\nlet getLoopBounds = memoize(function (loop) {\n    let extremes = [\n        [\n            { bezier: undefined, t: undefined, val: INF },\n            { bezier: undefined, t: undefined, val: INF }\n        ],\n        [\n            { bezier: undefined, t: undefined, val: -INF },\n            { bezier: undefined, t: undefined, val: -INF }\n        ]\n    ];\n    loop.curves.forEach(function (curve) {\n        let ps = curve.ps;\n        let bounds = flo_bezier3_1.getBounds(ps);\n        for (let i = 0; i < 2; i++) {\n            for (let j = 0; j < 2; j++) {\n                let v = bounds.box[i][j];\n                let m = i === 0 ? -1 : 1; // min or max?\n                let x = extremes[i][j].val;\n                if (m * v > m * x || (v === x && bounds.ts[i][j] > extremes[i][j].t)) {\n                    extremes[i][j] = {\n                        bezier: curve,\n                        t: bounds.ts[i][j],\n                        val: v\n                    };\n                }\n            }\n        }\n    });\n    return {\n        minX: new point_on_shape_1.PointOnShape(extremes[0][0].bezier, extremes[0][0].t),\n        minY: new point_on_shape_1.PointOnShape(extremes[0][1].bezier, extremes[0][1].t),\n        maxX: new point_on_shape_1.PointOnShape(extremes[1][0].bezier, extremes[1][0].t),\n        maxY: new point_on_shape_1.PointOnShape(extremes[1][1].bezier, extremes[1][1].t)\n    };\n});\nexports.getLoopBounds = getLoopBounds;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/svg/fs/get-loop-bounds.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/svg/fs/get-min-y-pos.js":
/*!***************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/svg/fs/get-min-y-pos.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst get_loop_bounds_1 = __webpack_require__(/*! ./get-loop-bounds */ \"./node_modules/flo-mat/node/src/svg/fs/get-loop-bounds.js\");\n/**\n * Get topmost PointOnShape the given loop.\n */\nfunction getMinYPos(loop) {\n    let pos = get_loop_bounds_1.getLoopBounds(loop).minY;\n    if (typeof _debug_ !== 'undefined') {\n        _debug_.generated.elems.minY.push(pos);\n    }\n    return pos;\n}\nexports.getMinYPos = getMinYPos;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/svg/fs/get-min-y-pos.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/svg/fs/get-paths-from-str.js":
/*!********************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/svg/fs/get-paths-from-str.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst get_beziers_from_raw_paths_1 = __webpack_require__(/*! ./get-beziers-from-raw-paths */ \"./node_modules/flo-mat/node/src/svg/fs/get-beziers-from-raw-paths.js\");\nconst loop_1 = __webpack_require__(/*! ../../loop */ \"./node_modules/flo-mat/node/src/loop.js\");\nconst parse_path_data_string_1 = __webpack_require__(/*! ../path-data-polyfill/parse-path-data-string */ \"./node_modules/flo-mat/node/src/svg/path-data-polyfill/parse-path-data-string.js\");\nfunction getPathsFromStr(str) {\n    let bezierLoops = get_beziers_from_raw_paths_1.getBeziersFromRawPaths(parse_path_data_string_1.parsePathDataString(str));\n    //---- For debugging ----//\n    // TODO\n    //console.log(paths);\n    /*\n    let pathsStr = '';\n    for (let i=0; i<bezierLoops.length; i++) {\n        let bezierLoop = bezierLoops[i];\n\r\n        pathsStr += beziersToSvgPathStr(bezierLoop) + '\\n';\n    }\n    console.log(pathsStr);\n    */\n    //-----------------------//\n    return bezierLoops.map(path => new loop_1.Loop(path));\n}\nexports.getPathsFromStr = getPathsFromStr;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/svg/fs/get-paths-from-str.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/svg/fs/get-paths-from-svg-path-elem.js":
/*!******************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/svg/fs/get-paths-from-svg-path-elem.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst get_paths_from_str_1 = __webpack_require__(/*! ./get-paths-from-str */ \"./node_modules/flo-mat/node/src/svg/fs/get-paths-from-str.js\");\nfunction getPathsFromSvgPathElem(elem) {\n    return get_paths_from_str_1.getPathsFromStr(elem.getAttribute(\"d\"));\n}\nexports.getPathsFromSvgPathElem = getPathsFromSvgPathElem;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/svg/fs/get-paths-from-svg-path-elem.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/svg/fs/get-shape-bounds.js":
/*!******************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/svg/fs/get-shape-bounds.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\nconst get_loop_bounds_1 = __webpack_require__(/*! ./get-loop-bounds */ \"./node_modules/flo-mat/node/src/svg/fs/get-loop-bounds.js\");\nlet { m1: memoize } = flo_memoize_1.default;\nlet getShapeBounds = memoize(function (loops) {\n    let minX_ = Number.POSITIVE_INFINITY;\n    let maxX_ = Number.NEGATIVE_INFINITY;\n    let minY_ = Number.POSITIVE_INFINITY;\n    let maxY_ = Number.NEGATIVE_INFINITY;\n    let minX;\n    let maxX;\n    let minY;\n    let maxY;\n    for (let loop of loops) {\n        let bounds = get_loop_bounds_1.getLoopBounds(loop);\n        if (bounds.minX.p[0] < minX_) {\n            minX = bounds.minX;\n            minX_ = bounds.minX.p[0];\n        }\n        if (bounds.maxX.p[0] > maxX_) {\n            maxX = bounds.maxX;\n            maxX_ = bounds.maxX.p[0];\n        }\n        if (bounds.minY.p[1] < minY_) {\n            minY = bounds.minY;\n            minY_ = bounds.minY.p[1];\n        }\n        if (bounds.maxY.p[1] > maxY_) {\n            maxY = bounds.maxY;\n            maxY_ = bounds.maxY.p[1];\n        }\n    }\n    return { minX, minY, maxX, maxY };\n});\nexports.getShapeBounds = getShapeBounds;\nlet getShapesBounds = memoize(function (loopss) {\n    let minX_ = Number.POSITIVE_INFINITY;\n    let maxX_ = Number.NEGATIVE_INFINITY;\n    let minY_ = Number.POSITIVE_INFINITY;\n    let maxY_ = Number.NEGATIVE_INFINITY;\n    let minX;\n    let maxX;\n    let minY;\n    let maxY;\n    for (let loops of loopss) {\n        let bounds = getShapeBounds(loops);\n        if (bounds.minX.p[0] < minX_) {\n            minX = bounds.minX;\n            minX_ = bounds.minX.p[0];\n        }\n        if (bounds.maxX.p[0] > maxX_) {\n            maxX = bounds.maxX;\n            maxX_ = bounds.maxX.p[0];\n        }\n        if (bounds.minY.p[1] < minY_) {\n            minY = bounds.minY;\n            minY_ = bounds.minY.p[1];\n        }\n        if (bounds.maxY.p[1] > maxY_) {\n            maxY = bounds.maxY;\n            maxY_ = bounds.maxY.p[1];\n        }\n    }\n    return { minX, minY, maxX, maxY };\n});\nexports.getShapesBounds = getShapesBounds;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/svg/fs/get-shape-bounds.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/svg/fs/is-almost-zero-length.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/svg/fs/is-almost-zero-length.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\nconst DELTA = 1e-6;\n/**\n * Returns true if distance between consecutive points are all less than\n * some delta, false otherwise.\n * @private\n * @param ps - an array of points\n * @param delta - a tolerance - defaults to 1e-6;\n */\nfunction isAlmostZeroLength(ps, delta = DELTA) {\n    for (let i = 1; i < ps.length; i++) {\n        let p1 = ps[i - 1];\n        let p2 = ps[i];\n        if (flo_vector2d_1.manhattanDistanceBetween(p1, p2) > delta) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isAlmostZeroLength = isAlmostZeroLength;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/svg/fs/is-almost-zero-length.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/svg/fs/is-path-positively-oriented.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/svg/fs/is-path-positively-oriented.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Bezier3 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\nconst Vector = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\nconst get_loop_bounds_1 = __webpack_require__(/*! ./get-loop-bounds */ \"./node_modules/flo-mat/node/src/svg/fs/get-loop-bounds.js\");\nlet { m1: memoize } = flo_memoize_1.default;\n/**\n * Returns true if the given beizer loop is positively orientated, false\n * otherwise. Careful! Checks leftmost part of loop so twisted complex paths\n * may give an ambiguous orientation.\n */\nlet isPathPositivelyOrientated = memoize(function (bezierLoop) {\n    let extreme = get_loop_bounds_1.getLoopBounds(bezierLoop).minX;\n    let t = extreme.t;\n    let curve;\n    if (t === 0) {\n        curve = extreme.curve.prev;\n        t = 1;\n    }\n    else {\n        curve = extreme.curve;\n    }\n    let ps = curve.ps;\n    let tan = Bezier3.tangent(ps)(t);\n    if (t !== 1) {\n        // Not a sharp corner\n        return tan[1] < 0;\n    }\n    let psNext = curve.next.ps;\n    let tanNext = Bezier3.tangent(psNext)(0);\n    if (tan[1] * tanNext[1] > 0) {\n        // Both tangents points up or both points down.\n        return tan[1] < 0;\n    }\n    // One tangent points up and the other down.\n    let c = Vector.cross(tan, tanNext);\n    return c > 0;\n    // We don't check for the very special case where the cross === 0. \n});\nexports.isPathPositivelyOrientated = isPathPositivelyOrientated;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/svg/fs/is-path-positively-oriented.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/svg/fs/push-bezier.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/svg/fs/push-bezier.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst de_pathologify_1 = __webpack_require__(/*! ./de-pathologify */ \"./node_modules/flo-mat/node/src/svg/fs/de-pathologify.js\");\nconst is_almost_zero_length_1 = __webpack_require__(/*! ./is-almost-zero-length */ \"./node_modules/flo-mat/node/src/svg/fs/is-almost-zero-length.js\");\n// TODO - 1e4 is arbitrary\nconst RESOLUTION = 1e4;\n/**\n *\n * @param beziers The array of path curves\n * @param ps_ The bezier\n * @param state The current path state\n */\nfunction pushBezier(beziers, ps_, s, max) {\n    /*\nif ( isAlmostZeroLength(ps_, max/RESOLUTION) ) {\nif ( isAlmostZeroLength(ps_, 0) ) {\n    return;\n}\n//console.log(ps_);\n}\n\r\nbeziers.push(ps_);\n*/\n    if (is_almost_zero_length_1.isAlmostZeroLength(ps_, max / RESOLUTION)) {\n        let len = beziers.length;\n        if (len === 0) {\n            s.initialPoint = ps_[3];\n        }\n        else {\n            let prevPs = beziers[len - 1];\n            prevPs[3] = ps_[3];\n        }\n        return;\n    }\n    let ps = de_pathologify_1.dePathologify(ps_, max);\n    beziers.push(ps);\n}\nexports.pushBezier = pushBezier;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/svg/fs/push-bezier.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/svg/fs/simplify-paths/complete-loop.js":
/*!******************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/svg/fs/simplify-paths/complete-loop.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\nconst get_next_x_1 = __webpack_require__(/*! ./get-next-x */ \"./node_modules/flo-mat/node/src/svg/fs/simplify-paths/get-next-x.js\");\nfunction completeLoop(intersections, takenXs, xStack, loopTree, x) {\n    let beziers = [];\n    let reversed = (loopTree.windingNum === 0 && loopTree.orientation === -1) ||\n        (loopTree.windingNum !== 0 && loopTree.orientation === +1);\n    let pos = reversed ? x.pos : x.opposite.pos;\n    let startBez = pos.curve;\n    let startT = pos.t;\n    let curBez = startBez;\n    let curT = startT;\n    let fromX = x.isDummy\n        ? undefined\n        : reversed ? x.opposite : x;\n    let wasOnX = true;\n    while (true) {\n        let xs = intersections.get(curBez);\n        let x_ = xs ? get_next_x_1.getNextX(xs, curT, !reversed, wasOnX) : undefined;\n        // Add a bezier to the component loop.\n        if (x_) {\n            // We are at an intersection\n            wasOnX = true;\n            if (curT !== x_.pos.t) {\n                let ps = reversed\n                    ? flo_bezier3_1.reverse(flo_bezier3_1.fromTo(curBez.ps)(x_.pos.t, curT))\n                    : flo_bezier3_1.fromTo(curBez.ps)(curT, x_.pos.t);\n                beziers.push(ps);\n                addXOutPs(reversed, fromX, ps);\n                fromX = x_;\n            }\n            // Move onto next bezier\n            curBez = x_.opposite.pos.curve; // Switch to other path's bezier\n            curT = x_.opposite.pos.t; // ...\n            let _x_ = reversed ? x_.opposite : x_;\n            _x_.loopTree = loopTree;\n            if (!takenXs.has(_x_.opposite)) {\n                xStack.push(_x_.opposite);\n            }\n            takenXs.add(_x_); // Mark this intersection as taken\n        }\n        else {\n            wasOnX = false;\n            let t = reversed ? 0 : 1;\n            if (curT !== t) {\n                let ps = reversed\n                    ? flo_bezier3_1.reverse(flo_bezier3_1.fromTo(curBez.ps)(0, curT))\n                    : flo_bezier3_1.fromTo(curBez.ps)(curT, 1);\n                beziers.push(ps);\n                addXOutPs(reversed, fromX, ps);\n                fromX = undefined;\n            }\n            // Move onto next bezier on current path\n            curBez = reversed ? curBez.prev : curBez.next;\n            curT = reversed ? 1 : 0;\n        }\n        if (curBez === startBez && curT === startT) {\n            break;\n        }\n    }\n    return beziers;\n}\nexports.completeLoop = completeLoop;\nfunction addXOutPs(reversed, fromX, ps) {\n    if (fromX && !fromX.isDummy) {\n        let x = reversed ? fromX : fromX.opposite;\n        x.outPs = ps;\n        fromX = undefined;\n        //_debug_.fs.draw.bezier(_debug_.generated.g, ps, 'red thin10 nofill');\n    }\n}\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/svg/fs/simplify-paths/complete-loop.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/svg/fs/simplify-paths/complete-path.js":
/*!******************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/svg/fs/simplify-paths/complete-path.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst loop_1 = __webpack_require__(/*! ../../../loop */ \"./node_modules/flo-mat/node/src/loop.js\");\nconst complete_loop_1 = __webpack_require__(/*! ./complete-loop */ \"./node_modules/flo-mat/node/src/svg/fs/simplify-paths/complete-loop.js\");\nconst get_initial_x_1 = __webpack_require__(/*! ./get-initial-x */ \"./node_modules/flo-mat/node/src/svg/fs/simplify-paths/get-initial-x.js\");\nconst get_loop_metrics_1 = __webpack_require__(/*! ./get-loop-metrics */ \"./node_modules/flo-mat/node/src/svg/fs/simplify-paths/get-loop-metrics.js\");\n/**\n *\n * @param intersections\n * @param loopsTaken\n * @param loop\n * @param parent\n */\nfunction completePath(intersections, loopsTaken, parent, loop) {\n    // Each loop generated by xs in xStack will give rise to one componentLoop. \n    // The initial intersection in the stack is a dummy.\n    /** Intersection stack */\n    let initialX = get_initial_x_1.getInitialX(intersections, parent, loop);\n    let curve = initialX.pos.curve;\n    let xs = intersections.get(curve) || [];\n    if (xs.length === 0) {\n        intersections.set(curve, xs);\n    }\n    xs.push(initialX);\n    let xStack = [initialX];\n    let takenXs = new Set(); // Taken intersections\n    while (xStack.length) {\n        let x = xStack.pop();\n        loopsTaken.add(x.pos.curve.loop);\n        if (takenXs.has(x)) {\n            continue;\n        }\n        let loopTree = get_loop_metrics_1.getLoopMetrics(x);\n        loopTree.beziers = complete_loop_1.completeLoop(intersections, takenXs, xStack, loopTree, x);\n        loopTree.loop = new loop_1.Loop(loopTree.beziers);\n    }\n}\nexports.completePath = completePath;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/svg/fs/simplify-paths/complete-path.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/svg/fs/simplify-paths/get-initial-x.js":
/*!******************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/svg/fs/simplify-paths/get-initial-x.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst point_on_shape_1 = __webpack_require__(/*! ../../../point-on-shape */ \"./node_modules/flo-mat/node/src/point-on-shape.js\");\nconst is_path_positively_oriented_1 = __webpack_require__(/*! ../../fs/is-path-positively-oriented */ \"./node_modules/flo-mat/node/src/svg/fs/is-path-positively-oriented.js\");\nconst get_loop_bounds_1 = __webpack_require__(/*! ../get-loop-bounds */ \"./node_modules/flo-mat/node/src/svg/fs/get-loop-bounds.js\");\nconst x_1 = __webpack_require__(/*! ../../../x */ \"./node_modules/flo-mat/node/src/x.js\");\n/**\n * Get initial intersection which is really a dummy intersection.\n * @param loop\n * @param parent\n */\nfunction getInitialX(intersections, parent, loop) {\n    let dummyLoop = {\n        parent,\n        children: new Set(),\n        beziers: [],\n        loop: undefined,\n        orientation: is_path_positively_oriented_1.isPathPositivelyOrientated(loop) ? -1 : +1,\n        windingNum: parent.windingNum\n    };\n    let pos = get_loop_bounds_1.getLoopBounds(loop).minX;\n    let xs = intersections.get(pos.curve);\n    // If no intersections on this curve, just start at 0\n    if (!xs) {\n        pos = new point_on_shape_1.PointOnShape(pos.curve, 0);\n    }\n    let x = new x_1.X(pos, true, undefined, // will be set just below\n    dummyLoop);\n    x.opposite = x;\n    return x;\n}\nexports.getInitialX = getInitialX;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/svg/fs/simplify-paths/get-initial-x.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/svg/fs/simplify-paths/get-intersections.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/svg/fs/simplify-paths/get-intersections.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\nconst x_1 = __webpack_require__(/*! ../../../x */ \"./node_modules/flo-mat/node/src/x.js\");\nconst point_on_shape_1 = __webpack_require__(/*! ../../../point-on-shape */ \"./node_modules/flo-mat/node/src/point-on-shape.js\");\nconst pair_set_1 = __webpack_require__(/*! ./pair-set */ \"./node_modules/flo-mat/node/src/svg/fs/simplify-paths/pair-set.js\");\nconst find_bb_intersections_1 = __webpack_require__(/*! ../../../bounding-box/find-bb-intersections */ \"./node_modules/flo-mat/node/src/bounding-box/find-bb-intersections.js\");\n// TODO - DELTA is somewhat arbitrary\nconst DELTA = 1e-10;\n/**\n * Find and return all intersections on all given loops.\n * @param loops\n */\nfunction getIntersections(loops) {\n    // intersection <=> X\n    let { boxes, boxInfoMap } = getBoxInfos(loops);\n    let boxIntersections = find_bb_intersections_1.default(boxes);\n    // Check curve intersection amongst possibilities\n    /** A map from each curve to its intersectings */\n    let xMap = new Map();\n    let checkedPairs = new Map();\n    for (let i = 0; i < boxIntersections.length; i++) {\n        let { box1, box2 } = boxIntersections[i];\n        let curves = [\n            boxInfoMap.get(box1).curve,\n            boxInfoMap.get(box2).curve,\n        ];\n        if (pair_set_1.pairSet_has(checkedPairs, curves)) {\n            continue;\n        }\n        pair_set_1.pairSet_add(checkedPairs, curves);\n        let pss = curves.map(curve => curve.ps);\n        let tPairs = flo_bezier3_1.bezier3Intersection(pss[0], pss[1]);\n        if (!tPairs.length) {\n            continue;\n        }\n        for (let tPair of tPairs) {\n            let curves_ = confirmIntersection(checkedPairs, curves, tPair);\n            if (curves_ === undefined) {\n                continue;\n            }\n            let xs = [];\n            for (let j of [0, 1]) {\n                let curve = curves_[j];\n                let x = new x_1.X(new point_on_shape_1.PointOnShape(curve, tPair[j]));\n                // Get intersections stored at this curve\n                let curveXs = xMap.get(curve) || [];\n                if (!curveXs.length) {\n                    xMap.set(curve, curveXs);\n                }\n                // Add an intersection to this curve\n                curveXs.push(x);\n                xs.push(x);\n            }\n            xs[0].opposite = xs[1];\n            xs[1].opposite = xs[0];\n        }\n    }\n    return xMap;\n}\nexports.getIntersections = getIntersections;\n/**\n *\n */\nfunction confirmIntersection(checkedPairs, curves, tPair) {\n    let curves_ = curves.slice();\n    // TODO - the below check is temporary - there is a better way\n    // TODO - eliminate the fact that intersections are found twice\n    if (((Math.abs(tPair[0]) < DELTA && Math.abs(tPair[1] - 1) < DELTA) ||\n        (Math.abs(tPair[0] - 1) < DELTA && Math.abs(tPair[1]) < DELTA) ||\n        (Math.abs(tPair[0]) < DELTA && Math.abs(tPair[1]) < DELTA) ||\n        (Math.abs(tPair[0] - 1) < DELTA && Math.abs(tPair[1] - 1) < DELTA)) &&\n        (curves_[0].next === curves_[1] || curves_[1].next === curves_[0])) {\n        return undefined;\n    }\n    if (Math.abs(tPair[0] - 1) < DELTA) {\n        // If the intersection occurs at the end, move it to the start\n        // so we don't have a very small bezier piece left.\n        curves_[0] = curves_[0].next;\n        tPair[0] = 0;\n        // Recheck\n        if (pair_set_1.pairSet_has(checkedPairs, [curves_[0], curves_[1]])) {\n            return undefined;\n        }\n    }\n    if (Math.abs(tPair[1] - 1) < DELTA) {\n        // If the intersection occurs at the end, move it to the start\n        // so we don't have a very small bezier piece left.\n        curves_[1] = curves_[1].next;\n        tPair[1] = 0;\n        // Recheck\n        if (pair_set_1.pairSet_has(checkedPairs, [curves_[0], curves_[1]])) {\n            return undefined;\n        }\n    }\n    return curves_;\n}\n/**\n * Returns an array of lines of the bounding hulls of the Loop beziers' control\n * points including a map that maps each line to its hull, path and curve.\n * @param loops An array of Loops\n */\nfunction getBoxInfos(loops) {\n    /** Map that maps a line segment to some info. */\n    let boxInfoMap = new Map();\n    let boxes = [];\n    // Get lines making up the hulls of the paths\n    for (let loop of loops) {\n        loop.curves.forEach(function (curve) {\n            let box = flo_bezier3_1.getBoundingBox(curve.ps);\n            boxes.push(box);\n            boxInfoMap.set(box, { box, loop, curve });\n        });\n    }\n    return { boxes, boxInfoMap };\n}\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/svg/fs/simplify-paths/get-intersections.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/svg/fs/simplify-paths/get-loop-metrics.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/svg/fs/simplify-paths/get-loop-metrics.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\n/**\n *\n * @param x The intersection\n */\nfunction getLoopMetrics(x) {\n    let oppositeLoopTree = x.opposite.loopTree;\n    let oppositeOrientation = oppositeLoopTree.orientation;\n    let oppositeWindingNum = oppositeLoopTree.windingNum;\n    // Left or right turning? - The current X\n    let oldInBez = x.opposite.pos.curve.ps;\n    let oldOutBez = x.pos.curve.ps;\n    let orientation;\n    let windingNum;\n    let parent;\n    if (oldInBez !== oldOutBez) {\n        let tanIn = flo_bezier3_1.tangent(oldInBez, x.opposite.pos.t);\n        let tanOut = flo_bezier3_1.tangent(oldOutBez, x.pos.t);\n        // TODO - if cross product is close to 0 check second derivatives (the \n        // same can be done at cusps in the mat code). E.g. a figure eight with \n        // coinciding bezier stretches may cause floating point instability.\n        let isLeft = flo_vector2d_1.cross(tanIn, tanOut) > 0;\n        let isTwist = (isLeft && oppositeOrientation === +1) ||\n            (!isLeft && oppositeOrientation === -1);\n        let windingNumberInc = isTwist\n            ? -2 * oppositeOrientation\n            : oppositeOrientation;\n        orientation = isTwist\n            ? -1 * oppositeOrientation\n            : +1 * oppositeOrientation;\n        windingNum = oppositeWindingNum + windingNumberInc;\n        parent = isTwist ? oppositeLoopTree.parent : oppositeLoopTree;\n    }\n    else {\n        // This is the first loop's start - it's a special case\n        orientation = oppositeOrientation === +1 ? -1 : +1;\n        windingNum = oppositeWindingNum + orientation;\n        parent = oppositeLoopTree.parent;\n    }\n    let iLoopTree = {\n        parent,\n        children: new Set(),\n        beziers: undefined,\n        loop: undefined,\n        orientation,\n        windingNum\n    };\n    parent.children.add(iLoopTree);\n    return iLoopTree;\n}\nexports.getLoopMetrics = getLoopMetrics;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/svg/fs/simplify-paths/get-loop-metrics.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/svg/fs/simplify-paths/get-next-x.js":
/*!***************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/svg/fs/simplify-paths/get-next-x.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n *\n * @param xs An array of intersections on the curve\n * @param curT The current t value\n * @param forwards If true go forwards else go backwards\n */\nfunction getNextX(xs, curT, forwards, wasOnX) {\n    let bestX = undefined;\n    let bestT = Number.POSITIVE_INFINITY;\n    for (let i = 0; i < xs.length; i++) {\n        let x = xs[i];\n        let t = x.pos.t;\n        let deltaT = forwards\n            ? t - curT\n            : curT - t;\n        if ((deltaT > 0 || (deltaT === 0 && !wasOnX)) && deltaT < bestT) {\n            bestX = x;\n            bestT = deltaT;\n        }\n    }\n    return bestX;\n}\nexports.getNextX = getNextX;\n/**\n *\n * @param xs An array of intersections on the curve\n * @param t The current t value\n */\nfunction getThisX(xs, t) {\n    for (let i = 0; i < xs.length; i++) {\n        let x = xs[i];\n        if (x.pos.t - t === 0) {\n            return x;\n        }\n    }\n}\nexports.getThisX = getThisX;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/svg/fs/simplify-paths/get-next-x.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/svg/fs/simplify-paths/get-tightest-containing-loop.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/svg/fs/simplify-paths/get-tightest-containing-loop.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst is_loop_in_loop_1 = __webpack_require__(/*! ./is-loop-in-loop */ \"./node_modules/flo-mat/node/src/svg/fs/simplify-paths/is-loop-in-loop.js\");\n/**\n *\n * @param root\n * @param loop\n */\nfunction getTightestContainingLoop(root, loop) {\n    let containingLoop = undefined;\n    let stack = [root];\n    while (stack.length) {\n        let loopTree = stack.pop();\n        f(loopTree);\n    }\n    //console.log(containingLoop)\n    return containingLoop;\n    function f(parent) {\n        if (parent === root || is_loop_in_loop_1.isLoopInLoop([loop, parent.loop])) {\n            containingLoop = parent;\n            for (let child of parent.children) {\n                stack.push(child);\n            }\n        }\n    }\n}\nexports.getTightestContainingLoop = getTightestContainingLoop;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/svg/fs/simplify-paths/get-tightest-containing-loop.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/svg/fs/simplify-paths/is-loop-in-loop.js":
/*!********************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/svg/fs/simplify-paths/is-loop-in-loop.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\nconst point_on_shape_1 = __webpack_require__(/*! ../../../point-on-shape */ \"./node_modules/flo-mat/node/src/point-on-shape.js\");\nconst get_loop_bounds_1 = __webpack_require__(/*! ../get-loop-bounds */ \"./node_modules/flo-mat/node/src/svg/fs/get-loop-bounds.js\");\nconst DELTA = 1e-6;\n/**\n * Returns true if the first loop is contained wholly within the second. At this\n * stage we already know the loop is either wholly contained inside the loop\n * or is wholly outside.\n * @param loops\n */\nfunction isLoopInLoop(loops) {\n    let i = 0;\n    let seed = 1231; // Just some value\n    do {\n        i++;\n        // This gets us a predictable random number between 0 and 1;\n        let rand1 = flo_poly_1.default.random.flatCoefficients(1, 0, 1, seed);\n        let t = rand1.p[0];\n        seed = rand1.seed; // Get next seed.\n        // This gets us a predictable random number roughly between 0 and the \n        // number of curves in the loop.\n        let curveCount = loops[0].curves.length;\n        let rand2 = flo_poly_1.default.random.flatCoefficients(1, 0, curveCount, seed);\n        let idx = Math.floor(rand2.p[0]);\n        seed = rand2.seed; // Get next seed.\n        let ps = loops[0].curves[idx].ps;\n        let p = flo_bezier3_1.evaluate(ps, t);\n        let res = f(loops, p);\n        if (res !== undefined) {\n            return res;\n        }\n    } while (i < 10);\n    return undefined; // There's no chance we'll get up to this point.\n    function f(loops, p) {\n        if (isLoopNotInLoop(loops)) {\n            return false;\n        }\n        //let g = _debug_.generated.g;\n        //let bounds = getShapeBounds(loops);\n        //_debug_.fs.draw.dot(g, p, (bounds.maxX.p[0] - bounds.minX.p[0]) * 0.002, 'blue');\n        let intersections = getAxisAlignedRayLoopIntersections(loops[1], p, 'left');\n        //console.log(intersections, intersections.length % 2 !== 0);\n        if (intersections) {\n            return intersections.length % 2 !== 0;\n        }\n    }\n}\nexports.isLoopInLoop = isLoopInLoop;\n/**\n * Returns true if the first loop is not wholly within the second. The converse\n * is not necessarily true. It is assumed the loops don't intersect.\n * @param loops\n */\nfunction isLoopNotInLoop(loops) {\n    let loopBoundss = loops.map(get_loop_bounds_1.getLoopBounds);\n    let boundss = loopBoundss.map(loopBound => {\n        return {\n            minX: loopBound.minX.p[0],\n            maxX: loopBound.maxX.p[0],\n            minY: loopBound.minY.p[1],\n            maxY: loopBound.maxY.p[1]\n        };\n    });\n    return (boundss[0].minX < boundss[1].minX ||\n        boundss[0].maxX > boundss[1].maxX ||\n        boundss[0].minY < boundss[1].minY ||\n        boundss[0].maxY > boundss[1].maxY);\n}\n//enum Dir { LEFT, RIGHT, UP, DOWN }\n/**\n *\n * @param p The point where the horizontal ray starts\n * @param toLeft The ray to the left of this point (else right)\n * @param loop A loop of curves\n */\nfunction getAxisAlignedRayLoopIntersections(loop, p, dir) {\n    let [x, y] = p;\n    let curves = loop.curves;\n    let possAll = [];\n    for (let i = 0; i < curves.length; i++) {\n        let curve = curves[i];\n        let ps = curve.ps;\n        //------------------------------------------------------/\n        //---- Check if ray intersects bezier bounding box -----/\n        //------------------------------------------------------/\n        let [[minX, minY], [maxX, maxY]] = flo_bezier3_1.getBoundingBox(ps);\n        let notIntersecting = ((dir === 'left' || dir === 'right') && (minY > y || maxY < y)) ||\n            ((dir === 'up' || dir === 'down') && (minX > x || maxX < x));\n        notIntersecting = notIntersecting ||\n            (dir === 'left' && minX > x) || (dir === 'right' && maxX < x) ||\n            (dir === 'down' && minY > y) || (dir === 'up' && maxY < y);\n        if (notIntersecting) {\n            continue;\n        } // No intersection with bezier\n        //------------------------------------------------------/\n        //----------- Get intersection ts on bezier ------------/\n        //------------------------------------------------------/\n        // Get the bezier's x-coordinate power representation.\n        let ts = [];\n        let f;\n        let offset;\n        let axis;\n        let dirIsDecreasing = (dir === 'left' || dir === 'up');\n        if (dir === 'left' || dir === 'right') {\n            f = flo_bezier3_1.getY;\n            offset = [0, -y];\n            axis = 0;\n        }\n        else {\n            f = flo_bezier3_1.getX;\n            offset = [-x, 0];\n            axis = 1;\n        }\n        let translatedPs = flo_bezier3_1.translate(offset, ps);\n        let poly = f(translatedPs);\n        let ev = flo_bezier3_1.evaluate(translatedPs);\n        let ts_ = flo_poly_1.default.allRoots(poly, 0 - DELTA, 1 + DELTA);\n        for (let i = 0; i < ts_.length; i++) {\n            let t = ts_[i];\n            if (Math.abs(t) < DELTA || Math.abs(t - 1) < DELTA) {\n                // We don't know the exact number of intersections due to\n                // floating point arithmetic. \n                return undefined;\n            }\n            let p_ = ev(t);\n            if ((dirIsDecreasing && p[axis] >= p_[axis]) ||\n                (!dirIsDecreasing && p[axis] <= p_[axis])) {\n                ts.push(t);\n            }\n        }\n        //------------------------------------------------------/\n        //----- Check if line is tangent to intersections ------/\n        //------------------------------------------------------/\n        // We only care if there were 1 or 3 intersections.\n        if (ts.length === 1 || ts.length === 3) {\n            for (let t of ts) {\n                let tan = flo_bezier3_1.tangent(ps, t);\n                if (((dir === 'left' || dir === 'right') && Math.abs(tan[1]) < DELTA) ||\n                    ((dir === 'down' || dir === 'up') && Math.abs(tan[0]) < DELTA)) {\n                    // We don't know the exact number of intersections due to\n                    // floating point arithmetic\n                    return undefined;\n                }\n            }\n        }\n        possAll.push(...ts.map(t => new point_on_shape_1.PointOnShape(curve, t)));\n    }\n    return possAll;\n}\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/svg/fs/simplify-paths/is-loop-in-loop.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/svg/fs/simplify-paths/pair-set.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/svg/fs/simplify-paths/pair-set.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Adds an unordered pair of values to the set (given as a special map)\n * @param map The map representing the pairs.\n * @param vs The pair to add.\n */\nfunction pairSet_add(map, vs) {\n    if (pairSet_has(map, vs)) {\n        return;\n    }\n    f(vs[0], vs[1]);\n    f(vs[1], vs[0]);\n    function f(v1, v2) {\n        let set = map.get(v1);\n        if (!set) {\n            set = new Set();\n            map.set(v1, set);\n        }\n        set.add(v2);\n    }\n}\nexports.pairSet_add = pairSet_add;\n/**\n * Returns true if the unordered pair is in the set of pairs (represented by a\n * map).\n * @param map The map representing the pairs.\n * @param vs The pair to check.\n */\nfunction pairSet_has(map, vs) {\n    let set;\n    set = map.get(vs[0]);\n    let has1 = set && set.has(vs[1]);\n    set = map.get(vs[1]);\n    let has2 = set && set.has(vs[0]);\n    return has1 || has2;\n}\nexports.pairSet_has = pairSet_has;\n/**\n * Returns the unordered pairs as an array.\n * @param map The map representing the pairs.\n */\nfunction pairSet_asArray(map) {\n    let items = [];\n    let map_ = new Map();\n    for (let m of map) {\n        for (let s of m[1]) {\n            let vs = [m[0], s];\n            if (!pairSet_has(map_, vs)) {\n                items.push(vs);\n                pairSet_add(map_, vs);\n            }\n        }\n    }\n    return items;\n}\nexports.pairSet_asArray = pairSet_asArray;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/svg/fs/simplify-paths/pair-set.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/svg/fs/simplify-paths/simplify-paths.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/svg/fs/simplify-paths/simplify-paths.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst loop_1 = __webpack_require__(/*! ../../../loop */ \"./node_modules/flo-mat/node/src/loop.js\");\nconst get_loop_bounds_1 = __webpack_require__(/*! ../get-loop-bounds */ \"./node_modules/flo-mat/node/src/svg/fs/get-loop-bounds.js\");\nconst get_intersections_1 = __webpack_require__(/*! ./get-intersections */ \"./node_modules/flo-mat/node/src/svg/fs/simplify-paths/get-intersections.js\");\nconst complete_path_1 = __webpack_require__(/*! ./complete-path */ \"./node_modules/flo-mat/node/src/svg/fs/simplify-paths/complete-path.js\");\nconst get_tightest_containing_loop_1 = __webpack_require__(/*! ./get-tightest-containing-loop */ \"./node_modules/flo-mat/node/src/svg/fs/simplify-paths/get-tightest-containing-loop.js\");\n/**\n * Uses the algorithm of Lavanya Subramaniam (PARTITION OF A NON-SIMPLE POLYGON\n * INTO SIMPLE POLYGONS) but modified to use cubic bezier curves (as opposed to\n * polygons) and to additionally take care of paths with multiple subpaths, i.e.\n * such as disjoint nested paths.\n * @param loops An array of possibly intersecting paths\n */\nfunction simplifyPaths(loops) {\n    /*\n    let s = '';\n    for (let loop of loops) {\n        s = s + '\\n\\n' + beziersToSvgPathStr(loop.curves.map(c => c.ps), 5)\n    }\n    console.log(s);\n    */\n    /** A map from each curve to an array of intersections on that curve. */\n    let intersections = get_intersections_1.getIntersections(loops);\n    let loopsTaken = new Set();\n    let root = {\n        parent: undefined,\n        children: new Set(),\n        beziers: undefined,\n        loop: undefined,\n        orientation: undefined,\n        windingNum: 0\n    };\n    loops.sort(ascendingByTopmostPoint);\n    if (typeof _debug_ !== 'undefined') {\n        for (let loop of loops) {\n            _debug_.fs.nameObj(loop);\n        }\n    }\n    for (let loop of loops) {\n        // TODO - handle special case of 1 curve - mayve just delete lines below\n        if (loop.curves.length <= 1) {\n            continue;\n        }\n        if (loopsTaken.has(loop)) {\n            continue;\n        }\n        loopsTaken.add(loop);\n        let parent = get_tightest_containing_loop_1.getTightestContainingLoop(root, loop);\n        complete_path_1.completePath(intersections, loopsTaken, parent, loop);\n    }\n    // Take the forest of trees, create a new root making it a tree and snip\n    // branches such that each branch determines a new set of loops each \n    // representing an individual independent shape that possess its own Medial\n    // Axis Transform (still to be determined).\n    let loopTrees = splitLoopTrees(root);\n    let iLoopSets = loopTrees.map(getLoopsFromTree);\n    let loopss = iLoopSets.map(loopSet => loopSet.map(ILoopToLoop));\n    /*\n    let str = '';\n    for (let simplePaths of loopss) {\n        //console.log(str)\n        for (let loop of simplePaths) {\n            str = str + '\\n\\n' + beziersToSvgPathStr(\n                loop.curves.map(c => c.ps),\n                5\n            )\n        }\n        //console.log(str)\n        //console.log('-----------------');\n    }\n    console.log(str)\n    */\n    let xMap = new Map();\n    for (let intersection of intersections) {\n        for (let x of intersection[1]) {\n            if (x.isDummy) {\n                continue;\n            }\n            xMap.set(x.outPs, { ps: x.opposite.outPs });\n            if (typeof _debug_ !== 'undefined') {\n                _debug_.generated.elems.intersection.push(x);\n            }\n        }\n    }\n    return { loopss, xMap };\n}\nexports.simplifyPaths = simplifyPaths;\n/**\n *\n * @param iLoop\n */\nfunction ILoopToLoop(iLoop) {\n    return new loop_1.Loop(iLoop.beziers);\n}\nfunction splitLoopTrees(root) {\n    let iLoopTrees = [];\n    let nodeStack = [root];\n    while (nodeStack.length) {\n        let parent = nodeStack.pop();\n        for (let child of parent.children) {\n            if (parent.windingNum === 0) {\n                iLoopTrees.push(child);\n            }\n            nodeStack.push(child);\n        }\n        if (parent.windingNum === 0) {\n            parent.children = new Set(); // Make it a leaf\n        }\n    }\n    return iLoopTrees;\n}\n/**\n * Returns an array of LoopTrees from the given LoopTree where each returned\n * LoopTree is one of the nodes of the tree. Nodes with winding number > 1 are\n * not returned.\n * @param root\n */\nfunction getLoopsFromTree(root) {\n    let loopTrees = [];\n    let stack = [root];\n    while (stack.length) {\n        let node = stack.pop();\n        f(node);\n    }\n    return loopTrees;\n    function f(parent) {\n        if (Math.abs(parent.windingNum) <= 1) {\n            loopTrees.push(parent);\n        }\n        for (let child of parent.children) {\n            stack.push(child);\n        }\n    }\n}\n/**\n *\n * @param loopA\n * @param loopB\n */\nfunction ascendingByTopmostPoint(loopA, loopB) {\n    let boundsA = get_loop_bounds_1.getLoopBounds(loopA);\n    let boundsB = get_loop_bounds_1.getLoopBounds(loopB);\n    let a = boundsA.minY.p[1];\n    let b = boundsB.minY.p[1];\n    return a - b;\n}\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/svg/fs/simplify-paths/simplify-paths.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/svg/path-data-polyfill/parse-number.js":
/*!******************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/svg/path-data-polyfill/parse-number.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Parse a number from an SVG path. This very closely follows genericParseNumber(...) from\n// Source/core/svg/SVGParserUtilities.cpp.\n// Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-PathDataBNF\nfunction parseNumber(source) {\n    var exponent = 0;\n    var integer = 0;\n    var frac = 1;\n    var decimal = 0;\n    var sign = 1;\n    var expsign = 1;\n    var startIndex = source._currentIndex;\n    source._skipOptionalSpaces();\n    // Read the sign.\n    if (source._currentIndex < source._endIndex && source._string[source._currentIndex] === \"+\") {\n        source._currentIndex += 1;\n    }\n    else if (source._currentIndex < source._endIndex && source._string[source._currentIndex] === \"-\") {\n        source._currentIndex += 1;\n        sign = -1;\n    }\n    if (source._currentIndex === source._endIndex ||\n        ((source._string[source._currentIndex] < \"0\" || source._string[source._currentIndex] > \"9\") &&\n            source._string[source._currentIndex] !== \".\")) {\n        // The first character of a number must be one of [0-9+-.].\n        return null;\n    }\n    // Read the integer part, build right-to-left.\n    var startIntPartIndex = source._currentIndex;\n    while (source._currentIndex < source._endIndex &&\n        source._string[source._currentIndex] >= \"0\" &&\n        source._string[source._currentIndex] <= \"9\") {\n        source._currentIndex += 1; // Advance to first non-digit.\n    }\n    if (source._currentIndex !== startIntPartIndex) {\n        var scanIntPartIndex = source._currentIndex - 1;\n        var multiplier = 1;\n        while (scanIntPartIndex >= startIntPartIndex) {\n            integer += multiplier * (Number(source._string[scanIntPartIndex]) - 0);\n            scanIntPartIndex -= 1;\n            multiplier *= 10;\n        }\n    }\n    // Read the decimals.\n    if (source._currentIndex < source._endIndex && source._string[source._currentIndex] === \".\") {\n        source._currentIndex += 1;\n        // There must be a least one digit following the .\n        if (source._currentIndex >= source._endIndex ||\n            source._string[source._currentIndex] < \"0\" ||\n            source._string[source._currentIndex] > \"9\") {\n            return null;\n        }\n        while (source._currentIndex < source._endIndex &&\n            source._string[source._currentIndex] >= \"0\" &&\n            source._string[source._currentIndex] <= \"9\") {\n            frac *= 10;\n            decimal += (Number(source._string.charAt(source._currentIndex))) / frac;\n            source._currentIndex += 1;\n        }\n    }\n    // Read the exponent part.\n    if (source._currentIndex !== startIndex &&\n        source._currentIndex + 1 < source._endIndex &&\n        (source._string[source._currentIndex] === \"e\" || source._string[source._currentIndex] === \"E\") &&\n        (source._string[source._currentIndex + 1] !== \"x\" && source._string[source._currentIndex + 1] !== \"m\")) {\n        source._currentIndex += 1;\n        // Read the sign of the exponent.\n        if (source._string[source._currentIndex] === \"+\") {\n            source._currentIndex += 1;\n        }\n        else if (source._string[source._currentIndex] === \"-\") {\n            source._currentIndex += 1;\n            expsign = -1;\n        }\n        // There must be an exponent.\n        if (source._currentIndex >= source._endIndex ||\n            source._string[source._currentIndex] < \"0\" ||\n            source._string[source._currentIndex] > \"9\") {\n            return null;\n        }\n        while (source._currentIndex < source._endIndex &&\n            source._string[source._currentIndex] >= \"0\" &&\n            source._string[source._currentIndex] <= \"9\") {\n            exponent *= 10;\n            exponent += (Number(source._string[source._currentIndex]));\n            source._currentIndex += 1;\n        }\n    }\n    var number = integer + decimal;\n    number *= sign;\n    if (exponent) {\n        number *= Math.pow(10, expsign * exponent);\n    }\n    if (startIndex === source._currentIndex) {\n        return null;\n    }\n    source._skipOptionalSpacesOrDelimiter();\n    return number;\n}\nexports.parseNumber = parseNumber;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/svg/path-data-polyfill/parse-number.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/svg/path-data-polyfill/parse-path-data-string.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/svg/path-data-polyfill/parse-path-data-string.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst source_1 = __webpack_require__(/*! ./source */ \"./node_modules/flo-mat/node/src/svg/path-data-polyfill/source.js\");\nfunction parsePathDataString(string) {\n    if (!string.length)\n        return [];\n    let source = new source_1.Source(string);\n    let pathData = [];\n    if (!source.initialCommandIsMoveTo()) {\n        return [];\n    }\n    while (source.hasMoreData()) {\n        let pathSeg = source.parseSegment();\n        if (pathSeg === null) {\n            break;\n        }\n        else {\n            pathData.push(pathSeg);\n        }\n    }\n    return pathData;\n}\nexports.parsePathDataString = parsePathDataString;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/svg/path-data-polyfill/parse-path-data-string.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/svg/path-data-polyfill/source.js":
/*!************************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/svg/path-data-polyfill/source.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst parse_number_1 = __webpack_require__(/*! ./parse-number */ \"./node_modules/flo-mat/node/src/svg/path-data-polyfill/parse-number.js\");\nconst COMMAND_MAP = {\n    \"Z\": \"Z\", \"M\": \"M\", \"L\": \"L\", \"C\": \"C\", \"Q\": \"Q\", \"A\": \"A\", \"H\": \"H\", \"V\": \"V\", \"S\": \"S\", \"T\": \"T\",\n    \"z\": \"Z\", \"m\": \"m\", \"l\": \"l\", \"c\": \"c\", \"q\": \"q\", \"a\": \"a\", \"h\": \"h\", \"v\": \"v\", \"s\": \"s\", \"t\": \"t\"\n};\nclass Source {\n    constructor(string) {\n        this._string = string;\n        this._currentIndex = 0;\n        this._endIndex = this._string.length;\n        this._prevCommand = null;\n        this._skipOptionalSpaces();\n    }\n    parseSegment() {\n        var char = this._string[this._currentIndex];\n        var command = COMMAND_MAP[char] ? COMMAND_MAP[char] : null;\n        if (command === null) {\n            // Possibly an implicit command. Not allowed if this is the first command.\n            if (this._prevCommand === null) {\n                return null;\n            }\n            // Check for remaining coordinates in the current command.\n            if ((char === \"+\" || char === \"-\" || char === \".\" || (char >= \"0\" && char <= \"9\")) && this._prevCommand !== \"Z\") {\n                if (this._prevCommand === \"M\") {\n                    command = \"L\";\n                }\n                else if (this._prevCommand === \"m\") {\n                    command = \"l\";\n                }\n                else {\n                    command = this._prevCommand;\n                }\n            }\n            else {\n                command = null;\n            }\n            if (command === null) {\n                return null;\n            }\n        }\n        else {\n            this._currentIndex += 1;\n        }\n        this._prevCommand = command;\n        var values = null;\n        var cmd = command.toUpperCase();\n        if (cmd === \"H\" || cmd === \"V\") {\n            values = [parse_number_1.parseNumber(this)];\n        }\n        else if (cmd === \"M\" || cmd === \"L\" || cmd === \"T\") {\n            values = [parse_number_1.parseNumber(this), parse_number_1.parseNumber(this)];\n        }\n        else if (cmd === \"S\" || cmd === \"Q\") {\n            values = [parse_number_1.parseNumber(this), parse_number_1.parseNumber(this), parse_number_1.parseNumber(this), parse_number_1.parseNumber(this)];\n        }\n        else if (cmd === \"C\") {\n            values = [\n                parse_number_1.parseNumber(this),\n                parse_number_1.parseNumber(this),\n                parse_number_1.parseNumber(this),\n                parse_number_1.parseNumber(this),\n                parse_number_1.parseNumber(this),\n                parse_number_1.parseNumber(this)\n            ];\n        }\n        else if (cmd === \"A\") {\n            values = [\n                parse_number_1.parseNumber(this),\n                parse_number_1.parseNumber(this),\n                parse_number_1.parseNumber(this),\n                this._parseArcFlag(),\n                this._parseArcFlag(),\n                parse_number_1.parseNumber(this),\n                parse_number_1.parseNumber(this)\n            ];\n        }\n        else if (cmd === \"Z\") {\n            this._skipOptionalSpaces();\n            values = [];\n        }\n        if (values === null || values.indexOf(null) >= 0) {\n            // Unknown command or known command with invalid values\n            return null;\n        }\n        else {\n            return { type: command, values: values };\n        }\n    }\n    hasMoreData() {\n        return this._currentIndex < this._endIndex;\n    }\n    peekSegmentType() {\n        var char = this._string[this._currentIndex];\n        return COMMAND_MAP[char] ? COMMAND_MAP[char] : null;\n    }\n    initialCommandIsMoveTo() {\n        // If the path is empty it is still valid, so return true.\n        if (!this.hasMoreData()) {\n            return true;\n        }\n        var command = this.peekSegmentType();\n        // Path must start with moveTo.\n        return command === \"M\" || command === \"m\";\n    }\n    _isCurrentSpace() {\n        var char = this._string[this._currentIndex];\n        return char <= \" \" && (char === \" \" || char === \"\\n\" || char === \"\\t\" || char === \"\\r\" || char === \"\\f\");\n    }\n    _skipOptionalSpaces() {\n        while (this._currentIndex < this._endIndex && this._isCurrentSpace()) {\n            this._currentIndex += 1;\n        }\n        return this._currentIndex < this._endIndex;\n    }\n    _skipOptionalSpacesOrDelimiter() {\n        if (this._currentIndex < this._endIndex &&\n            !this._isCurrentSpace() &&\n            this._string[this._currentIndex] !== \",\") {\n            return false;\n        }\n        if (this._skipOptionalSpaces()) {\n            if (this._currentIndex < this._endIndex && this._string[this._currentIndex] === \",\") {\n                this._currentIndex += 1;\n                this._skipOptionalSpaces();\n            }\n        }\n        return this._currentIndex < this._endIndex;\n    }\n    _parseArcFlag() {\n        if (this._currentIndex >= this._endIndex) {\n            return null;\n        }\n        var flag = null;\n        var flagChar = this._string[this._currentIndex];\n        this._currentIndex += 1;\n        if (flagChar === \"0\") {\n            flag = 0;\n        }\n        else if (flagChar === \"1\") {\n            flag = 1;\n        }\n        else {\n            return null;\n        }\n        this._skipOptionalSpacesOrDelimiter();\n        return flag;\n    }\n}\nexports.Source = Source;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/svg/path-data-polyfill/source.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/svg/path-segment/a.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/svg/path-segment/a.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * A and a: (from www.w3.org)\n *\n * params: rx ry x-axis-rotation large-arc-flag sweep-flag x y\n *\n * Draws an elliptical arc from the current point to (x, y). The size and\n * orientation of the ellipse are defined by two radii (rx, ry) and an\n * x-axis-rotation, which indicates how the ellipse as a whole is rotated\n * relative to the current coordinate system. The center (cx, cy) of the ellipse\n * is calculated automatically to satisfy the constraints imposed by the other\n * parameters. large-arc-flag and sweep-flag contribute to the automatic\n * calculations and help determine how the arc is drawn.\n */\nfunction a(s) {\n    // TODO - not implemented yet (or not necessary)\n    s.prev2ndCubicControlPoint = undefined;\n    s.prev2ndQuadraticControlPoint = undefined;\n    // Update current point\n    //x0 = ? ps[3][0]; \n    //y0 = ? ps[3][1];\n    return undefined;\n}\nexports.a = a;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/svg/path-segment/a.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/svg/path-segment/c.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/svg/path-segment/c.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * C and c: (from www.w3.org)\n *\n * params: x1 y1 x2 y2 x y\n *\n * Draws a cubic Bézier curve from the current point to (x,y)\n * using (x1,y1) as the control point at the beginning of the\n * curve and (x2,y2) as the control point at the end of the\n * curve. C (uppercase) indicates that absolute coordinates\n * will follow; c (lowercase) indicates that relative\n * coordinates will follow. Multiple sets of coordinates may\n * be specified to draw a polybézier. At the end of the\n * command, the new current point becomes the final (x,y)\n * coordinate pair used in the polybézier.\n */\nfunction c(s) {\n    let ps = [\n        s.p,\n        [s.vals[0], s.vals[1]],\n        [s.vals[2], s.vals[3]],\n        [s.vals[4], s.vals[5]]\n    ];\n    s.prev2ndCubicControlPoint = ps[2];\n    s.prev2ndQuadraticControlPoint = undefined;\n    return ps;\n}\nexports.c = c;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/svg/path-segment/c.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/svg/path-segment/h.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/svg/path-segment/h.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * H and h: (from www.w3.org)\n *\n * params: x\n *\n * Draws a horizontal line from the current point (cpx, cpy) to (x, cpy). H\n * (uppercase) indicates that absolute coordinates will follow; h (lowercase)\n * indicates that relative coordinates will follow. Multiple x values can be\n * provided (although usually this doesn't make sense). At the end of the\n * command, the new current point becomes (x, cpy) for the final value of x.\n */\nfunction h(s) {\n    let xInterval = (s.vals[0] - s.p[0]) / 3;\n    let ps = [\n        s.p,\n        [s.p[0] + xInterval * 1, s.p[1]],\n        [s.p[0] + xInterval * 2, s.p[1]],\n        [s.p[0] + xInterval * 3, s.p[1]]\n    ];\n    s.prev2ndCubicControlPoint = undefined;\n    s.prev2ndQuadraticControlPoint = undefined;\n    return ps;\n}\nexports.h = h;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/svg/path-segment/h.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/svg/path-segment/l.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/svg/path-segment/l.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * L and l: (from www.w3.org)\n *\n * params: x y\n *\n * Draw a line from the current point to the given (x,y) coordinate which\n * becomes the new current point. L (uppercase) indicates that absolute\n * coordinates will follow; l (lowercase) indicates that relative coordinates\n * will follow. A number of coordinates pairs may be specified to draw a\n * polyline. At the end of the command, the new current point is set to the\n * final set of coordinates provided.\n */\nfunction l(s) {\n    let xInterval = (s.vals[0] - s.p[0]) / 3;\n    let yInterval = (s.vals[1] - s.p[1]) / 3;\n    let ps = [\n        s.p,\n        [s.p[0] + xInterval * 1, s.p[1] + yInterval * 1],\n        [s.p[0] + xInterval * 2, s.p[1] + yInterval * 2],\n        [s.p[0] + xInterval * 3, s.p[1] + yInterval * 3]\n    ];\n    s.prev2ndCubicControlPoint = undefined;\n    s.prev2ndQuadraticControlPoint = undefined;\n    return ps;\n}\nexports.l = l;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/svg/path-segment/l.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/svg/path-segment/q.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/svg/path-segment/q.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Q and q: (from www.w3.org)\n *\n * params: x1 y1 x y\n *\n * Draws a quadratic Bézier curve from the current point to (x,y) using (x1,y1)\n * as the control point. Q (uppercase) indicates that absolute coordinates will\n * follow; q (lowercase) indicates that relative coordinates will follow.\n * Multiple sets of coordinates may be specified to draw a polybézier. At the\n * end of the command, the new current point becomes the final (x,y) coordinate\n * pair used in the polybézier.\n */\nfunction q(s) {\n    //---------------------------------------------------\n    // Convert quadratic to cubic\n    // see https://stackoverflow.com/questions/3162645/convert-a-quadratic-bezier-to-a-cubic/3162732#3162732\n    //---------------------------------------------------\n    let QP0 = s.p;\n    let QP1 = [s.vals[0], s.vals[1]];\n    let QP2 = [s.vals[2], s.vals[3]];\n    // Endpoints stay the same\n    let CP0 = QP0;\n    let CP3 = QP2;\n    // CP1 = QP0 + 2/3 *(QP1-QP0)\n    let CP1 = [\n        QP0[0] + (2 / 3) * (QP1[0] - QP0[0]),\n        QP0[1] + (2 / 3) * (QP1[1] - QP0[1])\n    ];\n    // CP2 = QP2 + 2/3 *(QP1-QP2)\n    let CP2 = [\n        QP2[0] + (2 / 3) * (QP1[0] - QP2[0]),\n        QP2[1] + (2 / 3) * (QP1[1] - QP2[1])\n    ];\n    let ps = [CP0, CP1, CP2, CP3];\n    s.prev2ndCubicControlPoint = undefined;\n    s.prev2ndQuadraticControlPoint = QP1;\n    return ps;\n}\nexports.q = q;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/svg/path-segment/q.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/svg/path-segment/s.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/svg/path-segment/s.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * S and s: (from www.w3.org)\n *\n * params: x2 y2 x y\n *\n * Draws a cubic Bézier curve from the current point to (x,y). The first control\n * point is assumed to be the reflection of the second control point on the\n * previous command relative to the current point. (If there is no previous\n * command or if the previous command was not an C, c, S or s, assume the first\n * control point is coincident with the current point.) (x2,y2) is the second\n * control point (i.e., the control point at the end of the curve). S\n * (uppercase) indicates that absolute coordinates will follow; s (lowercase)\n * indicates that relative coordinates will follow. Multiple sets of coordinates\n * may be specified to draw a polybézier. At the end of the command, the new\n * current point becomes the final (x,y) coordinate pair used in the polybézier.\n */\nfunction s(s) {\n    let p = [undefined, undefined];\n    if (s.prev2ndCubicControlPoint) {\n        p[0] = (s.p[0] - s.prev2ndCubicControlPoint[0]) + s.p[0];\n        p[1] = (s.p[1] - s.prev2ndCubicControlPoint[1]) + s.p[1];\n    }\n    else {\n        p = s.p;\n    }\n    let ps = [\n        s.p,\n        p,\n        [s.vals[0], s.vals[1]],\n        [s.vals[2], s.vals[3]]\n    ];\n    s.prev2ndCubicControlPoint = ps[2];\n    s.prev2ndQuadraticControlPoint = undefined;\n    return ps;\n}\nexports.s = s;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/svg/path-segment/s.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/svg/path-segment/t.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/svg/path-segment/t.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * T and t: (from www.w3.org)\n *\n * params: x y\n *\n * Draws a quadratic Bézier curve from the current point to (x,y). The control\n * point is assumed to be the reflection of the control point on the previous\n * command relative to the current point. (If there is no previous command or if\n * the previous command was not a Q, q, T or t, assume the control point is\n * coincident with the current point.) T (uppercase) indicates that absolute\n * coordinates will follow; t (lowercase) indicates that relative coordinates\n * will follow. At the end of the command, the new current point becomes the\n * final (x,y) coordinate pair used in the polybézier.\n */\nfunction t(s) {\n    let p = [undefined, undefined];\n    if (s.prev2ndQuadraticControlPoint) {\n        p[0] = (s.p[0] - s.prev2ndQuadraticControlPoint[0]) + s.p[0];\n        p[1] = (s.p[1] - s.prev2ndQuadraticControlPoint[1]) + s.p[1];\n    }\n    else {\n        p = s.p;\n    }\n    //---------------------------------------------------\n    // Convert quadratic to cubic\n    // see https://stackoverflow.com/questions/3162645/convert-a-quadratic-bezier-to-a-cubic/3162732#3162732\n    //---------------------------------------------------\n    let QP0 = s.p;\n    let QP1 = p;\n    let QP2 = [s.vals[0], s.vals[1]];\n    // CP1 = QP0 + 2/3 *(QP1-QP0)\n    let CP1 = [\n        QP0[0] + (2 / 3) * (QP1[0] - QP0[0]),\n        QP0[1] + (2 / 3) * (QP1[1] - QP0[1])\n    ];\n    // CP2 = QP2 + 2/3 *(QP1-QP2)\n    let CP2 = [\n        QP2[0] + (2 / 3) * (QP1[0] - QP2[0]),\n        QP2[1] + (2 / 3) * (QP1[1] - QP2[1])\n    ];\n    let ps = [QP0, CP1, CP2, QP2];\n    s.prev2ndCubicControlPoint = undefined;\n    s.prev2ndQuadraticControlPoint = QP1;\n    return ps;\n}\nexports.t = t;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/svg/path-segment/t.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/svg/path-segment/v.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/svg/path-segment/v.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * V and v: (from www.w3.org)\n *\n * params: y\n *\n * Draws a vertical line from the current point (cpx, cpy) to (cpx, y). V\n * (uppercase) indicates that absolute coordinates will follow; v (lowercase)\n * indicates that relative coordinates will follow. Multiple y values can be\n * provided (although usually this doesn't make sense). At the end of the\n * command, the new current point becomes (cpx, y) for the final value of y.\n */\nfunction v(s) {\n    let yInterval = (s.vals[0] - s.p[1]) / 3;\n    let ps = [\n        s.p,\n        [s.p[0], s.p[1] + yInterval * 1],\n        [s.p[0], s.p[1] + yInterval * 2],\n        [s.p[0], s.p[1] + yInterval * 3]\n    ];\n    s.prev2ndCubicControlPoint = undefined;\n    s.prev2ndQuadraticControlPoint = undefined;\n    return ps;\n}\nexports.v = v;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/svg/path-segment/v.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/svg/path-segment/z.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-mat/node/src/svg/path-segment/z.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Z and z: (from www.w3.org)\n *\n * params: (none)\n *\n * Close the current subpath by drawing a straight line from the current point\n * to current subpath's initial point. Since the Z and z commands take no\n * parameters, they have an identical effect.\n */\nfunction z(s) {\n    let xInterval = (s.initialPoint[0] - s.p[0]) / 3;\n    let yInterval = (s.initialPoint[1] - s.p[1]) / 3;\n    let ps = [\n        s.p,\n        [s.p[0] + xInterval, s.p[1] + yInterval],\n        [s.p[0] + xInterval * 2, s.p[1] + yInterval * 2],\n        [s.p[0] + xInterval * 3, s.p[1] + yInterval * 3]\n    ];\n    s.prev2ndCubicControlPoint = undefined;\n    s.prev2ndQuadraticControlPoint = undefined;\n    return ps;\n}\nexports.z = z;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/svg/path-segment/z.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/svg/path-state.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-mat/node/src/svg/path-state.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass PathState {\n    constructor() {\n        this.initialPoint = undefined;\n        // Used in conjunction with \"S\" and \"s\"\n        this.prev2ndCubicControlPoint = undefined;\n        this.prev2ndQuadraticControlPoint = undefined;\n        this.p = [0, 0];\n    }\n}\nexports.PathState = PathState;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/svg/path-state.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/svg/svg.js":
/*!**************************************************!*\
  !*** ./node_modules/flo-mat/node/src/svg/svg.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst get_min_y_pos_1 = __webpack_require__(/*! ./fs/get-min-y-pos */ \"./node_modules/flo-mat/node/src/svg/fs/get-min-y-pos.js\");\nexports.getMinYPos = get_min_y_pos_1.getMinYPos;\nconst get_paths_from_svg_path_elem_1 = __webpack_require__(/*! ./fs/get-paths-from-svg-path-elem */ \"./node_modules/flo-mat/node/src/svg/fs/get-paths-from-svg-path-elem.js\");\nexports.getPathsFromSvgPathElem = get_paths_from_svg_path_elem_1.getPathsFromSvgPathElem;\nconst get_paths_from_str_1 = __webpack_require__(/*! ./fs/get-paths-from-str */ \"./node_modules/flo-mat/node/src/svg/fs/get-paths-from-str.js\");\nexports.getPathsFromStr = get_paths_from_str_1.getPathsFromStr;\nconst get_loop_bounds_1 = __webpack_require__(/*! ./fs/get-loop-bounds */ \"./node_modules/flo-mat/node/src/svg/fs/get-loop-bounds.js\");\nexports.getLoopBounds = get_loop_bounds_1.getLoopBounds;\nconst is_path_positively_oriented_1 = __webpack_require__(/*! ./fs/is-path-positively-oriented */ \"./node_modules/flo-mat/node/src/svg/fs/is-path-positively-oriented.js\");\nexports.isPathPositivelyOrientated = is_path_positively_oriented_1.isPathPositivelyOrientated;\nconst get_curvature_at_interface_1 = __webpack_require__(/*! ./fs/get-curvature-at-interface */ \"./node_modules/flo-mat/node/src/svg/fs/get-curvature-at-interface.js\");\nexports.getCurvatureAtInterface = get_curvature_at_interface_1.getCurvatureAtInterface;\nconst simplify_paths_1 = __webpack_require__(/*! ./fs/simplify-paths/simplify-paths */ \"./node_modules/flo-mat/node/src/svg/fs/simplify-paths/simplify-paths.js\");\nexports.simplifyPaths = simplify_paths_1.simplifyPaths;\nconst circle_to_cubic_beziers_1 = __webpack_require__(/*! ./fs/circle-to-cubic-beziers */ \"./node_modules/flo-mat/node/src/svg/fs/circle-to-cubic-beziers.js\");\nexports.circleToCubicBeziers = circle_to_cubic_beziers_1.circleToCubicBeziers;\nconst beziers_to_svg_path_str_1 = __webpack_require__(/*! ./fs/beziers-to-svg-path-str */ \"./node_modules/flo-mat/node/src/svg/fs/beziers-to-svg-path-str.js\");\nexports.beziersToSvgPathStr = beziers_to_svg_path_str_1.beziersToSvgPathStr;\nconst get_shape_bounds_1 = __webpack_require__(/*! ./fs/get-shape-bounds */ \"./node_modules/flo-mat/node/src/svg/fs/get-shape-bounds.js\");\nexports.getShapeBounds = get_shape_bounds_1.getShapeBounds;\nexports.getShapesBounds = get_shape_bounds_1.getShapesBounds;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/svg/svg.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/src/x.js":
/*!********************************************!*\
  !*** ./node_modules/flo-mat/node/src/x.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Representation of one side of an intersection. The opposite side is at\n * X.opposite.\n */\nclass X {\n    constructor(\n        /**\n         * The PointOnShape on the curve of the intersection. This side of the\n         * intersection is represented by the incoming part of this curve.\n         */\n        pos, isDummy = false, \n        /** The opposite side of the intersection */\n        opposite, loopTree, \n        //public inPs?     : number[][],\n        outPs) {\n        this.pos = pos;\n        this.isDummy = isDummy;\n        this.opposite = opposite;\n        this.loopTree = loopTree;\n        this.outPs = outPs;\n    }\n}\nexports.X = X;\n\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/src/x.js?");

/***/ }),

/***/ "./node_modules/flo-memoize/node/index.js":
/*!************************************************!*\
  !*** ./node_modules/flo-memoize/node/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst SUPPORTED = typeof WeakMap === 'function';\n/**\n * Memoize the given arity 1 function.\n */\nfunction m1(f) {\n    if (!SUPPORTED) {\n        return f;\n    }\n    let results = new WeakMap();\n    return function (a) {\n        let result = results.get(a);\n        if (result !== undefined) {\n            //console.log('cache hit');\n            return result;\n        }\n        //console.log('cache miss');\n        result = f(a);\n        results.set(a, result);\n        return result;\n    };\n}\nlet Memoize = { m1, };\nexports.default = Memoize;\n\n\n//# sourceURL=webpack:///./node_modules/flo-memoize/node/index.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/index.js":
/*!*********************************************!*\
  !*** ./node_modules/flo-poly/node/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst core_operators_1 = __webpack_require__(/*! ./src/core-operators */ \"./node_modules/flo-poly/node/src/core-operators.js\");\nconst root_operators_1 = __webpack_require__(/*! ./src/root-operators */ \"./node_modules/flo-poly/node/src/root-operators.js\");\nconst root_bounds_1 = __webpack_require__(/*! ./src/root-bounds */ \"./node_modules/flo-poly/node/src/root-bounds.js\");\nconst all_roots_recursive_1 = __webpack_require__(/*! ./src/all-roots-recursive */ \"./node_modules/flo-poly/node/src/all-roots-recursive.js\");\nconst random_1 = __webpack_require__(/*! ./src/random */ \"./node_modules/flo-poly/node/src/random.js\");\nconst error_analysis_1 = __webpack_require__(/*! ./src/error-analysis */ \"./node_modules/flo-poly/node/src/error-analysis.js\");\nconst from_roots_1 = __webpack_require__(/*! ./src/from-roots */ \"./node_modules/flo-poly/node/src/from-roots.js\");\nconst multiply = core_operators_1.default.multiply;\n/**\n* Simple & fast practical library functions for functional univariate\n* polynomials over the reals (actually ECMAScript numbers, i.e. double\n* floats).\n*\n* All polinomials are represented as a simple array starting with the\n* highest non-zero power, e.g.\n*   3x^3 + 5x^2 + 7x + 2 -> [3,5,7,2]\n*\n* @ignore\n*/\nconst FloPoly = Object.assign({}, core_operators_1.default, root_operators_1.default, root_bounds_1.default, error_analysis_1.default, { random: random_1.default,\n    fromRoots: from_roots_1.default,\n    allRoots: all_roots_recursive_1.default });\nexports.default = FloPoly;\n\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/index.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/src/all-roots-recursive.js":
/*!***************************************************************!*\
  !*** ./node_modules/flo-poly/node/src/all-roots-recursive.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst core_operators_1 = __webpack_require__(/*! ./core-operators */ \"./node_modules/flo-poly/node/src/core-operators.js\");\nconst root_operators_1 = __webpack_require__(/*! ./root-operators */ \"./node_modules/flo-poly/node/src/root-operators.js\");\nconst root_bounds_1 = __webpack_require__(/*! ./root-bounds */ \"./node_modules/flo-poly/node/src/root-bounds.js\");\nconst { clip0, evaluate, differentiate, toCasStr } = core_operators_1.default;\nconst { brent, quadraticRoots } = root_operators_1.default;\nconst { rootMagnitudeUpperBound_fujiwara, positiveRootUpperBound_LMQ, positiveRootLowerBound_LMQ, negativeRootUpperBound_LMQ, negativeRootLowerBound_LMQ, } = root_bounds_1.default;\nconst INF = Number.POSITIVE_INFINITY;\n/**\n * <p>Finds a near optimal approximation to the real roots (or those\n * within a range) of the input polynomial.\n * </p>\n * <p>\n * Only multiple roots of even order that is very close together may be\n * missed. (This is rarely a problem in practice - in a geometrical\n * application, for instance, this may mean two objects are barely\n * touching and returning either, all, or none of the repeated even\n * roots should not break the algorithm).\n * </p>\n * @param p - The polynomial\n * @param a - Lower limit of root values that should be returned -\n * defaults to -∞\n * @param b - Upper limit of root values that should be returned -\n * defaults to +∞\n * @example\n * FloPoly.allRoots([1, -10, 35, -50, 24]); //=> [1, 2.0000000000000036, 3.0000000000000067, 4]\n */\nfunction allRoots(p, a = -INF, b = +INF) {\n    p = clip0(p);\n    let d = p.length - 1;\n    let rangeFilter = inRange(a, b);\n    if (d === 2) {\n        return quadraticRoots(p)\n            .filter(rangeFilter);\n        // Investigate if any numerically stable algorithm could be as fast\n        // as this algorithm (i.e by finding cubic roots within quadratic\n        // root demarcated intervals via Brent's method. The cubicRoots \n        // algoritm below has been removed since it was numerically \n        // unstable.\n        /*} else if (d === 3) {\n            return cubicRoots(p)\n                .filter(rangeFilter)\n                .sort((a,b) => a-b)\n        } else if (d > 3) {*/\n    }\n    else if (d > 2) {\n        // TODO The root bounding function below might have an impact on \n        // performance - it would probably be better to use \n        // positiveRootUpperBound_LMQ or (possibly) even better, the \n        // linear version of it (see paper of Viglas, Akritas and \n        // Strzebonski) and re-calculate bounds on every iteration.\n        let lowerBound;\n        let upperBound;\n        if (a === -INF || b === +INF) {\n            //let magnitudeBound = rootMagnitudeUpperBound_fujiwara(p);\n            //lowerBound = a === -INF ? -magnitudeBound : a;\n            //upperBound = b === +INF ? +magnitudeBound : b;\n            if (a === -INF) {\n                lowerBound = negativeRootLowerBound_LMQ(p);\n            }\n            else {\n                lowerBound = a;\n            }\n            if (b === +INF) {\n                upperBound = positiveRootUpperBound_LMQ(p);\n            }\n            else {\n                upperBound = b;\n            }\n        }\n        else {\n            lowerBound = a;\n            upperBound = b;\n        }\n        // If the roots of the differentiated polynomial is out of range \n        // then the roots of the polynomial itself will also be out of \n        // range.\n        let dp = differentiate(p);\n        let roots = allRoots(dp, lowerBound, upperBound)\n            .filter(rangeFilter);\n        if (roots[0] !== lowerBound) {\n            // For code coverage to cover the 'else' case we would need\n            // to find a case where the lower bound actually matches the\n            // root which would be very rare - needs further \n            // investigation.\n            // Not an actual root.\n            roots.unshift(lowerBound);\n        }\n        if (roots[roots.length - 1] !== upperBound) {\n            // Not an actual root.\n            roots.push(upperBound);\n        }\n        return rootsWithin(p, roots);\n    }\n    else if (d === 1) {\n        // Less likely so put near bottom (micro optimization)\n        return [-p[1] / p[0]]\n            .filter(rangeFilter);\n    }\n    else if (d === 0) {\n        return []; // y = c -> no roots\t\n    }\n    // Least likely so put at bottom (micro optimization)\n    // d === -1\n    // y = 0 -> infinite number of roots\n    return [];\n}\n/**\n * Returns a function that returns true if x is in the range [a,b].\n * @param a\n * @param b\n * @private\n */\nfunction inRange(a, b) {\n    return x => x >= a && x <= b;\n}\n/**\n * Finds all roots of the given polynomial within the given intervals.\n * @private\n * @param p\n * @param intervals\n */\nfunction rootsWithin(p, intervals) {\n    let roots = [];\n    let peval = evaluate(p);\n    let prevRoot;\n    let a = intervals[0];\n    for (let i = 1; i < intervals.length; i++) {\n        let root;\n        let b = intervals[i];\n        let evA = peval(a);\n        let evB = peval(b);\n        let k = evA * evB;\n        if (k === 0) {\n            if (evA === 0) {\n                root = a;\n            }\n            else if (evB === 0 && i === intervals.length - 1) {\n                root = b;\n            }\n        }\n        else if (evA * evB < 0) {\n            root = brent(peval, a, b);\n        }\n        // Add root if it exists and suppress exact duplicates\n        if (root !== undefined && root !== prevRoot) {\n            roots.push(root);\n            prevRoot = root;\n        }\n        a = b;\n    }\n    return roots;\n}\nexports.default = allRoots;\n\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/src/all-roots-recursive.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/src/core-operators.js":
/*!**********************************************************!*\
  !*** ./node_modules/flo-poly/node/src/core-operators.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Returns true if two polynomials are exactly equal by comparing\n * coefficients.\n * @param p1 - A polynomial\n * @param p2 - Another polynomial\n * @example\n * FloPoly.equal([1,2,3,4], [1,2,3,4]);   //=> true\n * FloPoly.equal([1,2,3,4], [1,2,3,4,5]); //=> false\n */\nfunction equal(p1, p2) {\n    if (p1.length !== p2.length) {\n        return false;\n    }\n    for (let i = 0; i < p1.length; i++) {\n        if (p1[i] !== p2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Adds two polynomials.\n * @param p1 - The first polynomial\n * @param p2 - The second polynomial\n * @example\n * FloPoly.add([1,2,3],[3,4]); //=> [1,5,7]\n */\nfunction add(p1, p2) {\n    // Initialize result array  \n    let d1 = p1.length - 1;\n    let d2 = p2.length - 1;\n    let Δd = d1 - d2;\n    let Δd1 = 0;\n    let Δd2 = 0;\n    if (Δd > 0) {\n        Δd2 = -Δd;\n    }\n    else if (Δd < 0) {\n        Δd1 = +Δd;\n    }\n    let d = Math.max(d1, d2);\n    // Add coefficients\n    let result = [];\n    for (let i = 0; i < d + 1; i++) {\n        let c1 = p1[i + Δd1];\n        let c2 = p2[i + Δd2];\n        result.push((c1 || 0) + (c2 || 0));\n    }\n    // Ensure the result is a valid polynomial representation\n    return clip0(result);\n}\n/**\n * Subtracts the second polynomial from first (p1 - p2).\n * @param p1 - The polynomial from which will be subtracted\n * @param p2 - The polynomial that will be subtracted\n * @example\n * FloPoly.subtract([2,3],[4,4]); //=> [-2, -1]\n */\nfunction subtract(p1, p2) {\n    // Initialize result array  \n    let d1 = p1.length - 1;\n    let d2 = p2.length - 1;\n    let Δd = d1 - d2;\n    let Δd1 = 0;\n    let Δd2 = 0;\n    if (Δd > 0) {\n        Δd2 = -Δd;\n    }\n    else if (Δd < 0) {\n        Δd1 = +Δd;\n    }\n    let d = Math.max(d1, d2);\n    // Add coefficients\n    let result = [];\n    for (let i = 0; i < d + 1; i++) {\n        let c1 = p1[i + Δd1];\n        let c2 = p2[i + Δd2];\n        result.push((c1 || 0) - (c2 || 0));\n    }\n    // Ensure the result is a valid polynomial representation\n    return clip0(result);\n}\n/**\n * Negate the given polynomial (p -> -p).\n * @param p - The polynomial\n * @example\n * FloPoly.negate([0.1, -0.2]); //=> [-0.1, 0.2]\n */\nfunction negate(p) {\n    return multiplyByConst(-1, p);\n}\n/**\n * Differentiates the given polynomial.\n * @param p - The polynomial\n * @example\n * FloPoly.differentiate([5, 4, 3, 2, 1]); //=> [20, 12, 6, 2]\n */\nfunction differentiate(p) {\n    let result = [];\n    let d = p.length - 1;\n    for (let i = 0; i < d; i++) {\n        result.push((d - i) * p[i]);\n    }\n    return result;\n}\n/**\n * <p>\n * Multiplies the two given polynomials and returns the result.\n * </p>\n * <p>\n * See <a href=\"https://en.wikipedia.org/wiki/Polynomial_arithmetic\">polynomial arithmetic</a>\n * </p>\n * <p>\n * See <a href=\"https://en.wikipedia.org/wiki/Discrete_Fourier_transform#Polynomial_multiplication\">polynomial multiplication</a>\n * </p>\n * <p>\n * See <a herf=\"http://web.cs.iastate.edu/~cs577/handouts/polymultiply.pdf\">polynomial multiplication (pdf)</a>\n * </p>\n * @param p1 - The one polynomial.\n * @param p2 - The other polynomial.\n * @example\n * FloPoly.multiply([1,2,3], [2,5,3,5]); //=> [2, 9, 19, 26, 19, 15]\n */\nfunction multiply(p1, p2) {\n    let d1 = p1.length - 1;\n    let d2 = p2.length - 1;\n    let d = d1 + d2;\n    let result = new Array(d + 1).fill(0);\n    for (let i = 0; i < d1 + 1; i++) {\n        for (let j = 0; j < d2 + 1; j++) {\n            result[d - (i + j)] += (p1[d1 - i] * p2[d2 - j]);\n        }\n    }\n    return clip0(result);\n}\n/**\n * Multiplies 2 polynomials by a constant.\n * @param c - The constant\n * @param p - The polynomial\n * @example\n * FloPoly.multiplyByConst(0.25, [3,2,1]); //=> [0.75, 0.5, 0.25]\n */\nfunction multiplyByConst(c, p) {\n    if (c === 0) {\n        return [];\n    }\n    let d = p.length - 1;\n    let result = [];\n    for (let i = 0; i < d + 1; i++) {\n        result.push(c * p[i]);\n    }\n    // We have to clip due to possible floating point underflow\n    return clip0(result);\n}\n/**\n * Returns the degree of the polynomial.\n * @param p - The polynomial\n * @example\n * FloPoly.degree([9,8,7,6,5,4,3,2,1]); //=> 9\n */\nfunction degree(p) {\n    return p.length - 1;\n}\nfunction evaluate(p, a) {\n    function f(a) {\n        //if p.length === 0 { return 0; }\n        let result = p[0];\n        for (let i = 1; i < p.length; i++) {\n            result = p[i] + result * a;\n        }\n        return result;\n    }\n    // Curry the function\n    return a === undefined ? f : f(a);\n}\n/**\n * Evaluates the given polynomial at 0 - it is much faster than at an\n * arbitrary point.\n * @param p - The polynomial\n * @example\n * FloPoly.evaluateAt0([3,2,99]); //=> 99\n */\nfunction evaluateAt0(p) {\n    return p[p.length - 1];\n}\n;\n/**\n * <p>\n * Returns the number of sign changes in the polynomial coefficents\n * when ordered in descending order; zeros are ignored.\n * </p>\n * <p>\n * Descartes' rule of signs states (quoted from Wikipedia):\n * \"if the terms of a polynomial are ordered by descending variable\n * exponent, then the number of positive roots of the polynomial is\n * either equal to the number of sign differences between consecutive\n * nonzero coefficients, or is less than it by an even number. Multiple\n * roots of the same value are counted separately.\"\n * </p>\n * See https://en.wikipedia.org/wiki/Descartes%27_rule_of_signs\n * @param p - The polynomial\n * @example\n * FloPoly.signChanges([1,2,-3,0,0,3,-1]); //=> 3\n */\nfunction signChanges(p) {\n    let d = p.length - 1;\n    let result = 0;\n    let prevSign = Math.sign(p[0]);\n    for (let i = 1; i < d + 1; i++) {\n        let sign = Math.sign(p[i]);\n        if (sign !== prevSign && sign !== 0) {\n            result++;\n            prevSign = sign;\n        }\n    }\n    return result;\n}\n/**\n * Deflates the given polynomial by removing a factor (x - r), where\n * r is a root of the polynomial.\n * @param p - The polynomial\n * @param root - A pre-calculated root of the polynomial.\n * @example\n * // The polynomial x^3 - 5x^2 + 8x - 4 has a root at 1 and a double root at 2\n * FloPoly.deflate([1, -5, 8, -4], 2); //=> [1, -3, 2]\n * FloPoly.deflate([1, -3, 2], 2);     //=> [1,-1]\n * FloPoly.deflate([1, -1], 1);        //=> [1]\n */\nfunction deflate(p, root) {\n    let d = p.length - 1;\n    let bs = [p[0]];\n    for (let i = 1; i < d; i++) {\n        bs.push(p[i] + root * bs[i - 1]);\n    }\n    return bs;\n}\n/**\n * Inverts the given polynomial by reversing the order of the\n * coefficients, i.e. p(x) -> x^deg(p) * p(1/x)\n * @param p - The polynomial\n * @example\n * FloPoly.invert([1,2,3,4]); // => [4,3,2,1]\n * FloPoly.invert([3,2,-5]);  // => [-5,2,3]\n */\nfunction invert(p) {\n    return p.slice().reverse();\n}\n/**\n * <p>\n * Performs a change of variables of the form: p(x) <- p(ax + b).\n * </p>\n * <p>\n * See <a href=\"http://stackoverflow.com/questions/141422/how-can-a-transform-a-polynomial-to-another-coordinate-system\">this stackoverflow question</a>\n * </p>\n * @param p - The polynomial\n * @param a\n * @param b\n * @example\n * FloPoly.changeVariables([1,2,7], 3, 4); //=> [9, 30, 31]\n */\nfunction changeVariables(p, a, b) {\n    // We let the coefficients of p(ax + b) be denoted by d_i in the \n    // code below. \n    // d_i is calculated as d = T*c, where c are the original \n    // coefficients.\n    let d = p.length - 1;\n    // Initialize a zero matrix\n    let t = [];\n    for (let i = 0; i < d + 1; i++) {\n        t.push(new Array(d + 1).fill(0));\n    }\n    // Calculate the triangular matrix T\n    t[0][0] = 1;\n    for (let j = 1; j <= d; j++) {\n        t[0][j] = b * t[0][j - 1];\n        for (let i = 1; i <= j; i++) {\n            t[i][j] = b * t[i][j - 1] + a * t[i - 1][j - 1];\n        }\n    }\n    // Multiply\n    let res = new Array(d + 1).fill(0);\n    for (let i = 0; i <= d; i++) {\n        res[d - i] = 0;\n        for (let j = i; j <= d; j++) {\n            let acc = t[i][j] * p[d - j];\n            res[d - i] += acc;\n        }\n    }\n    return res;\n}\n/**\n * Reflects the given polynomial about the Y-axis, i.e. perform the\n * change of variables: p(x) <- p(-x).\n * @param p - The polynomial to reflect\n * @example\n * FloPoly.reflectAboutYAxis([5,4,3,2,1]); //=> [5, -4, 3, -2, 1]\n */\nfunction reflectAboutYAxis(p) {\n    let d = p.length - 1;\n    let result = p.slice();\n    for (let i = 0; i < d + 1; i++) {\n        if (i % 2) {\n            result[i] = -result[i];\n        }\n    }\n    return result;\n}\n/**\n * Generates a sturm chain for the given polynomial.\n * See https://en.wikipedia.org/wiki/Sturm%27s_theorem\n * @param p - The polynomial\n * @example\n * FloPoly.sturmChain([-3,4,2,-2]); //=> [[-3, 4, 2, -2], [-9, 8, 2], [-2.5185185185185186, 1.7037037037037037], [-3.2932525951557086]]\n */\nfunction sturmChain(p) {\n    /**\n     * Returns the negative of the remainder when dividing the first\n     * polynomial (the dividend) by the second (the divisor) provided\n     * that deg(p1) - deg(p2) === 1.\n     * @private\n     * @param p1 - The first polynomial (dividend)\n     * @param p2 - The second polynomial (divisor)\n     * See https://en.wikipedia.org/wiki/Sturm%27s_theorem\n     */\n    function negRemainder(p1, p2) {\n        let d1 = p1.length - 1;\n        let d2 = p2.length - 1;\n        let d = d1 - d2;\n        let a = p1[1] / p1[0] - p2[1] / p2[0];\n        let b = p1[0] / p2[0];\n        let p3 = multiply(multiplyByConst(b, p2), [1, a]);\n        return subtract(p3, p1);\n    }\n    let m = []; // Sturm chain\n    m.push(p);\n    m.push(differentiate(p));\n    //const δ = 10 * Number.EPSILON;\n    let i = 1;\n    while (m[i].length - 1 > 0) {\n        let pnext = negRemainder(m[i - 1], m[i]);\n        //pnext = clip(pnext, δ);\n        // If the polynomial degree was not reduced due to roundoff\n        // such that the first 1 or more terms are very small.\n        while (m[i].length - pnext.length < 1) {\n            pnext.shift();\n        }\n        /*\n        if (pnext.length === 0) {\n            break;\n        }\n        */\n        m.push(pnext);\n        i++;\n    }\n    return m;\n}\n/**\n * If the highest power coefficient is small in the sense that the\n * highest power term has a negligible contribution (compared to the\n * other terms) at x = 1 then clip() can be called to remove all such\n * highest terms. A contribution of less than Number.EPSILON of the\n * highest coefficient will be considered negligible by default.\n * @param p - The polynomial to be clipped.\n * @param δ - The optional contribution tolerence else\n *        Number.EPSILON will be used by default.\n * @example\n * FloPoly.clip([1e-18, 1e-10, 1e-5]); //=> [1e-18, 1e-10, 1e-5]\n * FloPoly.clip([1e-18, 1e-10, 1e-1]); //=> [1e-10, 1e-1]\n */\nfunction clip(p, δ) {\n    δ = (δ === undefined) ? Number.EPSILON : δ;\n    let c = maxCoefficient(p);\n    if (c === 0) {\n        return [];\n    }\n    if (Math.abs(p[0]) > δ * c) {\n        return p;\n    }\n    let p_ = p.slice(1);\n    while (Math.abs(p_[0]) < δ * c) {\n        p_ = p_.slice(1);\n    }\n    return clip(p_, δ);\n}\n/**\n * If the highest power coefficient is 0 then clip() can be called to\n * remove all such highest terms so that the array is a valid\n * presentation of a polynomial.\n * @param p - The polynomial to be clipped.\n * @example\n * FloPoly.clip0([1e-18, 1e-10, 1e-1]); //=> [1e-18, 1e-10, 1e-1]\n * FloPoly.clip0([0, 1e-10, 1e-1]); //=> [1e-10, 1e-1]\n */\nfunction clip0(p) {\n    return p[0] !== 0 ? p : clip0(p.slice(1));\n}\n/**\n * Returns the absolute value of the highest coefficient of the polynomial.\n * @param p - The polynomial.\n * @example\n * FloPoly.maxCoefficient([-2, 0.1, 0.2]); //=> 2\n */\nfunction maxCoefficient(p) {\n    let max = 0;\n    for (let i = 0; i < p.length; i++) {\n        let c = Math.abs(p[i]);\n        if (c > max) {\n            max = c;\n        }\n    }\n    return max;\n}\n/**\n * Returns a string representing the given polynomial that is readable\n * by a human or a CAS (Computer Algebra System).\n * @param p - The polynomial\n * @example\n * FloPoly.toCasStr([5,4,3,2,1]); //=> \"x^4*5 + x^3*4 + x^2*3 + x*2 + 1\"\n */\nfunction toCasStr(p) {\n    let d = p.length - 1;\n    let str = '';\n    for (let i = 0; i < d + 1; i++) {\n        let cStr = p[i].toString();\n        if (i === d) {\n            str += cStr;\n        }\n        else if (i === d - 1) {\n            str += 'x*' + cStr + ' + ';\n        }\n        else {\n            str += 'x^' + (d - i).toString() + '*' + cStr + ' + ';\n        }\n    }\n    return str;\n}\nlet coreOperators = {\n    equal,\n    add,\n    subtract,\n    multiplyByConst,\n    negate,\n    differentiate,\n    multiply,\n    degree,\n    evaluate,\n    evaluateAt0,\n    signChanges,\n    invert,\n    changeVariables,\n    reflectAboutYAxis,\n    sturmChain,\n    clip,\n    clip0,\n    deflate,\n    maxCoefficient,\n    toCasStr,\n};\nexports.default = coreOperators;\n\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/src/core-operators.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/src/error-analysis.js":
/*!**********************************************************!*\
  !*** ./node_modules/flo-poly/node/src/error-analysis.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst core_operators_1 = __webpack_require__(/*! ./core-operators */ \"./node_modules/flo-poly/node/src/core-operators.js\");\nconst { evaluate } = core_operators_1.default;\n/**\n * <p>\n * Approximate condition number for polynomial evaluation multiplied by the\n * exact value of the polynomial evaluation.\n * </p>\n * <p>\n * See <a href=\"http://www-pequan.lip6.fr/~jmc/polycopies/Compensation-horner.pdf\">Compensated Horner Scheme - paragraph 1.1</a>\n * </p>\n * @ignore\n * @param p - The polynomial\n * @param x - The evaluation point\n */\nfunction conditionNumber(p, x) {\n    let d = p.length - 1;\n    let res = 0;\n    for (let i = 0; i < d; i++) {\n        res += Math.abs(p[i] * Math.pow(x, d - i));\n    }\n    return res;\n}\n/**\n * <p>\n * Classic rule of thumb approximate error bound when using Horner's\n * method to evaluate polynomials.\n * </p>\n * <p>\n * See for instance <a href=\"http://www-pequan.lip6.fr/~jmc/polycopies/Compensation-horner.pdf\">compensated horner evaluation</a>\n * </p>\n * @param p - The polynomial\n * @param x - Value at which polynomial is evaluated.\n  * @example\n * hornerErrorBound([1.1,2.2,-3.3], 1.5); //=> 5.1292303737682235e-15\n */\nfunction hornerErrorBound(p, x) {\n    const δ = Number.EPSILON;\n    let d = p.length - 1;\n    return 2 * d * δ * conditionNumber(p, x);\n}\nlet errorAnalysis = {\n    hornerErrorBound\n};\nexports.default = errorAnalysis;\n\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/src/error-analysis.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/src/from-roots.js":
/*!******************************************************!*\
  !*** ./node_modules/flo-poly/node/src/from-roots.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst core_operators_1 = __webpack_require__(/*! ./core-operators */ \"./node_modules/flo-poly/node/src/core-operators.js\");\nconst { multiply } = core_operators_1.default;\n/**\n * <p>\n * Constructs a polynomial from the given roots by multiplying out the\n * factors (x - root1)(x - root2)... Note that the resulting polynomial\n * will not have any complex roots.\n * </p>\n * <p>\n * Mostly provided for testing purposes. Note that the real roots of the\n * constructed polynomial may not be exactly the same as the roots that\n * the polynomial has been constructed from due to floating-point\n * round-off.\n * </p>\n *\n * @param roots - The roots\n * @example\n * FloPoly.fromRoots([1,2,3,3]); //=> [1, -9, 29, -39, 18]\n * FloPoly.allRoots([1, -9, 29, -39, 18]); //=> [1.0000000000000007, 2.000000000000004]\n * // In the above note the rounding error. Also note the multiple root of 3 that has been missed but as stated previously this does not generally pose a problem for even multiple roots. See the examples below.\n * FloPoly.allRoots([1, -9, 29, -39, 17.99999999999999]); //=> [0.9999999999999973, 2.00000000000002, 2.9999999999999982]\n * FloPoly.allRoots([1, -9, 29, -39, 17.9999999999999]); //=> [0.999999999999975, 2.0000000000000986, 2.9999997898930832, 3.0000002095475775]\n */\nfunction fromRoots(roots) {\n    let p = [1];\n    for (let i = 0; i < roots.length; i++) {\n        p = multiply(p, [1, -roots[i]]);\n    }\n    return p;\n}\nexports.default = fromRoots;\n\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/src/from-roots.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/src/random.js":
/*!**************************************************!*\
  !*** ./node_modules/flo-poly/node/src/random.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst from_roots_1 = __webpack_require__(/*! ./from-roots */ \"./node_modules/flo-poly/node/src/from-roots.js\");\n/**\n * Some seed value for the simple random number generator.\n * @ignore\n */\nconst SEED = 123456789;\n/**\n * The range for the simple random number generator, i.e. the generated\n * numbers will be in [0,RANGE].\n * @ignore\n */\nconst RANGE = 4294967296;\n/**\n * Creates a function from the given function with parameters similar\n * to flatRoots but with an extra parameter in the beginning indicating\n * the length of the array generated by the original function.\n * @private\n * @param {function} f\n * @returns {function}\n */\nfunction createArrFunction(f) {\n    return function (n, d, a, b, seed = SEED, odds = 0) {\n        let res = [];\n        for (let i = 0; i < n; i++) {\n            let v = f(d, a, b, seed, odds);\n            let p = v.p;\n            seed = v.seed;\n            res.push(p);\n        }\n        return res;\n    };\n}\n/**\n * Generates an array of random polynomials with parameters as specified\n * by flatRoots. The exact same polynomials will be created on each\n * call to this function if the same seed is used - this is by design to\n * improve testability.\n * @memberof Random\n * @param n - The number of polynomials to generate.\n * @param d - The degree of the polynomials\n * @param a - The lower bound of the distribution - defaults\n * to 0\n * @param b - The upper bound of the distribution - defaults\n * to 1\n * @param seed - A seed value for generating random values (so\n * that the results are reproducable)\n * @param odds - The odds that a root will be doubled (applied\n * recursively so that some roots will be tripled, etc. - defaults to 0\n * @example\n * FloPoly.Random.flatRootsArr(2,3,0,10); //=> [[1, -17.27247918024659, 97.33487287168995, -179.34094494147305], [1, -14.934967160224915, 57.624514485645406, -14.513933300587215]]\n * FloPoly.Random.flatRootsArr(2,3,0,10); //=> [[1, -17.27247918024659, 97.33487287168995, -179.34094494147305], [1, -14.934967160224915, 57.624514485645406, -14.513933300587215]]\n */\nlet flatRootsArr = createArrFunction(flatRoots);\n/**\n * Generates an array of random polynomials as specified by\n * flatCoefficients. The exact same polynomials will be created on each\n * call to this function if the same seed is used - this is by design to\n * improve testability.\n *\n * @memberof Random\n * @param n - The number of polynomials to generate.\n * @param d - The degree of the polynomials\n * @param a - The lower bound of the distribution - defaults\n * to 0\n * @param b - The upper bound of the distribution - defaults\n * to 1\n * @param seed - A seed value for generating random values (so\n * that the results are reproducable)\n * @returns {number[][]} The array of random polynomials.\n * @example\n * FloPoly.Random.flatCoefficientsArr(2,3,-2,2); //=> [[0.1749166026711464, -0.20349335670471191, 0.9375684261322021], [1.0617692470550537, -1.8918039798736572, 0.8040215969085693]]\n * FloPoly.Random.flatCoefficientsArr(2,3,-2,2); //=> [[0.1749166026711464, -0.20349335670471191, 0.9375684261322021], [1.0617692470550537, -1.8918039798736572, 0.8040215969085693]]\n */\nlet flatCoefficientsArr = createArrFunction(flatCoefficients);\n/**\n * Returns a quasi-random number to be used as the next input to this function.\n * See https://stackoverflow.com/questions/3062746/special-simple-random-number-generator\n * @private\n * @param seed\n */\nfunction predictiveRandom(seed) {\n    const a = 134775813;\n    return (a * seed + 1) % RANGE;\n}\n/**\n * Generates a random array of numbers picked from a bounded flat\n * distribution (i.e. a rectangular distribution) with specified odds of\n * duplication of consecutive values.\n *\n * @ignore\n * @param n - The number of values to generate.\n * @param a - The lower bound of the distribution - defaults\n * to 0\n * @param b - The upper bound of the distribution - defaults\n * to 1\n * @param seed - A seed value for generating random values (so\n * that the results are reproducable)\n * @param odds - The odds that a root will be doubled (applied\n * recursively so that some roots will be tripled, etc. - defaults to 0\n */\nfunction randomArray(n, a, b, seed = SEED, odds = 0) {\n    let vs = [];\n    for (let i = 0; i < n; i++) {\n        seed = predictiveRandom(seed);\n        let v = ((seed / RANGE) * (b - a)) + a;\n        seed = push(seed, vs, v, odds);\n    }\n    vs = vs.slice(0, n);\n    return { vs, seed };\n}\n/**\n * Helper function that will add more numbers to the passed array - modifies the\n * values parameter.\n * @private\n * @param seed\n * @param values - An existing array of values - will be modified!\n * @param x - The number that will be added (possibly multiple times)\n * @param odds - The odds that the number will be added again (recursively).\n */\nfunction push(seed, values, x, odds) {\n    seed = predictiveRandom(seed);\n    values.push(x);\n    if ((seed / RANGE) < odds) {\n        seed = push(seed, values, x, odds);\n    }\n    return seed;\n}\n/**\n * Generates a random polynomial with roots picked from a bounded flat\n * distribution (i.e. a rectangular distribution) with specified odds of\n * duplication of consecutive values. Note that the resulting polynomial\n * won't have any complex roots.\n * @memberof Random\n * @param d - The degree of the polynomials\n * @param a - The lower bound of the distribution - defaults\n * to 0\n * @param b - The upper bound of the distribution - defaults\n * to 1\n * @param seed - A seed value for generating random values (so\n * that the results are reproducable)\n * @param odds - The odds that a root will be doubled (applied\n * recursively so that some roots will be tripled, etc. - defaults to 0\n * @example\n * FloPoly.Random.flatRoots(3,0,10); //=> { p: [1, -17.27247918024659, 97.33487287168995, -179.34094494147305], seed: 939629312 }\n */\nfunction flatRoots(d, a = 0, b = 1, seed = SEED, odds = 0) {\n    let randArr = randomArray(d, a, b, seed, odds);\n    seed = randArr.seed;\n    let p = from_roots_1.default(randArr.vs);\n    return { p, seed };\n}\n/**\n * Generates a random polynomial with coefficients picked from a bounded\n * flat distribution (i.e. a rectangular distribution).\n * @memberof Random\n * @param d - The degree of the polynomials\n * @param a - The lower bound of the distribution - defaults to -1\n * @param b - The upper bound of the distribution - defaults to 1\n * @param seed - A seed value for generating random values (so that the results\n * are reproducable)\n * @example\n * FloPoly.Random.flatCoefficients(3,-5,5); //=> { p: [0.437291506677866, -0.5087333917617798, 2.3439210653305054], seed: 939629312 }\n */\nfunction flatCoefficients(d, a = -1, b = +1, seed = SEED) {\n    a = (a === undefined) ? -1 : a;\n    b = (b === undefined) ? +1 : b;\n    seed = (seed === undefined) ? SEED : seed;\n    let randArr = randomArray(d, a, b, seed);\n    seed = randArr.seed;\n    let p = randArr.vs;\n    return { p, seed };\n}\nlet random = {\n    flatRoots,\n    flatRootsArr,\n    flatCoefficients,\n    flatCoefficientsArr,\n};\nexports.default = random;\n\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/src/random.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/src/root-bounds.js":
/*!*******************************************************!*\
  !*** ./node_modules/flo-poly/node/src/root-bounds.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst core_operators_1 = __webpack_require__(/*! ./core-operators */ \"./node_modules/flo-poly/node/src/core-operators.js\");\nconst { invert, negate, reflectAboutYAxis } = core_operators_1.default;\n/**\n * Returns the maximum magnitude value within the supplied array of numbers.\n * @private\n */\nfunction maxAbs(ns) {\n    return Math.max(...ns.map(n => Math.abs(n)));\n}\n/**\n * Finds an upper bound on the magnitude (absolute value) of the roots\n * (including complex roots) of the given polynomial using Rouche's\n * Theorem with k = n. This function is fast but the bound is not tight.\n * @param p - The polynomial.\n */\nfunction rootMagnitudeUpperBound_rouche(p) {\n    let d = p.length - 1;\n    let R = 1 + (1 / p[0]) * maxAbs(p.slice(1));\n    return R;\n}\n/**\n * Finds an upper bound on the magnitude (absolute value) of the roots\n * of the given polynomial using the near-optimal Fujiwara bound. Note\n * that the bound includes complex roots. The bound is tight but slow\n * due to usage of Math.pow().\n * See https://en.wikipedia.org/wiki/Properties_of_polynomial_roots#cite_note-Fujiwara1916-4\n * @param p - The polynomial.\n * @example\n * FloPoly.rootMagnitudeUpperBound_fujiwara([2,-3,6,5,-130]); //=> 6.753296750770361\n * FloPoly.allRoots([2,-3,6,5,-130]); //=> [-2.397918624065303, 2.8793785310848383]\n */\nfunction rootMagnitudeUpperBound_fujiwara(p) {\n    let d = p.length - 1;\n    let an = p[0];\n    let bs = [];\n    for (let i = 1; i < d; i++) {\n        let b = Math.pow(Math.abs(p[i] / an), 1 / i);\n        bs.push(b);\n    }\n    bs.push(Math.pow(Math.abs(p[d] / 2 * an), 1 / d));\n    return 2 * Math.max.apply(undefined, bs);\n}\nconst POWERS = [\n    1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768,\n    65536, 131072, 262144, 524288, 1048576, 2097152\n];\n/**\n * <p>\n * Returns an upper bound for the positive real roots of the given\n * polynomial.\n * </p>\n * <p>\n * See algoritm 6 of the paper by Vigklas, Akritas and Strzeboński,\n * specifically the LocalMaxQuadratic algorithm hence LMQ.\n * </p>\n * @param p - The polynomial\n * @example\n * FloPoly.positiveRootUpperBound_LMQ([2,-3,6,5,-130]); //=> 4.015534272870436\n * FloPoly.positiveRootUpperBound_LMQ([2,3]);           //=> 0\n * FloPoly.positiveRootUpperBound_LMQ([-2,-3,-4]);      //=> 0\n */\nfunction positiveRootUpperBound_LMQ(p) {\n    let deg = p.length - 1;\n    if (deg < 1) {\n        return 0;\n    }\n    if (p[0] < 0) {\n        p = negate(p);\n    }\n    let timesUsed = [];\n    for (let i = 0; i < deg; i++) {\n        timesUsed.push(1);\n    }\n    let ub = 0;\n    for (let m = 0; m <= deg; m++) {\n        if (p[m] >= 0)\n            continue;\n        let tempub = Number.POSITIVE_INFINITY;\n        let any = false;\n        for (let k = 0; k < m; k++) {\n            if (p[k] <= 0) {\n                continue;\n            }\n            // Table lookup is about 70% faster but both are\n            // extemely fast anyway. \n            // Result is at https://www.measurethat.net/Benchmarks/ShowResult/6610\n            let pow = timesUsed[k];\n            let powres;\n            if (pow > 20) {\n                powres = Math.pow(2, pow);\n            }\n            else {\n                powres = POWERS[pow];\n            }\n            let temp = Math.pow(-p[m] / (p[k] / powres), 1 / (m - k));\n            timesUsed[k]++;\n            if (tempub > temp) {\n                tempub = temp;\n            }\n            any = true;\n        }\n        if (any && ub < tempub)\n            ub = tempub;\n    }\n    return ub;\n}\n/**\n * <p>\n * Calculates a lower bound for the positive roots of the given\n * polynomial.\n * </p>\n * <p>\n * See algoritm 6 of the paper by Vigklas, Akritas and Strzeboński,\n * specifically the LocalMaxQuadratic algorithm hence LMQ.\n * </p>\n * @param p - The polynomial\n * @example\n * FloPoly.positiveRootLowerBound_LMQ([2,-3,6,5,-130]); //=> 1.6883241876925903\n * FloPoly.positiveRootLowerBound_LMQ([2,3]);           //=> 0\n * FloPoly.positiveRootLowerBound_LMQ([-2,-3,-4]);      //=> 0\n */\nfunction positiveRootLowerBound_LMQ(p) {\n    let ub = positiveRootUpperBound_LMQ(invert(p));\n    if (ub === 0) {\n        return 0;\n    }\n    return 1 / ub;\n}\n/**\n * See positiveRootUpperBound_LMQ\n *\n * @param p - The polynomial\n * @returns {number} An upper bound.\n */\nfunction negativeRootUpperBound_LMQ(p) {\n    return -positiveRootLowerBound_LMQ(reflectAboutYAxis(p));\n}\n/**\n * See positiveRootLowerBound_LMQ\n *\n * @param p - The polynomial\n * @returns {number} A lower bound.\n */\nfunction negativeRootLowerBound_LMQ(p) {\n    return -positiveRootUpperBound_LMQ(reflectAboutYAxis(p));\n}\nlet rootBounds = {\n    rootMagnitudeUpperBound_fujiwara,\n    positiveRootUpperBound_LMQ,\n    positiveRootLowerBound_LMQ,\n    negativeRootUpperBound_LMQ,\n    negativeRootLowerBound_LMQ,\n    rootMagnitudeUpperBound_rouche\n};\nexports.default = rootBounds;\n\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/src/root-bounds.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/src/root-operators.js":
/*!**********************************************************!*\
  !*** ./node_modules/flo-poly/node/src/root-operators.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst core_operators_1 = __webpack_require__(/*! ./core-operators */ \"./node_modules/flo-poly/node/src/core-operators.js\");\nconst { sturmChain, evaluate, signChanges } = core_operators_1.default;\n/**\n * <p>\n * Floating-point-stably calculates and returns the ordered quadratic\n * roots of the given quadratic polynomial.\n * </p>\n * <p>\n * This function is included only because it might be slightly faster\n * than calling allRoots due to allRoots first checking if the\n * polynomial is quadratic and checking if the roots are within the\n * given range.\n * </p>\n * @param p - The 2nd order polynomial\n * @example\n * FloPoly.quadraticRoots([1, -3, 2]); //=> [1,2]\n */\nfunction quadraticRoots(p) {\n    let [a, b, c] = p;\n    let delta = b * b - 4 * a * c;\n    if (delta < 0) {\n        // No real roots;\n        return [];\n    }\n    if (delta === 0) {\n        return [-b / (2 * a)];\n    }\n    delta = Math.sqrt(delta);\n    let root1;\n    let root2;\n    if (b >= 0) {\n        root1 = (-b - delta) / (2 * a);\n        root2 = (2 * c) / (-b - delta);\n    }\n    else {\n        root1 = (2 * c) / (-b + delta);\n        root2 = (-b + delta) / (2 * a);\n    }\n    if (root1 < root2) {\n        return [root1, root2];\n    }\n    return [root2, root1];\n}\n/**\n * Calculates the roots of the given cubic polynomial.\n *\n * This code is mostly from the Pomax guide found at\n * https://pomax.github.io/bezierinfo/#extremities\n *\n * @param p - A cubic polynomial.\n */\n// TODO - This function as it currently stands is very sensitive to\n// the first coefficient if it is very small, e.g. compare:\n// cubicRoots([1e-5, 1560,-1740,96]) = [1.1903631761670113, -156000001.1153846, -0.07497859001159668] \n// vs\n// quadraticRoots([1560,-1740,96]) = [0.05821032751613551, 1.0571742878684798]\n// It is completely useless in some ranges of its input domain:\n// the part of the function 'if (discriminant < 0) {}'\n// is highly problematic for numerical stability.\n// Simply use allRoots / allRootsRecursive instead.\n/*\nfunction cubicRoots(p) {\n\r\n    function cuberoot(v) {\n        return v < 0\n            ? -Math.pow(-v, 1/3)\n            : +Math.pow(v, 1/3);\n    }\n    \r\n    let cbrt = Math.cbrt || cuberoot;\n    \r\n    let d = p[0];\n    let a = p[1] / d;\n    let b = p[2] / d;\n    let c = p[3] / d;\n    \r\n    let s  = (3*b - a*a) / 9;\n    let q  = (2*a*a*a - 9*a*b + 27*c) / 54;\n    \r\n    let s3 = s*s*s;\n    let q2 = q*q;\n    \r\n    let discriminant = q2 + s3;\n\r\n    if (!Number.isFinite(discriminant)) {\n        \r\n        // Overflow occured - in which case one root will be very large.\n        // We might want to report such large roots as positive or\n        // negative infinity but since they are rarely of interest we\n        // report only the smaller roots.\n        \r\n        // Here q*q   === (729*c^2 - 486*a*b*c + 108*a^3*c + 81*a^2*b^2 - 36*a^4*b + 4*a^6) / (729*4)\n        // and  s*s*s === (27*b^3 - 27*a^2*b^2 + 9*a^4*b - a^6) / (729*1)\n        \r\n        return quadraticRoots(p.slice(1));\n    }\n    \r\n    if (discriminant < 0) {\n        // three real roots\n        \r\n        let r = Math.sqrt(-s3);\n        let t = -q / r;\n        \r\n        let cosphi = t < -1 ? -1 : t > 1 ? 1 : t;\n        let phi    = Math.acos(cosphi);\n        let\tt1     = 2*cbrt(r);\n        \r\n        let ao3 = a/3;\n        \r\n        return [\n            t1*Math.cos((phi            )/3) - ao3,\n            t1*Math.cos((phi + 2*Math.PI)/3) - ao3,\n            t1*Math.cos((phi + 4*Math.PI)/3) - ao3\n        ]\n    } else if (discriminant === 0) {\n        // three real roots, but two of them are equal\n        \r\n        let u1 = q < 0 ? cbrt(-q) : -cbrt(q);\n        let ao3 = a/3;\n        \r\n        return [\n            2*u1 - ao3,\n            -u1 - ao3\n        ];\n    } else {\n        // one real root, two complex roots\n        \r\n        let sd = Math.sqrt(discriminant);\n        let u1 = cbrt(sd - q);\n        let v1 = cbrt(sd + q);\n        \r\n        return [u1 - v1 - a/3];\n    }\n}\n*/\n/**\n * Returns the number of real roots in the interval (a,b) of the given\n * polynomial.\n * @param p - The polynomial\n * @param a - The lower bound\n * @param b - The upper bound\n * @example\n * let p = [1, 1, -64, 236, -240];\n * FloPoly.numRootsWithin(p,-20,-11); //=> 0\n * FloPoly.numRootsWithin(p,-11,-9);  //=> 1\n * FloPoly.numRootsWithin(p,-11,3.5); //=> 3\n * FloPoly.numRootsWithin(p,-11,5);   //=> 4\n */\nfunction numRootsWithin(p, a, b) {\n    let ps = sturmChain(p);\n    let ev = evaluate(p);\n    let as = ps.map(p => evaluate(p)(a));\n    let bs = ps.map(p => evaluate(p)(b));\n    return signChanges(as) - signChanges(bs);\n}\n/**\n * <p>\n * Searches an interval (a,b) for a root (i.e. zero) of the\n * given function with respect to its first argument using the Bisection\n * Method root-finding algorithm. Any function can be supplied (it does\n * not even have to be continuous) as long as the root is bracketed.\n * </p>\n * <p>\n * Note: This function has no advantages above the Brent method except\n * for its simpler implementation and can be much slower. Use brent\n * instead.\n * </p>\n * @param f - The function for which the root is sought.\n * @param a - The lower limit of the search interval.\n * @param b - The upper limit of the search interval.\n * @example\n * let p = FloPoly.fromRoots([-10,2,3,4]);  //=> [1, 1, -64, 236, -240]\n * let f = FloPoly.evaluate(p);\n * FloPoly.bisection(f,2.2,3.8); //=> 3\n * FloPoly.bisection(f,2.2,3.1); //=> 3.0000000000000044\n */\nfunction bisection(f, a, b) {\n    if (a === b) {\n        // Presumably the root is already found.\n        return a;\n    }\n    else if (b < a) {\n        [a, b] = [b, a]; // Swap a and b \n    }\n    let fa = f(a);\n    let fb = f(b);\n    if (fa === 0) {\n        return a;\n    }\n    if (fb === 0) {\n        return b;\n    }\n    if (fa * fb > 0) {\n        // Root is not bracketed - this is a precondition.\n        throw new Error('Root not bracketed');\n    }\n    while (true) {\n        let c = a + (b - a) / 2; // Take midpoint\n        let fc = f(c);\n        if (fc === 0) {\n            return c;\n        }\n        if (fa * fc < 0) {\n            b = c;\n        }\n        else {\n            a = c;\n        }\n        // We don't add Number.EPSILON in the line below because we want\n        // accuracy to improve even below 1.\n        let δ = 2 * Number.EPSILON * Math.abs(b) /*+ Number.EPSILON*/;\n        if (Math.abs(a - b) <= δ) {\n            return b;\n        }\n    }\n}\n/**\n * <p>\n * Searches an interval (a,b) for a root (i.e. zero) of the\n * given function with respect to its first argument using the Brent's\n * Method root-finding algorithm. Any function can be supplied (it does\n * not even have to be continuous) as long as the root is bracketed.\n * </p>\n * <p>\n * Brent's Method is an excellent root-finding choice since it is\n * (1) guaranteed to converge (unlike the Newton and other so-called\n * single-point methods), (2) converges in a reasonable number of\n * iterations even for highly contrived functions (unlike Dekker's\n * Method) and (3) nearly always converges extremely fast, i.e. super-\n * linearly (unlike the Secant and Regula-Falsi methods).\n * </p>\n * <p>\n * The max error, δ, is set equal to 2*Number.EPSILON*Math.abs(b)\n * after each iteration where b is the max of the current 2 best\n * guesses.\n * </p>\n * <p>\n * See <a href=\"https://en.wikipedia.org/wiki/Brent%27s_method\">Wikipedia</a>\n * </p>\n * <p>\n * See <a href=\"https://maths-people.anu.edu.au/~brent/pd/rpb011i.pdf\">Brent (page 47)</a>\n * </p>\n * @param f - The function for which the root is sought.\n * @param a - The lower limit of the search interval.\n * @param b - The upper limit of the search interval.\n * about 1e-15 multiplied by the root magnitued).\n * @example\n * let p = FloPoly.fromRoots([-10,2,3,4]);  //=> [1, 1, -64, 236, -240]\n * let f = FloPoly.evaluate(p);\n * FloPoly.brent(f,2.2,3.8); //=> 3.000000000000003\n * FloPoly.brent(f,2.2,3.1); //=> 3.000000000000001\n */\nfunction brent(f, a, b) {\n    if (a === b) {\n        // Presumably the root is already found.\n        return a;\n    }\n    // We assume on the first iteration f(a) !== 0 && f(b) !== 0. \n    let fa = f(a);\n    let fb = f(b);\n    if (fa * fb > 0) {\n        // Root is not bracketed - this is a precondition.\n        throw new Error('Root not bracketed');\n    }\n    let c; // Value of previous guess - set to a initially \n    if (Math.abs(fa) < Math.abs(fb)) {\n        // Swap a,b\n        c = a;\n        a = b;\n        b = c;\n        // Swap fa,fb\n        let temp = fa;\n        fa = fb;\n        fb = temp;\n    }\n    c = a;\n    let mflag = true;\n    let d; // Value of guess before previous guess\n    while (true) {\n        let δ = 2 * Number.EPSILON * Math.abs(b); // + Number.EPSILON;\n        let fc = f(c);\n        // Calculate provisional interpolation value\n        let s;\n        if (fa !== fc && fb !== fc) {\n            // 3 points available - inverse quadratic interpolation\n            let fac = fa - fc;\n            let fab = fa - fb;\n            let fbc = fb - fc;\n            // The below has been multiplied out to speed up the algorithm.\n            /*s = ((a * fb * fc) / ( fab * fac)) +\n                  ((b * fa * fc) / (-fab * fbc)) +\n                  ((c * fa * fb) / ( fac * fbc));*/\n            s = ((a * fb * fbc - b * fa * fac) * fc + c * fa * fab * fb) / (fab * fac * fbc);\n        }\n        else {\n            // only 2 points available - secant method\n            s = b - (fb * ((b - a) / (fb - fa)));\n        }\n        let t1 = (3 * a + b) / 4;\n        let b_c = Math.abs(b - c);\n        let s_b = Math.abs(s - b);\n        let c_d = Math.abs(c - d);\n        if ((!((s > t1 && s < b) ||\n            (s < t1 && s > b))) ||\n            (mflag && (\n            // condition 2\n            (s_b >= b_c / 2) ||\n                // condition 4\n                (b_c < δ))) ||\n            (!mflag && (\n            // condition 3\n            (s_b >= c_d / 2) ||\n                // condition 5\n                (c_d < δ)))) {\n            // Bisection\n            s = (a + b) / 2;\n            mflag = true;\n        }\n        else {\n            mflag = false;\n        }\n        let fs = f(s);\n        d = c;\n        c = b;\n        if (fa * fs < 0) {\n            b = s;\n        }\n        else {\n            a = s;\n        }\n        if (Math.abs(fa) < Math.abs(fb)) {\n            // Swap a,b\n            let temp = a;\n            a = b;\n            b = temp;\n        }\n        if (fb === 0) {\n            return b;\n        }\n        if (fs === 0) {\n            return s;\n        }\n        if (Math.abs(a - b) <= δ) {\n            return b;\n        }\n        fa = f(a);\n        fb = f(b);\n    }\n}\nlet rootOperators = {\n    quadraticRoots,\n    numRootsWithin,\n    brent,\n    bisection,\n};\nexports.default = rootOperators;\n\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/src/root-operators.js?");

/***/ }),

/***/ "./node_modules/flo-vector2d/node/index.js":
/*!*************************************************!*\
  !*** ./node_modules/flo-vector2d/node/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst DELTA = 1e-10;\n/**\n * Curry the given arity two function.\n * @param f - A function\n */\nfunction curry2(f) {\n    function g(t, u) {\n        return u === undefined\n            ? (u) => f(t, u)\n            : f(t, u);\n    }\n    return g;\n}\n/**\n* Creates a transformation function that operates on multiple points from the\n* given arity two function.\n* @private\n*/\nfunction mapCurry2(f) {\n    function g(t, us) {\n        let h = f(t);\n        let hUs = (us) => us.map(h);\n        // Curry the function\n        return us === undefined ? hUs : hUs(us);\n    }\n    return g;\n}\n/**\n* Creates a transformation function that operates on multiple points from the\n* given arity 3 curried function (keeping the first two parameters uncurried).\n* @private\n*/\nfunction specialMapCurry(f) {\n    function g(s, t, us) {\n        let h = f(s, t);\n        let hUs = (us) => us.map(h);\n        // Curry the function\n        return us === undefined ? hUs : hUs(us);\n    }\n    return g;\n}\n/**\n * Returns the dot (inner) product between two 2-vectors.\n * @param a - The first vector\n * @param b - The second vector\n */\nfunction dot(a, b) {\n    return a[0] * b[0] + a[1] * b[1];\n}\nexports.dot = dot;\n/**\n * Returns the cross product signed magnitude between two 2-vectors.\n * @param a - The first vector\n * @param b - The second vector\n */\nfunction cross(a, b) {\n    return a[0] * b[1] - a[1] * b[0];\n}\nexports.cross = cross;\n/**\n * Three 2d points are a counter-clockwise turn if ccw > 0, clockwise if\n * ccw < 0, and colinear if ccw = 0 because ccw is a determinant that gives\n * twice the signed area of the triangle formed by p1, p2 and p3.\n * @param p1 - The first point\n * @param p2 - The second point\n * @param p3 - The third point\n * @param delta - The tolerance at which the three points are considered\n * collinear - defaults to 1e-10.\n */\nfunction ccw(p1, p2, p3, delta = DELTA) {\n    let res = (p2[0] - p1[0]) * (p3[1] - p1[1]) -\n        (p2[1] - p1[1]) * (p3[0] - p1[0]);\n    return Math.abs(res) <= delta ? 0 : res;\n}\nexports.ccw = ccw;\n/**\n* <p>\n* Returns the point where two line segments intersect or undefined if they\n* don't intersect or a line if they intersect at infinitely many points.\n* </p>\n* <p>\n* See <a href=\"http://algs4.cs.princeton.edu/91primitives\">Geometric primitves</a>\n* </p>\n* @param ab - The first line\n* @param cd - The second line\n* @param delta - The tolerance at which the lines are considered parallel -\n* defaults to 1e-10.\n*/\nfunction segSegIntersection(ab, cd, delta = DELTA) {\n    let [a, b] = ab;\n    let [c, d] = cd;\n    let denom = (b[0] - a[0]) * (d[1] - c[1]) - (b[1] - a[1]) * (d[0] - c[0]);\n    let rNumer = (a[1] - c[1]) * (d[0] - c[0]) - (a[0] - c[0]) * (d[1] - c[1]);\n    let sNumer = (a[1] - c[1]) * (b[0] - a[0]) - (a[0] - c[0]) * (b[1] - a[1]);\n    if (Math.abs(denom) <= delta) {\n        // parallel\n        if (Math.abs(rNumer) <= delta) {\n            // colinear\n            // TODO Check if x-projections and y-projections intersect\n            // and return the line of intersection if they do.\n            return undefined;\n        }\n        return undefined;\n    }\n    let r = rNumer / denom;\n    let s = sNumer / denom;\n    if (0 <= r && r <= 1 && 0 <= s && s <= 1) {\n        return [a[0] + r * (b[0] - a[0]), a[1] + r * (b[1] - a[1])];\n    }\n    return undefined;\n}\nexports.segSegIntersection = segSegIntersection;\n/**\n* Returns true if the two given 2d line segments intersect, false otherwise.\n* @param a - A line segment\n* @param b - Another line segment\n*/\nfunction doesSegSegIntersect(a, b) {\n    if ((ccw(a[0], a[1], b[0]) * ccw(a[0], a[1], b[1])) > 0) {\n        return false;\n    }\n    else if ((ccw(b[0], b[1], a[0]) * ccw(b[0], b[1], a[1])) > 0) {\n        return false;\n    }\n    return true;\n}\nexports.doesSegSegIntersect = doesSegSegIntersect;\n/**\n* Returns the squared distance between two 2d points.\n* @param p1 - A point\n* @param p2 - Another point\n*/\nfunction squaredDistanceBetween(p1, p2) {\n    let x = p2[0] - p1[0];\n    let y = p2[1] - p1[1];\n    return x * x + y * y;\n}\nexports.squaredDistanceBetween = squaredDistanceBetween;\n/**\n* Returns a scaled version of the given 2-vector.\n* @param p - A vector\n* @param factor - A scale factor\n*/\nfunction scale(p, factor) {\n    return [p[0] * factor, p[1] * factor];\n}\nexports.scale = scale;\n/**\n* Returns the given 2-vector reversed.\n* @param p - A vector\n*/\nfunction reverse(p) {\n    return [-p[0], -p[1]];\n}\nexports.reverse = reverse;\n/**\n* Returns the given 2-vector scaled to a length of one.\n* @param p - A vector\n*/\nfunction toUnitVector(p) {\n    let scaleFactor = 1 / len(p);\n    return [p[0] * scaleFactor, p[1] * scaleFactor];\n}\nexports.toUnitVector = toUnitVector;\n/**\n* Returns the given 2-vector scaled to the given length.\n* @param p - A vector\n* @param length - The length to scale to\n*/\nfunction toLength(p, length) {\n    let scaleFactor = length / len(p);\n    return [p[0] * scaleFactor, p[1] * scaleFactor];\n}\nexports.toLength = toLength;\n/**\n* Returns the second 2-vector minus the first.\n* @param p1 - The first vector\n* @param p2 - The second vector\n*/\nfunction fromTo(p1, p2) {\n    return [p2[0] - p1[0], p2[1] - p1[1]];\n}\nexports.fromTo = fromTo;\n/**\n* Performs linear interpolation between two 2d points and returns the resultant point.\n* @param p1 - The first point.\n* @param p2 - The second point.\n* @param t - The interpolation fraction (often in [0,1]).\n*/\nfunction interpolate(p1, p2, t) {\n    return [\n        p1[0] + (p2[0] - p1[0]) * t,\n        p1[1] + (p2[1] - p1[1]) * t\n    ];\n}\nexports.interpolate = interpolate;\n/**\n* Returns the mean of two 2d points.\n* @param ps - The two points\n*/\nfunction mean(ps) {\n    let p1 = ps[0];\n    let p2 = ps[1];\n    return [(p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2];\n}\nexports.mean = mean;\n/**\n* Returns the distance between two 2d points.\n* @param p1 - A point.\n* @param p2 - Another point.\n*/\nfunction distanceBetween(p1, p2) {\n    return Math.sqrt(squaredDistanceBetween(p1, p2));\n}\nexports.distanceBetween = distanceBetween;\n/**\n* Returns the length of the given 2-vector.\n* @param p - A vector\n*/\nfunction len(p) {\n    return Math.sqrt((p[0] * p[0]) + (p[1] * p[1]));\n}\nexports.len = len;\n/**\n* Returns the squared length of the given 2-vector.\n* @param p - A vector\n*/\nfunction lengthSquared(v) {\n    return v[0] * v[0] + v[1] * v[1];\n}\nexports.lengthSquared = lengthSquared;\n/**\n* Returns the Manhattan distance between two 2d points.\n* @param p1 - A point.\n* @param p2 - Another point.\n*/\nfunction manhattanDistanceBetween(p1, p2) {\n    return Math.abs(p1[0] - p2[0]) + Math.abs(p1[1] - p2[1]);\n}\nexports.manhattanDistanceBetween = manhattanDistanceBetween;\n/**\n* Returns the Manhattan length of the given 2-vector.\n* @param p - A vector\n*/\nfunction manhattanLength(p) {\n    return Math.abs(p[0]) + Math.abs(p[1]);\n}\nexports.manhattanLength = manhattanLength;\n/**\n* <p>\n* Returns the distance between the given point and line.\n* </p>\n* <p>\n* See <a href=\"https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Line_defined_by_two_points\">\n* this Wikipedia article</a>\n* </p>\n* @param p - A point\n* @param l - A line\n*/\nfunction distanceBetweenPointAndLine(p, l) {\n    let [x0, y0] = p;\n    let [[x1, y1], [x2, y2]] = l;\n    let y = y2 - y1;\n    let x = x2 - x1;\n    let a = (y * x0 - x * y0 + x2 * y1 - y2 * x1);\n    let b = Math.sqrt(x * x + y * y);\n    return Math.abs(a / b);\n}\nexports.distanceBetweenPointAndLine = distanceBetweenPointAndLine;\n/**\n* Returns the squared distance between the given point and line segment.\n* @param p - A point\n* @param l - A line\n*/\nfunction squaredDistanceBetweenPointAndLineSegment(p, l) {\n    const sqDst = squaredDistanceBetween;\n    let v = l[0];\n    let w = l[1];\n    let l2 = sqDst(v, w);\n    if (l2 == 0) {\n        return sqDst(p, v);\n    }\n    let t = ((p[0] - v[0]) * (w[0] - v[0]) + (p[1] - v[1]) * (w[1] - v[1])) / l2;\n    t = Math.max(0, Math.min(1, t));\n    let d2 = sqDst(p, [v[0] + t * (w[0] - v[0]), v[1] + t * (w[1] - v[1])]);\n    return d2;\n}\nexports.squaredDistanceBetweenPointAndLineSegment = squaredDistanceBetweenPointAndLineSegment;\n/**\n* Returns the circumcenter of the given 2d triangle.\n* @param triangle\n*/\nfunction circumCenter(triangle) {\n    // See wikipedia\n    let p1 = triangle[0];\n    let p2 = triangle[1];\n    let p3 = triangle[2];\n    const sqLen = lengthSquared;\n    let Sx = 0.5 * det3([sqLen(p1), p1[1], 1], [sqLen(p2), p2[1], 1], [sqLen(p3), p3[1], 1]);\n    let Sy = 0.5 * det3([p1[0], sqLen(p1), 1], [p2[0], sqLen(p2), 1], [p3[0], sqLen(p3), 1]);\n    let a = det3([p1[0], p1[1], 1], [p2[0], p2[1], 1], [p3[0], p3[1], 1]);\n    let b = det3([p1[0], p1[1], sqLen(p1)], [p2[0], p2[1], sqLen(p2)], [p3[0], p3[1], sqLen(p3)]);\n    return [Sx / a, Sy / a];\n}\nexports.circumCenter = circumCenter;\n/**\n* <p>\n* Returns the incenter of the given triangle.\n* </p>\n* <p>\n* See Wikipedia - https://en.wikipedia.org/wiki/Incenter\n* </p>\n* @param triangle\n*/\nfunction inCenter(triangle) {\n    const dst = distanceBetween;\n    let p1 = triangle[0];\n    let p2 = triangle[1];\n    let p3 = triangle[2];\n    let l1 = dst(p2, p3);\n    let l2 = dst(p1, p3);\n    let l3 = dst(p1, p2);\n    let lengthSum = l1 + l2 + l3;\n    return [\n        (l1 * p1[0] + l2 * p2[0] + l3 * p3[0]) / lengthSum,\n        (l1 * p1[1] + l2 * p2[1] + l3 * p3[1]) / lengthSum\n    ];\n}\nexports.inCenter = inCenter;\n/**\n* Returns the centroid of the given polygon, e.g. triangle. The polygon\n* must be simple, i.e. not self-intersecting.\n* @param polygon\n*/\nfunction centroid(polygon) {\n    if (polygon.length === 3) {\n        let p1 = polygon[0];\n        let p2 = polygon[1];\n        let p3 = polygon[2];\n        let x = p1[0] + p2[0] + p3[0];\n        let y = p1[1] + p2[1] + p3[1];\n        return [x / 3, y / 3];\n    }\n    // polygon.length assumed > 3 and assumed to be non-self-intersecting\n    // See wikipedia\n    // First calculate the area, A, of the polygon\n    let A = 0;\n    for (let i = 0; i < polygon.length; i++) {\n        let p0 = polygon[i];\n        let p1 = (i === polygon.length - 1)\n            ? polygon[0]\n            : polygon[i + 1];\n        A = A + (p0[0] * p1[1] - p1[0] * p0[1]);\n    }\n    A = A / 2;\n    let C = [0, 0];\n    for (let i = 0; i < polygon.length; i++) {\n        let p0 = polygon[i];\n        let p1 = (i === polygon.length - 1)\n            ? polygon[0]\n            : polygon[i + 1];\n        C[0] = C[0] + (p0[0] + p1[0]) * (p0[0] * p1[1] - p1[0] * p0[1]);\n        C[1] = C[1] + (p0[1] + p1[1]) * (p0[0] * p1[1] - p1[0] * p0[1]);\n    }\n    return [C[0] / (6 * A), C[1] / (6 * A)];\n}\nexports.centroid = centroid;\n/**\n* Calculate the determinant of three 3d vectors, i.e. 3x3 matrix\n* @ignore\n* @param x - A 2d vector\n* @param y - Another 2d vector\n* @param z - Another 2d vector\n*/\nfunction det3(x, y, z) {\n    return (x[0] * (y[1] * z[2] - y[2] * z[1])) -\n        (x[1] * (y[0] * z[2] - y[2] * z[0])) +\n        (x[2] * (y[0] * z[1] - y[1] * z[0]));\n}\nexports.det3 = det3;\nfunction translate(a, b) {\n    function f(b) {\n        return [a[0] + b[0], a[1] + b[1]];\n    }\n    // Curry the function\n    return b === undefined ? f : f(b);\n}\nexports.translate = translate;\n/**\n* Return the given 2d points translated by the given 2d vector. This\n* function is curried.\n* @param v\n* @param ps\n*/\nlet translatePs = mapCurry2(translate);\nexports.translatePs = translatePs;\n/**\n* Return the given 2d points translated by the given 2d vector. This function\n* is curried.\n* @param sinθ\n* @param cosθ\n* @param ps\n*/\nlet rotatePs = specialMapCurry(rotate);\nexports.rotatePs = rotatePs;\nfunction rotate(sinθ, cosθ, p) {\n    let a = translatePs([1, 2]);\n    function rotateByθ(p) {\n        return [\n            p[0] * cosθ - p[1] * sinθ,\n            p[0] * sinθ + p[1] * cosθ\n        ];\n    }\n    // Curry the function\n    return p === undefined ? rotateByθ : rotateByθ(p);\n}\nexports.rotate = rotate;\n/**\n* Returns true if two 2-vectors are identical (by value), false otherwise.\n* @param a - A 2d vector\n* @param b - Another 2d vector\n*/\nfunction equal(a, b) {\n    return (a[0] === b[0] && a[1] === b[1]);\n}\nexports.equal = equal;\n/**\n* Returns a anti-clockwise rotated version of the given 2-vector given the\n* sine and cosine of the angle.\n* @param p - A 2d vector\n* @param sinθ\n* @param cosθ\n*/\nfunction reverseRotate(sinθ, cosθ, p) {\n    return [\n        +p[0] * cosθ + p[1] * sinθ,\n        -p[0] * sinθ + p[1] * cosθ\n    ];\n}\nexports.reverseRotate = reverseRotate;\n/**\n* Returns a 90 degrees rotated version of the given 2-vector.\n* @param p - A 2d vector\n*/\nfunction rotate90Degrees(p) {\n    return [-p[1], p[0]];\n}\nexports.rotate90Degrees = rotate90Degrees;\n/**\n* Returns a negative 90 degrees rotated version of the given 2-vector.\n* @param p - A 2d vector\n*/\nfunction rotateNeg90Degrees(p) {\n    return [p[1], -p[0]];\n}\nexports.rotateNeg90Degrees = rotateNeg90Degrees;\n/**\n* Transforms the given 2-vector by applying the given function to each\n* coordinate.\n* @param p - A 2d vector\n* @param f - A transformation function\n*/\nfunction transform(p, f) {\n    return [f(p[0]), f(p[1])];\n}\nexports.transform = transform;\n/**\n* Returns the closest point to the array of 2d points, optionally providing\n* a distance function.\n* @param p\n* @param ps\n* @param f - Optional distance function - defaults to\n* squaredDistanceBetween.\n*/\nfunction getClosestTo(p, ps) {\n    let closestPoint = undefined;\n    let closestDistance = Number.POSITIVE_INFINITY;\n    for (let i = 0; i < ps.length; i++) {\n        let q = ps[i];\n        let d = squaredDistanceBetween(p, q);\n        if (d < closestDistance) {\n            closestPoint = q;\n            closestDistance = d;\n        }\n    }\n    return closestPoint;\n}\nexports.getClosestTo = getClosestTo;\n/**\n* Returns the closest point to the array of 2d points, optionally providing\n* a distance function.\n* @param p\n* @param ps\n* @param f - Optional distance function - defaults to\n* squaredDistanceBetween.\n*/\nfunction getObjClosestTo(p, ps, f) {\n    let closestObj = undefined; // Closest Point\n    let closestDistance = Number.POSITIVE_INFINITY;\n    for (let i = 0; i < ps.length; i++) {\n        let o = ps[i];\n        let d = squaredDistanceBetween(p, f(o));\n        if (d < closestDistance) {\n            closestObj = o;\n            closestDistance = d;\n        }\n    }\n    return closestObj;\n}\nexports.getObjClosestTo = getObjClosestTo;\n/**\n* Returns an array of points by applying a translation and then rotation to\n* the given points.\n* @param v - The translation vector\n* @param sinθ\n* @param cosθ\n* @param ps - The input points\n**/\nfunction translateThenRotatePs(v, sinθ, cosθ, ps) {\n    const f = translate(v);\n    return ps.map(p => rotate(sinθ, cosθ, f(p)));\n}\nexports.translateThenRotatePs = translateThenRotatePs;\n/**\n* Returns an array of points by applying a rotation and then translation to\n* the given points.\n* @param sinθ\n* @param cosθ\n* @param v - The translation vector\n* @param ps - The input points\n**/\nfunction rotateThenTranslatePs(sinθ, cosθ, v, ps) {\n    return ps.map(p => translate(v, rotate(sinθ, cosθ, p)));\n}\nexports.rotateThenTranslatePs = rotateThenTranslatePs;\n;\n//export  Vector2d;\n\n\n//# sourceURL=webpack:///./node_modules/flo-vector2d/node/index.js?");

/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target, parent) {\n  if (parent){\n    return parent.querySelector(target);\n  }\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target, parent) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target, parent);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(/*! ./urls */ \"./node_modules/style-loader/lib/urls.js\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertAt.before, target);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\tif(options.attrs.nonce === undefined) {\n\t\tvar nonce = getNonce();\n\t\tif (nonce) {\n\t\t\toptions.attrs.nonce = nonce;\n\t\t}\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction getNonce() {\n\tif (false) {}\n\n\treturn __webpack_require__.nc;\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = typeof options.transform === 'function'\n\t\t ? options.transform(obj.css) \n\t\t : options.transform.default(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n\n\n//# sourceURL=webpack:///./node_modules/style-loader/lib/addStyles.js?");

/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n\n\n//# sourceURL=webpack:///./node_modules/style-loader/lib/urls.js?");

/***/ }),

/***/ "./style.css":
/*!*******************!*\
  !*** ./style.css ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !./node_modules/css-loader!./style.css */ \"./node_modules/css-loader/index.js!./style.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ./node_modules/style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}\n\n//# sourceURL=webpack:///./style.css?");

/***/ })

/******/ });