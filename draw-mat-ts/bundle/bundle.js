/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__webpack_require__(/*! ./style.css */ \"./style.css\"); // Import stylesheets\r\nconst flo_mat_1 = __webpack_require__(/*! flo-mat */ \"./node_modules/flo-mat/node/index.js\");\r\nconst NS = 'http://www.w3.org/2000/svg'; // Svg namespace\r\n/**\r\n * Creates and returns an SVG DOM element.\r\n * @param id The dom id to assign to the SVG element, e.g. 1 -> 'svg-1'\r\n */\r\nfunction createSvg(id) {\r\n    let $e = document.createElementNS(NS, 'svg');\r\n    $e.setAttributeNS(null, 'id', 'svg' + id);\r\n    $e.setAttributeNS(null, 'style', 'width: 100%; display: inline-block');\r\n    $e.setAttributeNS(null, 'viewBox', '75 4 557 502');\r\n    return $e;\r\n}\r\n/**\r\n * Returns an SVG path string of a line.\r\n * @param ps The line endpoints.\r\n */\r\nfunction getLinePathStr(ps) {\r\n    let [[x0, y0], [x1, y1]] = ps;\r\n    return `M${x0} ${y0} L${x1} ${y1}`;\r\n}\r\n/**\r\n * Returns an SVG path string of a quadratic bezier curve.\r\n * @param ps The quadratic bezier control points.\r\n */\r\nfunction getQuadBezierPathStr(ps) {\r\n    let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    return `M${x0} ${y0} Q${x1} ${y1} ${x2} ${y2}`;\r\n}\r\n/**\r\n * Returns an SVG path string of a cubic bezier curve.\r\n * @param ps The cubic bezier control points.\r\n */\r\nfunction getCubicBezierPathStr(ps) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    return `M${x0} ${y0} C${x1} ${y1} ${x2} ${y2} ${x3} ${y3}`;\r\n}\r\n/**\r\n * Returns a function that draws an array of MAT curves on an SVG element.\r\n * @param mats An array of MATs to draw.\r\n * @param svg The SVG element on which to draw.\r\n * @param type The type of MAT to draw. This simply affects the class on the\r\n * path element.\r\n  */\r\nfunction drawMats(mats, svg, type) {\r\n    mats.forEach(f);\r\n    /**\r\n     * Draws a MAT curve on an SVG element.\r\n     */\r\n    function f(mat) {\r\n        let cpNode = mat.cpNode;\r\n        if (!cpNode) {\r\n            return;\r\n        }\r\n        let fs = [, , getLinePathStr, getQuadBezierPathStr, getCubicBezierPathStr];\r\n        flo_mat_1.traverseEdges(cpNode, function (cpNode) {\r\n            if (cpNode.isTerminating()) {\r\n                return;\r\n            }\r\n            let bezier = cpNode.matCurveToNextVertex;\r\n            if (!bezier) {\r\n                return;\r\n            }\r\n            let $path = document.createElementNS(NS, 'path');\r\n            $path.setAttributeNS(null, \"d\", fs[bezier.length](bezier));\r\n            $path.setAttributeNS(null, \"class\", type);\r\n            svg.appendChild($path);\r\n        });\r\n    }\r\n}\r\n/**\r\n * The SVG path string representing our shape.\r\n */\r\nconst svgPathStr = `\r\n        M 144 251\r\n        C 145 169 110 82 227 59 \r\n        C 344 36 429 -46 505 96 \r\n        C 581 238 696 407 554 435 \r\n        C 412 463 191 532 197 442 \r\n        C 203 352 213 363 276 346 \r\n        C 339 329 563 318 437 242 \r\n        C 311 166 302 181 297 314 \r\n        C 292 447 160 585 151 419 \r\n        C 142 253 87.12 312.78 86 314 \r\n        C 87.16 312.74 142.8632 252.2348 144 251 \r\n        z\r\n`;\r\n/**\r\n * Adds a path to the given SVG element and give it a shape-path class.\r\n */\r\nfunction setSvgShapePath($svg, pathStr) {\r\n    let $path = document.createElementNS(NS, 'path'); // Create SVG path elem.\r\n    $path.setAttribute('class', 'shape-path');\r\n    $svg.appendChild($path); // Add the path element to the SVG.\r\n    document.body.appendChild($svg); // Add the SVG to the document body.\r\n    $path.setAttribute('d', svgPathStr);\r\n}\r\nfunction main() {\r\n    // Create and add and SVG element to our HTML page.\r\n    let $svg = createSvg(1); // Create SVG element.\r\n    setSvgShapePath($svg, svgPathStr);\r\n    // Get loops (representing the shape) from some SVG path.\r\n    let bezierLoops = flo_mat_1.getPathsFromStr(svgPathStr);\r\n    // We could also just give an array of linear, quadratic or cubic beziers as \r\n    // below (all lines in this case). Note that in the below case there is only\r\n    // one array of beziers (forming a single loop shape).\r\n    /*\r\n    bezierLoops = [\r\n        [\r\n            [[50.000, 95.000],[92.797, 63.905]],\r\n            [[92.797, 63.905],[76.450, 13.594]],\r\n            [[76.450, 13.594],[23.549, 13.594]],\r\n            [[23.549, 13.594],[7.202,  63.90]],\r\n            [[7.202,  63.900],[50.000, 95.000]]\r\n        ]\r\n    ];\r\n    */\r\n    // Get MATs from the loops.\r\n    let mats = flo_mat_1.findMats(bezierLoops, 3);\r\n    // Draw the MATs.\r\n    drawMats(mats, $svg, 'mat');\r\n    let sats = mats.map(mat => flo_mat_1.toScaleAxis(mat, 1.5));\r\n    // Get the SAT (at scale 1.5) of the MATs (of which there is only 1)\r\n    drawMats(sats, $svg, 'sat');\r\n}\r\nmain();\r\n\n\n//# sourceURL=webpack:///./index.ts?");

/***/ }),

/***/ "./node_modules/css-loader/index.js!./style.css":
/*!*********************************************!*\
  !*** ./node_modules/css-loader!./style.css ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ./node_modules/css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.i, \"\\r\\n.shape-path {\\r\\n    fill: lightgray;\\r\\n    stroke: darkgray;\\r\\n    stroke-width: 0.1%;\\r\\n}\\r\\n\\r\\n.mat {\\r\\n    fill: none;\\r\\n    stroke: deeppink;\\r\\n    stroke-width: 0.2%;\\r\\n}\\r\\n\\r\\n.sat {\\r\\n    fill: none;\\r\\n    stroke: blue;\\r\\n    stroke-width: 0.2%;\\r\\n}\", \"\"]);\n\n// exports\n\n\n//# sourceURL=webpack:///./style.css?./node_modules/css-loader");

/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n\n\n//# sourceURL=webpack:///./node_modules/css-loader/lib/css-base.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/index.js":
/*!************************************************!*\
  !*** ./node_modules/flo-bezier3/node/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst Vector = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\r\nconst flo_gauss_quadrature_1 = __webpack_require__(/*! flo-gauss-quadrature */ \"./node_modules/flo-gauss-quadrature/node/index.js\");\r\nconst flo_graham_scan_1 = __webpack_require__(/*! flo-graham-scan */ \"./node_modules/flo-graham-scan/node/index.js\");\r\nconst get_x_1 = __webpack_require__(/*! ./src/get-x */ \"./node_modules/flo-bezier3/node/src/get-x.js\");\r\nexports.getX = get_x_1.getX;\r\nconst get_y_1 = __webpack_require__(/*! ./src/get-y */ \"./node_modules/flo-bezier3/node/src/get-y.js\");\r\nexports.getY = get_y_1.getY;\r\nconst get_dx_1 = __webpack_require__(/*! ./src/get-dx */ \"./node_modules/flo-bezier3/node/src/get-dx.js\");\r\nexports.getDx = get_dx_1.getDx;\r\nconst get_dy_1 = __webpack_require__(/*! ./src/get-dy */ \"./node_modules/flo-bezier3/node/src/get-dy.js\");\r\nexports.getDy = get_dy_1.getDy;\r\nconst evaluate_x_1 = __webpack_require__(/*! ./src/evaluate-x */ \"./node_modules/flo-bezier3/node/src/evaluate-x.js\");\r\nexports.evaluateX = evaluate_x_1.evaluateX;\r\nconst evaluate_y_1 = __webpack_require__(/*! ./src/evaluate-y */ \"./node_modules/flo-bezier3/node/src/evaluate-y.js\");\r\nexports.evaluateY = evaluate_y_1.evaluateY;\r\nconst evaluate_1 = __webpack_require__(/*! ./src/evaluate */ \"./node_modules/flo-bezier3/node/src/evaluate.js\");\r\nexports.evaluate = evaluate_1.evaluate;\r\nconst evaluate_dx_1 = __webpack_require__(/*! ./src/evaluate-dx */ \"./node_modules/flo-bezier3/node/src/evaluate-dx.js\");\r\nexports.evaluateDx = evaluate_dx_1.evaluateDx;\r\nconst evaluate_dy_1 = __webpack_require__(/*! ./src/evaluate-dy */ \"./node_modules/flo-bezier3/node/src/evaluate-dy.js\");\r\nexports.evaluateDy = evaluate_dy_1.evaluateDy;\r\nconst evaluate_dx2_1 = __webpack_require__(/*! ./src/evaluate-dx2 */ \"./node_modules/flo-bezier3/node/src/evaluate-dx2.js\");\r\nconst evaluate_dy2_1 = __webpack_require__(/*! ./src/evaluate-dy2 */ \"./node_modules/flo-bezier3/node/src/evaluate-dy2.js\");\r\nconst tangent_1 = __webpack_require__(/*! ./src/tangent */ \"./node_modules/flo-bezier3/node/src/tangent.js\");\r\nexports.tangent = tangent_1.tangent;\r\nconst normal_1 = __webpack_require__(/*! ./src/normal */ \"./node_modules/flo-bezier3/node/src/normal.js\");\r\nexports.normal = normal_1.normal;\r\nconst from_0_to_T_1 = __webpack_require__(/*! ./src/from-0-to-T */ \"./node_modules/flo-bezier3/node/src/from-0-to-T.js\");\r\nexports.from0ToT = from_0_to_T_1.from0ToT;\r\nconst from_T_to_1_1 = __webpack_require__(/*! ./src/from-T-to-1 */ \"./node_modules/flo-bezier3/node/src/from-T-to-1.js\");\r\nexports.fromTTo1 = from_T_to_1_1.fromTTo1;\r\nconst from_to_1 = __webpack_require__(/*! ./src/from-to */ \"./node_modules/flo-bezier3/node/src/from-to.js\");\r\nexports.fromTo = from_to_1.fromTo;\r\nconst to_hybrid_quadratic_1 = __webpack_require__(/*! ./src/to-hybrid-quadratic */ \"./node_modules/flo-bezier3/node/src/to-hybrid-quadratic.js\");\r\nexports.toHybridQuadratic = to_hybrid_quadratic_1.toHybridQuadratic;\r\nconst coincident_1 = __webpack_require__(/*! ./src/coincident */ \"./node_modules/flo-bezier3/node/src/coincident.js\");\r\nexports.coincident = coincident_1.coincident;\r\nconst line_intersection_1 = __webpack_require__(/*! ./src/line-intersection */ \"./node_modules/flo-bezier3/node/src/line-intersection.js\");\r\nexports.lineIntersection = line_intersection_1.lineIntersection;\r\nconst bezier3_intersection_1 = __webpack_require__(/*! ./src/bezier3-intersection/bezier3-intersection */ \"./node_modules/flo-bezier3/node/src/bezier3-intersection/bezier3-intersection.js\");\r\nexports.bezier3Intersection = bezier3_intersection_1.bezier3Intersection;\r\nconst bezier3_intersection_sylvester_1 = __webpack_require__(/*! ./src/bezier3-intersection-sylvester/bezier3-intersection-sylvester_ */ \"./node_modules/flo-bezier3/node/src/bezier3-intersection-sylvester/bezier3-intersection-sylvester_.js\");\r\nexports.bezier3IntersectionSylvester = bezier3_intersection_sylvester_1.bezier3IntersectionSylvester;\r\nconst ts_at_x_1 = __webpack_require__(/*! ./src/ts-at-x */ \"./node_modules/flo-bezier3/node/src/ts-at-x.js\");\r\nexports.tsAtX = ts_at_x_1.tsAtX;\r\nconst ts_at_y_1 = __webpack_require__(/*! ./src/ts-at-y */ \"./node_modules/flo-bezier3/node/src/ts-at-y.js\");\r\nexports.tsAtY = ts_at_y_1.tsAtY;\r\nconst debug_1 = __webpack_require__(/*! ./src/debug/debug */ \"./node_modules/flo-bezier3/node/src/debug/debug.js\");\r\nexports.BezDebug = debug_1.BezDebug;\r\nconst fat_line_1 = __webpack_require__(/*! ./src/debug/fat-line */ \"./node_modules/flo-bezier3/node/src/debug/fat-line.js\");\r\nexports.FatLine = fat_line_1.FatLine;\r\nconst de_casteljau_1 = __webpack_require__(/*! ./src/de-casteljau */ \"./node_modules/flo-bezier3/node/src/de-casteljau.js\");\r\nexports.deCasteljau = de_casteljau_1.deCasteljau;\r\nconst eval_de_casteljau_1 = __webpack_require__(/*! ./src/eval-de-casteljau */ \"./node_modules/flo-bezier3/node/src/eval-de-casteljau.js\");\r\nexports.evalDeCasteljau = eval_de_casteljau_1.evalDeCasteljau;\r\n// Possibly typescript bug? Below line does not work\r\n//const { rotatePs: rotate, translatePs: translate } = Vector;\r\nlet rotate = Vector.rotatePs;\r\nexports.rotate = rotate;\r\nlet translate = Vector.translatePs;\r\nexports.translate = translate;\r\n/**\r\n * Returns the second derivative of the power basis representation of the\r\n * bezier's x-coordinates. This function is memoized on its points parameter by\r\n * object reference.\r\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @returns The twice differentiated power basis polynomial from\r\n * highest power to lowest, e.g. at + b is returned as [a,b]\r\n */\r\nlet getDdx = flo_memoize_1.memoize((ps) => flo_poly_1.default.differentiate(get_dx_1.getDx(ps)));\r\nexports.getDdx = getDdx;\r\n/**\r\n * Returns the second derivative of the power basis representation of the\r\n * bezier's y-coordinates. This function is memoized on its points parameter by\r\n * object reference.\r\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @returns The twice differentiated power basis polynomial from\r\n * highest power to lowest, e.g. at + b is returned as [a,b]\r\n */\r\nlet getDdy = flo_memoize_1.memoize((ps) => flo_poly_1.default.differentiate(get_dy_1.getDy(ps)));\r\nexports.getDdy = getDdy;\r\n/**\r\n * Returns the third derivative of the power basis representation of the\r\n * bezier's x-coordinates. This function is memoized on its points parameter by\r\n * object reference.\r\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @returns The thrice differentiated power basis polynomial (a\r\n * constant in array from), e.g. a is returned as [a]\r\n */\r\nlet getDddx = flo_memoize_1.memoize((ps) => flo_poly_1.default.differentiate(getDdx(ps)));\r\nexports.getDddx = getDddx;\r\n/**\r\n * Returns the third derivative of the power basis representation of the\r\n * bezier's y-coordinates. This function is memoized on its points parameter by\r\n * object reference.\r\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @returns The thrice differentiated power basis polynomial (a\r\n * constant in array from), e.g. a is returned as [a]\r\n */\r\nlet getDddy = flo_memoize_1.memoize((ps) => flo_poly_1.default.differentiate(getDdy(ps)));\r\nexports.getDddy = getDddy;\r\n/**\r\n * Returns the convex hull of a bezier's control points. This hull bounds the\r\n * bezier curve. This function is memoized.\r\n *\r\n * The tolerance at which the cross product of two nearly collinear lines of the\r\n * hull are considered collinear is 1e-12.\r\n * @param ps - A bezier curve, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @returns An ordered array of convex hull points.\r\n */\r\nlet getBoundingHull = flo_memoize_1.memoize(flo_graham_scan_1.default);\r\nexports.getBoundingHull = getBoundingHull;\r\n/**\r\n * Returns a cubic bezier from the given line with evenly spaced control points.\r\n * @param l - a 2d line represented by two points\r\n * @returns Control points of the cubic bezier.\r\n */\r\nfunction fromLine(l) {\r\n    let [[x0, y0], [x1, y1]] = l;\r\n    let xInterval = (x1 - x0) / 3;\r\n    let yInterval = (y1 - y0) / 3;\r\n    return [\r\n        [x0, y0],\r\n        [x0 + xInterval, y0 + yInterval],\r\n        [x0 + xInterval * 2, y0 + yInterval * 2],\r\n        [x1, y1]\r\n    ];\r\n}\r\nexports.fromLine = fromLine;\r\n/**\r\n * Returns the given bezier's inflection points.\r\n **/\r\nfunction findInflectionPoints(ps) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    // From http://www.caffeineowl.com/graphics/2d/vectorial/cubic-inflexion.html eq. 4\r\n    let ax = x1 - x0;\r\n    let ay = y1 - y0;\r\n    let bx = x2 - x1 - ax;\r\n    let by = y2 - y1 - ay;\r\n    let cx = x3 - x2 - ax - (2 * bx);\r\n    let cy = y3 - y2 - ay - (2 * by);\r\n    // From http://www.caffeineowl.com/graphics/2d/vectorial/cubic-inflexion.html eq. 6:\r\n    //   infl(t) := ax*by - ay*bx + t*(ax*cy - ay*cx) + t^2*(bx*cy - by*cx);\r\n    // We find the roots of the quadratic - a,b,c are the quadratic coefficients\r\n    let a = bx * cy - by * cx;\r\n    let b = ax * cy - ay * cx;\r\n    let c = ax * by - ay * bx;\r\n    let inflectionTs = flo_poly_1.default.allRoots([a, b, c], 0, 1);\r\n    const evPs = evaluate_1.evaluate(ps);\r\n    return inflectionTs.map(evPs);\r\n}\r\nfunction κ(ps, t) {\r\n    const evDx = evaluate_dx_1.evaluateDx(ps);\r\n    const evDy = evaluate_dy_1.evaluateDy(ps);\r\n    const evDdx = evaluateDdx(ps);\r\n    const evDdy = evaluateDdy(ps);\r\n    function f(t) {\r\n        let dx = evDx(t);\r\n        let dy = evDy(t);\r\n        let ddx = evDdx(t);\r\n        let ddy = evDdy(t);\r\n        let a = dx * ddy - dy * ddx;\r\n        let b = Math.sqrt(Math.pow((dx * dx + dy * dy), 3));\r\n        return a / b;\r\n    }\r\n    // Curry\r\n    return t === undefined ? f : f(t);\r\n}\r\nexports.κ = κ;\r\n/**\r\n * Alias of κ.\r\n */\r\nlet curvature = κ;\r\nexports.curvature = curvature;\r\nfunction κds(ps, t) {\r\n    const evDx = evaluate_dx_1.evaluateDx(ps);\r\n    const evDy = evaluate_dy_1.evaluateDy(ps);\r\n    const evDdx = evaluateDdx(ps);\r\n    const evDdy = evaluateDdy(ps);\r\n    function f(t) {\r\n        let dx = evDx(t);\r\n        let dy = evDy(t);\r\n        let ddx = evDdx(t);\r\n        let ddy = evDdy(t);\r\n        let a = dx * ddy - dy * ddx;\r\n        let b = dx * dx + dy * dy;\r\n        return a / b;\r\n    }\r\n    // Curry\r\n    return t === undefined ? f : f(t);\r\n}\r\nfunction dκMod(ps, t) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    function f(t) {\r\n        let ts = t * t;\r\n        let omt = 1 - t;\r\n        let a = ts * x3;\r\n        let b = ts * y3;\r\n        let c = 2 * t - 3 * ts;\r\n        let d = (3 * t - 1) * omt;\r\n        let e = omt * omt;\r\n        let f = 3 * (a + c * x2 - d * x1 - e * x0);\r\n        let g = 3 * (b + c * y2 - d * y1 - e * y0);\r\n        let h = 6 * (t * y3 - (3 * t - 1) * y2 + (3 * t - 2) * y1 + omt * y0);\r\n        let i = 6 * (t * x3 - (3 * t - 1) * x2 + (3 * t - 2) * x1 + omt * x0);\r\n        let j = Math.sqrt(f * f + g * g);\r\n        return 4 * (f * (y3 - 3 * y2 + 3 * y1 - y0) -\r\n            g * (x3 - 3 * x2 + 3 * x1 - x0)) * Math.pow(j, 3) -\r\n            (f * h - i * g) * (2 * h * g + 2 * i * f) * j;\r\n    }\r\n    return t === undefined ? f : f(t);\r\n}\r\nexports.dκMod = dκMod;\r\n/**\r\n * Categorizes the given cubic bezier curve according to whether it has a loop,\r\n * a cusp, or zero, one or two inflection points all of which are mutually\r\n * exclusive.\r\n *\r\n * See <a href=\"http://graphics.pixar.com/people/derose/publications/CubicClassification/paper.pdf\">\r\n * this</a> paper.\r\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @returns A value of 'L', 'C', '0', '1', or '2' depending on whether\r\n * the curve has a loop, a cusp, or zero, one or two inflection points.\r\n */\r\nfunction categorize(ps) {\r\n    // TODO - finish\r\n}\r\nfunction totalCurvature(ps, interval) {\r\n    const tanPs = tangent_1.tangent(ps);\r\n    function f(interval) {\r\n        return flo_gauss_quadrature_1.default(κds(ps), interval);\r\n        // TODO\r\n        /*\r\n        let [a,b] = interval;\r\n        let tangentA = tanPs(a);\r\n        let tangentB = tanPs(b);\r\n        let sinθ = Vector.cross(tanA, tanB)\r\n        */\r\n    }\r\n    // Curry\r\n    return interval === undefined ? f : f(interval);\r\n}\r\nexports.totalCurvature = totalCurvature;\r\nfunction totalAbsoluteCurvature(ps, interval) {\r\n    function f(interval = [0, 1]) {\r\n        // Numerically integrate the absolute curvature\r\n        let result = flo_gauss_quadrature_1.default(t => Math.abs(κds(ps)(t)), interval);\r\n        return result;\r\n    }\r\n    // Curry\r\n    return interval === undefined ? f : f(interval);\r\n}\r\nexports.totalAbsoluteCurvature = totalAbsoluteCurvature;\r\nfunction len(interval, ps) {\r\n    function f(ps) {\r\n        let fs = [, , length1, length2, length3];\r\n        return fs[ps.length](interval, ps);\r\n    }\r\n    // Curry\r\n    return ps === undefined ? f : f(ps);\r\n}\r\nexports.len = len;\r\n/**\r\n * Returns the curve length in the specified interval. This function is curried.\r\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @param interval - The paramter interval over which the length is\r\n * to be calculated (often === [0,1]).\r\n */\r\nfunction length3(interval, ps) {\r\n    if (interval[0] === interval[1]) {\r\n        return 0;\r\n    }\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    // Keep line below to ensure zero length curve returns zero!\r\n    if (x0 === x1 && x1 === x2 && x2 === x3 &&\r\n        y0 === y1 && y1 === y2 && y2 === y3) {\r\n        return 0;\r\n    }\r\n    const evDs = ds(ps);\r\n    return flo_gauss_quadrature_1.default(evDs, interval);\r\n}\r\n/**\r\n * Returns the curve length in the specified interval. This function is curried.\r\n * Unused because it is not numerically stable in its current form.\r\n * See https://gist.github.com/tunght13488/6744e77c242cc7a94859\r\n * @param ps - A quadratic bezier, e.g. [[0,0],[1,1],[2,1]]\r\n * @param interval - The paramter interval over which the length is\r\n * to be calculated (often === [0,1]).\r\n */\r\n/*\r\nfunction length2(interval: number[], ps: number[][]) {\r\n    if (interval[0] === interval[1]) { return 0; }\r\n\r\n    let [[x0_, y0_], [x1_, y1_], [x2_, y2_]] = ps;\r\n    // Keep line below to ensure zero length curve returns zero!\r\n    if (x0_ === x1_ && x1_ === x2_ && y0_ === y1_ && y1_ === y2_) {\r\n        return 0;\r\n    }\r\n\r\n    let [[x0, y0], [x1, y1], [x2, y2]] =\r\n            fromTo(ps)(interval[0], interval[1]);\r\n\r\n    let ax = x0 - 2*x1 + x2;\r\n    let ay = y0 - 2*y1 + y2;\r\n    let bx = 2*x1 - 2*x0;\r\n    let by = 2*y1 - 2*y0;\r\n\r\n    let A = 4 * (ax*ax + ay*ay);\r\n    let B = 4 * (ax*bx + ay*by);\r\n    let C = bx*bx + by*by;\r\n\r\n    let Sabc = 2*Math.sqrt(A+B+C);\r\n    let A_2 = Math.sqrt(A);\r\n    let A_32 = 2*A*A_2;\r\n    let C_2 = 2*Math.sqrt(C);\r\n    let BA = B/A_2;\r\n\r\n    return (\r\n        A_32*Sabc + A_2*B*(Sabc - C_2) +\r\n        (4*C*A - B*B)*Math.log((2*A_2 + BA + Sabc) / (BA + C_2))\r\n    ) / (4*A_32);\r\n}\r\n*/\r\nfunction length2(interval, ps) {\r\n    if (interval[0] === interval[1]) {\r\n        return 0;\r\n    }\r\n    let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    // Keep line below to ensure zero length curve returns zero!\r\n    if (x0 === x1 && x1 === x2 && y0 === y1 && y1 === y2) {\r\n        return 0;\r\n    }\r\n    const evDs = ds2(ps);\r\n    return flo_gauss_quadrature_1.default(evDs, interval);\r\n}\r\nfunction length1(interval, ps) {\r\n    let [t1, t2] = interval;\r\n    if (t1 === t2) {\r\n        return 0;\r\n    }\r\n    let [[x0, y0], [x1, y1]] = ps;\r\n    // Keep line below to ensure zero length curve returns zero!\r\n    if (x0 === x1 && y0 === y1) {\r\n        return 0;\r\n    }\r\n    let p1 = [x0 + t1 * (x1 - x0), y0 + t1 * (y1 - y0)];\r\n    let p2 = [x0 + t2 * (x1 - x0), y0 + t2 * (y1 - y0)];\r\n    return Vector.distanceBetween(p1, p2);\r\n}\r\nfunction getTAtLength(ps, s) {\r\n    const lenAtT = (t) => len([0, t], ps);\r\n    function f(s) {\r\n        return flo_poly_1.default.brent(t => (lenAtT(t) - s), 0, 1);\r\n    }\r\n    // Curry\r\n    return s === undefined ? f : f(s);\r\n}\r\nexports.getTAtLength = getTAtLength;\r\nfunction ds(ps, t) {\r\n    const evDx = evaluate_dx_1.evaluateDx(ps);\r\n    const evDy = evaluate_dy_1.evaluateDy(ps);\r\n    function f(t) {\r\n        let dx = evDx(t);\r\n        let dy = evDy(t);\r\n        return Math.sqrt(dx * dx + dy * dy);\r\n    }\r\n    // Curry\r\n    return t === undefined ? f : f(t);\r\n}\r\nfunction ds2(ps, t) {\r\n    const evDx = evaluate_dx2_1.evaluateDx2(ps);\r\n    const evDy = evaluate_dy2_1.evaluateDy2(ps);\r\n    function f(t) {\r\n        let dx = evDx(t);\r\n        let dy = evDy(t);\r\n        return Math.sqrt(dx * dx + dy * dy);\r\n    }\r\n    // Curry\r\n    return t === undefined ? f : f(t);\r\n}\r\nfunction evaluateDdx(ps, t) {\r\n    const ddPs = getDdx(ps); // Speed optimizing cache\r\n    const f = flo_poly_1.default.evaluate(ddPs);\r\n    return t === undefined ? f : f(t); // Curry\r\n}\r\nexports.evaluateDdx = evaluateDdx;\r\nfunction evaluateDdy(ps, t) {\r\n    const ddPs = getDdy(ps); // Speed optimizing cache\r\n    const f = flo_poly_1.default.evaluate(ddPs);\r\n    return t === undefined ? f : f(t); // Curry\r\n}\r\nexports.evaluateDdy = evaluateDdy;\r\nfunction evaluateDddx(ps, t) {\r\n    const dddPs = getDddx(ps); // Speed optimizing cache\r\n    const f = flo_poly_1.default.evaluate(dddPs);\r\n    return t === undefined ? f : f(t); // Curry\r\n}\r\nexports.evaluateDddx = evaluateDddx;\r\nfunction evaluateDddy(ps, t) {\r\n    const dddPs = getDddy(ps); // Speed optimizing cache\r\n    const f = flo_poly_1.default.evaluate(dddPs);\r\n    return t === undefined ? f : f(t); // Curry\r\n}\r\nexports.evaluateDddy = evaluateDddy;\r\n// TODO - refactor getBounds, getBoundingBox, etc.\r\n/**\r\n * Helper function. Returns the bounding box of the normalized (i.e. first point\r\n * moved to origin and rotated so that last point lies on x-axis) given cubic\r\n * bezier.\r\n * @ignore\r\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @param sinθ - Sine of angle made by line from first bezier point to\r\n * last with x-axis.\r\n * @param cosθ - Cosine of angle made by line from first bezier point\r\n * to last with x-axis.\r\n * @returns Bounding box in the form [[minX, minY], [maxX,maxY]\r\n */\r\nfunction getNormalizedBoundingBox(ps, sinθ, cosθ) {\r\n    let vectorToOrigin = Vector.transform(ps[0], x => -x);\r\n    let boundingPs = Vector.translateThenRotatePs(vectorToOrigin, -sinθ, cosθ, ps);\r\n    return getBoundingBox(boundingPs);\r\n}\r\n/**\r\n * Returns the tight bounding box of the given cubic bezier.\r\n * @returns The tight bounding box of the bezier as four ordered\r\n * points of a rotated rectangle.\r\n * TODO - test case of baseLength === 0\r\n */\r\nlet getBoundingBoxTight = flo_memoize_1.memoize(function (ps) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    let baseLength = Math.sqrt((x3 - x0) * (x3 - x0) + (y3 - y0) * (y3 - y0));\r\n    let sinθ = (y3 - y0) / baseLength;\r\n    let cosθ = (x3 - x0) / baseLength;\r\n    let box = getNormalizedBoundingBox(ps, sinθ, cosθ);\r\n    let [[p0x, p0y], [p1x, p1y]] = box;\r\n    let axisAlignedBox = [\r\n        box[0], [p1x, p0y],\r\n        box[1], [p0x, p1y]\r\n    ];\r\n    return Vector.rotateThenTranslatePs(sinθ, cosθ, ps[0], axisAlignedBox);\r\n});\r\nexports.getBoundingBoxTight = getBoundingBoxTight;\r\n/**\r\n * Returns the axis-aligned bounding box of a given bezier.\r\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @returns the axis-aligned bounding box in the form\r\n * [[minx, miny], [maxx,maxy]\r\n */\r\nlet getBoundingBox = flo_memoize_1.memoize(function (ps) {\r\n    return getBounds(ps).box;\r\n});\r\nexports.getBoundingBox = getBoundingBox;\r\n/**\r\n * Calculates and returns general bezier bounds.\r\n * @returns The axis-aligned bounding box together with the t values\r\n * where the bounds on the bezier are reached.\r\n */\r\nlet getBounds = flo_memoize_1.memoize(function (ps) {\r\n    // Roots of derivative\r\n    let roots = [get_dx_1.getDx(ps), get_dy_1.getDy(ps)]\r\n        .map(poly => flo_poly_1.default.allRoots(poly, 0, 1));\r\n    // Endpoints\r\n    roots[0].push(0, 1);\r\n    roots[1].push(0, 1);\r\n    let minX = Number.POSITIVE_INFINITY;\r\n    let maxX = Number.NEGATIVE_INFINITY;\r\n    let minY = Number.POSITIVE_INFINITY;\r\n    let maxY = Number.NEGATIVE_INFINITY;\r\n    let tMinX = undefined;\r\n    let tMinY = undefined;\r\n    let tMaxX = undefined;\r\n    let tMaxY = undefined;\r\n    // Test points\r\n    for (let i = 0; i < roots[0].length; i++) {\r\n        let t = roots[0][i];\r\n        let x = evaluate_x_1.evaluateX(ps, t);\r\n        if (x < minX) {\r\n            minX = x;\r\n            tMinX = t;\r\n        }\r\n        if (x > maxX) {\r\n            maxX = x;\r\n            tMaxX = t;\r\n        }\r\n    }\r\n    for (let i = 0; i < roots[1].length; i++) {\r\n        let t = roots[1][i];\r\n        let y = evaluate_y_1.evaluateY(ps, t);\r\n        if (y < minY) {\r\n            minY = y;\r\n            tMinY = t;\r\n        }\r\n        if (y > maxY) {\r\n            maxY = y;\r\n            tMaxY = t;\r\n        }\r\n    }\r\n    let ts = [[tMinX, tMinY], [tMaxX, tMaxY]];\r\n    let box = [[minX, minY], [maxX, maxY]];\r\n    return { ts, box };\r\n});\r\nexports.getBounds = getBounds;\r\n/**\r\n * Returns 2 new beziers split at the given t parameter, i.e. for the ranges\r\n * [0,t] and [t,1]. Uses de Casteljau's algorithm.\r\n *\r\n * A loose bound on the accuracy of the resultant points is given by:\r\n * |δP| = 2n*max_k(|b_k|)η, where n = 3 (cubic), b_k are the control points\r\n * abd η is Number.EPSILON.\r\n * @param ps - A cubic bezier curve\r\n * @param t - The t parameter where the curve should be split\r\n */\r\nfunction splitAt(ps, t) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    let s = 1 - t;\r\n    let t2 = t * t;\r\n    let t3 = t2 * t;\r\n    let s2 = s * s;\r\n    let s3 = s2 * s;\r\n    let ps1 = [\r\n        [x0, y0],\r\n        [t * x1 + s * x0, t * y1 + s * y0],\r\n        [t2 * x2 + 2 * s * t * x1 + s2 * x0, t2 * y2 + 2 * s * t * y1 + s2 * y0],\r\n        [t3 * x3 + 3 * s * t2 * x2 + 3 * s2 * t * x1 + s3 * x0,\r\n            t3 * y3 + 3 * s * t2 * y2 + 3 * s2 * t * y1 + s3 * y0]\r\n    ];\r\n    let ps2 = [\r\n        ps1[3],\r\n        [t2 * x3 + 2 * t * s * x2 + s2 * x1, t2 * y3 + 2 * t * s * y2 + s2 * y1],\r\n        [t * x3 + s * x2, t * y3 + s * y2],\r\n        [x3, y3]\r\n    ];\r\n    return [ps1, ps2];\r\n}\r\nexports.splitAt = splitAt;\r\n/**\r\n * Returns a new bezier from the given bezier by limiting its t range.\r\n *\r\n * Uses de Casteljau's algorithm.\r\n *\r\n * @param ps A bezier\r\n * @param tRange A t range\r\n */\r\nfunction bezierFromBezierPiece(ps, tRange) {\r\n    // If tRange = [0,1] then return original bezier.\r\n    if (tRange[0] === 0 && tRange[1] === 1) {\r\n        return ps;\r\n    }\r\n    // If tRange[0] === tRange[1] then return a single point degenerated bezier.\r\n    if (tRange[0] === tRange[1]) {\r\n        let p = evaluate_1.evaluate(ps)(tRange[0]);\r\n        return [p, p, p, p];\r\n    }\r\n    if (tRange[0] === 0) {\r\n        return from_0_to_T_1.from0ToT(ps, tRange[1]);\r\n    }\r\n    if (tRange[1] === 1) {\r\n        return from_T_to_1_1.fromTTo1(ps, tRange[0]);\r\n    }\r\n    // At this stage we know the t range is not degenerate and tRange[0] !== 0 \r\n    // and tRange[1] !== 1\r\n    return from_0_to_T_1.from0ToT(from_T_to_1_1.fromTTo1(ps, tRange[0]), (tRange[1] - tRange[0]) / (1 - tRange[0]));\r\n}\r\nexports.bezierFromBezierPiece = bezierFromBezierPiece;\r\n/**\r\n * Returns a human readable string representation of the given bezier.\r\n * @param ps - A bezier curve\r\n */\r\nfunction toString(ps) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    return `[[${x0},${y0}],[${x1},${y1}],[${x2},${y2}],[${x3},${y3}]]`;\r\n}\r\n/**\r\n * Scales all control points of the given bezier by the given factor.\r\n * @param ps - A bezier curve\r\n * @param c - The scale factor\r\n */\r\nfunction scale(ps, c) {\r\n    return ps.map(x => [x[0] * c, x[1] * c]);\r\n}\r\nexports.scale = scale;\r\n/**\r\n * Returns the best least squares quadratic bezier approximation to the given\r\n * cubic bezier. Note that the two bezier endpoints differ in general.\r\n * @param ps - A cubic bezier curve.\r\n */\r\nfunction toQuadratic(ps) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    return [\r\n        [(19 / 20) * x0 + (3 / 20) * x1 + (-3 / 20) * x2 + (1 / 20) * x3,\r\n            (19 / 20) * y0 + (3 / 20) * y1 + (-3 / 20) * y2 + (1 / 20) * y3],\r\n        [(-1 / 4) * x0 + (3 / 4) * x1 + (3 / 4) * x2 + (-1 / 4) * x3,\r\n            (-1 / 4) * y0 + (3 / 4) * y1 + (3 / 4) * y2 + (-1 / 4) * y3],\r\n        [(1 / 20) * x0 + (-3 / 20) * x1 + (3 / 20) * x2 + (19 / 20) * x3,\r\n            (1 / 20) * y0 + (-3 / 20) * y1 + (3 / 20) * y2 + (19 / 20) * y3]\r\n    ];\r\n}\r\nexports.toQuadratic = toQuadratic;\r\n/**\r\n * Evaluates the given hybrid quadratic at the given t and th parameters. (see\r\n * toHybridQuadratic for details).\r\n * @param hq - A hybrid quadratic\r\n * @param t - The bezier parameter value\r\n * @param th - The parameter value for the hybrid quadratic point.\r\n */\r\nfunction evaluateHybridQuadratic(hq, t, th) {\r\n    let P0 = hq[0];\r\n    let P1_ = hq[1];\r\n    let P2 = hq[2];\r\n    let P1 = evaluateLinear(hq[1], th);\r\n    return evaluateQuadratic([P0, P1, P2], t);\r\n}\r\nexports.evaluateHybridQuadratic = evaluateHybridQuadratic;\r\n/**\r\n * Evaluates the given linear bezier (line) at a specific t value.\r\n * @param ps - A linear bezier curve.\r\n * @param t - The value where the bezier should be evaluated\r\n */\r\nfunction evaluateLinear(ps, t) {\r\n    let [[x0, y0], [x1, y1]] = ps;\r\n    let x = x0 * (1 - t) + x1 * t;\r\n    let y = y0 * (1 - t) + y1 * t;\r\n    return [x, y];\r\n}\r\nexports.evaluateLinear = evaluateLinear;\r\n/**\r\n * Returns a clone of the given cubic bezier. Use sparingly; this is not in the\r\n * spirit of functional programming.\r\n * @param ps - A cubic bezier given by its array of control points\r\n */\r\nfunction clone(ps) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    return [[x0, y0], [x1, y1], [x2, y2], [x3, y3]];\r\n}\r\nexports.clone = clone;\r\n/**\r\n * Evaluates the given quadratic bezier at a specific t value.\r\n * @param ps - A quadratic bezier curve.\r\n * @param t - The value where the bezier should be evaluated\r\n */\r\nfunction evaluateQuadratic(ps, t) {\r\n    let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    let x = x0 * Math.pow((1 - t), 2) + x1 * 2 * (1 - t) * t + x2 * Math.pow(t, 2);\r\n    let y = y0 * Math.pow((1 - t), 2) + y1 * 2 * (1 - t) * t + y2 * Math.pow(t, 2);\r\n    return [x, y];\r\n}\r\nexports.evaluateQuadratic = evaluateQuadratic;\r\n/**\r\n * Returns the cubic version of the given quadratic bezier curve. Quadratic\r\n * bezier curves can always be represented by cubics - the converse is false.\r\n * @param ps - A quadratic bezier curve.\r\n */\r\nfunction toCubic(ps) {\r\n    let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    return [\r\n        [x0, y0],\r\n        [(1 / 3) * x0 + (2 / 3) * x1, (1 / 3) * y0 + (2 / 3) * y1],\r\n        [(2 / 3) * x1 + (1 / 3) * x2, (2 / 3) * y1 + (1 / 3) * y2],\r\n        [x2, y2]\r\n    ];\r\n}\r\nexports.toCubic = toCubic;\r\n/**\r\n * Returns the given points (e.g. bezier) in reverse order.\r\n * @param ps\r\n */\r\nfunction reverse(ps) {\r\n    return ps.slice().reverse();\r\n}\r\nexports.reverse = reverse;\r\nfunction equal(psA, psB) {\r\n    let [[ax0, ay0], [ax1, ay1], [ax2, ay2], [ax3, ay3]] = psA;\r\n    let [[bx0, by0], [bx1, by1], [bx2, by2], [bx3, by3]] = psB;\r\n    return (ax0 === bx0 && ax1 === bx1 && ax2 === bx2 && ax3 === bx3 &&\r\n        ay0 === by0 && ay1 === by1 && ay2 === by2 && ay3 === by3);\r\n}\r\nexports.equal = equal;\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/index.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/bezier3-intersection-sylvester/bezier3-intersection-sylvester_.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/bezier3-intersection-sylvester/bezier3-intersection-sylvester_.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst get_x_1 = __webpack_require__(/*! ../get-x */ \"./node_modules/flo-bezier3/node/src/get-x.js\");\r\nconst get_y_1 = __webpack_require__(/*! ../get-y */ \"./node_modules/flo-bezier3/node/src/get-y.js\");\r\nlet DELTA = 10 - 6;\r\n/**\r\n * TODO - unfinished\r\n * Returns the intersection points between two cubic beziers. This function is\r\n * not numerically stable. Use for experimentation and comparison only. The\r\n * algorithm may be enhanced to use exact arithmetic in degenerate cases.\r\n * T-value pairs at intersection of the first and second beziers respectively.\r\n * @param ps1 - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @param ps2 - Another cubic bezier\r\n * See http://mat.polsl.pl/sjpam/zeszyty/z6/Silesian_J_Pure_Appl_Math_v6_i1_str_155-176.pdf\r\n */\r\nfunction bezier3IntersectionSylvester(ps1, ps2) {\r\n    let [x1, y1] = ps1[0];\r\n    let [x2, y2] = ps2[0];\r\n    // Rotate by θ so that Δx ≡ d_0x - c_0x === 0 (as suggested by the paper)\r\n    let rotatedPs1;\r\n    let rotatedPs2;\r\n    if (Math.abs(x1 - x2) > 1e-12) {\r\n        let tanθ = (x1 - x2) / (y1 - y2);\r\n        let tanθ2 = tanθ * tanθ;\r\n        let sinθ = (tanθ2) / (1 + tanθ2); // Trig. identity\r\n        let cosθ = sinθ / tanθ;\r\n        let rotatedPs1_ = flo_vector2d_1.rotatePs(sinθ, cosθ, ps1);\r\n        let rotatedPs2_ = flo_vector2d_1.rotatePs(sinθ, cosθ, ps2);\r\n        rotatedPs1 = rotatedPs1_;\r\n        rotatedPs2 = rotatedPs2_;\r\n    }\r\n    else {\r\n        rotatedPs1 = ps1;\r\n        rotatedPs2 = ps2;\r\n    }\r\n    // Cache\r\n    let [c_3x, c_2x, c_1x, c_0x] = get_x_1.getX(rotatedPs1);\r\n    let [c_3y, c_2y, c_1y, c_0y] = get_y_1.getY(rotatedPs1);\r\n    let [d_3x, d_2x, d_1x, d_0x] = get_x_1.getX(rotatedPs2);\r\n    let [d_3y, d_2y, d_1y, d_0y] = get_y_1.getY(rotatedPs2);\r\n    let [a, b, c, d, e, f] = [d_3x, c_3x, d_2x, c_2x, d_1x, c_1x];\r\n    //let Δx = d_0x - c_0x; // === 0 after rotation\r\n    let [m, n, p, q, r, s] = [d_3y, c_3y, d_2y, c_2y, d_1y, c_1y];\r\n    let Δy = d_0y - c_0y;\r\n    let a2 = a * a;\r\n    let b2 = b * b;\r\n    let c2 = c * c;\r\n    let d2 = d * d;\r\n    let e2 = e * e;\r\n    let f2 = f * f;\r\n    let m2 = m * m;\r\n    let n2 = n * n;\r\n    let p2 = p * p;\r\n    let q2 = q * q;\r\n    let r2 = r * r;\r\n    let s2 = s * s;\r\n    let Δy2 = Δy * Δy;\r\n    let a3 = a2 * a;\r\n    let b3 = b2 * b;\r\n    let c3 = c2 * c;\r\n    let d3 = d2 * d;\r\n    let e3 = e2 * e;\r\n    let f3 = f2 * f;\r\n    let Δy3 = Δy2 * Δy;\r\n    let dΔy = d * Δy;\r\n    let dΔy2 = d * Δy2;\r\n    let bdΔy = b * dΔy;\r\n    let bdΔy2 = b * dΔy2;\r\n    let cΔy = c * Δy;\r\n    let cΔy2 = c * Δy2;\r\n    let bΔy = b * Δy;\r\n    let bΔy2 = b * Δy2;\r\n    let bΔy3 = b * Δy3;\r\n    let k9 = -b2 * Δy * f * s2 + bdΔy * f * q * s + 2 * bΔy * f2 * n * s - d2 * Δy * f * n * s -\r\n        b2 * dΔy2 * s - bΔy * f2 * q2 + dΔy * f2 * n * q - 2 * b2 * Δy2 * f * q +\r\n        d2 * bΔy2 * q - Δy * f3 * n2 + 3 * bdΔy2 * f * n - d3 * Δy2 * n - b3 * Δy3;\r\n    let k8 = b2 * Δy * e * s2 + 2 * b2 * Δy * f * r * s - bdΔy * e * q * s - 4 * bΔy * e * f * n * s +\r\n        d2 * Δy * e * n * s - bdΔy * f * q * r - 2 * bΔy * f2 * n * r + d2 * Δy * f * n * r +\r\n        b2 * dΔy2 * r + 2 * bΔy * e * f * q2 - 2 * dΔy * e * f * n * q + 2 * b2 * Δy2 * e * q +\r\n        3 * Δy * e * f2 * n2 - 3 * bdΔy2 * e * n;\r\n    let k7 = -2 * b2 * Δy * e * r * s - b * cΔy * f * q * s - bdΔy * f * p * s + 2 * c * dΔy * f * n * s +\r\n        2 * bΔy * e2 * n * s + b2 * cΔy2 * s - b2 * Δy * f * r2 + bdΔy * e * q * r +\r\n        4 * bΔy * e * f * n * r - d2 * Δy * e * n * r - bΔy * e2 * q2 + 2 * bΔy * f2 * p * q -\r\n        cΔy * f2 * n * q + dΔy * e2 * n * q - 2 * b * c * dΔy2 * q - dΔy * f2 * n * p +\r\n        2 * b2 * Δy2 * f * p - b * d2 * Δy2 * p - 3 * Δy * e2 * f * n2 - 3 * b * cΔy2 * f * n +\r\n        3 * c * d2 * Δy2 * n;\r\n    let k6 = 2 * a * bΔy * f * s2 - a * dΔy * f * q * s + b * cΔy * e * q * s + bdΔy * e * p * s -\r\n        2 * a * Δy * f2 * n * s - 2 * c * dΔy * e * n * s - 2 * bΔy * f2 * m * s + d2 * Δy * f * m * s +\r\n        2 * a * bdΔy2 * s + b2 * Δy * e * r2 + b * cΔy * f * q * r + bdΔy * f * p * r -\r\n        2 * c * dΔy * f * n * r - 2 * bΔy * e2 * n * r - b2 * cΔy2 * r + a * Δy * f2 * q2 -\r\n        4 * bΔy * e * f * p * q + 2 * cΔy * e * f * n * q - dΔy * f2 * m * q + 4 * a * bΔy2 * f * q -\r\n        a * d2 * Δy2 * q + 2 * dΔy * e * f * n * p - 2 * b2 * Δy2 * e * p + Δy * e3 * n2 +\r\n        2 * Δy * f3 * m * n - 3 * a * dΔy2 * f * n + 3 * b * cΔy2 * e * n - 3 * bdΔy2 * f * m +\r\n        d3 * Δy2 * m + 3 * a * b2 * Δy3;\r\n    let k5 = -2 * a * bΔy * e * s2 - 4 * a * bΔy * f * r * s + a * dΔy * e * q * s + b * cΔy * f * p * s +\r\n        4 * a * Δy * e * f * n * s - c2 * Δy * f * n * s + 4 * bΔy * e * f * m * s - d2 * Δy * e * m * s +\r\n        a * dΔy * f * q * r - b * cΔy * e * q * r - bdΔy * e * p * r + 2 * a * Δy * f2 * n * r +\r\n        2 * c * dΔy * e * n * r + 2 * bΔy * f2 * m * r - d2 * Δy * f * m * r - 2 * a * bdΔy2 * r -\r\n        2 * a * Δy * e * f * q2 + 2 * bΔy * e2 * p * q - cΔy * e2 * n * q + 2 * dΔy * e * f * m * q -\r\n        4 * a * bΔy2 * e * q + b * c2 * Δy2 * q - bΔy * f2 * p2 + cΔy * f2 * n * p -\r\n        dΔy * e2 * n * p + 2 * b * c * dΔy2 * p - 6 * Δy * e * f2 * m * n + 3 * a * dΔy2 * e * n -\r\n        3 * c2 * dΔy2 * n + 3 * bdΔy2 * e * m;\r\n    let k4 = 4 * a * bΔy * e * r * s + a * cΔy * f * q * s + a * dΔy * f * p * s - b * cΔy * e * p * s -\r\n        2 * a * Δy * e2 * n * s + c2 * Δy * e * n * s - 2 * c * dΔy * f * m * s - 2 * bΔy * e2 * m * s -\r\n        2 * a * b * cΔy2 * s + 2 * a * bΔy * f * r2 - a * dΔy * e * q * r - b * cΔy * f * p * r -\r\n        4 * a * Δy * e * f * n * r + c2 * Δy * f * n * r - 4 * bΔy * e * f * m * r + d2 * Δy * e * m * r +\r\n        a * Δy * e2 * q2 - 2 * a * Δy * f2 * p * q + cΔy * f2 * m * q - dΔy * e2 * m * q +\r\n        2 * a * c * dΔy2 * q + 2 * bΔy * e * f * p2 - 2 * cΔy * e * f * n * p + dΔy * f2 * m * p -\r\n        4 * a * bΔy2 * f * p + a * d2 * Δy2 * p + 6 * Δy * e2 * f * m * n + 3 * a * cΔy2 * f * n +\r\n        3 * b * cΔy2 * f * m - 3 * c * d2 * Δy2 * m;\r\n    let k3 = -a2 * Δy * f * s2 - a * cΔy * e * q * s - a * dΔy * e * p * s + 2 * a * Δy * f2 * m * s +\r\n        2 * c * dΔy * e * m * s - a2 * dΔy2 * s - 2 * a * bΔy * e * r2 - a * cΔy * f * q * r -\r\n        a * dΔy * f * p * r + b * cΔy * e * p * r + 2 * a * Δy * e2 * n * r - c2 * Δy * e * n * r +\r\n        2 * c * dΔy * f * m * r + 2 * bΔy * e2 * m * r + 2 * a * b * cΔy2 * r +\r\n        4 * a * Δy * e * f * p * q - 2 * cΔy * e * f * m * q - 2 * a2 * Δy2 * f * q - bΔy * e2 * p2 +\r\n        cΔy * e2 * n * p - 2 * dΔy * e * f * m * p + 4 * a * bΔy2 * e * p - b * c2 * Δy2 * p -\r\n        2 * Δy * e3 * m * n - 3 * a * cΔy2 * e * n + c3 * Δy2 * n - Δy * f3 * m2 +\r\n        3 * a * dΔy2 * f * m - 3 * b * cΔy2 * e * m - 3 * a2 * bΔy3;\r\n    let k2 = a2 * Δy * e * s2 + 2 * a2 * Δy * f * r * s - a * cΔy * f * p * s - 4 * a * Δy * e * f * m * s +\r\n        c2 * Δy * f * m * s + a * cΔy * e * q * r + a * dΔy * e * p * r - 2 * a * Δy * f2 * m * r -\r\n        2 * c * dΔy * e * m * r + a2 * dΔy2 * r - 2 * a * Δy * e2 * p * q + cΔy * e2 * m * q +\r\n        2 * a2 * Δy2 * e * q - a * c2 * Δy2 * q + a * Δy * f2 * p2 - cΔy * f2 * m * p +\r\n        dΔy * e2 * m * p - 2 * a * c * dΔy2 * p + 3 * Δy * e * f2 * m2 - 3 * a * dΔy2 * e * m +\r\n        3 * c2 * dΔy2 * m;\r\n    let k1 = -2 * a2 * Δy * e * r * s + a * cΔy * e * p * s + 2 * a * Δy * e2 * m * s - c2 * Δy * e * m * s +\r\n        a2 * cΔy2 * s - a2 * Δy * f * r2 + a * cΔy * f * p * r + 4 * a * Δy * e * f * m * r -\r\n        c2 * Δy * f * m * r - 2 * a * Δy * e * f * p2 + 2 * cΔy * e * f * m * p + 2 * a2 * Δy2 * f * p -\r\n        3 * Δy * e2 * f * m2 - 3 * a * cΔy2 * f * m;\r\n    let k0 = a2 * Δy * e * r2 - a * cΔy * e * p * r - 2 * a * Δy * e2 * m * r + c2 * Δy * e * m * r -\r\n        a2 * cΔy2 * r + a * Δy * e2 * p2 - cΔy * e2 * m * p - 2 * a2 * Δy2 * e * p +\r\n        a * c2 * Δy2 * p + Δy * e3 * m2 + 3 * a * cΔy2 * e * m - c3 * Δy2 * m + a3 * Δy3;\r\n    let poly = [k9, k8, k7, k6, k5, k4, k3, k2, k1, k0];\r\n    let roots = flo_poly_1.default.allRoots(poly, 0);\r\n    let tPairs = [];\r\n    for (let i = 0; i < roots.length; i++) {\r\n        let k = roots[i];\r\n        let k2 = k * k;\r\n        let k3 = k2 * k;\r\n        let ps1k = {\r\n            x: [c_3x * k3, c_2x * k2, c_1x * k, c_0x],\r\n            y: [c_3y * k3, c_2y * k2, c_1y * k, c_0y]\r\n        };\r\n        let ps2k = {\r\n            x: [d_3x * k3, d_2x * k2, d_1x * k, d_0x],\r\n            y: [d_3y * k3, d_2y * k2, d_1y * k, d_0y]\r\n        };\r\n        let xx = flo_poly_1.default.subtract(get_x_1.getX(rotatedPs2), ps1k.x);\r\n        let yy = flo_poly_1.default.subtract(get_y_1.getY(rotatedPs2), ps1k.y);\r\n        let rootsx = flo_poly_1.default.allRoots(xx, 0, 1);\r\n        let rootsy = flo_poly_1.default.allRoots(yy, 0, 1);\r\n        for (let j = 0; j < rootsx.length; j++) {\r\n            let rootx = rootsx[j];\r\n            for (let l = 0; l < rootsy.length; l++) {\r\n                let rooty = rootsy[l];\r\n                if (Math.abs(rootx - rooty) < DELTA) {\r\n                    let t = (rootx + rooty) / 2;\r\n                    let tk = t * k;\r\n                    if (t >= 0 && t <= 1 && tk >= 0 && tk <= 1) {\r\n                        tPairs.push([tk, t]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return tPairs;\r\n}\r\nexports.bezier3IntersectionSylvester = bezier3IntersectionSylvester;\r\n//# sourceMappingURL=bezier3-intersection-sylvester_.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/bezier3-intersection-sylvester/bezier3-intersection-sylvester_.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/bezier3-intersection/bezier3-intersection.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/bezier3-intersection/bezier3-intersection.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst coincident_1 = __webpack_require__(/*! ../coincident */ \"./node_modules/flo-bezier3/node/src/coincident.js\");\r\nconst from_to_1 = __webpack_require__(/*! ../from-to */ \"./node_modules/flo-bezier3/node/src/from-to.js\");\r\nconst get_distance_to_line_function_1 = __webpack_require__(/*! ./get-distance-to-line-function */ \"./node_modules/flo-bezier3/node/src/bezier3-intersection/get-distance-to-line-function.js\");\r\nconst calc_other_t_1 = __webpack_require__(/*! ./calc-other-t */ \"./node_modules/flo-bezier3/node/src/bezier3-intersection/calc-other-t.js\");\r\nconst geo_clip_1 = __webpack_require__(/*! ./geo-clip */ \"./node_modules/flo-bezier3/node/src/bezier3-intersection/geo-clip.js\");\r\nconst center_1 = __webpack_require__(/*! ./center */ \"./node_modules/flo-bezier3/node/src/bezier3-intersection/center.js\");\r\nconst evaluate_1 = __webpack_require__(/*! ../evaluate */ \"./node_modules/flo-bezier3/node/src/evaluate.js\");\r\nconst fat_line_1 = __webpack_require__(/*! ../debug/fat-line */ \"./node_modules/flo-bezier3/node/src/debug/fat-line.js\");\r\n/**\r\n * Aaccurate, fast (cubically convergent) algorithm that returns the\r\n * intersections between two cubic beziers.\r\n *\r\n * At stretches where the two curves run extremely close to (or on top of) each\r\n * other and curve the same direction an interval is returned instead of a\r\n * point. This tolerance can be set by the Δ parameter.\r\n *\r\n * The algorithm is based on a paper at http://scholarsarchive.byu.edu/cgi/viewcontent.cgi?article=2206&context=etd\r\n * that finds the intersection of a fat line and a so-called geometric interval\r\n * making it faster than the standard fat-line intersection algorithm. The\r\n * algorithm has been modified to prevent run-away recursion by checking for\r\n * coincident pieces at subdivision steps.\r\n *\r\n * @param ps1 - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @param ps2 - Another cubic bezier\r\n * @param δ - An optional tolerance to within which the t parameter\r\n * should be calculated - defaults to the minimum value of 24*Number.EPSILON or\r\n * approximately 5e-15. Note that it might not make sense to set this to as\r\n * large as say 1e-5 since only a single iteration later the maximum accuracy\r\n * will be attained and not much speed will be gained anyway. Similarly if δ is\r\n * set to 1e-2 only two iterations will be saved. This is due to the algorithm\r\n * being cubically convergent (usually converging in about 4 to 8 iterations for\r\n * typical intersections).\r\n * @param Δ - A tolerance that indicates how closely a stretch of the\r\n * beziers can run together before being considered coincident. Defaults to the\r\n * minimum possible value of 1e-6 if not specified.\r\n * @returns An array that contains the t-value pairs at intersection\r\n * of the first and second beziers respectively. The array can also contain t\r\n * range pairs for coincident pieces that can be either used or ignored\r\n * depending on the application, e.g. the return value might be [[0.1,0.2],\r\n * [0.3,0.5],[[0.4,0.5],[0.6,0.7]]] that indicates intersection points at t\r\n * values of t1=0.1 and t2=0.2 for the first and second bezier respectively as\r\n * well as at t1=0.3 and t2=0.5 and finally indicates the curves to be nearly\r\n * coincident from t1=0.4 to t1=0.5 for the first bezier and t2=0.6 to t=0.7 for\r\n * the second bezier.\r\n */\r\nfunction bezier3Intersection(ps1, ps2, δ, Δ) {\r\n    // The minimum value Δ can be. If it is too small the algorithm may take too\r\n    // long in cases where the two curves run extremely close to each other for\r\n    // their entire length and curve the same direction.\r\n    const ΔMin = 1e-6;\r\n    // This is an estimate of the relative floating point error during clipping.\r\n    // A bound is given by |δP| = 2n*max_k(|b_k|)η, where n = 3 (cubic), b_k\r\n    // are the control points indexed by k=0,1,2,3 and η is machine epsilon, \r\n    // i.e. Number.EPSILON. We quadruple the bound to be sure.\r\n    const δMin = 6 * 4 * 8 * Number.EPSILON;\r\n    // Maximum error - limited to take rounding error into account.\r\n    if (δ === undefined) {\r\n        δ = 0;\r\n    }\r\n    δ = Math.max(δ, δMin);\r\n    if (Δ === undefined) {\r\n        Δ = ΔMin;\r\n    }\r\n    Δ = Math.max(Δ, ΔMin);\r\n    let flip = 0;\r\n    // Intersection t values for both beziers\r\n    let tss = [];\r\n    if (typeof _bez_debug_ !== 'undefined') {\r\n        _bez_debug_.generated.elems.beziers.push([ps1, ps2]);\r\n        _bez_debug_.generated.elems.fatLine.push(new fat_line_1.FatLine([[0, 0], [1e-10, 1e-10]], 0, 0) // unused\r\n        );\r\n    }\r\n    let iteration = {\r\n        ps1,\r\n        ps2,\r\n        tRange1: [0, 1],\r\n        tRange2: [0, 1],\r\n        idx: 1\r\n    };\r\n    /*\r\n    let tree: IterationTree = {\r\n        parent: undefined,\r\n        iteration,\r\n        children: []\r\n    };\r\n    */\r\n    let stack = [];\r\n    stack.push(iteration);\r\n    while (stack.length !== 0) {\r\n        let toCheck = stack.pop();\r\n        let { ps1, ps2, tRange1, tRange2, idx } = toCheck;\r\n        f(ps1, ps2, tRange1, tRange2, idx);\r\n    }\r\n    if (typeof _bez_debug_ !== 'undefined') {\r\n        for (let ts of tss) {\r\n            _bez_debug_.generated.elems.intersection.push(evaluate_1.evaluate(ps1, ts[0]));\r\n        }\r\n    }\r\n    return tss;\r\n    // Helper function\r\n    function f(Q_, P_, qRange, pRange, idx) {\r\n        let cidx = idx === 0 ? 1 : 0; // Counter flip-flop index\r\n        // Move intersection toward the origin to prevent floating point issues\r\n        // that are introduced specifically by the getLineEquation function. \r\n        // This allows us to get a relative error in the final result usually in \r\n        // the 10 ULPS or less range.\r\n        //let [mx, my] = cc(P_, Q_); // TODO - REMOVE! JUST FOR TESTING\r\n        [P_, Q_] = center_1.center(P_, Q_);\r\n        if (typeof _bez_debug_ !== 'undefined') {\r\n            _bez_debug_.generated.elems.beziers.push([P_, Q_]);\r\n        }\r\n        let [Q0, , , Q3] = Q_;\r\n        // Get the implict line equation for the line defined by the first and \r\n        // last control point of Q. This equation gives the distance between any \r\n        // point and the line.\r\n        let dQ;\r\n        let dMin;\r\n        let dMax;\r\n        flip++;\r\n        let doA = flip === 1 || flip === 2;\r\n        if (flip === 4) {\r\n            flip = 0;\r\n        }\r\n        //if (doA) {\r\n        dQ = get_distance_to_line_function_1.getDistanceToLineFunction([Q0, Q3]);\r\n        // Calculate the distance from the control points of Q to the line \r\n        let dQi = (i) => dQ(Q_[i]);\r\n        let [dQ1, dQ2] = [1, 2].map(dQi);\r\n        // Calculate the fat line of Q.\r\n        let C = (dQ1 * dQ2 > 0) ? 3 / 4 : 4 / 9;\r\n        dMin = C * Math.min(0, dQ1, dQ2);\r\n        dMax = C * Math.max(0, dQ1, dQ2);\r\n        if (typeof _bez_debug_ !== 'undefined') {\r\n            _bez_debug_.generated.elems.fatLine.push(new fat_line_1.FatLine([Q0, Q3], dMin, dMax));\r\n        }\r\n        /*} else if (!doA) {\r\n            \r\n            let mid = [(Q0[0] + Q3[0]) / 2, (Q0[1] + Q3[1]) / 2];\r\n            // Rotate line [Q0,Q3]\r\n            let l_ = [[-Q0[1], Q0[0]], [-Q3[1], Q3[0]]];\r\n\r\n            let v = [l_[1][0] - l_[0][0], l_[1][1] - l_[0][1]];\r\n            let l = [\r\n                [mid[0], mid[1]],\r\n                [mid[0] + v[0], mid[1] + v[1]]\r\n            ];\r\n            dQ = getDistanceToLineFunction(l);\r\n\r\n            // Calculate the distance from the control points of Q to the line\r\n            let dQi = (i: number) => dQ(Q_[i]);\r\n            let dQs = [0,1,2,3].map(dQi);\r\n            let [dQ0,dQ1,dQ2,dQ3] = dQs;\r\n\r\n            // Calculate the fat line of Q.\r\n            dMin = Math.min(0,dQ0,dQ1,dQ2,dQ3);\r\n            dMax = Math.max(0,dQ0,dQ1,dQ2,dQ3);\r\n\r\n            //console.log(dMin, dMax)\r\n            if (typeof _bez_debug_ !== 'undefined') {\r\n                _bez_debug_.generated.elems.fatLine.push(\r\n                    new FatLine(l, dMin, dMax)\r\n                );\r\n            }\r\n        }*/\r\n        let { tMin, tMax } = geo_clip_1.geoClip(P_, dQ, dMin, dMax);\r\n        if (tMin === Number.POSITIVE_INFINITY) {\r\n            return; // No intersection\r\n        }\r\n        // The paper calls for a heuristic that if less than 30% will be\r\n        // clipped, rather split the longest curve and find intersections in the\r\n        // two halfs seperately.\r\n        if (tMax - tMin > 0.7) {\r\n            // Some length measure\r\n            let pSpan = pRange[1] - pRange[0];\r\n            let qSpan = qRange[1] - qRange[0];\r\n            let pq = coincident_1.coincident(P_, Q_);\r\n            if (pq !== undefined) {\r\n                return;\r\n            }\r\n            // Split the curve in half\r\n            if (pSpan <= qSpan) {\r\n                cidx = idx;\r\n                [P_, Q_] = [Q_, P_];\r\n                [pRange, qRange] = [qRange, pRange];\r\n            }\r\n            // Update t range.\r\n            let span = pRange[1] - pRange[0];\r\n            // 1st half\r\n            let tMinA = pRange[0];\r\n            let tMaxA = tMinA + span / 2;\r\n            // 2nd half\r\n            let tMinB = tMaxA;\r\n            let tMaxB = pRange[1];\r\n            let A = from_to_1.fromTo(P_)(0, 0.5);\r\n            let B = from_to_1.fromTo(P_)(0.5, 1);\r\n            stack.push({ ps1: A, ps2: Q_, tRange1: [tMinA, tMaxA], tRange2: qRange, idx: cidx });\r\n            stack.push({ ps1: B, ps2: Q_, tRange1: [tMinB, tMaxB], tRange2: qRange, idx: cidx });\r\n            //f(A, Q_, [tMinA, tMaxA], qRange, cidx);\r\n            //f(B, Q_, [tMinB, tMaxB], qRange, cidx);\r\n            return;\r\n        }\r\n        // Update t range.\r\n        let span = pRange[1] - pRange[0];\r\n        let tMin_ = (tMin * span + pRange[0]);\r\n        let tMax_ = (tMax * span + pRange[0]);\r\n        // Clip\r\n        P_ = from_to_1.fromTo(P_)(tMin, tMax);\r\n        if (Math.abs(tMax_ - tMin_) < δ) {\r\n            let t1 = (tMax_ + tMin_) / 2;\r\n            let pq = idx === 0 ? [ps1, ps2] : [ps2, ps1];\r\n            let t2 = calc_other_t_1.calcOtherT(t1, pq[0], pq[1]);\r\n            if (t2 === undefined) {\r\n                return undefined;\r\n            }\r\n            let ts = idx === 0 ? [t1, t2] : [t2, t1];\r\n            tss.push(ts);\r\n            return;\r\n        }\r\n        // Swap Q and P and iterate.\r\n        stack.push({ ps1: P_, ps2: Q_, tRange1: [tMin_, tMax_], tRange2: qRange, idx: cidx });\r\n    }\r\n}\r\nexports.bezier3Intersection = bezier3Intersection;\r\n//# sourceMappingURL=bezier3-intersection.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/bezier3-intersection/bezier3-intersection.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/bezier3-intersection/calc-other-t.js":
/*!********************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/bezier3-intersection/calc-other-t.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst evaluate_1 = __webpack_require__(/*! ../evaluate */ \"./node_modules/flo-bezier3/node/src/evaluate.js\");\r\nconst ts_at_x_1 = __webpack_require__(/*! ../ts-at-x */ \"./node_modules/flo-bezier3/node/src/ts-at-x.js\");\r\nconst ts_at_y_1 = __webpack_require__(/*! ../ts-at-y */ \"./node_modules/flo-bezier3/node/src/ts-at-y.js\");\r\n/**\r\n * Calculates the t-value of the closest point on Q to P(t).\r\n * @param δ\r\n * @param t\r\n * @param P\r\n * @param Q\r\n */\r\nfunction calcOtherT(t, P, Q) {\r\n    // Get some length measure on P and Q\r\n    let max = Math.max(P[0][0], P[0][1], P[1][0], P[1][1], P[2][0], P[2][1], P[3][0], P[3][1], Q[0][0], Q[0][1], Q[1][0], Q[1][1], Q[2][0], Q[2][1], Q[3][0], Q[3][1]);\r\n    let pp = evaluate_1.evaluate(P)(t);\r\n    let [x, y] = pp;\r\n    let tqsh = ts_at_y_1.tsAtY(Q, y);\r\n    let tqsv = ts_at_x_1.tsAtX(Q, x);\r\n    if (!tqsh.length && !tqsv.length) {\r\n        return undefined;\r\n    }\r\n    let tqs = [...tqsh, ...tqsv];\r\n    let bestT = undefined;\r\n    let bestD = Number.POSITIVE_INFINITY;\r\n    for (let tq of tqs) {\r\n        let pq = evaluate_1.evaluate(Q)(tq);\r\n        let d = flo_vector2d_1.squaredDistanceBetween(pp, pq);\r\n        if (d < bestD) {\r\n            bestD = d;\r\n            bestT = tq;\r\n        }\r\n    }\r\n    // If the best distance > the max allowed tolerance then no intersection\r\n    // occured - this happens only in special cases where clipping occured at\r\n    // the endpoint of a curve.\r\n    let maxTolerance = 256 * 24 * Number.EPSILON * max;\r\n    if (bestD > maxTolerance * maxTolerance) {\r\n        return undefined;\r\n    }\r\n    return bestT;\r\n}\r\nexports.calcOtherT = calcOtherT;\r\n//# sourceMappingURL=calc-other-t.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/bezier3-intersection/calc-other-t.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/bezier3-intersection/center.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/bezier3-intersection/center.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\n/**\r\n * Return the given two beziers but translated such that the shorter (by\r\n * some length measure) is closer to the origin.\r\n * @private\r\n * @param P\r\n * @param Q\r\n */\r\nfunction center(P, Q) {\r\n    let [P0, P1, P2, P3] = P;\r\n    let [Q0, Q1, Q2, Q3] = Q;\r\n    let lengthP = flo_vector2d_1.squaredDistanceBetween(P0, P1) + flo_vector2d_1.squaredDistanceBetween(P1, P2) + flo_vector2d_1.squaredDistanceBetween(P2, P3);\r\n    let lengthQ = flo_vector2d_1.squaredDistanceBetween(Q0, Q1) + flo_vector2d_1.squaredDistanceBetween(Q1, Q2) + flo_vector2d_1.squaredDistanceBetween(Q2, Q3);\r\n    let moveX;\r\n    let moveY;\r\n    if (lengthQ < lengthP) {\r\n        moveX = (Q0[0] + Q1[0] + Q2[0] + Q3[0]) / 4;\r\n        moveY = (Q0[1] + Q1[1] + Q2[1] + Q3[1]) / 4;\r\n    }\r\n    else {\r\n        moveX = (P0[0] + P1[0] + P2[0] + P3[0]) / 4;\r\n        moveY = (P0[1] + P1[1] + P2[1] + P3[1]) / 4;\r\n    }\r\n    P = P.map(x => [x[0] - moveX, x[1] - moveY]);\r\n    Q = Q.map(x => [x[0] - moveX, x[1] - moveY]);\r\n    return [P, Q];\r\n}\r\nexports.center = center;\r\n//# sourceMappingURL=center.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/bezier3-intersection/center.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/bezier3-intersection/geo-clip.js":
/*!****************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/bezier3-intersection/geo-clip.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst to_hybrid_quadratic_1 = __webpack_require__(/*! ../to-hybrid-quadratic */ \"./node_modules/flo-bezier3/node/src/to-hybrid-quadratic.js\");\r\n/**\r\n * @param P\r\n * @param dQ\r\n * @param dMin\r\n * @param dMax\r\n */\r\nfunction geoClip(P, dQ, dMin, dMax) {\r\n    let hq = to_hybrid_quadratic_1.toHybridQuadratic(P);\r\n    let dH0 = dQ(hq[0]);\r\n    let dH2 = dQ(hq[2]);\r\n    let dH10 = dQ(hq[1][0]);\r\n    let dH11 = dQ(hq[1][1]);\r\n    let dHmin = Math.min(dH10, dH11);\r\n    let dHmax = Math.max(dH10, dH11);\r\n    let DyMin = [\r\n        dH0 - 2 * dHmin + dH2,\r\n        -2 * dH0 + 2 * dHmin,\r\n        dH0\r\n    ];\r\n    let DyMax = [\r\n        dH0 - 2 * dHmax + dH2,\r\n        -2 * dH0 + 2 * dHmax,\r\n        dH0\r\n    ];\r\n    let errorBound = 2 * Math.max(flo_poly_1.default.hornerErrorBound(DyMin, 1), flo_poly_1.default.hornerErrorBound(DyMax, 1));\r\n    dMin = dMin - errorBound;\r\n    dMax = dMax + errorBound;\r\n    let DyMinMin = DyMin.slice();\r\n    DyMinMin[2] = DyMinMin[2] - dMin;\r\n    let DyMinMax = DyMin.slice();\r\n    DyMinMax[2] = DyMinMax[2] - dMax;\r\n    let DyMaxMin = DyMax.slice();\r\n    DyMaxMin[2] = DyMaxMin[2] - dMin;\r\n    let DyMaxMax = DyMax.slice();\r\n    DyMaxMax[2] = DyMaxMax[2] - dMax;\r\n    let tMin = Number.POSITIVE_INFINITY;\r\n    let tMax = Number.NEGATIVE_INFINITY;\r\n    let rootsMinMin = flo_poly_1.default.allRoots(DyMinMin, 0, 1);\r\n    let rootsMinMax = flo_poly_1.default.allRoots(DyMinMax, 0, 1);\r\n    let rootsMaxMin = flo_poly_1.default.allRoots(DyMaxMin, 0, 1);\r\n    let rootsMaxMax = flo_poly_1.default.allRoots(DyMaxMax, 0, 1);\r\n    tMin = Math.min(...rootsMinMin, ...rootsMinMax, ...rootsMaxMin, ...rootsMaxMax);\r\n    tMax = Math.max(...rootsMinMin, ...rootsMinMax, ...rootsMaxMin, ...rootsMaxMax);\r\n    if (dH0 >= dMin && dH0 <= dMax) {\r\n        tMin = 0;\r\n    }\r\n    if (dH2 >= dMin && dH2 <= dMax) {\r\n        tMax = 1;\r\n    }\r\n    if (tMin < 0) {\r\n        tMin = 0;\r\n    }\r\n    if (tMax > 1) {\r\n        tMax = 1;\r\n    }\r\n    return { tMin, tMax };\r\n}\r\nexports.geoClip = geoClip;\r\n//# sourceMappingURL=geo-clip.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/bezier3-intersection/geo-clip.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/bezier3-intersection/get-distance-to-line-function.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/bezier3-intersection/get-distance-to-line-function.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_line_equation_1 = __webpack_require__(/*! ./get-line-equation */ \"./node_modules/flo-bezier3/node/src/bezier3-intersection/get-line-equation.js\");\r\n/**\r\n * @private\r\n * @param l\r\n */\r\nfunction getDistanceToLineFunction(l) {\r\n    let [a, b, c] = get_line_equation_1.getLineEquation(l);\r\n    return function (p) {\r\n        return a * p[0] + b * p[1] + c;\r\n    };\r\n}\r\nexports.getDistanceToLineFunction = getDistanceToLineFunction;\r\n//# sourceMappingURL=get-distance-to-line-function.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/bezier3-intersection/get-distance-to-line-function.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/bezier3-intersection/get-line-equation.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/bezier3-intersection/get-line-equation.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Get the implicit line equation from two 2d points in the form f(x,y) ax + by + c = 0\r\n * returned as the array [a,b,c].\r\n * @param l - A line given by two points, e.g. [[2,0],[3,3]]\r\n */\r\nfunction getLineEquation(l) {\r\n    let [[x1, y1], [x2, y2]] = l;\r\n    let a = y1 - y2;\r\n    let b = x2 - x1;\r\n    let c = x1 * y2 - x2 * y1;\r\n    let d = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\r\n    return [a / d, b / d, c / d];\r\n}\r\nexports.getLineEquation = getLineEquation;\r\n//# sourceMappingURL=get-line-equation.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/bezier3-intersection/get-line-equation.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/coincident.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/coincident.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Vector = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst evaluate_1 = __webpack_require__(/*! ./evaluate */ \"./node_modules/flo-bezier3/node/src/evaluate.js\");\r\nconst line_intersection_1 = __webpack_require__(/*! ./line-intersection */ \"./node_modules/flo-bezier3/node/src/line-intersection.js\");\r\nconst normal_1 = __webpack_require__(/*! ./normal */ \"./node_modules/flo-bezier3/node/src/normal.js\");\r\n/**\r\n * Check if the two given cubic beziers are nearly coincident everywhere along\r\n * a finite stretch and returns the coincident stretch (if any), otherwise\r\n * returns undefined.\r\n * @param P - A cubic bezier curve.\r\n * @param Q - Another cubic bezier curve.\r\n * @param δ - An indication of how closely the curves should stay to\r\n * each other before considered coincident.\r\n */\r\nfunction coincident(P, Q, δ = 1e-6) {\r\n    let PtoQs = [0.01, 0.99].map(i => calcPointAndNeighbor(P, Q, i));\r\n    let QtoPs = [0.01, 0.99].map(i => calcPointAndNeighbor(Q, P, i));\r\n    // Check if start and end points are coincident.\r\n    let tStartQ = 0.01;\r\n    let tEndQ = 0.99;\r\n    let tStartP = 0.01;\r\n    let tEndP = 0.99;\r\n    if (PtoQs[0].d <= δ) {\r\n        tStartQ = PtoQs[0].t;\r\n    }\r\n    if (PtoQs[1].d <= δ) {\r\n        tEndQ = PtoQs[1].t;\r\n    }\r\n    if (QtoPs[0].d <= δ) {\r\n        tStartP = QtoPs[0].t;\r\n    }\r\n    if (QtoPs[1].d <= δ) {\r\n        tEndP = QtoPs[1].t;\r\n    }\r\n    if (tStartP > tEndP) {\r\n        [tStartP, tEndP] = [tEndP, tStartP];\r\n    }\r\n    if (tStartQ > tEndQ) {\r\n        [tStartQ, tEndQ] = [tEndQ, tStartQ];\r\n    }\r\n    let tSpanP = tEndP - tStartP;\r\n    let tSpanQ = tEndQ - tStartQ;\r\n    // We must check at least 10 points to ensure entire curve is coincident, \r\n    // otherwise we may simply have found intersection points. We cannot simply \r\n    // check the control points for closeness since well seperated control \r\n    // points does not necessarily translate into well seperated curves.\r\n    // If the overlapping part is smaller than 1/10 (a heuristical value) then\r\n    // do not consider pieces overlapping.\r\n    if (tSpanP < 0.1 && tSpanQ < 0.1) {\r\n        return undefined;\r\n    }\r\n    let res = true;\r\n    for (let i = 0; i < 10; i++) {\r\n        let t = tStartP + tSpanP * (i / 10);\r\n        let { d } = calcPointAndNeighbor(P, Q, t);\r\n        if (d > δ) {\r\n            return undefined;\r\n        }\r\n    }\r\n    return { p: [tStartP, tEndP], q: [tStartQ, tEndQ] };\r\n}\r\nexports.coincident = coincident;\r\nfunction calcPointAndNeighbor(P, Q, t) {\r\n    // TODO - must also check crossing of normals - for if two curves open\r\n    // at endpoints and stop essentially at same point.\r\n    let pp1 = evaluate_1.evaluate(P)(t);\r\n    let normalVector = normal_1.normal(P)(t);\r\n    let pp2 = Vector.translate(pp1, normalVector);\r\n    let ts = line_intersection_1.lineIntersection(Q, [pp1, pp2]);\r\n    let bestT = undefined;\r\n    let bestQ = undefined;\r\n    let bestD = Number.POSITIVE_INFINITY;\r\n    for (let t of ts) {\r\n        let q = evaluate_1.evaluate(Q)(t);\r\n        let d = Vector.distanceBetween(q, pp1);\r\n        if (d < bestD) {\r\n            bestT = t;\r\n            bestQ = q;\r\n            bestD = d;\r\n        }\r\n    }\r\n    return { t: bestT, p: bestQ, d: bestD };\r\n}\r\n//# sourceMappingURL=coincident.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/coincident.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/de-casteljau.js":
/*!***********************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/de-casteljau.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction deCasteljau(cs, t) {\r\n    // See https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm\r\n    function f(t) {\r\n        if (t === 0) {\r\n            return [[cs[0], cs[0], cs[0], cs[0]], cs];\r\n        }\r\n        if (t === 1) {\r\n            return [cs, [cs[3], cs[3], cs[3], cs[3]]];\r\n        }\r\n        let t_ = 1 - t;\r\n        // j === 0, ..., n (with n === 3 -> cubic bezier)\r\n        let b00 = cs[0]; // i === 0 \r\n        let b10 = cs[1]; // i === 1 \r\n        let b20 = cs[2]; // i === 2 \r\n        let b30 = cs[3]; // i === 3 \r\n        // j === 1\r\n        let b01 = (b00 * t_) + (b10 * t); // i === 0\r\n        let b11 = (b10 * t_) + (b20 * t); // i === 1\r\n        let b21 = (b20 * t_) + (b30 * t); // i === 2\r\n        // j === 2\r\n        let b02 = (b01 * t_) + (b11 * t); // i === 0\r\n        let b12 = (b11 * t_) + (b21 * t); // i === 1\r\n        // j === 3\r\n        let b03 = (b02 * t_) + (b12 * t); // i === 0\r\n        return [[b00, b01, b02, b03], [b03, b12, b21, b30]];\r\n    }\r\n    return t === undefined ? f : f(t); // Curry\r\n}\r\nexports.deCasteljau = deCasteljau;\r\n//# sourceMappingURL=de-casteljau.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/de-casteljau.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/debug/debug.js":
/*!**********************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/debug/debug.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n//import * as Vector from 'flo-vector2d';\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst draw_elem_1 = __webpack_require__(/*! ./draw-elem/draw-elem */ \"./node_modules/flo-bezier3/node/src/debug/draw-elem/draw-elem.js\");\r\nclass BezDebug {\r\n    /**\r\n     * @param config - configuration settings.\r\n     * @param fs - some useful functions.\r\n     * @private\r\n     */\r\n    constructor(draw, g) {\r\n        //(this as any).Bezier3 = Bezier3; // Included only for quick debugging from console\r\n        //(this as any).Vector2d = Vector; // ...\r\n        this.draw = draw;\r\n        this.g = g;\r\n        //-----------------------------------------------\r\n        // Generated by debug object for later inspection\r\n        //-----------------------------------------------\r\n        this.generated = {\r\n            elems: {\r\n                beziers: [],\r\n                fatLine: [],\r\n                looseBoundingBox: [],\r\n                tightBoundingBox: [],\r\n                extreme: [],\r\n                boundingHull: [],\r\n                intersection: [],\r\n            }\r\n        };\r\n        this.fs = {\r\n            draw,\r\n            drawElem: draw_elem_1.drawElemFunctions,\r\n        };\r\n    }\r\n}\r\nexports.BezDebug = BezDebug;\r\n//# sourceMappingURL=debug.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/debug/debug.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/debug/draw-elem/draw-elem.js":
/*!************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/debug/draw-elem/draw-elem.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nfunction fatLine(g, fatLine) {\r\n    let draw = _bez_debug_.fs.draw;\r\n    let { l, minD, maxD } = fatLine;\r\n    let [lp1, lp2] = l;\r\n    const E = 1024;\r\n    let lv = flo_vector2d_1.fromTo(lp1, lp2);\r\n    let lvTimes10 = [+E * lv[0], +E * lv[1]];\r\n    let reverseLvTimes10 = [-E * lv[0], -E * lv[1]];\r\n    let normal = [-lv[1], lv[0]]; // Rotate by -90 degrees\r\n    let normMin = flo_vector2d_1.toLength(normal, minD);\r\n    let normMax = flo_vector2d_1.toLength(normal, maxD);\r\n    let extLp1 = flo_vector2d_1.translate(lp1, reverseLvTimes10);\r\n    let extLp2 = flo_vector2d_1.translate(lp2, lvTimes10);\r\n    let nl11 = flo_vector2d_1.translate(extLp1, normMin);\r\n    let nl12 = flo_vector2d_1.translate(extLp2, normMin);\r\n    let nl21 = flo_vector2d_1.translate(extLp1, normMax);\r\n    let nl22 = flo_vector2d_1.translate(extLp2, normMax);\r\n    let nl1 = [nl11, nl12];\r\n    let nl2 = [nl21, nl22];\r\n    let $line1 = draw.line(g, nl1);\r\n    let $line2 = draw.line(g, nl2);\r\n    return [...$line1, ...$line2];\r\n}\r\nfunction beziers(g, beziers) {\r\n    let draw = _bez_debug_.fs.draw;\r\n    let $bezier1 = draw.bezier(g, beziers[0], 'blue thin5 nofill');\r\n    let $bezier2 = draw.bezier(g, beziers[1], 'green thin5 nofill');\r\n    let size = getSize([...beziers[0], ...beziers[1]]) / 400;\r\n    let $dots = [\r\n        ...draw.dot(g, beziers[0][0], size, 'blue'),\r\n        ...draw.dot(g, beziers[0][1], size, 'blue'),\r\n        ...draw.dot(g, beziers[0][2], size, 'blue'),\r\n        ...draw.dot(g, beziers[0][3], size, 'blue'),\r\n        ...draw.dot(g, beziers[1][0], size, 'green'),\r\n        ...draw.dot(g, beziers[1][1], size, 'green'),\r\n        ...draw.dot(g, beziers[1][2], size, 'green'),\r\n        ...draw.dot(g, beziers[1][3], size, 'green'),\r\n    ];\r\n    return [...$bezier1, ...$bezier2, ...$dots];\r\n}\r\nfunction getSize(ps) {\r\n    let minX = Number.POSITIVE_INFINITY;\r\n    let minY = Number.POSITIVE_INFINITY;\r\n    let maxX = Number.NEGATIVE_INFINITY;\r\n    let maxY = Number.NEGATIVE_INFINITY;\r\n    for (let p of ps) {\r\n        if (p[0] < minX) {\r\n            minX = p[0];\r\n        }\r\n        if (p[1] < minY) {\r\n            minY = p[1];\r\n        }\r\n        if (p[0] > maxX) {\r\n            maxX = p[0];\r\n        }\r\n        if (p[1] > maxY) {\r\n            maxY = p[1];\r\n        }\r\n    }\r\n    let width = maxX - minX;\r\n    let height = maxY - minY;\r\n    return Math.max(width, height);\r\n}\r\nfunction intersection(g, p) {\r\n    let $elems = _bez_debug_.fs.draw.crossHair(g, p, 'red thin5 nofill', 0.05);\r\n    return $elems;\r\n}\r\nfunction extreme(g, extreme) {\r\n    let $elems = _bez_debug_.fs.draw.crossHair(g, extreme.p, 'red thin10 nofill', 0.05);\r\n    return $elems;\r\n}\r\nfunction boundingHull(g, hull) {\r\n    let $polygon = _bez_debug_.fs.draw.polygon(g, hull, 'thin5 black nofill');\r\n    return $polygon;\r\n}\r\nfunction looseBoundingBox(g, box) {\r\n    let $box = _bez_debug_.fs.draw.rect(g, box, 'thin5 brown nofill');\r\n    return $box;\r\n}\r\nfunction tightBoundingBox(g, box) {\r\n    let $box = _bez_debug_.fs.draw.polygon(g, box, 'thin5 black nofill');\r\n    return $box;\r\n}\r\nlet drawElemFunctions = {\r\n    beziers,\r\n    intersection,\r\n    extreme,\r\n    boundingHull,\r\n    looseBoundingBox,\r\n    tightBoundingBox,\r\n    fatLine\r\n};\r\nexports.drawElemFunctions = drawElemFunctions;\r\n//# sourceMappingURL=draw-elem.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/debug/draw-elem/draw-elem.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/debug/fat-line.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/debug/fat-line.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass FatLine {\r\n    constructor(l, minD, maxD) {\r\n        this.l = l;\r\n        this.minD = minD;\r\n        this.maxD = maxD;\r\n    }\r\n}\r\nexports.FatLine = FatLine;\r\n//# sourceMappingURL=fat-line.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/debug/fat-line.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/eval-de-casteljau.js":
/*!****************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/eval-de-casteljau.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst de_casteljau_1 = __webpack_require__(/*! ./de-casteljau */ \"./node_modules/flo-bezier3/node/src/de-casteljau.js\");\r\nfunction evalDeCasteljau(ps, t) {\r\n    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    let evX = de_casteljau_1.deCasteljau([x0, x1, x2, x3]);\r\n    let evY = de_casteljau_1.deCasteljau([y0, y1, y2, y3]);\r\n    function f(t) {\r\n        if (t === 0) {\r\n            return [x0, y0];\r\n        }\r\n        else if (t === 1) {\r\n            return [x3, y3];\r\n        }\r\n        return [evX(t)[1][0], evY(t)[1][0]];\r\n    }\r\n    return t === undefined ? f : f(t);\r\n}\r\nexports.evalDeCasteljau = evalDeCasteljau;\r\n//# sourceMappingURL=eval-de-casteljau.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/eval-de-casteljau.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/evaluate-dx.js":
/*!**********************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/evaluate-dx.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst get_dx_1 = __webpack_require__(/*! ./get-dx */ \"./node_modules/flo-bezier3/node/src/get-dx.js\");\r\nfunction evaluateDx(ps, t) {\r\n    const dPs = get_dx_1.getDx(ps); // Speed optimizing cache\r\n    const f = flo_poly_1.default.evaluate(dPs);\r\n    return t === undefined ? f : f(t); // Curry\r\n}\r\nexports.evaluateDx = evaluateDx;\r\n//# sourceMappingURL=evaluate-dx.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/evaluate-dx.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/evaluate-dx2.js":
/*!***********************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/evaluate-dx2.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst get_dx2_1 = __webpack_require__(/*! ./get-dx2 */ \"./node_modules/flo-bezier3/node/src/get-dx2.js\");\r\nfunction evaluateDx2(ps, t) {\r\n    const dPs = get_dx2_1.getDx2(ps); // Speed optimizing cache\r\n    const f = flo_poly_1.default.evaluate(dPs);\r\n    return t === undefined ? f : f(t); // Curry\r\n}\r\nexports.evaluateDx2 = evaluateDx2;\r\n//# sourceMappingURL=evaluate-dx2.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/evaluate-dx2.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/evaluate-dy.js":
/*!**********************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/evaluate-dy.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst get_dy_1 = __webpack_require__(/*! ./get-dy */ \"./node_modules/flo-bezier3/node/src/get-dy.js\");\r\nfunction evaluateDy(ps, t) {\r\n    const dPs = get_dy_1.getDy(ps); // Speed optimizing cache\r\n    const f = flo_poly_1.default.evaluate(dPs);\r\n    return t === undefined ? f : f(t); // Curry\r\n}\r\nexports.evaluateDy = evaluateDy;\r\n//# sourceMappingURL=evaluate-dy.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/evaluate-dy.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/evaluate-dy2.js":
/*!***********************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/evaluate-dy2.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst get_dy2_1 = __webpack_require__(/*! ./get-dy2 */ \"./node_modules/flo-bezier3/node/src/get-dy2.js\");\r\nfunction evaluateDy2(ps, t) {\r\n    const dPs = get_dy2_1.getDy2(ps); // Speed optimizing cache\r\n    const f = flo_poly_1.default.evaluate(dPs);\r\n    return t === undefined ? f : f(t); // Curry\r\n}\r\nexports.evaluateDy2 = evaluateDy2;\r\n//# sourceMappingURL=evaluate-dy2.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/evaluate-dy2.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/evaluate-x.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/evaluate-x.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst get_x_1 = __webpack_require__(/*! ./get-x */ \"./node_modules/flo-bezier3/node/src/get-x.js\");\r\nfunction evaluateX(ps, t) {\r\n    const xPs = get_x_1.getX(ps); // Speed optimizing cache\r\n    const evPs = flo_poly_1.default.evaluate(xPs);\r\n    function f(t) {\r\n        if (t === 0) {\r\n            return ps[0][0];\r\n        }\r\n        if (t === 1) {\r\n            return ps[3][0];\r\n        }\r\n        return evPs(t);\r\n    }\r\n    return t === undefined ? f : f(t); // Curry\r\n}\r\nexports.evaluateX = evaluateX;\r\n//# sourceMappingURL=evaluate-x.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/evaluate-x.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/evaluate-y.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/evaluate-y.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst get_y_1 = __webpack_require__(/*! ./get-y */ \"./node_modules/flo-bezier3/node/src/get-y.js\");\r\nfunction evaluateY(ps, t) {\r\n    const yPs = get_y_1.getY(ps); // Speed optimizing cache\r\n    const evPs = flo_poly_1.default.evaluate(yPs);\r\n    function f(t) {\r\n        if (t === 0) {\r\n            return ps[0][1];\r\n        }\r\n        if (t === 1) {\r\n            return ps[3][1];\r\n        }\r\n        return evPs(t);\r\n    }\r\n    return t === undefined ? f : f(t); // Curry\r\n}\r\nexports.evaluateY = evaluateY;\r\n//# sourceMappingURL=evaluate-y.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/evaluate-y.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/evaluate.js":
/*!*******************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/evaluate.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst evaluate_x_1 = __webpack_require__(/*! ./evaluate-x */ \"./node_modules/flo-bezier3/node/src/evaluate-x.js\");\r\nconst evaluate_y_1 = __webpack_require__(/*! ./evaluate-y */ \"./node_modules/flo-bezier3/node/src/evaluate-y.js\");\r\nfunction evaluate(ps, t) {\r\n    const [[x0, y0], , , [x3, y3]] = ps;\r\n    const evX = evaluate_x_1.evaluateX(ps);\r\n    const evY = evaluate_y_1.evaluateY(ps);\r\n    function f(t) {\r\n        if (t === 0) {\r\n            return [x0, y0];\r\n        }\r\n        else if (t === 1) {\r\n            return [x3, y3];\r\n        }\r\n        return [evX(t), evY(t)];\r\n    }\r\n    return t === undefined ? f : f(t);\r\n}\r\nexports.evaluate = evaluate;\r\n//# sourceMappingURL=evaluate.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/evaluate.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/from-0-to-T.js":
/*!**********************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/from-0-to-T.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns a cubic bezier curve that starts at the given curve's t=0 and ends\r\n * at the given t parameter. Uses de Casteljau's algorithm.\r\n *\r\n * A loose bound on the accuracy of the resultant points is given by:\r\n * |δP| = 2n*max_k(|b_k|)η, where n = 3 (cubic), b_k are the control points\r\n * abd η is Number.EPSILON.\r\n * @param ps - A cubic bezier curve\r\n * @param t - The t parameter where the resultant bezier should end\r\n */\r\nfunction from0ToT(ps, t) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    let s = 1 - t;\r\n    let t2 = t * t;\r\n    let t3 = t2 * t;\r\n    let s2 = s * s;\r\n    let s3 = s2 * s;\r\n    return [\r\n        [x0, y0],\r\n        [t * x1 + s * x0, t * y1 + s * y0],\r\n        [t2 * x2 + 2 * s * t * x1 + s2 * x0, t2 * y2 + 2 * s * t * y1 + s2 * y0],\r\n        [t3 * x3 + 3 * s * t2 * x2 + 3 * s2 * t * x1 + s3 * x0,\r\n            t3 * y3 + 3 * s * t2 * y2 + 3 * s2 * t * y1 + s3 * y0]\r\n    ];\r\n}\r\nexports.from0ToT = from0ToT;\r\n//# sourceMappingURL=from-0-to-T.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/from-0-to-T.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/from-T-to-1.js":
/*!**********************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/from-T-to-1.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns a cubic bezier curve that starts at the given t parameter and\r\n * ends at t=1. Uses de Casteljau's algorithm.\r\n *\r\n * A loose bound on the accuracy of the resultant points is given by:\r\n * |δP| = 2n*max_k(|b_k|)η, where n = 3 (cubic), b_k are the control points\r\n * abd η is Number.EPSILON.\r\n * @param ps - A cubic bezier curve\r\n * @param t - The t parameter where the resultant bezier should start\r\n */\r\nfunction fromTTo1(ps, t) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    let s = 1 - t;\r\n    let t2 = t * t;\r\n    let t3 = t2 * t;\r\n    let s2 = s * s;\r\n    let s3 = s2 * s;\r\n    return [\r\n        [t3 * x3 + 3 * s * t2 * x2 + 3 * s2 * t * x1 + s3 * x0,\r\n            t3 * y3 + 3 * s * t2 * y2 + 3 * s2 * t * y1 + s3 * y0],\r\n        [t2 * x3 + 2 * t * s * x2 + s2 * x1, t2 * y3 + 2 * t * s * y2 + s2 * y1],\r\n        [t * x3 + s * x2, t * y3 + s * y2],\r\n        [x3, y3]\r\n    ];\r\n}\r\nexports.fromTTo1 = fromTTo1;\r\n//# sourceMappingURL=from-T-to-1.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/from-T-to-1.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/from-to.js":
/*!******************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/from-to.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst evaluate_1 = __webpack_require__(/*! ./evaluate */ \"./node_modules/flo-bezier3/node/src/evaluate.js\");\r\nconst from_0_to_T_1 = __webpack_require__(/*! ./from-0-to-T */ \"./node_modules/flo-bezier3/node/src/from-0-to-T.js\");\r\nconst from_T_to_1_1 = __webpack_require__(/*! ./from-T-to-1 */ \"./node_modules/flo-bezier3/node/src/from-T-to-1.js\");\r\n/**\r\n * Returns a cubic bezier curve that starts at the given curve and ends at the\r\n * given t parameter. Uses de Casteljau's algorithm.\r\n *\r\n * A loose bound on the accuracy of the resultant points is given by:\r\n * |δP| = 2*2n*max_k(|b_k|)η, where n = 3 (cubic), b_k are the control points\r\n * abd η is Number.EPSILON.\r\n * @param ps - A cubic bezier curve\r\n * @param t1 - The t parameter where the resultant bezier should start\r\n * @param t2 - The t parameter where the resultant bezier should end\r\n */\r\nfunction fromTo(ps) {\r\n    return function (t1, t2) {\r\n        if (t1 === t2) {\r\n            // Degenerate case\r\n            let p = evaluate_1.evaluate(ps, t1);\r\n            return [p, p, p, p];\r\n        }\r\n        else if (t1 === 0 && t2 === 1) {\r\n            return ps;\r\n        }\r\n        else if (t1 === 0) {\r\n            return from_0_to_T_1.from0ToT(ps, t2);\r\n        }\r\n        else if (t2 === 1) {\r\n            return from_T_to_1_1.fromTTo1(ps, t1);\r\n        }\r\n        let t = from_T_to_1_1.fromTTo1(ps, t1);\r\n        return from_0_to_T_1.from0ToT(t, (t2 - t1) / (1 - t1));\r\n    };\r\n}\r\nexports.fromTo = fromTo;\r\n//# sourceMappingURL=from-to.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/from-to.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/get-dx.js":
/*!*****************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/get-dx.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\r\nconst get_x_1 = __webpack_require__(/*! ./get-x */ \"./node_modules/flo-bezier3/node/src/get-x.js\");\r\n/**\r\n * Returns the derivative of the power basis representation of the bezier's\r\n * x-coordinates. This function is memoized on its points parameter by object\r\n * reference.\r\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n */\r\nlet getDx = flo_memoize_1.memoize((ps) => flo_poly_1.default.differentiate(get_x_1.getX(ps)));\r\nexports.getDx = getDx;\r\n//# sourceMappingURL=get-dx.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/get-dx.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/get-dx2.js":
/*!******************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/get-dx2.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\r\nconst get_x2_1 = __webpack_require__(/*! ./get-x2 */ \"./node_modules/flo-bezier3/node/src/get-x2.js\");\r\n/**\r\n * Returns the derivative of the power basis representation of the bezier's\r\n * x-coordinates. This function is memoized on its points parameter by object\r\n * reference.\r\n * @param ps - A quadratic bezier, e.g. [[0,0],[1,1],[2,1]]\r\n */\r\nlet getDx2 = flo_memoize_1.memoize((ps) => flo_poly_1.default.differentiate(get_x2_1.getX2(ps)));\r\nexports.getDx2 = getDx2;\r\n//# sourceMappingURL=get-dx2.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/get-dx2.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/get-dy.js":
/*!*****************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/get-dy.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\r\nconst get_y_1 = __webpack_require__(/*! ./get-y */ \"./node_modules/flo-bezier3/node/src/get-y.js\");\r\n/**\r\n * Returns the derivative of the power basis representation of the bezier's\r\n * y-coordinates. This function is memoized on its points parameter by object\r\n * reference.\r\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @returns The differentiated power basis polynomial from highest\r\n * power to lowest, e.g. at^2 + bt + c is returned as [a,b,c]\r\n */\r\nlet getDy = flo_memoize_1.memoize((ps) => flo_poly_1.default.differentiate(get_y_1.getY(ps)));\r\nexports.getDy = getDy;\r\n//# sourceMappingURL=get-dy.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/get-dy.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/get-dy2.js":
/*!******************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/get-dy2.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\r\nconst get_y2_1 = __webpack_require__(/*! ./get-y2 */ \"./node_modules/flo-bezier3/node/src/get-y2.js\");\r\n/**\r\n * Returns the derivative of the power basis representation of the bezier's\r\n * y-coordinates. This function is memoized on its points parameter by object\r\n * reference.\r\n * @param ps - A quadratic bezier, e.g. [[0,0],[1,1],[2,1]]\r\n * @returns The differentiated power basis polynomial from highest\r\n * power to lowest, e.g. at^2 + bt + c is returned as [a,b,c]\r\n */\r\nlet getDy2 = flo_memoize_1.memoize((ps) => flo_poly_1.default.differentiate(get_y2_1.getY2(ps)));\r\nexports.getDy2 = getDy2;\r\n//# sourceMappingURL=get-dy2.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/get-dy2.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/get-x.js":
/*!****************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/get-x.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\r\n/**\r\n * Returns the power basis representation of the bezier's x-coordinates.\r\n * This function is memoized on its points parameter by object reference.\r\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @returns The power basis polynomial from highest power to lowest,\r\n * e.g. at^3 + bt^2 + ct + d is returned as [a,b,c,d]\r\n */\r\nlet getX = flo_memoize_1.memoize(function (ps) {\r\n    let [[x0,], [x1,], [x2,], [x3,]] = ps;\r\n    return [\r\n        x3 - 3 * x2 + 3 * x1 - x0,\r\n        3 * x2 - 6 * x1 + 3 * x0,\r\n        3 * x1 - 3 * x0,\r\n        x0,\r\n    ];\r\n});\r\nexports.getX = getX;\r\n//# sourceMappingURL=get-x.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/get-x.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/get-x2.js":
/*!*****************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/get-x2.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\r\n/**\r\n * Returns the power basis representation of the bezier's x-coordinates.\r\n * This function is memoized on its points parameter by object reference.\r\n * @param ps - A quadratic bezier, e.g. [[0,0],[1,1],[2,1]]\r\n * @returns The power basis polynomial from highest power to lowest,\r\n * e.g. at^2 + bt + c is returned as [a,b,c]\r\n */\r\nlet getX2 = flo_memoize_1.memoize(function (ps) {\r\n    let [[x0,], [x1,], [x2,]] = ps;\r\n    return [\r\n        x2 - 2 * x1 + x0,\r\n        2 * x1 - 2 * x0,\r\n        x0,\r\n    ];\r\n});\r\nexports.getX2 = getX2;\r\n//# sourceMappingURL=get-x2.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/get-x2.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/get-y.js":
/*!****************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/get-y.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\r\n/**\r\n * Returns the power basis representation of the bezier's y-coordinates.\r\n * This function is memoized on its points parameter by object reference.\r\n * @param ps - A bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n */\r\nlet getY = flo_memoize_1.memoize(function (ps) {\r\n    let [[, y0], [, y1], [, y2], [, y3]] = ps;\r\n    return [\r\n        y3 - 3 * y2 + 3 * y1 - y0,\r\n        3 * y2 - 6 * y1 + 3 * y0,\r\n        3 * y1 - 3 * y0,\r\n        y0,\r\n    ];\r\n});\r\nexports.getY = getY;\r\n//# sourceMappingURL=get-y.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/get-y.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/get-y2.js":
/*!*****************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/get-y2.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\r\n/**\r\n * Returns the power basis representation of the bezier's y-coordinates.\r\n * This function is memoized on its points parameter by object reference.\r\n * @param ps - A quadratic bezier, e.g. [[0,0],[1,1],[2,1]]\r\n */\r\nlet getY2 = flo_memoize_1.memoize(function (ps) {\r\n    let [[, y0], [, y1], [, y2]] = ps;\r\n    return [\r\n        y2 - 2 * y1 + y0,\r\n        2 * y1 - 2 * y0,\r\n        y0,\r\n    ];\r\n});\r\nexports.getY2 = getY2;\r\n//# sourceMappingURL=get-y2.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/get-y2.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/line-intersection.js":
/*!****************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/line-intersection.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst get_y_1 = __webpack_require__(/*! ./get-y */ \"./node_modules/flo-bezier3/node/src/get-y.js\");\r\n/**\r\n * Returns the bezier t values of the intersection between the given cubic\r\n * bezier and the given line.\r\n * @param ps - The bezier curve\r\n * @param l - The line given as a start and end point\r\n */\r\nfunction lineIntersection(ps, l) {\r\n    let [[x0, y0], [x1, y1]] = l;\r\n    let [x, y] = [x1 - x0, y1 - y0];\r\n    if (x === 0 && y === 0) {\r\n        return [];\r\n    } // It is not a line, it's a point. \r\n    // Move the line and the bezier together so the line's first point is on the\r\n    // origin.\r\n    ps = flo_vector2d_1.translatePs([-x0, -y0], ps);\r\n    // Rotate the bezier and line together so the line is y=0.\r\n    let len = Math.sqrt(x * x + y * y);\r\n    let sinθ = y / len;\r\n    let cosθ = x / len;\r\n    ps = flo_vector2d_1.rotatePs(-sinθ, cosθ, ps);\r\n    // Find the intersection t values\r\n    return flo_poly_1.default.allRoots(get_y_1.getY(ps), 0, 1);\r\n}\r\nexports.lineIntersection = lineIntersection;\r\n//# sourceMappingURL=line-intersection.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/line-intersection.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/normal.js":
/*!*****************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/normal.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst tangent_1 = __webpack_require__(/*! ./tangent */ \"./node_modules/flo-bezier3/node/src/tangent.js\");\r\nfunction normal(ps, t) {\r\n    const tanPs = tangent_1.tangent(ps);\r\n    function f(t) {\r\n        let v = tanPs(t);\r\n        return [v[1], -v[0]];\r\n    }\r\n    // Curry\r\n    return t === undefined ? f : f(t);\r\n}\r\nexports.normal = normal;\r\n//# sourceMappingURL=normal.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/normal.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/tangent.js":
/*!******************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/tangent.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst evaluate_dx_1 = __webpack_require__(/*! ./evaluate-dx */ \"./node_modules/flo-bezier3/node/src/evaluate-dx.js\");\r\nconst evaluate_dy_1 = __webpack_require__(/*! ./evaluate-dy */ \"./node_modules/flo-bezier3/node/src/evaluate-dy.js\");\r\nfunction tangent(ps, t) {\r\n    const evDx = evaluate_dx_1.evaluateDx(ps);\r\n    const evDy = evaluate_dy_1.evaluateDy(ps);\r\n    function f(t) {\r\n        let dx = evDx(t);\r\n        let dy = evDy(t);\r\n        let d = Math.sqrt(dx * dx + dy * dy);\r\n        return [dx / d, dy / d];\r\n    }\r\n    // Curry\r\n    return t === undefined ? f : f(t);\r\n}\r\nexports.tangent = tangent;\r\n//# sourceMappingURL=tangent.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/tangent.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/to-hybrid-quadratic.js":
/*!******************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/to-hybrid-quadratic.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the hybrid quadratic version of the given cubic bezier. For a\r\n * definition of hybrid quadratic bezier curves see <a href=\"http://scholarsarchive.byu.edu/cgi/viewcontent.cgi?article=2206&context=etd\">\r\n * this paper</a>.\r\n * @param ps - A cubic bezier curve.\r\n * @returns An array of three quadratic bezier points where the\r\n * middle point is a 'hybrid' point represented as a line (itself represented\r\n * by two points (a linear bezier curve)) which can be evaluated at a different\r\n * t value (call it th). If evaluated at the same t value the result is the same\r\n * as evaluating the original cubic bezier at t. The set generated by evaluating\r\n * the hybrid quadratic curve for all (t,th) value pairs forms a geometric area\r\n * bound around the orginal cubic bezier curve. The length of the linear bezier\r\n * curve mentioned above is a measure of how closely the cubic can be\r\n * represented as a quadratic bezier curve.\r\n */\r\nfunction toHybridQuadratic(ps) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    return [\r\n        [x0, y0],\r\n        [[(3 * x1 - x0) / 2, (3 * y1 - y0) / 2],\r\n            [(3 * x2 - x3) / 2, (3 * y2 - y3) / 2]],\r\n        [x3, y3] // evaluated at t\r\n    ];\r\n}\r\nexports.toHybridQuadratic = toHybridQuadratic;\r\n//# sourceMappingURL=to-hybrid-quadratic.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/to-hybrid-quadratic.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/ts-at-x.js":
/*!******************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/ts-at-x.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst get_x_1 = __webpack_require__(/*! ./get-x */ \"./node_modules/flo-bezier3/node/src/get-x.js\");\r\n/**\r\n * Returns the bezier t values of the intersection between the given cubic\r\n * bezier and the given vertical line.\r\n * @param ps - The bezier curve\r\n * @param y - The y value of the horizontal line\r\n */\r\nfunction tsAtX(ps, x) {\r\n    // Translate ps so that x = 0.\r\n    ps = ps.map(p => [p[0] - x, p[1]]);\r\n    // Find the intersection t values\r\n    return flo_poly_1.default.allRoots(get_x_1.getX(ps), 0, 1);\r\n}\r\nexports.tsAtX = tsAtX;\r\n//# sourceMappingURL=ts-at-x.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/ts-at-x.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/src/ts-at-y.js":
/*!******************************************************!*\
  !*** ./node_modules/flo-bezier3/node/src/ts-at-y.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst get_y_1 = __webpack_require__(/*! ./get-y */ \"./node_modules/flo-bezier3/node/src/get-y.js\");\r\n/**\r\n * Returns the bezier t values of the intersection between the given cubic\r\n * bezier and the given horizontal line.\r\n * @param ps - The bezier curve\r\n * @param y - The y value of the horizontal line\r\n */\r\nfunction tsAtY(ps, y) {\r\n    // Translate ps so that y = 0.\r\n    ps = ps.map(p => [p[0], p[1] - y]);\r\n    // Find the intersection t values\r\n    return flo_poly_1.default.allRoots(get_y_1.getY(ps), 0, 1);\r\n}\r\nexports.tsAtY = tsAtY;\r\n//# sourceMappingURL=ts-at-y.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/src/ts-at-y.js?");

/***/ }),

/***/ "./node_modules/flo-gauss-quadrature/node/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-gauss-quadrature/node/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// TODO A future improvement can be to use the Gauss–Kronrod rules\n// to estimate the error and thus choose a number of constants based\n// on the error.\n// TODO In future, the constants can be calculated and cached so we can\n// chooce any value for the order.\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Integrates the given function using the Gaussian Quadrature method.\n * See https://en.wikipedia.org/wiki/Gaussian_quadrature\n * See http://pomax.github.io/bezierinfo/#arclength\n * @param f - The univariate function to be integrated\n * @param interval - The integration interval\n * @param order - Can be 2, 4, 8, or 16. Higher values give\n * more accurate results but is slower - defaults to 16.\n */\nfunction gaussQuadrature(f, interval, order = 16) {\n    if (interval[0] === interval[1]) {\n        return 0;\n    }\n    let { weights, abscissas } = GAUSS_CONSTANTS[order];\n    let [a, b] = interval;\n    let result = 0;\n    let m1 = (b - a) / 2;\n    let m2 = (b + a) / 2;\n    for (let i = 0; i <= order - 1; i++) {\n        result += weights[i] * f(m1 * abscissas[i] + m2);\n    }\n    return m1 * result;\n}\n// The Gaussian Legendre Quadrature method constants. \nconst GAUSS_CONSTANTS = {\n    2: {\n        weights: [1, 1],\n        abscissas: [-0.5773502691896257, 0.5773502691896257]\n    },\n    4: {\n        weights: [0.6521451548625461, 0.6521451548625461,\n            0.3478548451374538, 0.3478548451374538],\n        abscissas: [-0.3399810435848563, 0.3399810435848563,\n            -0.8611363115940526, 0.8611363115940526]\n    },\n    8: {\n        weights: [0.3626837833783620, 0.3626837833783620,\n            0.3137066458778873, 0.3137066458778873,\n            0.2223810344533745, 0.2223810344533745,\n            0.1012285362903763, 0.1012285362903763],\n        abscissas: [-0.1834346424956498, 0.1834346424956498,\n            -0.5255324099163290, 0.5255324099163290,\n            -0.7966664774136267, 0.7966664774136267,\n            -0.9602898564975363, 0.9602898564975363]\n    },\n    // Taken from http://keisan.casio.com/exec/system/1330940731\n    16: {\n        abscissas: [-0.989400934991649932596,\n            -0.944575023073232576078,\n            -0.86563120238783174388,\n            -0.7554044083550030338951,\n            -0.6178762444026437484467,\n            -0.4580167776572273863424,\n            -0.28160355077925891323,\n            -0.0950125098376374401853,\n            0.0950125098376374401853,\n            0.28160355077925891323,\n            0.4580167776572273863424,\n            0.617876244402643748447,\n            0.755404408355003033895,\n            0.8656312023878317438805,\n            0.944575023073232576078,\n            0.989400934991649932596\n        ],\n        weights: [\n            0.0271524594117540948518,\n            0.062253523938647892863,\n            0.0951585116824927848099,\n            0.1246289712555338720525,\n            0.1495959888165767320815,\n            0.169156519395002538189,\n            0.182603415044923588867,\n            0.189450610455068496285,\n            0.1894506104550684962854,\n            0.182603415044923588867,\n            0.1691565193950025381893,\n            0.149595988816576732081,\n            0.124628971255533872053,\n            0.095158511682492784809,\n            0.062253523938647892863,\n            0.027152459411754094852\n        ]\n    }\n};\nexports.default = gaussQuadrature;\n\n\n//# sourceURL=webpack:///./node_modules/flo-gauss-quadrature/node/index.js?");

/***/ }),

/***/ "./node_modules/flo-graham-scan/node/index.js":
/*!****************************************************!*\
  !*** ./node_modules/flo-graham-scan/node/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Vector = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\nconst DELTA = 1e-10;\n/**\n * Performs a functional stable sort on the given array and\n * returns the newly sorted array.\n * @ignore\n */\nfunction stableSort(arr, f) {\n    let indxArray = [];\n    for (let i = 0; i < arr.length; i++) {\n        indxArray.push(i);\n    }\n    indxArray.sort(function (a, b) {\n        let res = f(arr[a], arr[b]);\n        if (res !== 0) {\n            return res;\n        }\n        return a - b;\n    });\n    let sorted = [];\n    for (let i = 0; i < arr.length; i++) {\n        sorted.push(arr[indxArray[i]]);\n    }\n    return sorted;\n}\n/**\n * In-place swap two elements in the given array.\n * @ignore\n */\nfunction swap(arr, a, b) {\n    if (a === b) {\n        return;\n    }\n    let temp = arr[a];\n    arr[a] = arr[b];\n    arr[b] = temp;\n}\n/**\n * @private\n */\nfunction getSmallestIndxYThenX(ps) {\n    let smallest = [\n        Number.POSITIVE_INFINITY,\n        Number.POSITIVE_INFINITY\n    ];\n    let smallestI;\n    for (let i = 0; i < ps.length; i++) {\n        let y = ps[i][1];\n        if ((y < smallest[1]) ||\n            (y === smallest[1] && ps[i][0] < smallest[0])) {\n            smallestI = i;\n            smallest = ps[i];\n        }\n    }\n    return smallestI;\n}\n/**\n * <p>\n * Finds the convex hull of the given set of 2d points using the\n * Graham Scan algorithm and returns the hull as an array of points.\n * </p>\n * <p>\n * See https://en.wikipedia.org/wiki/Graham_scan\n * </p>\n * @param ps_ - A set of points\n * @param includeAllBoundaryPoints - Set this to true to if all boundary points\n * should be returned, even redundant ones - defaults to false\n * @param delta - Tolerance at which three points are considered collinear -\n * defaults to 1e-10\n */\nfunction grahamScan(ps_, includeAllBoundaryPoints = false, delta = DELTA) {\n    includeAllBoundaryPoints = !!includeAllBoundaryPoints;\n    function fail(p1, p2, p3) {\n        let res = Vector.ccw(p1, p2, p3, delta);\n        if (includeAllBoundaryPoints) {\n            return res < 0;\n        }\n        return res <= 0;\n    }\n    let ps = ps_.slice();\n    let n = ps.length;\n    let idx = getSmallestIndxYThenX(ps);\n    let [p] = ps.splice(idx, 1);\n    ps = stableSort(ps, function (a, b) {\n        let res = Vector.cross(Vector.fromTo(p, b), Vector.fromTo(p, a));\n        res = Math.abs(res) < delta ? 0 : res;\n        if (res !== 0) {\n            return res;\n        }\n        res = a[1] - b[1];\n        res = Math.abs(res) < delta ? 0 : res;\n        if (res !== 0) {\n            return res;\n        }\n        return a[0] - b[0];\n    });\n    ps.unshift(p);\n    let m = 1;\n    for (let i = 2; i < n; i++) {\n        while (fail(ps[m - 1], ps[m], ps[i])) {\n            if (m > 1) {\n                m -= 1;\n                continue;\n            }\n            else if (i === n - 1) {\n                m -= 1;\n                break;\n            }\n            else {\n                i += 1;\n            }\n        }\n        m += 1;\n        swap(ps, m, i);\n    }\n    return ps.slice(0, m + 1);\n}\nexports.default = grahamScan;\n\n\n//# sourceURL=webpack:///./node_modules/flo-graham-scan/node/index.js?");

/***/ }),

/***/ "./node_modules/flo-ll-rb-tree/node/index.js":
/*!***************************************************!*\
  !*** ./node_modules/flo-ll-rb-tree/node/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Concise, Destructive, Left Leaning Red Black Tree implementation.\n * See: https://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf\n * See: https://en.wikipedia.org/wiki/Left-leaning_red%E2%80%93black_tree\n * See: http://www.teachsolaisgames.com/articles/balanced_left_leaning.html\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tree_node_1 = __webpack_require__(/*! ./src/tree-node */ \"./node_modules/flo-ll-rb-tree/node/src/tree-node.js\");\nconst tree_node_color_1 = __webpack_require__(/*! ./src/tree-node-color */ \"./node_modules/flo-ll-rb-tree/node/src/tree-node-color.js\");\nconst tree_node_direction_1 = __webpack_require__(/*! ./src/tree-node-direction */ \"./node_modules/flo-ll-rb-tree/node/src/tree-node-direction.js\");\nfunction isRed(node) {\n    return node && node.color === tree_node_color_1.default.RED;\n}\n/**\n * @param compare\n * @param datas\n * @param replaceDups - If true then if a duplicate is\n * inserted (as per the equivalence relation induced by the compare)\n * then replace it. If false then keep an array of values at the relevant\n * node.\n */\nclass LlRbTree {\n    constructor(compare, datas, replaceDups) {\n        this.getMinNode = this.getMinOrMaxNode(tree_node_direction_1.default.LEFT);\n        this.getMaxNode = this.getMinOrMaxNode(tree_node_direction_1.default.RIGHT);\n        const tree = this;\n        tree.setComparator(compare, replaceDups);\n        tree.replaceDups = replaceDups;\n        tree.root = null;\n        if (!datas) {\n            return;\n        }\n        for (let data of datas) {\n            tree.insert(data);\n        }\n    }\n    /**\n     * Destructively sets the tree compare. This function can be used for for e.g.\n     * the Bentley Ottmann algorithm.\n     */\n    setComparator(compare, replaceDups) {\n        if (replaceDups) {\n            this.compare = compare;\n        }\n        else {\n            this.compare = (a, b) => compare(a, b[0]);\n        }\n    }\n    isEmpty() { return !this.root; }\n    /**\n     * Find the node in the tree with the given data using the tree compare\n     * function.\n     * @returns {Node} node or null if not found.\n     */\n    find(data) {\n        const tree = this;\n        let node = this.root;\n        while (node) {\n            let c = tree.compare(data, node.data);\n            if (c === 0) {\n                return node;\n            }\n            else {\n                node = node[c > 0 ? tree_node_direction_1.default.RIGHT : tree_node_direction_1.default.LEFT];\n            }\n        }\n        return null;\n    }\n    /**\n     * .\n     */\n    toArrayInOrder() {\n        let nodes = [];\n        f(this.root);\n        function f(node) {\n            if (!node) {\n                return;\n            }\n            f(node[tree_node_direction_1.default.LEFT]);\n            nodes.push(node);\n            f(node[tree_node_direction_1.default.RIGHT]);\n        }\n        return nodes;\n    }\n    /**\n     * Inserts a node with the given data into the tree.\n     */\n    insert(data) {\n        const tree = this;\n        tree.root = f(tree.root, data);\n        tree.root.color = tree_node_color_1.default.BLACK;\n        tree.root.parent = undefined;\n        function f(h, data) {\n            if (!h) {\n                return new tree_node_1.default(data, !tree.replaceDups);\n            }\n            let c = tree.compare(data, h.data);\n            if (c === 0) {\n                if (tree.replaceDups) {\n                    h.data = data;\n                }\n                else {\n                    h.data.push(data);\n                }\n            }\n            else {\n                let dir = c > 0 ? tree_node_direction_1.default.RIGHT : tree_node_direction_1.default.LEFT;\n                h[dir] = f(h[dir], data);\n                h[dir].parent = h;\n            }\n            if (isRed(h[tree_node_direction_1.default.RIGHT]) &&\n                !isRed(h[tree_node_direction_1.default.LEFT])) {\n                h = rotate(tree_node_direction_1.default.LEFT, h);\n            }\n            if (isRed(h[tree_node_direction_1.default.LEFT]) &&\n                isRed(h[tree_node_direction_1.default.LEFT][tree_node_direction_1.default.LEFT])) {\n                h = rotate(tree_node_direction_1.default.RIGHT, h);\n            }\n            if (isRed(h[tree_node_direction_1.default.LEFT]) &&\n                isRed(h[tree_node_direction_1.default.RIGHT])) {\n                flipColors(h);\n            }\n            return h;\n        }\n    }\n    /**\n     * Removes an item from the tree based on the given data.\n     * @param {LlRbTree} tree\n     * @param {*} data\n     * @param {boolean} all - If the data is an array, remove all.\n     */\n    remove(data, all) {\n        const tree = this;\n        tree.root = f(tree.root, data);\n        if (tree.root) {\n            tree.root.color = tree_node_color_1.default.BLACK;\n            tree.root.parent = undefined;\n        }\n        function f(h, data) {\n            //let h = h_;\n            let c = tree.compare(data, h.data);\n            if (!tree.replaceDups && c === 0 && !all && h.data.length > 1) {\n                removeFromArray(data, h.data);\n                return h;\n            }\n            if (c < 0 && !h[tree_node_direction_1.default.LEFT] || c > 0 && !h[tree_node_direction_1.default.RIGHT]) {\n                return h;\n            }\n            if (c < 0) {\n                if (!isRed(h[tree_node_direction_1.default.LEFT]) &&\n                    !isRed(h[tree_node_direction_1.default.LEFT][tree_node_direction_1.default.LEFT])) {\n                    h = moveRedLeft(h);\n                }\n                h[tree_node_direction_1.default.LEFT] = f(h[tree_node_direction_1.default.LEFT], data);\n                if (h[tree_node_direction_1.default.LEFT]) {\n                    h[tree_node_direction_1.default.LEFT].parent = h;\n                }\n                return fixUp(h);\n            }\n            if (isRed(h[tree_node_direction_1.default.LEFT])) {\n                h = rotate(tree_node_direction_1.default.RIGHT, h);\n                c = tree.compare(data, h.data);\n                if (!tree.replaceDups && c === 0 && !all && h.data.length > 1) {\n                    removeFromArray(data, h.data);\n                    return h;\n                }\n            }\n            if (c === 0 && !h[tree_node_direction_1.default.RIGHT]) {\n                return null;\n            }\n            if (!isRed(h[tree_node_direction_1.default.RIGHT]) &&\n                !isRed(h[tree_node_direction_1.default.RIGHT][tree_node_direction_1.default.LEFT])) {\n                h = moveRedRight(h);\n                c = tree.compare(data, h.data);\n                if (!tree.replaceDups && c === 0 && !all && h.data.length > 1) {\n                    removeFromArray(data, h.data);\n                    return h;\n                }\n            }\n            if (c === 0) {\n                h.data = tree.min(h[tree_node_direction_1.default.RIGHT]);\n                h[tree_node_direction_1.default.RIGHT] = removeMin(h[tree_node_direction_1.default.RIGHT]);\n            }\n            else {\n                h[tree_node_direction_1.default.RIGHT] = f(h[tree_node_direction_1.default.RIGHT], data);\n            }\n            if (h[tree_node_direction_1.default.RIGHT]) {\n                h[tree_node_direction_1.default.RIGHT].parent = h;\n            }\n            return fixUp(h);\n        }\n    }\n    /**\n     * Returns the two ordered nodes bounding the data. If the\n     * data falls on a node, that node and the next (to the right) is\n     * returned.\n     * @returns {Node[]}\n     */\n    findBounds(data) {\n        const tree = this;\n        let node = tree.root;\n        let bounds = [undefined, undefined];\n        if (node === null) {\n            return bounds;\n        }\n        while (node) {\n            const c = tree.compare(data, node.data);\n            if (c >= 0) {\n                bounds[0] = node;\n            }\n            else {\n                bounds[1] = node;\n            }\n            node = node[c >= 0 ? tree_node_direction_1.default.RIGHT : tree_node_direction_1.default.LEFT];\n        }\n        return bounds;\n    }\n    /**\n     * @param {LlRbTree} tree\n     * @param {*} data\n     * @returns {Node[]} The two ordered nodes bounding the data. If the\n     * data falls on a node, returns the nodes before and after this one.\n     */\n    findBoundsExcl(data) {\n        const tree = this;\n        let node = tree.root;\n        let bounds = [undefined, undefined];\n        if (node === null) {\n            return bounds;\n        }\n        f(node);\n        function f(node) {\n            while (node) {\n                let c = tree.compare(data, node.data);\n                if (c === 0) {\n                    // Search on both sides\n                    f(node[tree_node_direction_1.default.LEFT]);\n                    f(node[tree_node_direction_1.default.RIGHT]);\n                    return;\n                }\n                if (c > 0) {\n                    bounds[0] = node;\n                }\n                else if (c < 0) {\n                    bounds[1] = node;\n                }\n                node = node[c > 0 ? tree_node_direction_1.default.RIGHT : tree_node_direction_1.default.LEFT];\n            }\n        }\n        return bounds;\n    }\n    /**\n     *\n     */\n    findAllInOrder(data) {\n        const tree = this;\n        let nodes = [];\n        f(tree.root);\n        function f(node) {\n            while (node) {\n                let c = tree.compare(data, node.data);\n                if (c === 0) {\n                    f(node[tree_node_direction_1.default.LEFT]);\n                    nodes.push(node);\n                    f(node[tree_node_direction_1.default.RIGHT]);\n                    return;\n                }\n                node = node[c > 0 ? tree_node_direction_1.default.RIGHT : tree_node_direction_1.default.LEFT];\n            }\n        }\n        return nodes;\n    }\n    getMinOrMaxNode(dir) {\n        return function (node) {\n            if (!node) {\n                return undefined;\n            }\n            while (node[dir]) {\n                node = node[dir];\n            }\n            return node;\n        };\n    }\n    min(node) {\n        return this.getMinNode(node).data;\n    }\n    max(node) {\n        return this.getMaxNode(node).data;\n    }\n}\n/**\n * Removes the data from the tuple using ===.\n * Note this function uses === and not the compare function!\n */\nfunction removeFromArray(elem, arr) {\n    let index = arr.indexOf(elem);\n    if (index !== -1) {\n        arr.splice(index, 1);\n    }\n}\n/**\n * Destructively rotates the given node, say h, in the\n * given direction as far as tree rotations go.\n * @param {boolean} dir true -> right, false -> left\n * @param {Node} h\n * @returns The node that is at the top after the rotation.\n */\nfunction rotate(dir, h) {\n    const otherDir = dir ? tree_node_direction_1.default.LEFT : tree_node_direction_1.default.RIGHT;\n    const x = h[otherDir];\n    h[otherDir] = x[dir];\n    if (x[dir]) {\n        x[dir].parent = h;\n    }\n    x[dir] = h;\n    h.parent = x;\n    x.color = h.color;\n    h.color = tree_node_color_1.default.RED;\n    return x;\n}\nfunction removeMin(h) {\n    if (!h[tree_node_direction_1.default.LEFT]) {\n        return null;\n    }\n    if (!isRed(h[tree_node_direction_1.default.LEFT]) &&\n        !isRed(h[tree_node_direction_1.default.LEFT][tree_node_direction_1.default.LEFT])) {\n        h = moveRedLeft(h);\n    }\n    h[tree_node_direction_1.default.LEFT] = removeMin(h[tree_node_direction_1.default.LEFT]);\n    if (h[tree_node_direction_1.default.LEFT]) {\n        h[tree_node_direction_1.default.LEFT].parent = h;\n    }\n    return fixUp(h);\n}\nfunction flipColor(color) {\n    return color === tree_node_color_1.default.RED ? tree_node_color_1.default.BLACK : tree_node_color_1.default.RED;\n}\n/**\n * Destructively flips the color of the given node and both\n * it's childrens' colors.\n * @param {Node} h\n */\nfunction flipColors(h) {\n    h.color = flipColor(h.color);\n    h[tree_node_direction_1.default.LEFT].color = flipColor(h[tree_node_direction_1.default.LEFT].color);\n    h[tree_node_direction_1.default.RIGHT].color = flipColor(h[tree_node_direction_1.default.RIGHT].color);\n}\n/**\n * @description\n * @param h\n * @returns The node that is at the top after the move.\n */\nfunction moveRedLeft(h) {\n    flipColors(h);\n    if (isRed(h[tree_node_direction_1.default.RIGHT][tree_node_direction_1.default.LEFT])) {\n        let a = rotate(tree_node_direction_1.default.RIGHT, h[tree_node_direction_1.default.RIGHT]);\n        h[tree_node_direction_1.default.RIGHT] = a;\n        a.parent = h;\n        h = rotate(tree_node_direction_1.default.LEFT, h);\n        flipColors(h);\n    }\n    return h;\n}\n/**\n * @description\n * @param h\n * @returns The node that is at the top after the move.\n */\nfunction moveRedRight(h) {\n    flipColors(h);\n    if (isRed(h[tree_node_direction_1.default.LEFT][tree_node_direction_1.default.LEFT])) {\n        h = rotate(tree_node_direction_1.default.RIGHT, h);\n        flipColors(h);\n    }\n    return h;\n}\n/**\n * @description Fix right-leaning red nodes.\n * @returns The node that is at the top after the fix.\n */\nfunction fixUp(h) {\n    if (isRed(h[tree_node_direction_1.default.RIGHT])) {\n        h = rotate(tree_node_direction_1.default.LEFT, h);\n    }\n    if (isRed(h[tree_node_direction_1.default.LEFT]) &&\n        isRed(h[tree_node_direction_1.default.LEFT][tree_node_direction_1.default.LEFT])) {\n        h = rotate(tree_node_direction_1.default.RIGHT, h);\n    }\n    // Split 4-nodes.\n    if (isRed(h[tree_node_direction_1.default.LEFT]) &&\n        isRed(h[tree_node_direction_1.default.RIGHT])) {\n        flipColors(h);\n    }\n    return h;\n}\nexports.default = LlRbTree;\n\n\n//# sourceURL=webpack:///./node_modules/flo-ll-rb-tree/node/index.js?");

/***/ }),

/***/ "./node_modules/flo-ll-rb-tree/node/src/tree-node-color.js":
/*!*****************************************************************!*\
  !*** ./node_modules/flo-ll-rb-tree/node/src/tree-node-color.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar TreeNodeColor;\n(function (TreeNodeColor) {\n    TreeNodeColor[TreeNodeColor[\"BLACK\"] = 0] = \"BLACK\";\n    TreeNodeColor[TreeNodeColor[\"RED\"] = 1] = \"RED\";\n})(TreeNodeColor || (TreeNodeColor = {}));\nexports.default = TreeNodeColor;\n\n\n//# sourceURL=webpack:///./node_modules/flo-ll-rb-tree/node/src/tree-node-color.js?");

/***/ }),

/***/ "./node_modules/flo-ll-rb-tree/node/src/tree-node-direction.js":
/*!*********************************************************************!*\
  !*** ./node_modules/flo-ll-rb-tree/node/src/tree-node-direction.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar TreeNodeDirection;\n(function (TreeNodeDirection) {\n    TreeNodeDirection[TreeNodeDirection[\"LEFT\"] = 0] = \"LEFT\";\n    TreeNodeDirection[TreeNodeDirection[\"RIGHT\"] = 1] = \"RIGHT\";\n})(TreeNodeDirection || (TreeNodeDirection = {}));\nexports.default = TreeNodeDirection;\n\n\n//# sourceURL=webpack:///./node_modules/flo-ll-rb-tree/node/src/tree-node-direction.js?");

/***/ }),

/***/ "./node_modules/flo-ll-rb-tree/node/src/tree-node.js":
/*!***********************************************************!*\
  !*** ./node_modules/flo-ll-rb-tree/node/src/tree-node.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tree_node_color_1 = __webpack_require__(/*! ./tree-node-color */ \"./node_modules/flo-ll-rb-tree/node/src/tree-node-color.js\");\n/**\n * Red Black Tree node.\n * @constructor\n * @param {*} data\n */\nclass TreeNode {\n    constructor(data, asArray) {\n        if (asArray) {\n            this.data = [data];\n        }\n        else {\n            this.data = data;\n        }\n        this.color = tree_node_color_1.default.RED;\n    }\n}\nexports.default = TreeNode;\n\n\n//# sourceURL=webpack:///./node_modules/flo-ll-rb-tree/node/src/tree-node.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/bezier-piece.js":
/*!***************************************************!*\
  !*** ./node_modules/flo-mat/node/bezier-piece.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Represents a part of a bezier within the shape boundary.\r\n */\r\nclass BezierPiece {\r\n    /**\r\n     * @param curve A bezier curve within the shape boundary.\r\n     * @param ts The start and end t parameter values of the bezier curve.\r\n     */\r\n    constructor(curve, ts) {\r\n        this.curve = curve;\r\n        this.ts = ts;\r\n    }\r\n}\r\nexports.BezierPiece = BezierPiece;\r\n//# sourceMappingURL=bezier-piece.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/bezier-piece.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/bounding-box/find-bb-intersections.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-mat/node/bounding-box/find-bb-intersections.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst EVENT_LEFT = 0;\r\nconst EVENT_RIGHT = 1;\r\n/**\r\n * Find and return axis-aligned open boxes that intersect via a sweepline\r\n * algorithm.\r\n */\r\nfunction findBbIntersections(boxes) {\r\n    // Initialize event queue to equal all box x-axis endpoints.\r\n    let events = [];\r\n    for (let i = 0; i < boxes.length; i++) {\r\n        let box = boxes[i];\r\n        let smallerSide = box[0][0] < box[1][0] ? 0 : 1;\r\n        let largerSide = smallerSide === 0 ? 1 : 0;\r\n        events.push(new Event_(0, box, box[smallerSide]));\r\n        events.push(new Event_(1, box, box[largerSide]));\r\n    }\r\n    events.sort(Event_.compare);\r\n    let activeBoxes = new Set();\r\n    let intersections = [];\r\n    for (let i = 0; i < events.length; i++) {\r\n        let event = events[i];\r\n        let box = event.box;\r\n        if (event.type === EVENT_LEFT) {\r\n            for (let activeBox of activeBoxes.values()) {\r\n                if (areBoxesIntersecting(box, activeBox)) {\r\n                    intersections.push({\r\n                        box1: box, box2: activeBox\r\n                    });\r\n                }\r\n            }\r\n            activeBoxes.add(box);\r\n        }\r\n        else if (event.type === EVENT_RIGHT) {\r\n            activeBoxes.delete(event.box);\r\n        }\r\n    }\r\n    return intersections;\r\n}\r\nexports.findBbIntersections = findBbIntersections;\r\nclass Event_ {\r\n    /**\r\n     * Event class constructor\r\n     * @param type - 0 -> left side, 1 -> right side\r\n     * @param box - An axis-aligned 2-box described by 2 points\r\n     * @param p - A point.\r\n     */\r\n    constructor(type, box, p) {\r\n        this.type = type;\r\n        this.box = box;\r\n        this.p = p;\r\n    }\r\n    /**\r\n     * Compare two Events by their x-axis and then by their type. Since it is\r\n     * open boxes that are compare we must let the right endpoint type come\r\n     * before the left.\r\n     * @param a A point (within an object)\r\n     * @param b A point (within an object)\r\n     */\r\n    static compare(a, b) {\r\n        let res = a.p[0] - b.p[0];\r\n        if (res !== 0) {\r\n            return res;\r\n        }\r\n        if (a.box === b.box) {\r\n            return a.type === EVENT_RIGHT ? -1 : +1;\r\n        }\r\n        return a.type === EVENT_LEFT ? +1 : -1;\r\n    }\r\n}\r\n/**\r\n * Returns true if the 2 given (open) boxes intersect. At this stage we already\r\n * know their x-axis intersect.\r\n */\r\nfunction areBoxesIntersecting(a, b) {\r\n    let [[, a0], [, a1]] = a;\r\n    let [[, b0], [, b1]] = b;\r\n    if (a0 > a1) {\r\n        [a0, a1] = [a1, a0];\r\n    }\r\n    ;\r\n    if (b0 > b1) {\r\n        [b0, b1] = [b1, b0];\r\n    }\r\n    ;\r\n    if (a0 === b0) {\r\n        if (a0 === a1 || b0 === b1) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    if (a0 < b0) {\r\n        if (a1 <= b0) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    if (a0 > b0) {\r\n        if (b1 <= a0) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n//# sourceMappingURL=find-bb-intersections.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/bounding-box/find-bb-intersections.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/circle.js":
/*!*********************************************!*\
  !*** ./node_modules/flo-mat/node/circle.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\n/**\r\n * Canonical circle representation.\r\n */\r\nclass Circle {\r\n    /**\r\n     * @param center The center.\r\n     * @param radius The radius.\r\n     */\r\n    constructor(center, radius) {\r\n        this.center = center;\r\n        this.radius = radius;\r\n    }\r\n    /**\r\n     * Returns a scaled version of the given circle without changing its center.\r\n     * @param circle\r\n     * @param s multiplier\r\n     */\r\n    static scale(circle, s) {\r\n        return new Circle(circle.center, circle.radius * s);\r\n    }\r\n    /**\r\n     * Returns true if the first circle engulfs the second.\r\n     * @param c1\r\n     * @param c2\r\n     */\r\n    static engulfsCircle(c1, c2) {\r\n        if (c1.radius <= c2.radius) {\r\n            return false;\r\n        }\r\n        let d = flo_vector2d_1.squaredDistanceBetween(c1.center, c2.center);\r\n        let dr = c1.radius - c2.radius;\r\n        let δ = dr * dr;\r\n        return δ > d;\r\n    }\r\n    /**\r\n     * Returns a human-readable string description of the given circle.\r\n     * @param circle\r\n     */\r\n    static toString(circle) {\r\n        return 'c: ' + circle.center + ' r: ' + circle.radius;\r\n    }\r\n}\r\nexports.Circle = Circle;\r\n//# sourceMappingURL=circle.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/circle.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/contact-point.js":
/*!****************************************************!*\
  !*** ./node_modules/flo-mat/node/contact-point.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst point_on_shape_1 = __webpack_require__(/*! ./point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\n/**\r\n * Represents a point on the shape boundary for which MAT data has been\r\n * calculated.\r\n */\r\nclass ContactPoint {\r\n    /**\r\n     * @param pointOnShape Identifies the point on the shape boundary.\r\n     * @param circle The maximal disk circle touching this point.\r\n     * @param order Internally used to order two points lying at the same planar\r\n     * point.\r\n     * @param order2\r\n     * Internally used to order two points lying at the same planar\r\n     * point.\r\n     */\r\n    constructor(pointOnShape, circle, order, order2) {\r\n        this.pointOnShape = pointOnShape;\r\n        this.circle = circle;\r\n        this.order = order;\r\n        this.order2 = order2;\r\n    }\r\n    /**\r\n     * Primarily for internal use.\r\n     *\r\n     * Compares the two contact points according to their order along the shape\r\n     * boundary. Returns > 0 if a > b, < 0 if a < b or 0 if a === b.\r\n     * @param a The first contact point.\r\n     * @param b The second contact point.\r\n     */\r\n    static compare(a, b) {\r\n        let res = point_on_shape_1.PointOnShape.compare(a.pointOnShape, b.pointOnShape);\r\n        if (res === undefined) {\r\n            return undefined;\r\n        }\r\n        if (res !== 0) {\r\n            return res;\r\n        }\r\n        res = a.order - b.order;\r\n        if (res !== 0) {\r\n            return res;\r\n        }\r\n        return a.order2 - b.order2;\r\n    }\r\n}\r\nexports.ContactPoint = ContactPoint;\r\n//# sourceMappingURL=contact-point.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/contact-point.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/corner.js":
/*!*********************************************!*\
  !*** ./node_modules/flo-mat/node/corner.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Represents a corner on the shape boundary, i.e. a point where two bezier\r\n * curves meet. This class is typically used internally only.\r\n */\r\nclass Corner {\r\n    /**\r\n     * @param tangents The unit tangents at the points t === 1 of the\r\n     * first curve and at t === 0 of the second respectively.\r\n     * @param crossTangents The cross of the unit tangents.\r\n     * @param isSharp True if the corner is sharp, i.e. > 0 radians as one goes\r\n     * in a positive direction around the shape boundary.\r\n     * @param isDull True if the corner is dull, i.e. < 0 radians as one goes\r\n     * in a positive direction around the shape boundary.\r\n     * @param isQuiteSharp True if the corner is quite sharp, i.e. > δ radians\r\n     * as one goes in a positive direction around the shape boundary where δ is\r\n     * some pre-determined parameter.\r\n     * @param isQuiteDull True if the corner is quite dull, i.e. < δ radians\r\n     * as one goes in a positive direction around the shape boundary where δ is\r\n     * some pre-determined parameter.\r\n     */\r\n    constructor(tangents, crossTangents, isSharp, isDull, isQuiteSharp, isQuiteDull) {\r\n        this.tangents = tangents;\r\n        this.crossTangents = crossTangents;\r\n        this.isSharp = isSharp;\r\n        this.isDull = isDull;\r\n        this.isQuiteSharp = isQuiteSharp;\r\n        this.isQuiteDull = isQuiteDull;\r\n    }\r\n}\r\nexports.Corner = Corner;\r\n//# sourceMappingURL=corner.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/corner.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/cp-node.js":
/*!**********************************************!*\
  !*** ./node_modules/flo-mat/node/cp-node.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst contact_point_1 = __webpack_require__(/*! ./contact-point */ \"./node_modules/flo-mat/node/contact-point.js\");\r\nconst cp_node_for_debugging_1 = __webpack_require__(/*! ./debug/cp-node-for-debugging */ \"./node_modules/flo-mat/node/debug/cp-node-for-debugging.js\");\r\n/** @private */\r\nconst EDGES = ['prev', 'next', 'prevOnCircle', 'nextOnCircle'];\r\n/**\r\n * The primary class of the library.\r\n *\r\n * Since the MAT is a full representation of the shape boundary an instance of\r\n * this class contains both the information of a boundary point and a medial\r\n * axis point (and edge to the next point(s)). It also contains edges to other\r\n * [[CpNode]]s which allows for traversal of the MAT and thus implictly\r\n * represents the entire MAT.\r\n *\r\n * To get the maximal disk circle (of which the center is on the medial axis)\r\n * use [[cp]].circle.\r\n *\r\n * To get the boundary point, use [[cp]].pointOnShape.\r\n *\r\n * The edge, [[next]] (resp. [[prev]]) allows one to move anti-clockwise (resp.\r\n * clockwise) on the shape boundary to the next [[CpNode]]. This also imposes a\r\n * direction of traversal of the MAT edges and vertices.\r\n *\r\n * The edge [[nextOnCircle]] (resp. [[prevOnCircle]]) allows one to go\r\n * anti-clockwise (resp. clockwise) around the maximal disks implied by\r\n * the CpNode to the next maximal disk contact point. This is equivalent to\r\n * following other branches on the MAT.\r\n *\r\n * Each [[CpNode]] has a property, [[matCurveToNextVertex]], which is a bezier\r\n * curve from the maximal disk of this [[CpNode]] to the next [[CpNode]]'s\r\n * maximal disk and thus directly represents a piece of the medial axis.\r\n *\r\n * The getter, [[children]], returns the children of this [[CpNode]] when\r\n * seen as a MAT edge. Only children in a 'forward' direction are returned. These\r\n * include all edges except the 'backward' edge given by [[prevOnCircle]]. For\r\n * [[CpNode]]s having a maximal disk with 2 contact points (a 2-prong, the usual\r\n * case) the children will be the single edge [[next]]. For a 3-prong this will\r\n * be the edgese [[next]] and [[nextOnCircle]], etc. [[children]] allows one to\r\n * easily traverse the MAT tree - see e.g. the implementation of\r\n * [[traverseEdges]].\r\n *\r\n * [[vertexChildren]] is similar to [[children]] but returns the child nodes of\r\n * the tree when [[CpNode]] is seen as a MAT vertex point (as opposed to edge).\r\n * In this way the dual graph of the tree can easily be traversed - see e.g.\r\n * [[traverseVertices]]. Generally, however, traversing the edges is preferred\r\n * as it returns the entire Medial Axis (by utilizing [[matCurveToNextVertex]]\r\n * on each returned edge).\r\n *\r\n * It may be worth mentioning that by traversing from the CpNode by following\r\n * [[next]] repeatedly until one is back at the same CpNode allows one\r\n * to 'go around' the shape and at the same time traverse the MAT twice in\r\n * different directions.\r\n */\r\nclass CpNode {\r\n    /**\r\n     * Primarily for internal use.\r\n     * @param cp The shape boundary contact point, i.e. a [[CpNode]] without its\r\n     * edges.\r\n     * @param prev The previous (going clockwise around the boundary) contact\r\n     * point ([[CpNode]]).\r\n     * @param next The next (going ant-clockwise around the boundary)\r\n     * contact ([[CpNode]]).\r\n     * @param prevOnCircle The previous [[CpNode]] (going clockwise around\r\n     * the inscribed circle defined by the maximal disk).\r\n     * @param nextOnCircle The next [[CpNode]] (going anti-clockwise around\r\n     * the inscribed circle defined by the maximal disk).\r\n     * @param matCurveToNextVertex The actual medial axis curve from this\r\n     * [[CpNode]]'s maximal disk circle to the next [[CpNode]]'s circle. It is a\r\n     * bezier curve of order 1, 2 or 3.\r\n     * @param isHoleClosing If true, this [[CpNode]] belongs to a hole-closing\r\n     * maximal disk.\r\n     */\r\n    constructor(cp, isHoleClosing, isIntersection, prev = undefined, next = undefined, prevOnCircle = undefined, nextOnCircle = undefined, matCurveToNextVertex = undefined) {\r\n        this.cp = cp;\r\n        this.isHoleClosing = isHoleClosing;\r\n        this.isIntersection = isIntersection;\r\n        this.prev = prev;\r\n        this.next = next;\r\n        this.prevOnCircle = prevOnCircle;\r\n        this.nextOnCircle = nextOnCircle;\r\n        this.matCurveToNextVertex = matCurveToNextVertex;\r\n    }\r\n    /**\r\n     * Returns the children of this [[CpNode]] when seen as a MAT edge. Only\r\n     * children in a 'forward' direction are returned. These include all edges\r\n     * except the 'backward' edge given by [[prevOnCircle]].\r\n     */\r\n    get children() {\r\n        let cp = this.next;\r\n        if (this.isTerminating()) {\r\n            return [];\r\n        }\r\n        let children = [cp];\r\n        let cp_ = cp;\r\n        while (cp_.nextOnCircle !== cp.prevOnCircle) {\r\n            cp_ = cp_.nextOnCircle;\r\n            children.push(cp_);\r\n        }\r\n        return children;\r\n    }\r\n    /**\r\n     * Similar to [[children]] but returns the child nodes of the tree when\r\n     * [[CpNode]] is seen as a MAT vertex point (as opposed to edge). In this\r\n     * way the dual graph of the tree can easily be traversed - see e.g.\r\n     * [[traverseVertices]]. Generally, however, traversing the edges is\r\n     * preferred as it returns the entire Medial Axis (by utilizing\r\n     * [[matCurveToNextVertex]] on each returned edge).\r\n     */\r\n    get vertexChildren() {\r\n        if (this.isTerminating()) {\r\n            return [];\r\n        }\r\n        let cp = this;\r\n        let children = [];\r\n        let cp_ = cp;\r\n        while (cp_ !== cp.prevOnCircle) {\r\n            if (!cp_.isTerminating()) {\r\n                children.push(cp_.next);\r\n            }\r\n            cp_ = cp_.nextOnCircle;\r\n        }\r\n        return children;\r\n    }\r\n    /**\r\n     * Returns all [[CpNode]]s on the MAT that this [[CpNode]] is part of\r\n     * starting from the current one and going anti-clockwise around the shape.\r\n     */\r\n    getAllOnLoop() {\r\n        let cpStart = this;\r\n        let cps = [cpStart];\r\n        let cp = this.next;\r\n        while (cp !== cpStart) {\r\n            cps.push(cp);\r\n            cp = cp.next;\r\n        }\r\n        return cps;\r\n    }\r\n    /**\r\n     * Returns a deep clone of this [[CpNode]]. Can be used to copy the MAT\r\n     * since cloning a single [[CpNode]] necessarily implies cloning all\r\n     * [[CpNode]]s on the same MAT tree.\r\n     */\r\n    clone() {\r\n        // Don't change this function to be recursive, the call stack may \r\n        // overflow if there are too many CpNodes.\r\n        let nodeMap = new Map();\r\n        let cpNode = this;\r\n        let newCpNode = new CpNode(cpNode.cp, cpNode.isHoleClosing, cpNode.isIntersection);\r\n        newCpNode.matCurveToNextVertex = cpNode.matCurveToNextVertex;\r\n        nodeMap.set(cpNode, newCpNode);\r\n        let cpStack = [{ cpNode, newCpNode }];\r\n        while (cpStack.length) {\r\n            let { cpNode, newCpNode } = cpStack.pop();\r\n            for (let edge of EDGES) {\r\n                let node = cpNode[edge];\r\n                let newNode = nodeMap.get(node);\r\n                if (!newNode) {\r\n                    newNode = new CpNode(node.cp, node.isHoleClosing, node.isIntersection);\r\n                    newNode.matCurveToNextVertex = node.matCurveToNextVertex;\r\n                    nodeMap.set(node, newNode);\r\n                    cpStack.push({ cpNode: node, newCpNode: newNode });\r\n                }\r\n                newCpNode[edge] = newNode;\r\n            }\r\n        }\r\n        return newCpNode;\r\n    }\r\n    /**\r\n     * Primarily for internal use.\r\n     *\r\n     * Insert a [[CpNode]] into the MAT tree graph after the specified point\r\n     * and returns the freshly inserted [[CpNode]].\r\n     * @param isHoleClosing True if this is a hole closing contact point.\r\n     * @param isIntersection True if this is a contact point at a shape boundary\r\n     * intersection point.\r\n     * @param cpTree The tree graph holding the [[CpNodes]] of the MAT.\r\n     * @param cp - [[ContactPoint]] defining the [[CpNode]].\r\n     * @param prev_ - Inserts the new [[CpNode]] right after this item if the\r\n     * loop is not empty, else insert the new [[CpNode]] as the only item in the\r\n     * loop.\r\n     */\r\n    static insert(isHoleClosing, isIntersection, cpTree, cp, prev_) {\r\n        let cpNode = new CpNode(cp, isHoleClosing, isIntersection);\r\n        if (typeof _debug_ !== 'undefined') {\r\n            _debug_.generated.elems.cpNode.push(new cp_node_for_debugging_1.CpNodeForDebugging(_debug_.generated, cpNode));\r\n        }\r\n        let prev;\r\n        let next;\r\n        if (!prev_) {\r\n            prev = cpNode;\r\n            next = cpNode;\r\n        }\r\n        else {\r\n            prev = prev_;\r\n            next = prev.next;\r\n        }\r\n        next.prev = cpNode;\r\n        prev.next = cpNode;\r\n        cpNode.prev = prev;\r\n        cpNode.next = next;\r\n        cpTree.insert(cpNode);\r\n        return cpNode;\r\n    }\r\n    /**\r\n     * Primarily for internal use.\r\n     *\r\n     * @param cpTree The tree graph holding the [[CpNodes]] of the MAT.\r\n     * @param cpNode The [[CpNode]] to remove.\r\n     */\r\n    remove(cpTree, cpNode) {\r\n        let prev = cpNode.prev;\r\n        let next = cpNode.next;\r\n        prev.next = next;\r\n        next.prev = prev;\r\n        cpTree.remove(cpNode, false);\r\n    }\r\n    /**\r\n     * Return this (except if exclThis is truthy) and the the other CpNodes\r\n     * around the maximal disk vertex circle in an anti-clockwise order.\r\n     * @param exclThis If true the returned array does not include this\r\n     * [[CpNode]].\r\n     */\r\n    getCpNodesOnCircle(exclThis = false) {\r\n        let startCp = this;\r\n        let cp = startCp;\r\n        let cps = [];\r\n        do {\r\n            if (exclThis) {\r\n                exclThis = false;\r\n            }\r\n            else {\r\n                cps.push(cp);\r\n            }\r\n            cp = cp.nextOnCircle;\r\n        } while (cp !== startCp);\r\n        return cps;\r\n    }\r\n    /**\r\n     * Returns true if the 2 given [[CpNode]]s are on the same maximal disk\r\n     * circle.\r\n     * @param cpNode1 A [[CpNode]].\r\n     * @param cpNode2 Another [[CpNode]]\r\n     */\r\n    static isOnSameCircle(cpNode1, cpNode2) {\r\n        let cpNodes = cpNode1.getCpNodesOnCircle(true);\r\n        return cpNodes.indexOf(cpNode2) >= 0;\r\n    }\r\n    /**\r\n     * Returns true if this [[CpNode]] is terminating, i.e. implies a leaf MAT\r\n     * vertex.\r\n     *\r\n     * This is always the case for sharp corners and maximal disks with\r\n     * a single contact point. Note, however, that even in these cases there are\r\n     * two contact points stored (sitting 'on top' of each other) for the\r\n     * maximal disk. It can be seen as a limiting case of a two-prong where the\r\n     * distance between two of the contact points tend to zero. One point\r\n     * (represented by a [[CpNode]] of course) will be terminating with the\r\n     * other point being its [[next]], whereas the other point will *not* be\r\n     * terminating and 'points' back into the shape.\r\n     */\r\n    isTerminating() {\r\n        return this === this.next.prevOnCircle;\r\n    }\r\n    /**\r\n     * Returns true if this [[CpNode]] represents a sharp corner, i.e. the\r\n     * limiting case of a two-prong having zero radius.\r\n     *\r\n     * Note that two [[CpNode]]s are stored for each sharp corner, one being\r\n     * terminating and one not. See [[isTerminating]] for more details.\r\n     */\r\n    isSharp() {\r\n        return this.cp.circle.radius === 0;\r\n    }\r\n    /**\r\n     * Returns true if this [[CpNode]]'s maximal disk has only one contact point\r\n     * on the shape boundary (up to planar coordinates). These includes sharp\r\n     * corners.\r\n     *\r\n     * Note, however, that two [[CpNode]]s are stored for each such point to\r\n     * preserve symmetry - see [[isTerminating]] for more details.\r\n     */\r\n    isOneProng() {\r\n        let cp1 = this;\r\n        if (cp1.cp.circle.radius === 0) {\r\n            return true;\r\n        }\r\n        let cp2 = cp1.nextOnCircle;\r\n        let p1 = cp1.cp.pointOnShape.p;\r\n        let p2 = cp2.cp.pointOnShape.p;\r\n        return (p1[0] === p2[0] && p1[1] === p2[1]);\r\n    }\r\n    /**\r\n     * Returns the number of contact points on the maximal disk circle implied\r\n     * by this [[CpNode]].\r\n     *\r\n     * Note, however, that even one-prongs and sharp corners will return 2 (see\r\n     * [[isTerminating]] for more details); if this is not desired use\r\n     * [[getRealProngCount]] instead which will return 1 in these cases.\r\n     */\r\n    getProngCount() {\r\n        let startCp = this;\r\n        let cp = startCp;\r\n        let i = 0;\r\n        do {\r\n            i++;\r\n            cp = cp.nextOnCircle;\r\n        } while (cp !== startCp);\r\n        return i;\r\n    }\r\n    /**\r\n     * Returns the number of contact points (up to planar coordinates) on the\r\n     * maximal disk circle implied by this [[CpNode]].\r\n     *\r\n     * See also [[getProngCount]].\r\n     */\r\n    getRealProngCount() {\r\n        if (this.isOneProng()) {\r\n            return 1;\r\n        }\r\n        return this.getProngCount();\r\n    }\r\n}\r\n/**\r\n * Primarily for internal use.\r\n *\r\n * Compares the order of two [[CpNode]]s. The order is cyclic and depends\r\n * on a [[CpNode]]'s relative position along the shape boundary.\r\n */\r\nCpNode.comparator = (a, b) => contact_point_1.ContactPoint.compare(a.cp, b.cp);\r\nexports.CpNode = CpNode;\r\n//# sourceMappingURL=cp-node.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/cp-node.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/curve.js":
/*!********************************************!*\
  !*** ./node_modules/flo-mat/node/curve.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst corner_1 = __webpack_require__(/*! ./corner */ \"./node_modules/flo-mat/node/corner.js\");\r\n/**\r\n * Represents a bezier curve on the shape boundary / loop.\r\n */\r\nclass Curve {\r\n    /**\r\n     * Primarily for internal use.\r\n     * @param loop The closed loop of bezier curves representing the shape\r\n     * boundary this curve belongs to.\r\n     * @param ps The bezier control points.\r\n     * @param prev The previous curve (when going in a negative direction around\r\n     * the shape boundary, i.e. clockwise for the outer shape and anti-clockwise\r\n     * for the holes (if any)).\r\n     * @param next The next curve (when going in a positive direction around\r\n     * the shape boundary, i.e. anti-clockwise for the outer shape and clockwise\r\n     * for the holes (if any)).\r\n     * @param idx The curve's ordered index in the loop. This imposes a cycling\r\n     * ordering of the curves in the loop.\r\n     */\r\n    constructor(loop, ps, prev, next, idx) {\r\n        this.loop = loop;\r\n        this.ps = ps;\r\n        this.prev = prev;\r\n        this.next = next;\r\n        this.idx = idx;\r\n    }\r\n    /**\r\n     * Returns information about the corner created at the end of this curve\r\n     * (at t === 1) and the start of the next curve (at t === 0).\r\n     * @param curve The relevant [[Curve]].\r\n     */\r\n    static getCornerAtEnd(curve) {\r\n        return getCornerAtEnd(curve);\r\n    }\r\n}\r\nexports.Curve = Curve;\r\n/**\r\n * Angle in degrees to radians.\r\n * @private\r\n */\r\nconst DEGREES = {\r\n    //'0'    : 0.0000,\r\n    0.25: 0.0050,\r\n    1: 0.0167,\r\n    4: 0.0698,\r\n    16: 0.2756,\r\n};\r\n/** @private */\r\nconst DEGREE_LIMIT = DEGREES[1];\r\n/**\r\n * Returns information about the corner created at the end of this curve\r\n * (at t === 1) and the start of the next curve (at t === 0).\r\n * @private\r\n */\r\nlet getCornerAtEnd = flo_memoize_1.memoize(function (curve) {\r\n    let tangents = [\r\n        flo_bezier3_1.tangent(curve.ps, 1),\r\n        flo_bezier3_1.tangent(curve.next.ps, 0)\r\n    ];\r\n    let crossTangents = flo_vector2d_1.cross(tangents[0], tangents[1]);\r\n    return new corner_1.Corner(tangents, crossTangents, crossTangents < 0, crossTangents > 0, crossTangents < -DEGREE_LIMIT, crossTangents > +DEGREE_LIMIT);\r\n});\r\n//# sourceMappingURL=curve.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/curve.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/cp-node-for-debugging.js":
/*!******************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/cp-node-for-debugging.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Class used for debugging only.\r\n */\r\nclass CpNodeForDebugging {\r\n    constructor(generated, cpNode) {\r\n        this.generated = generated;\r\n        this.cpNode = cpNode;\r\n    }\r\n}\r\nexports.CpNodeForDebugging = CpNodeForDebugging;\r\n//# sourceMappingURL=cp-node-for-debugging.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/cp-node-for-debugging.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/debug.js":
/*!**************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/debug.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Vector = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst Bezier3 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst general_1 = __webpack_require__(/*! ./functions/general */ \"./node_modules/flo-mat/node/debug/functions/general.js\");\r\nconst two_prong_1 = __webpack_require__(/*! ./functions/two-prong */ \"./node_modules/flo-mat/node/debug/functions/two-prong.js\");\r\nconst three_prong_1 = __webpack_require__(/*! ./functions/three-prong */ \"./node_modules/flo-mat/node/debug/functions/three-prong.js\");\r\nconst draw_elem_1 = __webpack_require__(/*! ./functions/draw-elem/draw-elem */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/draw-elem.js\");\r\nclass Generated {\r\n    constructor(path, g) {\r\n        this.path = path;\r\n        this.g = g;\r\n        this.elems = {\r\n            twoProng_regular: [],\r\n            twoProng_failed: [],\r\n            twoProng_notAdded: [],\r\n            twoProng_deleted: [],\r\n            twoProng_holeClosing: [],\r\n            looseBoundingBox: [],\r\n            tightBoundingBox: [],\r\n            oneProng: [],\r\n            oneProngAtDullCorner: [],\r\n            sharpCorner: [],\r\n            dullCorner: [],\r\n            minY: [],\r\n            threeProng: [],\r\n            boundingHull: [],\r\n            mat: [],\r\n            sat: [],\r\n            cpNode: [],\r\n            loop: [],\r\n            loops: [],\r\n            maxVertex: [],\r\n            leaves: [],\r\n            culls: [],\r\n            intersection: [],\r\n        };\r\n        this.timing = {\r\n            simplify: [0, 0],\r\n            holeClosers: [0, 0],\r\n            oneAnd2Prongs: [0, 0],\r\n            threeProngs: [0, 0],\r\n            mats: [0, 0],\r\n            sats: [0, 0]\r\n        };\r\n    }\r\n}\r\nexports.Generated = Generated;\r\nclass MatDebug {\r\n    /**\r\n     * @param fs - some useful functions.\r\n     */\r\n    constructor(draw) {\r\n        /* The current path for which MATs are being found */\r\n        this.generated = undefined;\r\n        /* Generated by debug object for later inspection */\r\n        this.generatedAll = new Map();\r\n        // These are included only for quick debugging from console\r\n        this.Bezier3 = Bezier3;\r\n        this.Vector2d = Vector;\r\n        this.directives = {\r\n            stopAfterHoleClosers: false,\r\n            stopAfterHoleClosersNum: undefined,\r\n            stopAfterTwoProngs: false,\r\n            stopAfterTwoProngsNum: undefined,\r\n            stopAfterThreeProngs: false,\r\n        };\r\n        /**\r\n         * These functions are meant to be used in the console, e.g. in the\r\n         * console try typing d.fs.twoProng.traceConvergence(0);\r\n         */\r\n        this.fs = Object.assign({ draw }, general_1.generalDebugFunctions, { twoProng: two_prong_1.twoProngDebugFunctions, threeProng: three_prong_1.threeProngDebugFunctions, drawElem: draw_elem_1.drawElemFunctions });\r\n    }\r\n    createNewGenerated(bezierLoops, path, g) {\r\n        this.generated = new Generated(path, g);\r\n        this.generatedAll.set(bezierLoops, this.generated);\r\n    }\r\n}\r\nexports.MatDebug = MatDebug;\r\n//# sourceMappingURL=debug.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/debug.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/bounding-hull.js":
/*!******************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/bounding-hull.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction boundingHull(g, hull, style = 'thin5 black nofill') {\r\n    let $polygon = _debug_.fs.draw.polygon(g, hull, style);\r\n    return $polygon;\r\n}\r\nexports.boundingHull = boundingHull;\r\n//# sourceMappingURL=bounding-hull.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/bounding-hull.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/culls.js":
/*!**********************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/culls.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction culls(g, culls) {\r\n    let $elems = [];\r\n    for (let circle of culls) {\r\n        let p = circle.center;\r\n        $elems.push(drawCircle(g, p, 0.4, 'cyan thin5 nofill'));\r\n    }\r\n    return $elems;\r\n}\r\nexports.culls = culls;\r\nfunction drawCircle(g, center, radiusPercent, classes) {\r\n    const XMLNS = 'http://www.w3.org/2000/svg';\r\n    let $circle = document.createElementNS(XMLNS, 'circle');\r\n    $circle.setAttributeNS(null, \"cx\", center[0].toString());\r\n    $circle.setAttributeNS(null, \"cy\", center[1].toString());\r\n    $circle.setAttributeNS(null, \"r\", radiusPercent.toString() + '%');\r\n    $circle.setAttributeNS(null, \"class\", classes);\r\n    g.appendChild($circle);\r\n    return $circle;\r\n}\r\n//# sourceMappingURL=culls.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/culls.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/draw-circle-percent.js":
/*!************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/draw-circle-percent.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction drawCirclePercent(g, center, radiusPercent, classes) {\r\n    const XMLNS = 'http://www.w3.org/2000/svg';\r\n    let $circle = document.createElementNS(XMLNS, 'circle');\r\n    $circle.setAttributeNS(null, \"cx\", center[0].toString());\r\n    $circle.setAttributeNS(null, \"cy\", center[1].toString());\r\n    $circle.setAttributeNS(null, \"r\", radiusPercent.toString() + '%');\r\n    $circle.setAttributeNS(null, \"class\", classes);\r\n    g.appendChild($circle);\r\n    return $circle;\r\n}\r\nexports.drawCirclePercent = drawCirclePercent;\r\n//# sourceMappingURL=draw-circle-percent.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/draw-circle-percent.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/draw-elem.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/draw-elem.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst one_prong_1 = __webpack_require__(/*! ./one-prong */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/one-prong.js\");\r\nconst two_prong_1 = __webpack_require__(/*! ./two-prong */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/two-prong.js\");\r\nconst three_prong_1 = __webpack_require__(/*! ./three-prong */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/three-prong.js\");\r\nconst vertex_1 = __webpack_require__(/*! ./vertex */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/vertex.js\");\r\nconst min_y_1 = __webpack_require__(/*! ./min-y */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/min-y.js\");\r\nconst bounding_hull_1 = __webpack_require__(/*! ./bounding-hull */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/bounding-hull.js\");\r\nconst loose_bounding_box_1 = __webpack_require__(/*! ./loose-bounding-box */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/loose-bounding-box.js\");\r\nconst tight_bounding_box_1 = __webpack_require__(/*! ./tight-bounding-box */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/tight-bounding-box.js\");\r\nconst sharp_corner_1 = __webpack_require__(/*! ./sharp-corner */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/sharp-corner.js\");\r\nconst dull_corner_1 = __webpack_require__(/*! ./dull-corner */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/dull-corner.js\");\r\nconst mat_1 = __webpack_require__(/*! ./mat */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/mat.js\");\r\nconst loop_1 = __webpack_require__(/*! ./loop */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/loop.js\");\r\nconst loops_1 = __webpack_require__(/*! ./loops */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/loops.js\");\r\nconst max_vertex_1 = __webpack_require__(/*! ./max-vertex */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/max-vertex.js\");\r\nconst leaves_1 = __webpack_require__(/*! ./leaves */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/leaves.js\");\r\nconst culls_1 = __webpack_require__(/*! ./culls */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/culls.js\");\r\nconst intersection_1 = __webpack_require__(/*! ./intersection */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/intersection.js\");\r\nconst one_prong_at_dull_corner_1 = __webpack_require__(/*! ./one-prong-at-dull-corner */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/one-prong-at-dull-corner.js\");\r\nlet drawElemFunctions = {\r\n    oneProng: one_prong_1.oneProng,\r\n    oneProngAtDullCorner: one_prong_at_dull_corner_1.oneProngAtDullCorner,\r\n    twoProng_regular: two_prong_1.twoProng,\r\n    twoProng_failed: two_prong_1.twoProng,\r\n    twoProng_notAdded: two_prong_1.twoProng,\r\n    twoProng_deleted: two_prong_1.twoProng,\r\n    twoProng_holeClosing: two_prong_1.twoProng,\r\n    threeProng: three_prong_1.threeProng,\r\n    minY: min_y_1.minY,\r\n    boundingHull: bounding_hull_1.boundingHull,\r\n    looseBoundingBox: loose_bounding_box_1.looseBoundingBox,\r\n    tightBoundingBox: tight_bounding_box_1.tightBoundingBox,\r\n    sharpCorner: sharp_corner_1.sharpCorner,\r\n    dullCorner: dull_corner_1.dullCorner,\r\n    vertex: vertex_1.vertex,\r\n    mat: mat_1.mat('mat', true),\r\n    sat: mat_1.mat('sat', true),\r\n    loop: loop_1.loop,\r\n    loops: loops_1.loops,\r\n    maxVertex: max_vertex_1.maxVertex,\r\n    leaves: leaves_1.leaves,\r\n    culls: culls_1.culls,\r\n    intersection: intersection_1.intersection\r\n};\r\nexports.drawElemFunctions = drawElemFunctions;\r\n//# sourceMappingURL=draw-elem.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/draw-elem.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/dull-corner.js":
/*!****************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/dull-corner.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction dullCorner(g, pos) {\r\n    const scaleFactor = 0.1;\r\n    let $pos = _debug_.fs.draw.dot(g, pos.p, 0.5 * scaleFactor, 'orange');\r\n    return $pos;\r\n}\r\nexports.dullCorner = dullCorner;\r\n//# sourceMappingURL=dull-corner.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/dull-corner.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/intersection.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/intersection.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst draw_circle_percent_1 = __webpack_require__(/*! ./draw-circle-percent */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/draw-circle-percent.js\");\r\nfunction intersection(g, x) {\r\n    return [draw_circle_percent_1.drawCirclePercent(g, x.pos.p, 0.7, 'purple thin2 nofill')];\r\n}\r\nexports.intersection = intersection;\r\n//# sourceMappingURL=intersection.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/intersection.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/leaves.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/leaves.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst draw_circle_percent_1 = __webpack_require__(/*! ./draw-circle-percent */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/draw-circle-percent.js\");\r\nfunction leaves(g, leaves) {\r\n    let $elems = [];\r\n    for (let cpNode of leaves) {\r\n        let cp = cpNode.cp;\r\n        let p = cp.circle.center;\r\n        $elems.push(draw_circle_percent_1.drawCirclePercent(g, p, 0.5, 'pinker thin5 nofill'));\r\n    }\r\n    return $elems;\r\n}\r\nexports.leaves = leaves;\r\n//# sourceMappingURL=leaves.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/leaves.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/loop.js":
/*!*********************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/loop.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// TODO - finish\r\nfunction loop(g, loop) {\r\n    /*\r\n    for (let curve of loop.curves) {\r\n        _debug_.fs.draw.bezier(g, curve.ps, undefined, 1000);\r\n    }\r\n    */\r\n    return [];\r\n}\r\nexports.loop = loop;\r\n//# sourceMappingURL=loop.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/loop.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/loops.js":
/*!**********************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/loops.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// TODO - finish\r\nfunction loops(g, loops) {\r\n    return [];\r\n}\r\nexports.loops = loops;\r\n//# sourceMappingURL=loops.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/loops.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/loose-bounding-box.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/loose-bounding-box.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction looseBoundingBox(g, box) {\r\n    let $box = _debug_.fs.draw.rect(g, box, 'thin5 brown nofill');\r\n    return $box;\r\n}\r\nexports.looseBoundingBox = looseBoundingBox;\r\n//# sourceMappingURL=loose-bounding-box.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/loose-bounding-box.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/mat.js":
/*!********************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/mat.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst traverse_edges_1 = __webpack_require__(/*! ../../../traverse-edges */ \"./node_modules/flo-mat/node/traverse-edges.js\");\r\nfunction mat(type, smooth) {\r\n    let classes = type === 'mat'\r\n        ? 'thin5 purple nofill'\r\n        : 'thin10 red nofill';\r\n    return f;\r\n    function f(g, mat) {\r\n        let cpNode = mat.cpNode;\r\n        if (!cpNode) {\r\n            return undefined;\r\n        }\r\n        let draw = _debug_.fs.draw;\r\n        let $svgs = [];\r\n        //const DRAW_CLASS_LINE = 'thin20 blue1 nofill';\r\n        //const DRAW_CLASS_QUAD = 'thin20 blue2 nofill';\r\n        //const DRAW_CLASS_CUBE = 'thin20 blue3 nofill';\r\n        traverse_edges_1.traverseEdges(cpNode, function (cpNode) {\r\n            if (cpNode.isTerminating()) {\r\n                return;\r\n            }\r\n            if (!smooth) {\r\n                let p1 = cpNode.cp.circle.center;\r\n                let p2 = cpNode.next.cp.circle.center;\r\n                $svgs.push(...draw.line(g, [p1, p2], classes));\r\n                return;\r\n            }\r\n            let bezier = cpNode.matCurveToNextVertex;\r\n            if (!bezier) {\r\n                return;\r\n            }\r\n            let fs = [, , draw.line, draw.quadBezier, draw.bezier];\r\n            $svgs.push(...fs[bezier.length](g, bezier, classes));\r\n        });\r\n        return $svgs;\r\n    }\r\n}\r\nexports.mat = mat;\r\n//# sourceMappingURL=mat.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/mat.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/max-vertex.js":
/*!***************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/max-vertex.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction maxVertex(g, cpNode) {\r\n    let draw = _debug_.fs.draw;\r\n    let circle = cpNode.cp.circle;\r\n    let $elems = draw.circle(g, circle, 'brown thin10 nofill');\r\n    return $elems;\r\n}\r\nexports.maxVertex = maxVertex;\r\n//# sourceMappingURL=max-vertex.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/max-vertex.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/min-y.js":
/*!**********************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/min-y.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nfunction minY(g, pos) {\r\n    let p = flo_bezier3_1.evaluate(pos.curve.ps, pos.t);\r\n    let $elems = _debug_.fs.draw.crossHair(g, p, 'red thin10 nofill');\r\n    return $elems;\r\n}\r\nexports.minY = minY;\r\n//# sourceMappingURL=min-y.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/min-y.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/one-prong-at-dull-corner.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/one-prong-at-dull-corner.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nfunction oneProngAtDullCorner(g, pos) {\r\n    let oCircle = point_on_shape_1.PointOnShape.getOsculatingCircle(Number.POSITIVE_INFINITY, pos);\r\n    let $center = _debug_.fs.draw.dot(g, pos.p, 0.1, 'orange');\r\n    let $circle = _debug_.fs.draw.dot(g, oCircle.center, 0.25, 'orange');\r\n    let $pos = _debug_.fs.draw.circle(g, oCircle, 'orange thin10 nofill');\r\n    return [...$center, ...$circle, ...$pos];\r\n}\r\nexports.oneProngAtDullCorner = oneProngAtDullCorner;\r\n//# sourceMappingURL=one-prong-at-dull-corner.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/one-prong-at-dull-corner.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/one-prong.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/one-prong.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nconst circle_1 = __webpack_require__(/*! ../../../circle */ \"./node_modules/flo-mat/node/circle.js\");\r\nconst scaleFactor = 0.5;\r\nfunction oneProng(g, pos) {\r\n    let draw = _debug_.fs.draw;\r\n    let circle = circle_1.Circle.scale(point_on_shape_1.PointOnShape.getOsculatingCircle(Number.POSITIVE_INFINITY, pos), 1);\r\n    let $center = draw.dot(g, pos.p, 0.1 * scaleFactor, 'gray');\r\n    let $circle = draw.dot(g, circle.center, 0.25 * scaleFactor, 'gray');\r\n    let $pos = draw.circle(g, circle, 'gray thin10 nofill');\r\n    return [...$center, ...$circle, ...$pos];\r\n}\r\nexports.oneProng = oneProng;\r\n//# sourceMappingURL=one-prong.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/one-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/sharp-corner.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/sharp-corner.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction sharpCorner(g, pos) {\r\n    const scaleFactor = 0.1;\r\n    let $pos = _debug_.fs.draw.dot(g, pos.p, 0.6 * scaleFactor, 'green');\r\n    return $pos;\r\n}\r\nexports.sharpCorner = sharpCorner;\r\n//# sourceMappingURL=sharp-corner.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/sharp-corner.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/three-prong.js":
/*!****************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/three-prong.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst circle_1 = __webpack_require__(/*! ../../../circle */ \"./node_modules/flo-mat/node/circle.js\");\r\nconst scaleFactor = 0.3;\r\nfunction threeProng(g, threeProng) {\r\n    let draw = _debug_.fs.draw;\r\n    let circle = circle_1.Circle.scale(threeProng.circle, 1);\r\n    let poss = threeProng.poss;\r\n    let $cp1 = draw.dot(g, poss[0].p, 0.1 * 1 * scaleFactor, 'blue');\r\n    let $cp2 = draw.dot(g, poss[1].p, 0.1 * 2 * scaleFactor, 'blue');\r\n    let $cp3 = draw.dot(g, poss[2].p, 0.1 * 3 * scaleFactor, 'blue');\r\n    let $center = draw.dot(g, circle.center, 0.3 * scaleFactor, 'blue');\r\n    let $circle = draw.circle(g, circle, 'blue thin2 nofill');\r\n    return [...$center, ...$cp1, ...$cp2, ...$cp3, ...$circle];\r\n}\r\nexports.threeProng = threeProng;\r\n//# sourceMappingURL=three-prong.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/three-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/tight-bounding-box.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/tight-bounding-box.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction tightBoundingBox(g, box) {\r\n    let $box = _debug_.fs.draw.polygon(g, box, 'thin5 black nofill');\r\n    return $box;\r\n}\r\nexports.tightBoundingBox = tightBoundingBox;\r\n//# sourceMappingURL=tight-bounding-box.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/tight-bounding-box.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/two-prong.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/two-prong.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_two_prong_type_1 = __webpack_require__(/*! ../../../mat/get-two-prong-type */ \"./node_modules/flo-mat/node/mat/get-two-prong-type.js\");\r\nfunction twoProng(g, twoProng) {\r\n    //let scaleFactor = width/200;\t\t\r\n    let scaleFactor = 0.3;\r\n    let $failedDot = [];\r\n    let $center = [];\r\n    let $circle = [];\r\n    let $cp1 = [];\r\n    let $cp2 = [];\r\n    let color;\r\n    let thin;\r\n    let draw = _debug_.fs.draw;\r\n    switch (get_two_prong_type_1.getTwoProngType(twoProng)) {\r\n        case 'twoProng_regular': {\r\n            color = 'red ';\r\n            thin = '2';\r\n            break;\r\n        }\r\n        case 'twoProng_holeClosing': {\r\n            color = 'cyan ';\r\n            thin = '10';\r\n            break;\r\n        }\r\n    }\r\n    if (twoProng.failed) {\r\n        $failedDot = draw.dot(g, twoProng.pos.p, 1 * scaleFactor, 'black');\r\n    }\r\n    else if (!twoProng.failed) {\r\n        $center = draw.dot(g, twoProng.circle.center, 0.05 * scaleFactor, 'yellow');\r\n        $circle = draw.circle(g, twoProng.circle, color + 'thin' + thin + ' nofill');\r\n        $cp1 = draw.dot(g, twoProng.pos.p, 0.035 * scaleFactor, color);\r\n        $cp2 = draw.dot(g, twoProng.z, 0.07 * scaleFactor, color);\r\n    }\r\n    return [...$failedDot, ...$center, ...$circle, ...$cp1, ...$cp2];\r\n}\r\nexports.twoProng = twoProng;\r\n//# sourceMappingURL=two-prong.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/two-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/vertex.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/vertex.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction vertex(g, cpNode, visible = true, displayDelay) {\r\n    let visibleClass = visible ? '' : ' invisible';\r\n    let circle = cpNode.cp.circle;\r\n    let draw = _debug_.fs.draw;\r\n    const THIN = 'thin20';\r\n    let cps = cpNode.getCpNodesOnCircle();\r\n    console.log(cps);\r\n    let $svgs = [];\r\n    let $circle = draw.circle(g, circle, 'red ' + THIN + ' nofill ' + visibleClass, displayDelay);\r\n    let $crossHair = draw.crossHair(g, circle.center, 'red ' + THIN + ' nofill ' + visibleClass, 3, displayDelay);\r\n    $svgs = [...$circle, ...$crossHair];\r\n    for (let i = 0; i < cps.length; i++) {\r\n        let cp = cps[i];\r\n        let edgeCircle = cp.next.cp.circle;\r\n        let $circle = draw.circle(g, edgeCircle, 'pink ' + THIN + ' nofill ' + visibleClass, displayDelay);\r\n        let $crossHair = draw.crossHair(g, edgeCircle.center, 'pink ' + THIN + ' nofill ' + visibleClass, 3, displayDelay);\r\n        $svgs.push(...$circle, ...$crossHair);\r\n        let p1 = circle.center;\r\n        let p2 = edgeCircle.center;\r\n        let thin = i === 0 ? 'thin10' : (i === 1 ? 'thin20' : 'thin35');\r\n        let $line = draw.line(g, [p1, p2], 'yellow ' + thin + ' nofill ' + visibleClass, displayDelay);\r\n        $svgs.push(...$line);\r\n    }\r\n    return $svgs;\r\n}\r\nexports.vertex = vertex;\r\n//# sourceMappingURL=vertex.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/vertex.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/general.js":
/*!**************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/general.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nlet i = 0;\r\n/** Name the given object - for debugging purposes only */\r\nfunction nameObj(o, pre = '') {\r\n    o.name = '' + pre + i++;\r\n}\r\n/**\r\n * Transforms a boundary piece (δ) into a human readable string.\r\n * @param cpNodes A boundary piece given by two CpNodes.\r\n */\r\nfunction δToString(cpNodes) {\r\n    return cpNodes.map(cpNode => point_on_shape_1.PointOnShape.toHumanString(cpNode.cp.pointOnShape));\r\n}\r\n/**\r\n * Transforms an array of boundary pieces (δs) into a human readable string.\r\n * @param cpNodes An array of boundary pieces.\r\n */\r\nfunction δsToString(cpNodes) {\r\n    return cpNodes.map(δToString);\r\n}\r\n/**\r\n * Convert the given points into a human readable string.\r\n * @param ps\r\n */\r\nfunction pointsToStr(ps, decimalPlaces = 3) {\r\n    return ps.map(p => pointToStr(p, decimalPlaces));\r\n}\r\n/**\r\n * Converts the given point into a human readable string.\r\n * @param p - The point\r\n * @param decimalPlaces - number of decimal places\r\n */\r\nfunction pointToStr(p, decimalPlaces = 3) {\r\n    return p[0].toFixed(decimalPlaces) + ', ' + p[1].toFixed(decimalPlaces);\r\n}\r\nlet generalDebugFunctions = {\r\n    δToString,\r\n    δsToString,\r\n    pointToStr,\r\n    pointsToStr,\r\n    nameObj,\r\n};\r\nexports.generalDebugFunctions = generalDebugFunctions;\r\n//# sourceMappingURL=general.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/general.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/three-prong.js":
/*!******************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/three-prong.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst circle_1 = __webpack_require__(/*! ../../circle */ \"./node_modules/flo-mat/node/circle.js\");\r\n/**\r\n * Draws 3 lines from the given 3-prong center to its 3 contact points.\r\n * @param n - The 3-prong's zero-based index.\r\n */\r\nfunction drawSpokes(n) {\r\n    let threeProng = _debug_.generated.elems.threeProng[n];\r\n    let g = threeProng.generated.g;\r\n    let cc = threeProng.circle.center;\r\n    let poss = threeProng.poss;\r\n    _debug_.fs.draw.line(g, [poss[0].p, cc], 'thin5 red');\r\n    _debug_.fs.draw.line(g, [poss[1].p, cc], 'thin5 red');\r\n    _debug_.fs.draw.line(g, [poss[2].p, cc], 'thin5 red');\r\n}\r\n/**\r\n * Shows the circle for each boundary iteration.\r\n * @param n_ - The 3-prong's zero-based index. If ommitted, all will be shown.\r\n * @param idx - The specific boundary iteration index to view. If ommitted, all\r\n * will be shown.\r\n */\r\nfunction traceConvergence(n_, idx) {\r\n    let sIndx;\r\n    let eIndx;\r\n    if (n_ === undefined) {\r\n        sIndx = 0;\r\n        eIndx = _debug_.generated.elems.threeProng.length;\r\n    }\r\n    else {\r\n        sIndx = n_;\r\n        eIndx = n_ + 1;\r\n    }\r\n    for (let n = sIndx; n < eIndx; n++) {\r\n        let forDebugging = _debug_.generated.elems.threeProng[n];\r\n        let g = forDebugging.generated.g;\r\n        console.log(forDebugging);\r\n        let candidateThreeProngs = forDebugging.candidateThreeProngs;\r\n        //-----------------------------\r\n        //---- Get start and end index\r\n        //-----------------------------\r\n        let startIndx;\r\n        let endIndx;\r\n        if (n_ === undefined || idx === -1) {\r\n            startIndx = forDebugging.bestIndx;\r\n            endIndx = forDebugging.bestIndx + 1;\r\n        }\r\n        else {\r\n            if (idx === undefined) {\r\n                startIndx = 0;\r\n                endIndx = candidateThreeProngs.length;\r\n            }\r\n            else {\r\n                startIndx = idx;\r\n                endIndx = idx + 1;\r\n            }\r\n        }\r\n        //---------------------------------\r\n        //---- Draw candidate three-prongs\r\n        //---------------------------------\r\n        for (let i = startIndx; i < endIndx; i++) {\r\n            let circle = candidateThreeProngs[i].circle;\r\n            if (forDebugging.bestIndx === i) {\r\n                _debug_.fs.draw.dot(g, circle.center, 0.2, 'green');\r\n                _debug_.fs.draw.circle(g, circle, 'black thin10 nofill');\r\n            }\r\n            else {\r\n                _debug_.fs.draw.dot(g, circle.center, 0.2, 'cyan');\r\n                _debug_.fs.draw.circle(g, circle, 'cyan thin5 nofill');\r\n            }\r\n        }\r\n    }\r\n}\r\n/**\r\n * Shows the actual boundary for each iteration.\r\n * @param n The 3-prong's zero-based index.\r\n * @param idx The specific boundary iteration index to view. If ommitted will\r\n * show all.\r\n */\r\nfunction showBoundary(n, idx) {\r\n    let debugInfo = _debug_.generated.elems.threeProng[n];\r\n    let g = debugInfo.generated.g;\r\n    let candidateThreeProngs = debugInfo.candidateThreeProngs;\r\n    let startIndx = idx === undefined ? 0 : idx;\r\n    let endIndx = idx === undefined ? candidateThreeProngs.length : idx;\r\n    // Draw relevant δs\r\n    let cpss = debugInfo.cpss;\r\n    let j = 0;\r\n    // For each iteration of δ3s (indexed by j)\r\n    for (let idx = 1; idx < cpss.length - 1; idx++) {\r\n        if (!(j >= startIndx && j <= endIndx)) {\r\n            j++;\r\n            continue;\r\n        }\r\n        let δ3s = [\r\n            cpss[0],\r\n            cpss[idx],\r\n            cpss[cpss.length - 1]\r\n        ];\r\n        // For each of the 3 δs\r\n        for (let i = 0; i < 3; i++) {\r\n            let δ = δ3s[i];\r\n            let δS = δ[0]; // Delta Start\r\n            let δE = δ[1]; // Delta End\r\n            let posS = δS.cp.pointOnShape;\r\n            let posE = δE.cp.pointOnShape;\r\n            let pS = posS.p;\r\n            let pE = posE.p;\r\n            let r = 1 + (i * 0.5);\r\n            if (flo_vector2d_1.equal(pS, pE)) {\r\n                _debug_.fs.draw.crossHair(g, pS, 'red thin10 nofill', r);\r\n            }\r\n            else {\r\n                _debug_.fs.draw.crossHair(g, pS, 'green thin10 nofill', r);\r\n                _debug_.fs.draw.crossHair(g, pE, 'blue thin10 nofill', r);\r\n            }\r\n        }\r\n        j++;\r\n    }\r\n}\r\n/**\r\n * @param n The 3-prong's zero-based index.\r\n */\r\nfunction logδs(n) {\r\n    let threeProng = _debug_.generated.elems.threeProng[n];\r\n    console.log(threeProng.cpss);\r\n}\r\n/**\r\n *\r\n * @param p\r\n */\r\nfunction logNearest(showSpokes = true, showTrace = true, showBoundaries = true) {\r\n    return function (p, showDelay = 1000) {\r\n        let closestPerLoops = [];\r\n        _debug_.generatedAll.forEach(function (generated) {\r\n            let threeProng = flo_vector2d_1.getObjClosestTo(p, generated.elems.threeProng, threeProng => threeProng.circle.center);\r\n            closestPerLoops.push(threeProng);\r\n        });\r\n        let threeProng = flo_vector2d_1.getObjClosestTo(p, closestPerLoops, threeProng => threeProng.circle.center);\r\n        let circle = threeProng.circle;\r\n        let g = threeProng.generated.g;\r\n        console.log(threeProng);\r\n        let circle2 = new circle_1.Circle(circle.center, circle.radius || 1);\r\n        let draw = _debug_.fs.draw;\r\n        draw.circle(g, circle2, 'blue thin10 nofill', showDelay);\r\n        draw.crossHair(g, circle.center, 'red thin2 nofill', 2, showDelay);\r\n        if (showSpokes) {\r\n            draw.line(g, [threeProng.poss[0].p, circle.center], 'blue thin5 nofill', showDelay);\r\n            draw.line(g, [threeProng.poss[1].p, circle.center], 'blue thin5 nofill', showDelay);\r\n            draw.line(g, [threeProng.poss[2].p, circle.center], 'blue thin5 nofill', showDelay);\r\n        }\r\n        if (showBoundaries) {\r\n            let boundaries = threeProng.boundaries;\r\n            let boundaryS = boundaries[0];\r\n            let boundaryE = boundaries[boundaries.length - 1];\r\n            draw.beziers(g, boundaryS, 'red thin5 nofill', showDelay);\r\n            for (let i = 1; i < boundaries.length - 1; i++) {\r\n                let boundary = boundaries[i];\r\n                draw.beziers(g, boundary, 'green thin5 nofill', showDelay);\r\n            }\r\n            draw.beziers(g, boundaryE, 'blue thin5 nofill', showDelay);\r\n        }\r\n        if (showTrace) {\r\n            let traces = threeProng.traces;\r\n            for (let trace of traces) {\r\n                draw.polyline(g, trace, 'red thin5 nofill', showDelay);\r\n            }\r\n        }\r\n    };\r\n}\r\nlet threeProngDebugFunctions = {\r\n    drawSpokes,\r\n    traceConvergence,\r\n    showBoundary,\r\n    logδs,\r\n    logNearest\r\n};\r\nexports.threeProngDebugFunctions = threeProngDebugFunctions;\r\n//# sourceMappingURL=three-prong.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/three-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/two-prong.js":
/*!****************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/two-prong.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst circle_1 = __webpack_require__(/*! ../../circle */ \"./node_modules/flo-mat/node/circle.js\");\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\n/**\r\n *\r\n */\r\nfunction logδ(n, type = 'twoProng_regular') {\r\n    let δ = _debug_.generated.elems[type][n].δ;\r\n    console.log(δ);\r\n}\r\n/**\r\n *\r\n */\r\nfunction log(n, type = 'twoProng_regular') {\r\n    let twoProng = _debug_.generated.elems[type][n];\r\n    console.log(twoProng);\r\n}\r\n/**\r\n *\r\n */\r\nfunction drawNormal(n, showDelay = 1000, type = 'twoProng_regular') {\r\n    let twoProngs = _debug_.generated.elems[type];\r\n    // If not specified which, draw all\r\n    if (n === undefined) {\r\n        for (let i = 0; i < twoProngs.length; i++) {\r\n            drawNormal(i);\r\n        }\r\n    }\r\n    let twoProng = twoProngs[n];\r\n    let g = twoProng.generated.g;\r\n    if (!twoProng) {\r\n        return;\r\n    }\r\n    _debug_.fs.draw.line(g, [twoProng.pos.p, twoProng.circle.center], 'thin10 blue', showDelay);\r\n}\r\n/**\r\n *\r\n */\r\nfunction logδBasic(n, type = 'twoProng_regular') {\r\n    let delta = _debug_.generated.elems[type][n].δ;\r\n    function f(x) {\r\n        let pos = x.cp.pointOnShape;\r\n        return {\r\n            bez: pos.curve.ps,\r\n            t: pos.t\r\n        };\r\n    }\r\n    console.log(f(delta[0]));\r\n    console.log(f(delta[1]));\r\n}\r\n/**\r\n *\r\n */\r\nfunction logNearest(p, showDelay = 1000, type = 'twoProng_regular') {\r\n    let closestPerLoops = [];\r\n    _debug_.generatedAll.forEach(function (generated, loops) {\r\n        let twoProng = flo_vector2d_1.getObjClosestTo(p, generated.elems[type], twoProng => twoProng.circle.center);\r\n        closestPerLoops.push(twoProng);\r\n    });\r\n    let twoProng = flo_vector2d_1.getObjClosestTo(p, closestPerLoops, twoProng => twoProng.circle.center);\r\n    console.log(twoProng);\r\n    let n;\r\n    for (let i = 0; i < _debug_.generated.elems[type].length; i++) {\r\n        let twoProng_ = _debug_.generated.elems[type][i];\r\n        if (twoProng_ === twoProng) {\r\n            n = i;\r\n            break;\r\n        }\r\n    }\r\n    if (n !== undefined) {\r\n        traceConvergence(n, true, showDelay);\r\n    }\r\n}\r\n/**\r\n *\r\n * @param n - The 2-prong's zero-based index.\r\n * @param range\r\n * cascade of convergence)\r\n */\r\nfunction traceConvergence(n, finalOnly, showDelay = 1000, range = undefined, type = 'twoProng_regular') {\r\n    if (n === undefined) {\r\n        return;\r\n    }\r\n    let twoProngInfo = _debug_.generated.elems[type][n];\r\n    let xs = twoProngInfo.xs;\r\n    let g = twoProngInfo.generated.g;\r\n    console.log(twoProngInfo);\r\n    console.log(twoProngInfo.xs.map(x => ({\r\n        x: x.x,\r\n        y: x.y,\r\n        z: x.z,\r\n        d: x.z ? flo_vector2d_1.squaredDistanceBetween(x.y.p, x.z.p) : 0,\r\n        t: x.t,\r\n    })));\r\n    for (let i = 0; i < xs.length; i++) {\r\n        if (range && (i < range[0] || i >= range[1])) {\r\n            continue;\r\n        }\r\n        if (finalOnly && i !== xs.length - 1) {\r\n            continue;\r\n        }\r\n        let x = twoProngInfo.xs[i];\r\n        let circle = new circle_1.Circle(x.x, flo_vector2d_1.distanceBetween(x.x, x.y.p));\r\n        _debug_.fs.draw.crossHair(g, x.x, 'red thin10 nofill', undefined, showDelay);\r\n        _debug_.fs.draw.circle(g, circle, 'blue thin10 nofill', showDelay);\r\n        if (x.z !== undefined) {\r\n            _debug_.fs.draw.crossHair(g, x.z.p, 'yellow thin10 nofill', 2, showDelay);\r\n        }\r\n    }\r\n    twoProngDebugFunctions.drawNormal(n, showDelay);\r\n}\r\nlet twoProngDebugFunctions = {\r\n    logδ,\r\n    log,\r\n    drawNormal,\r\n    logδBasic,\r\n    traceConvergence,\r\n    logNearest,\r\n};\r\nexports.twoProngDebugFunctions = twoProngDebugFunctions;\r\n//# sourceMappingURL=two-prong.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/two-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/three-prong-for-debugging.js":
/*!**********************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/three-prong-for-debugging.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst point_on_shape_1 = __webpack_require__(/*! ../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\n/**\r\n * Class used in debugging. A three-prong is a maximally inscribed circle that\r\n * touches the shape boundary (tangentially) at 3 points.\r\n */\r\nclass ThreeProngForDebugging {\r\n    /**\r\n     * @param circle The best fit circle found for the 3-prong.\r\n     * @param poss The best fit 3 points found for the 3-prong.\r\n     * @param cp3ss The 3 boundary pieces on which the three prong points were\r\n     * found.\r\n     * @param cpss The boundary pieces that were used to search the three prong\r\n     * on.\r\n     * @param bestIndx\r\n     * @param candidateThreeProngs An array of 3-prongs, each of which may be a\r\n     * best fit 3-prong.\r\n     */\r\n    constructor() { }\r\n    get cpsSimple() {\r\n        return this.cpss.map(δ => [point_on_shape_1.PointOnShape.toHumanString(δ[0].cp.pointOnShape),\r\n            point_on_shape_1.PointOnShape.toHumanString(δ[1].cp.pointOnShape)]);\r\n    }\r\n}\r\nexports.ThreeProngForDebugging = ThreeProngForDebugging;\r\n//# sourceMappingURL=three-prong-for-debugging.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/three-prong-for-debugging.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/two-prong-for-debugging.js":
/*!********************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/two-prong-for-debugging.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass TwoProngForDebugging {\r\n    constructor(generated, bezierPieces, pos, δ, z, circle, xs, failed, holeClosing, notAdded, deleted, cpNode = undefined) {\r\n        this.generated = generated;\r\n        this.bezierPieces = bezierPieces;\r\n        this.pos = pos;\r\n        this.δ = δ;\r\n        this.z = z;\r\n        this.circle = circle;\r\n        this.xs = xs;\r\n        this.failed = failed;\r\n        this.holeClosing = holeClosing;\r\n        this.notAdded = notAdded;\r\n        this.deleted = deleted;\r\n        this.cpNode = cpNode;\r\n    }\r\n}\r\nexports.TwoProngForDebugging = TwoProngForDebugging;\r\n//# sourceMappingURL=two-prong-for-debugging.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/two-prong-for-debugging.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/find-mats.js":
/*!************************************************!*\
  !*** ./node_modules/flo-mat/node/find-mats.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst loop_1 = __webpack_require__(/*! ./loop */ \"./node_modules/flo-mat/node/loop.js\");\r\nconst mat_1 = __webpack_require__(/*! ./mat */ \"./node_modules/flo-mat/node/mat.js\");\r\nconst get_loop_bounds_1 = __webpack_require__(/*! ./svg/fs/get-loop-bounds */ \"./node_modules/flo-mat/node/svg/fs/get-loop-bounds.js\");\r\nconst simplify_paths_1 = __webpack_require__(/*! ./svg/fs/simplify-paths/simplify-paths */ \"./node_modules/flo-mat/node/svg/fs/simplify-paths/simplify-paths.js\");\r\nconst get_extreme_1 = __webpack_require__(/*! ./svg/fs/get-extreme */ \"./node_modules/flo-mat/node/svg/fs/get-extreme.js\");\r\nconst find_and_add_3_prongs_1 = __webpack_require__(/*! ./mat/find-mat/find-and-add-3-prongs */ \"./node_modules/flo-mat/node/mat/find-mat/find-and-add-3-prongs.js\");\r\nconst create_initial_cp_graph_1 = __webpack_require__(/*! ./mat/find-mat/create-initial-cp-graph */ \"./node_modules/flo-mat/node/mat/find-mat/create-initial-cp-graph.js\");\r\n;\r\nconst add_debug_info_1 = __webpack_require__(/*! ./mat/find-mat/add-debug-info */ \"./node_modules/flo-mat/node/mat/find-mat/add-debug-info.js\");\r\nconst get_potential_2_prongs_1 = __webpack_require__(/*! ./mat/find-mat/get-potential-2-prongs */ \"./node_modules/flo-mat/node/mat/find-mat/get-potential-2-prongs.js\");\r\nconst get_sharp_corners_1 = __webpack_require__(/*! ./mat/find-mat/get-sharp-corners */ \"./node_modules/flo-mat/node/mat/find-mat/get-sharp-corners.js\");\r\nconst smoothen_1 = __webpack_require__(/*! ./mat/smoothen/smoothen */ \"./node_modules/flo-mat/node/mat/smoothen/smoothen.js\");\r\nconst find_and_add_2_prongs_on_all_paths_1 = __webpack_require__(/*! ./mat/find-mat/find-and-add-2-prongs-on-all-paths */ \"./node_modules/flo-mat/node/mat/find-mat/find-and-add-2-prongs-on-all-paths.js\");\r\nconst create_get_interesting_points_on_loop_1 = __webpack_require__(/*! ./mat/find-mat/create-get-interesting-points-on-loop */ \"./node_modules/flo-mat/node/mat/find-mat/create-get-interesting-points-on-loop.js\");\r\nconst find_and_add_hole_closing_2_prongs_1 = __webpack_require__(/*! ./mat/find-mat/find-and-add-hole-closing-2-prongs */ \"./node_modules/flo-mat/node/mat/find-mat/find-and-add-hole-closing-2-prongs.js\");\r\n/**\r\n * Find the Medial Axis Transforms (MATs) from the given array of bezier loops\r\n * representing shape boundaries.\r\n * @param bezierLoops An array of (possibly intersecting) loops with each loop\r\n * representing one or more piecewise smooth closed curves (i.e. shapes). Each\r\n * loop consists of an array of beziers represented by an array of control\r\n * points with 2,3 or 4 elements corresponding to linear, quadratic and cubic\r\n * beziers respectively. Each point is a two-element array (ordered pair), the\r\n * first of which is the x-coordinate and the second the y-coordinate.\r\n * @param additionalPointCount Additional points per bezier where a MAT circle\r\n * will be added. Defaults to 3.\r\n */\r\nfunction findMats(bezierLoops, additionalPointCount = 3) {\r\n    if (typeof _debug_ !== 'undefined') {\r\n        let timing = _debug_.generated.timing;\r\n        timing.simplify[0] = performance.now();\r\n    }\r\n    //let loops_ = loops.map(loop => Loop.perturb(loop, 10))\r\n    let loops = bezierLoops.map(beziers => loop_1.Loop.fromBeziers(beziers));\r\n    let { loopss, xMap } = simplify_paths_1.simplifyPaths(loops);\r\n    if (typeof _debug_ !== 'undefined') {\r\n        let timing = _debug_.generated.timing;\r\n        timing.simplify[1] += performance.now() - timing.simplify[0];\r\n    }\r\n    let mats = [];\r\n    for (let loops of loopss) {\r\n        loops.sort(ascendingByTopmostPoint);\r\n        let mat = findPartialMat(loops, xMap, additionalPointCount);\r\n        if (mat) {\r\n            mats.push(mat);\r\n        }\r\n    }\r\n    return mats;\r\n}\r\nexports.findMats = findMats;\r\n/**\r\n *\r\n * @param loops\r\n * @param xMap\r\n * @param additionalPointCount\r\n * @private\r\n */\r\nfunction findPartialMat(loops, xMap, additionalPointCount = 3) {\r\n    let extreme = get_extreme_1.getExtreme(loops);\r\n    add_debug_info_1.addDebugInfo1(loops);\r\n    // Gets interesting points on the shape, i.e. those that makes sense to use \r\n    // for the 2-prong procedure.\r\n    let f = create_get_interesting_points_on_loop_1.createGetInterestingPointsOnLoop(additionalPointCount);\r\n    let pointsPerLoop = loops.map(f);\r\n    let for2ProngsPerLoop = get_potential_2_prongs_1.getPotential2Prongs(pointsPerLoop);\r\n    let sharpCornersPerLoop = get_sharp_corners_1.getSharpCorners(pointsPerLoop);\r\n    let cpTrees = new Map();\r\n    let cpNode = create_initial_cp_graph_1.createInitialCpGraph(loops, cpTrees, sharpCornersPerLoop, xMap);\r\n    find_and_add_hole_closing_2_prongs_1.findAndAddHoleClosing2Prongs(loops, cpTrees, extreme);\r\n    if (typeof _debug_ !== 'undefined') {\r\n        if (_debug_.directives.stopAfterHoleClosers) {\r\n            return undefined;\r\n        }\r\n    }\r\n    add_debug_info_1.addDebugInfo2(pointsPerLoop);\r\n    cpNode = find_and_add_2_prongs_on_all_paths_1.findAndAdd2ProngsOnAllPaths(loops, cpTrees, for2ProngsPerLoop, extreme);\r\n    if (typeof _debug_ !== 'undefined') {\r\n        if (_debug_.directives.stopAfterTwoProngs) {\r\n            return undefined;\r\n        }\r\n    }\r\n    add_debug_info_1.addDebugInfo3();\r\n    if (cpNode === undefined) {\r\n        return undefined;\r\n    }\r\n    find_and_add_3_prongs_1.findAndAddAll3Prongs(cpTrees, cpNode, extreme);\r\n    if (typeof _debug_ !== 'undefined') {\r\n        if (_debug_.directives.stopAfterThreeProngs) {\r\n            return undefined;\r\n        }\r\n    }\r\n    let mat = new mat_1.Mat(cpNode, cpTrees);\r\n    smoothen_1.smoothen(mat.cpNode);\r\n    add_debug_info_1.addDebugInfo4(mat);\r\n    return mat;\r\n}\r\n/**\r\n *\r\n * @param loopA\r\n * @param loopB\r\n * @private\r\n */\r\nfunction ascendingByTopmostPoint(loopA, loopB) {\r\n    let boundsA = get_loop_bounds_1.getLoopBounds(loopA);\r\n    let boundsB = get_loop_bounds_1.getLoopBounds(loopB);\r\n    let a = boundsA.minY.p[1];\r\n    let b = boundsB.minY.p[1];\r\n    return a - b;\r\n}\r\n//# sourceMappingURL=find-mats.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/find-mats.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/index.js":
/*!********************************************!*\
  !*** ./node_modules/flo-mat/node/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst mat_1 = __webpack_require__(/*! ./mat */ \"./node_modules/flo-mat/node/mat.js\");\r\nexports.Mat = mat_1.Mat;\r\nconst loop_1 = __webpack_require__(/*! ./loop */ \"./node_modules/flo-mat/node/loop.js\");\r\nexports.Loop = loop_1.Loop;\r\nconst curve_1 = __webpack_require__(/*! ./curve */ \"./node_modules/flo-mat/node/curve.js\");\r\nexports.Curve = curve_1.Curve;\r\nconst cp_node_1 = __webpack_require__(/*! ./cp-node */ \"./node_modules/flo-mat/node/cp-node.js\");\r\nexports.CpNode = cp_node_1.CpNode;\r\nconst point_on_shape_1 = __webpack_require__(/*! ./point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nexports.PointOnShape = point_on_shape_1.PointOnShape;\r\nconst circle_1 = __webpack_require__(/*! ./circle */ \"./node_modules/flo-mat/node/circle.js\");\r\nexports.Circle = circle_1.Circle;\r\nconst contact_point_1 = __webpack_require__(/*! ./contact-point */ \"./node_modules/flo-mat/node/contact-point.js\");\r\nexports.ContactPoint = contact_point_1.ContactPoint;\r\nconst bezier_piece_1 = __webpack_require__(/*! ./bezier-piece */ \"./node_modules/flo-mat/node/bezier-piece.js\");\r\nexports.BezierPiece = bezier_piece_1.BezierPiece;\r\nconst find_mats_1 = __webpack_require__(/*! ./find-mats */ \"./node_modules/flo-mat/node/find-mats.js\");\r\nexports.findMats = find_mats_1.findMats;\r\nconst trim_mat_1 = __webpack_require__(/*! ./mat/trim-mat */ \"./node_modules/flo-mat/node/mat/trim-mat.js\");\r\nexports.trimMat = trim_mat_1.trimMat;\r\nconst to_scale_axis_1 = __webpack_require__(/*! ./to-scale-axis */ \"./node_modules/flo-mat/node/to-scale-axis.js\");\r\nexports.toScaleAxis = to_scale_axis_1.toScaleAxis;\r\nconst traverse_edges_1 = __webpack_require__(/*! ./traverse-edges */ \"./node_modules/flo-mat/node/traverse-edges.js\");\r\nexports.traverseEdges = traverse_edges_1.traverseEdges;\r\nconst traverse_vertices_1 = __webpack_require__(/*! ./traverse-vertices */ \"./node_modules/flo-mat/node/traverse-vertices.js\");\r\nexports.traverseVertices = traverse_vertices_1.traverseVertices;\r\nconst debug_1 = __webpack_require__(/*! ./debug/debug */ \"./node_modules/flo-mat/node/debug/debug.js\");\r\nexports.MatDebug = debug_1.MatDebug;\r\nconst cp_node_for_debugging_1 = __webpack_require__(/*! ./debug/cp-node-for-debugging */ \"./node_modules/flo-mat/node/debug/cp-node-for-debugging.js\");\r\nexports.CpNodeForDebugging = cp_node_for_debugging_1.CpNodeForDebugging;\r\nconst get_closest_boundary_point_1 = __webpack_require__(/*! ./mat/closest-boundary-point/get-closest-boundary-point */ \"./node_modules/flo-mat/node/mat/closest-boundary-point/get-closest-boundary-point.js\");\r\nexports.getClosestBoundaryPoint = get_closest_boundary_point_1.getClosestBoundaryPoint;\r\nconst closest_point_on_bezier_1 = __webpack_require__(/*! ./mat/closest-boundary-point/closest-point-on-bezier */ \"./node_modules/flo-mat/node/mat/closest-boundary-point/closest-point-on-bezier.js\");\r\nexports.closestPointOnBezier = closest_point_on_bezier_1.closestPointOnBezier;\r\nconst get_paths_from_str_1 = __webpack_require__(/*! ./svg/fs/get-paths-from-str */ \"./node_modules/flo-mat/node/svg/fs/get-paths-from-str.js\");\r\nexports.getPathsFromStr = get_paths_from_str_1.getPathsFromStr;\r\nconst beziers_to_svg_path_str_1 = __webpack_require__(/*! ./svg/fs/beziers-to-svg-path-str */ \"./node_modules/flo-mat/node/svg/fs/beziers-to-svg-path-str.js\");\r\nexports.beziersToSvgPathStr = beziers_to_svg_path_str_1.beziersToSvgPathStr;\r\nconst get_shape_bounds_1 = __webpack_require__(/*! ./svg/fs/get-shape-bounds */ \"./node_modules/flo-mat/node/svg/fs/get-shape-bounds.js\");\r\nexports.getShapeBounds = get_shape_bounds_1.getShapeBounds;\r\nexports.getShapesBounds = get_shape_bounds_1.getShapesBounds;\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/index.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/loop.js":
/*!*******************************************!*\
  !*** ./node_modules/flo-mat/node/loop.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst curve_1 = __webpack_require__(/*! ./curve */ \"./node_modules/flo-mat/node/curve.js\");\r\nconst quadratic_to_cubic_1 = __webpack_require__(/*! ./svg/fs/quadratic-to-cubic */ \"./node_modules/flo-mat/node/svg/fs/quadratic-to-cubic.js\");\r\nconst linear_to_cubic_1 = __webpack_require__(/*! ./svg/fs/linear-to-cubic */ \"./node_modules/flo-mat/node/svg/fs/linear-to-cubic.js\");\r\n/**\r\n * Represents a two-way linked loop of [[Curve]]s - mostly used internally to\r\n * conveniently represent shape boundaries.\r\n */\r\nclass Loop {\r\n    /**\r\n     * @param beziers - A pre-ordered array of bezier curves to add initially.\r\n     */\r\n    constructor(beziers = []) {\r\n        this.beziers = beziers;\r\n        this.curves = [];\r\n        let loop = this;\r\n        if (beziers.length === 0) {\r\n            return undefined;\r\n        }\r\n        let head;\r\n        let prev = null;\r\n        let node;\r\n        for (let i = 0; i < beziers.length; i++) {\r\n            node = new curve_1.Curve(loop, beziers[i], prev, null, i);\r\n            loop.curves.push(node);\r\n            if (prev) {\r\n                prev.next = node;\r\n            }\r\n            prev = node;\r\n            if (i === 0) {\r\n                head = node;\r\n            }\r\n        }\r\n        // Close loop\r\n        head.prev = node;\r\n        node.next = head;\r\n        this.head = head;\r\n    }\r\n    /**\r\n     * Returns the loop as an array of beziers.\r\n     */\r\n    toBeziers() {\r\n        let beziers = [];\r\n        for (let curve of this.curves) {\r\n            beziers.push(curve.ps);\r\n        }\r\n        return beziers;\r\n    }\r\n    /**\r\n     * Creates and returns a [[Loop]] from the given array of cubic beziers.\r\n     * @param beziers An array of cubic beziers.\r\n     */\r\n    static fromCubicBeziers(beziers = []) {\r\n        return new Loop(beziers);\r\n    }\r\n    /**\r\n     * Creates and returns a [[Loop]] from the given array of beziers.\r\n     * @param beziers An array of bezier curves (linear, quadratic or cubic).\r\n     */\r\n    static fromBeziers(items = []) {\r\n        let items_ = [];\r\n        for (let i = 0; i < items.length; i++) {\r\n            let item = items[i];\r\n            if (item.length === 4) {\r\n                items_.push(item);\r\n            }\r\n            else if (item.length === 3) {\r\n                items_.push(quadratic_to_cubic_1.quadraticToCubic(item));\r\n            }\r\n            else if (item.length === 2) {\r\n                items_.push(linear_to_cubic_1.linearToCubic(item));\r\n            }\r\n        }\r\n        return new Loop(items_);\r\n    }\r\n    /**\r\n     * Perturbs the loop. Not used.\r\n     * @param loop\r\n     * @param x\r\n     * @private\r\n     */\r\n    static perturb(loop, x) {\r\n        if (!x) {\r\n            return loop;\r\n        }\r\n        let seed = 2311; // Just some value\r\n        let newItems = [];\r\n        for (let i = 0; i < loop.beziers.length; i++) {\r\n            // This gets us a predictable random number between 0 and 1;\r\n            let rand1 = flo_poly_1.default.random.flatCoefficients(6, -1, 1, seed);\r\n            let rs = rand1.p;\r\n            seed = rand1.seed; // Get next seed.\r\n            let vs = rs.map(r => r * x);\r\n            console.log(vs);\r\n            let ps = loop.beziers[i];\r\n            let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n            let newPs = [\r\n                [x0 + vs[0], y0 + vs[1]],\r\n                [x1 + vs[2], y1 + vs[3]],\r\n                [x2 + vs[4], y2 + vs[5]],\r\n                [0, 0]\r\n            ];\r\n            if (i !== 0) {\r\n                let prev = newItems[newItems.length - 1];\r\n                prev[3][0] = newPs[0][0];\r\n                prev[3][1] = newPs[0][1];\r\n            }\r\n            newItems.push(newPs);\r\n        }\r\n        let last = newItems[newItems.length - 1];\r\n        last[3][0] = newItems[0][0][0];\r\n        last[3][1] = newItems[0][0][1];\r\n        return new Loop(newItems);\r\n    }\r\n}\r\nexports.Loop = Loop;\r\n//# sourceMappingURL=loop.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/loop.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat.js":
/*!******************************************!*\
  !*** ./node_modules/flo-mat/node/mat.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Represents a complete Medial Axis Transform (MAT).\r\n *\r\n * The MAT is fully described through its [[CpNode]] property. The [[cpTrees]]\r\n * property is only added to facilitate extension of the MAT, e.g. by adding\r\n * extra maximal disks and is typically not used. See [[CpNode]] for more\r\n * details.\r\n */\r\nclass Mat {\r\n    /**\r\n     * @param cpNode A complete representation of the MAT. See [[CpNode]].\r\n     * @param cpTrees Primarily for internal use. A tree structure storing the\r\n     * [[CpNode]]s of the MAT by their compare order, i.e. their cyclic order\r\n     * around the shape boundary.\r\n     */\r\n    constructor(cpNode, cpTrees) {\r\n        this.cpNode = cpNode;\r\n        this.cpTrees = cpTrees;\r\n    }\r\n}\r\nexports.Mat = Mat;\r\n//# sourceMappingURL=mat.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/add-to-cp-graph.js":
/*!**********************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/add-to-cp-graph.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst contact_point_1 = __webpack_require__(/*! ../contact-point */ \"./node_modules/flo-mat/node/contact-point.js\");\r\nconst cp_node_1 = __webpack_require__(/*! ../cp-node */ \"./node_modules/flo-mat/node/cp-node.js\");\r\nconst get_neighboring_cps_1 = __webpack_require__(/*! ./get-neighboring-cps */ \"./node_modules/flo-mat/node/mat/get-neighboring-cps.js\");\r\n/**\r\n *\r\n * @param circle\r\n * @param orders\r\n * @param cpTrees\r\n * @param poss\r\n * @param neighbors\r\n * @private\r\n */\r\nfunction addToCpGraph(circle, orders, cpTrees, poss, neighbors) {\r\n    let newCps = poss.map((pos, i) => {\r\n        let cpTree = cpTrees.get(pos.curve.loop);\r\n        let newCp_ = new contact_point_1.ContactPoint(pos, circle, orders[i], 0);\r\n        let neighboringCp = neighbors\r\n            ? neighbors[i]\r\n            : get_neighboring_cps_1.getNeighbouringPoints(cpTree, pos, orders[i], 0);\r\n        let newCp = cp_node_1.CpNode.insert(false, false, cpTree, newCp_, neighboringCp[0]);\r\n        return newCp;\r\n    });\r\n    let len = poss.length;\r\n    for (let i = 0; i < len; i++) {\r\n        let indxPrev = i === 0 ? len - 1 : i - 1;\r\n        let indxNext = i === len - 1 ? 0 : i + 1;\r\n        newCps[i].prevOnCircle = newCps[indxPrev];\r\n        newCps[i].nextOnCircle = newCps[indxNext];\r\n    }\r\n}\r\nexports.addToCpGraph = addToCpGraph;\r\n//# sourceMappingURL=add-to-cp-graph.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/add-to-cp-graph.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/closest-boundary-point/closest-point-on-bezier.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/closest-boundary-point/closest-point-on-bezier.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\n/**\r\n *\r\n * @param curve The bezier\r\n * @param p The point from which to check\r\n * @param tRange The allowed t range\r\n * @param touchedCurve The bezier on which p is located\r\n * @param t The t value of the bezier that locates p\r\n */\r\nfunction closestPointOnBezier(ps, p, tRange = [0, 1]) {\r\n    // TODO The site at http://jazzros.blogspot.ca/2011/03/projecting-point-on-bezier-curve.html\r\n    // may hint at requiring much fewer assignments?\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    let [xp, yp] = p;\r\n    let xx0 = x0 - xp;\r\n    let xx1 = x1 - xp;\r\n    let xx2 = x2 - xp;\r\n    let xx3 = x3 - xp;\r\n    let yy0 = y0 - yp;\r\n    let yy1 = y1 - yp;\r\n    let yy2 = y2 - yp;\r\n    let yy3 = y3 - yp;\r\n    let x00 = xx0 * xx0;\r\n    let x01 = 6 * xx0 * xx1;\r\n    let x02 = 6 * xx0 * xx2;\r\n    let x03 = 2 * xx0 * xx3;\r\n    let x11 = 9 * xx1 * xx1;\r\n    let x12 = 18 * xx1 * xx2;\r\n    let x13 = 6 * xx1 * xx3;\r\n    let x22 = 9 * xx2 * xx2;\r\n    let x23 = 6 * xx2 * xx3;\r\n    let x33 = xx3 * xx3;\r\n    let y00 = yy0 * yy0;\r\n    let y01 = 6 * yy0 * yy1;\r\n    let y02 = 6 * yy0 * yy2;\r\n    let y03 = 2 * yy0 * yy3;\r\n    let y11 = 9 * yy1 * yy1;\r\n    let y12 = 18 * yy1 * yy2;\r\n    let y13 = 6 * yy1 * yy3;\r\n    let y22 = 9 * yy2 * yy2;\r\n    let y23 = 6 * yy2 * yy3;\r\n    let y33 = yy3 * yy3;\r\n    let t5 = 6 * ((x33 - x23 + x13 - x03 + x22 - x12 + x02 + x11 - x01 + x00) +\r\n        (y33 - y23 + y13 - y03 + y22 - y12 + y02 + y11 - y01 + y00));\r\n    let t4 = 5 * ((x23 - 2 * x13 + 3 * x03 - 2 * x22 + 3 * x12 - 4 * x02 - 4 * x11 + 5 * x01 - 6 * x00) +\r\n        (y23 - 2 * y13 + 3 * y03 - 2 * y22 + 3 * y12 - 4 * y02 - 4 * y11 + 5 * y01 - 6 * y00));\r\n    let t3 = 4 * ((x13 - 3 * x03 + x22 - 3 * x12 + 6 * x02 + 6 * x11 - 10 * x01 + 15 * x00) +\r\n        (y13 - 3 * y03 + y22 - 3 * y12 + 6 * y02 + 6 * y11 - 10 * y01 + 15 * y00));\r\n    let t2 = 3 * ((x03 + x12 - 4 * x02 - 4 * x11 + 10 * x01 - 20 * x00) +\r\n        (y03 + y12 - 4 * y02 - 4 * y11 + 10 * y01 - 20 * y00));\r\n    let t1 = 2 * ((x02 + x11 - 5 * x01 + 15 * x00) +\r\n        (y02 + y11 - 5 * y01 + 15 * y00));\r\n    let t0 = ((x01 - 6 * x00) +\r\n        (y01 - 6 * y00));\r\n    let poly = [t5, t4, t3, t2, t1, t0];\r\n    let roots = flo_poly_1.default.allRoots(poly, tRange[0], tRange[1]);\r\n    // Also test the endpoints\r\n    let push0 = true;\r\n    let push1 = true;\r\n    if (tRange[0] === 0) {\r\n        if (push0) {\r\n            roots.push(tRange[0]);\r\n        }\r\n    }\r\n    else if (tRange[0] === 1) {\r\n        if (push1) {\r\n            roots.push(tRange[0]);\r\n        }\r\n    }\r\n    else {\r\n        roots.push(tRange[0]);\r\n    }\r\n    if (tRange[1] === 0) {\r\n        if (push0) {\r\n            roots.push(tRange[1]);\r\n        }\r\n    }\r\n    else if (tRange[1] === 1) {\r\n        if (push1) {\r\n            roots.push(tRange[1]);\r\n        }\r\n    }\r\n    else {\r\n        roots.push(tRange[1]);\r\n    }\r\n    let ev = flo_bezier3_1.evaluate(ps);\r\n    let ps_ = roots.map(root => ({ p: ev(root), t: root }));\r\n    return flo_vector2d_1.getObjClosestTo(p, ps_, p => p.p);\r\n}\r\nexports.closestPointOnBezier = closestPointOnBezier;\r\n//# sourceMappingURL=closest-point-on-bezier.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/closest-boundary-point/closest-point-on-bezier.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/closest-boundary-point/closest-point-on-curve.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/closest-boundary-point/closest-point-on-curve.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\n/**\r\n *\r\n * @param curve The bezier\r\n * @param p The point from which to check\r\n * @param tRange The allowed t range\r\n * @param touchedCurve The bezier on which p is located\r\n * @param t The t value of the bezier that locates p\r\n */\r\nfunction closestPointOnCurve(curve, p, tRange = [0, 1], touchedCurve, t) {\r\n    // TODO The site at http://jazzros.blogspot.ca/2011/03/projecting-point-on-bezier-curve.html\r\n    // may hint at requiring much fewer assignments?\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = curve.ps;\r\n    let [xp, yp] = p;\r\n    let xx0 = x0 - xp;\r\n    let xx1 = x1 - xp;\r\n    let xx2 = x2 - xp;\r\n    let xx3 = x3 - xp;\r\n    let yy0 = y0 - yp;\r\n    let yy1 = y1 - yp;\r\n    let yy2 = y2 - yp;\r\n    let yy3 = y3 - yp;\r\n    let x00 = xx0 * xx0;\r\n    let x01 = 6 * xx0 * xx1;\r\n    let x02 = 6 * xx0 * xx2;\r\n    let x03 = 2 * xx0 * xx3;\r\n    let x11 = 9 * xx1 * xx1;\r\n    let x12 = 18 * xx1 * xx2;\r\n    let x13 = 6 * xx1 * xx3;\r\n    let x22 = 9 * xx2 * xx2;\r\n    let x23 = 6 * xx2 * xx3;\r\n    let x33 = xx3 * xx3;\r\n    let y00 = yy0 * yy0;\r\n    let y01 = 6 * yy0 * yy1;\r\n    let y02 = 6 * yy0 * yy2;\r\n    let y03 = 2 * yy0 * yy3;\r\n    let y11 = 9 * yy1 * yy1;\r\n    let y12 = 18 * yy1 * yy2;\r\n    let y13 = 6 * yy1 * yy3;\r\n    let y22 = 9 * yy2 * yy2;\r\n    let y23 = 6 * yy2 * yy3;\r\n    let y33 = yy3 * yy3;\r\n    let t5 = 6 * ((x33 - x23 + x13 - x03 + x22 - x12 + x02 + x11 - x01 + x00) +\r\n        (y33 - y23 + y13 - y03 + y22 - y12 + y02 + y11 - y01 + y00));\r\n    let t4 = 5 * ((x23 - 2 * x13 + 3 * x03 - 2 * x22 + 3 * x12 - 4 * x02 - 4 * x11 + 5 * x01 - 6 * x00) +\r\n        (y23 - 2 * y13 + 3 * y03 - 2 * y22 + 3 * y12 - 4 * y02 - 4 * y11 + 5 * y01 - 6 * y00));\r\n    let t3 = 4 * ((x13 - 3 * x03 + x22 - 3 * x12 + 6 * x02 + 6 * x11 - 10 * x01 + 15 * x00) +\r\n        (y13 - 3 * y03 + y22 - 3 * y12 + 6 * y02 + 6 * y11 - 10 * y01 + 15 * y00));\r\n    let t2 = 3 * ((x03 + x12 - 4 * x02 - 4 * x11 + 10 * x01 - 20 * x00) +\r\n        (y03 + y12 - 4 * y02 - 4 * y11 + 10 * y01 - 20 * y00));\r\n    let t1 = 2 * ((x02 + x11 - 5 * x01 + 15 * x00) +\r\n        (y02 + y11 - 5 * y01 + 15 * y00));\r\n    let t0 = ((x01 - 6 * x00) +\r\n        (y01 - 6 * y00));\r\n    let poly = [t5, t4, t3, t2, t1, t0];\r\n    if (curve === touchedCurve) {\r\n        poly = flo_poly_1.default.deflate(poly, t);\r\n        /*\r\n        TODO - Optimization: may be used to quickly detect 1-prongs\r\n        if (Poly.evaluate(poly, t) < 1e-9) {\r\n            console.log(Poly.evaluate(poly, t))\r\n        }\r\n        */\r\n    }\r\n    let roots = flo_poly_1.default.allRoots(poly, tRange[0], tRange[1]);\r\n    // Also test the endpoints\r\n    let push0 = true;\r\n    let push1 = true;\r\n    if ((t === 1 && curve === touchedCurve.next) ||\r\n        (curve === touchedCurve && t === 0)) {\r\n        push0 = false;\r\n    }\r\n    if ((t === 0 && curve === touchedCurve.prev) ||\r\n        (curve === touchedCurve && t === 1)) {\r\n        push1 = false;\r\n    }\r\n    //let pushed0 = false;\r\n    //let pushed1 = false;\r\n    if (tRange[0] === 0) {\r\n        if (push0) {\r\n            roots.push(0);\r\n            //pushed0 = true;\r\n        }\r\n    }\r\n    else if (tRange[0] === 1) {\r\n        if (push1) {\r\n            roots.push(1);\r\n            //pushed1 = true;\r\n        }\r\n    }\r\n    else {\r\n        roots.push(tRange[0]);\r\n    }\r\n    if (tRange[1] === 0) {\r\n        if (push0) {\r\n            roots.push(0);\r\n            //pushed0 = true;\r\n        }\r\n    }\r\n    else if (tRange[1] === 1) {\r\n        if (push1) {\r\n            roots.push(1);\r\n            //pushed1 = true;\r\n        }\r\n    }\r\n    else {\r\n        roots.push(tRange[1]);\r\n    }\r\n    // This is to take care of a numerical issue - see shape p1.svg.\r\n    let roots_ = [];\r\n    for (let i = 0; i < roots.length; i++) {\r\n        let root = roots[i];\r\n        if (root !== 0 && root < 1e-11) {\r\n            root = 0;\r\n        }\r\n        else if (root !== 1 && 1 - root < 1e-11) {\r\n            root = 1;\r\n        }\r\n        roots_.push(root);\r\n    }\r\n    let ev = flo_bezier3_1.evaluate(curve.ps);\r\n    let ps = roots_.map(root => ({ p: ev(root), t: root }));\r\n    return flo_vector2d_1.getObjClosestTo(p, ps, p => p.p);\r\n}\r\nexports.closestPointOnCurve = closestPointOnCurve;\r\n//# sourceMappingURL=closest-point-on-curve.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/closest-boundary-point/closest-point-on-curve.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/closest-boundary-point/closest-points-on-curve.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/closest-boundary-point/closest-points-on-curve.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\n/**\r\n *\r\n * @param curve The bezier\r\n * @param p The point from which to check\r\n * @param tRange The allowed t range\r\n * @param touchedCurve The bezier on which p is located\r\n * @param t The t value of the bezier that locates p\r\n */\r\nfunction closestPointsOnCurve(curve, p, tRange = [0, 1], touchedCurve, t, distance, distanceTolerance) {\r\n    // TODO The site at http://jazzros.blogspot.ca/2011/03/projecting-point-on-bezier-curve.html\r\n    // may hint at requiring much fewer assignments?\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = curve.ps;\r\n    let [xp, yp] = p;\r\n    let xx0 = x0 - xp;\r\n    let xx1 = x1 - xp;\r\n    let xx2 = x2 - xp;\r\n    let xx3 = x3 - xp;\r\n    let yy0 = y0 - yp;\r\n    let yy1 = y1 - yp;\r\n    let yy2 = y2 - yp;\r\n    let yy3 = y3 - yp;\r\n    let x00 = xx0 * xx0;\r\n    let x01 = 6 * xx0 * xx1;\r\n    let x02 = 6 * xx0 * xx2;\r\n    let x03 = 2 * xx0 * xx3;\r\n    let x11 = 9 * xx1 * xx1;\r\n    let x12 = 18 * xx1 * xx2;\r\n    let x13 = 6 * xx1 * xx3;\r\n    let x22 = 9 * xx2 * xx2;\r\n    let x23 = 6 * xx2 * xx3;\r\n    let x33 = xx3 * xx3;\r\n    let y00 = yy0 * yy0;\r\n    let y01 = 6 * yy0 * yy1;\r\n    let y02 = 6 * yy0 * yy2;\r\n    let y03 = 2 * yy0 * yy3;\r\n    let y11 = 9 * yy1 * yy1;\r\n    let y12 = 18 * yy1 * yy2;\r\n    let y13 = 6 * yy1 * yy3;\r\n    let y22 = 9 * yy2 * yy2;\r\n    let y23 = 6 * yy2 * yy3;\r\n    let y33 = yy3 * yy3;\r\n    let t5 = 6 * ((x33 - x23 + x13 - x03 + x22 - x12 + x02 + x11 - x01 + x00) +\r\n        (y33 - y23 + y13 - y03 + y22 - y12 + y02 + y11 - y01 + y00));\r\n    let t4 = 5 * ((x23 - 2 * x13 + 3 * x03 - 2 * x22 + 3 * x12 - 4 * x02 - 4 * x11 + 5 * x01 - 6 * x00) +\r\n        (y23 - 2 * y13 + 3 * y03 - 2 * y22 + 3 * y12 - 4 * y02 - 4 * y11 + 5 * y01 - 6 * y00));\r\n    let t3 = 4 * ((x13 - 3 * x03 + x22 - 3 * x12 + 6 * x02 + 6 * x11 - 10 * x01 + 15 * x00) +\r\n        (y13 - 3 * y03 + y22 - 3 * y12 + 6 * y02 + 6 * y11 - 10 * y01 + 15 * y00));\r\n    let t2 = 3 * ((x03 + x12 - 4 * x02 - 4 * x11 + 10 * x01 - 20 * x00) +\r\n        (y03 + y12 - 4 * y02 - 4 * y11 + 10 * y01 - 20 * y00));\r\n    let t1 = 2 * ((x02 + x11 - 5 * x01 + 15 * x00) +\r\n        (y02 + y11 - 5 * y01 + 15 * y00));\r\n    let t0 = ((x01 - 6 * x00) +\r\n        (y01 - 6 * y00));\r\n    let poly = [t5, t4, t3, t2, t1, t0];\r\n    if (curve === touchedCurve) {\r\n        poly = flo_poly_1.default.deflate(poly, t);\r\n        /*\r\n        TODO - Optimization: may be used to quickly detect 1-prongs\r\n        if (Poly.evaluate(poly, t) < 1e-9) {\r\n            console.log(Poly.evaluate(poly, t))\r\n        }\r\n        */\r\n    }\r\n    let roots = flo_poly_1.default.allRoots(poly, tRange[0], tRange[1]);\r\n    // Also test the endpoints\r\n    let push0 = true;\r\n    let push1 = true;\r\n    if ((t === 1 && curve === touchedCurve.next) ||\r\n        (curve === touchedCurve && t === 0)) {\r\n        push0 = false;\r\n    }\r\n    if ((t === 0 && curve === touchedCurve.prev) ||\r\n        (curve === touchedCurve && t === 1)) {\r\n        push1 = false;\r\n    }\r\n    if (tRange[0] === 0) {\r\n        if (push0) {\r\n            roots.push(tRange[0]);\r\n        }\r\n    }\r\n    else if (tRange[0] === 1) {\r\n        if (push1) {\r\n            roots.push(tRange[0]);\r\n        }\r\n    }\r\n    else {\r\n        roots.push(tRange[0]);\r\n    }\r\n    if (tRange[1] === 0) {\r\n        if (push0) {\r\n            roots.push(tRange[1]);\r\n        }\r\n    }\r\n    else if (tRange[1] === 1) {\r\n        if (push1) {\r\n            roots.push(tRange[1]);\r\n        }\r\n    }\r\n    else {\r\n        roots.push(tRange[1]);\r\n    }\r\n    // This is to take care of a numerical issue.\r\n    let roots_ = [];\r\n    for (let i = 0; i < roots.length; i++) {\r\n        let root = roots[i];\r\n        if (root !== 0 && root < 1e-10) {\r\n            root = 0;\r\n        }\r\n        else if (root !== 1 && 1 - root < 1e-10) {\r\n            root = 1;\r\n        }\r\n        roots_.push(root);\r\n    }\r\n    let ev = flo_bezier3_1.evaluate(curve.ps);\r\n    let ps = roots.map(root => ({ p: ev(root), t: root }));\r\n    //let ps_: { p: number[]; t: number; }[] = [];\r\n    /*\r\n    for (let i=0; i<ps.length; i++) {\r\n        let p_ = ps[i];\r\n        let d = distanceBetween(p, p_.p);\r\n        if (Math.abs(d-distance) < distanceTolerance) {\r\n            ps_.push(p_);\r\n        }\r\n    }\r\n    */\r\n    //return ps_;\r\n    return ps;\r\n}\r\nexports.closestPointsOnCurve = closestPointsOnCurve;\r\n//# sourceMappingURL=closest-points-on-curve.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/closest-boundary-point/closest-points-on-curve.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/closest-boundary-point/cull-bezier-pieces.js":
/*!************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/closest-boundary-point/cull-bezier-pieces.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_best_distance_squared_1 = __webpack_require__(/*! ./get-best-distance-squared */ \"./node_modules/flo-mat/node/mat/closest-boundary-point/get-best-distance-squared.js\");\r\nconst cull_by_loose_bounding_box_1 = __webpack_require__(/*! ./cull-by-loose-bounding-box */ \"./node_modules/flo-mat/node/mat/closest-boundary-point/cull-by-loose-bounding-box.js\");\r\nconst cull_by_tight_boundary_box_1 = __webpack_require__(/*! ./cull-by-tight-boundary-box */ \"./node_modules/flo-mat/node/mat/closest-boundary-point/cull-by-tight-boundary-box.js\");\r\n/**\r\n *\r\n * @param bezierPieces\r\n * @param p\r\n * @param extreme\r\n */\r\nfunction cullBezierPieces(bezierPieces, p) {\r\n    const CULL_THRESHOLD = 0;\r\n    if (bezierPieces.length > CULL_THRESHOLD) {\r\n        let bestSquaredDistance = get_best_distance_squared_1.getBestDistanceSquared(bezierPieces, p);\r\n        bezierPieces = cull_by_loose_bounding_box_1.cullByLooseBoundingBox(bezierPieces, p, bestSquaredDistance);\r\n        bezierPieces = cull_by_tight_boundary_box_1.cullByTightBoundingBox(bezierPieces, p, bestSquaredDistance);\r\n    }\r\n    return bezierPieces;\r\n}\r\nexports.cullBezierPieces = cullBezierPieces;\r\n//# sourceMappingURL=cull-bezier-pieces.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/closest-boundary-point/cull-bezier-pieces.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/closest-boundary-point/cull-by-loose-bounding-box.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/closest-boundary-point/cull-by-loose-bounding-box.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst get_closest_square_distance_to_rect_1 = __webpack_require__(/*! ../geometry/get-closest-square-distance-to-rect */ \"./node_modules/flo-mat/node/mat/geometry/get-closest-square-distance-to-rect.js\");\r\n/**\r\n * When checking distances, ignore all those with closest possible distance\r\n * further than 'bestSquaredDistance', i.e. cull them.\r\n * @param bezierPieces\r\n * @param p\r\n * @param dSquared\r\n */\r\nfunction cullByLooseBoundingBox(bezierPieces, p, dSquared) {\r\n    let candidateBezierPieces = [];\r\n    for (let i = 0; i < bezierPieces.length; i++) {\r\n        let bezierPiece = bezierPieces[i];\r\n        let ps = bezierPiece.curve.ps;\r\n        let boundingBox = flo_bezier3_1.getBoundingBox(ps);\r\n        let d = get_closest_square_distance_to_rect_1.getClosestSquareDistanceToRect(boundingBox, p);\r\n        if (d <= dSquared) {\r\n            candidateBezierPieces.push(bezierPiece);\r\n        }\r\n    }\r\n    return candidateBezierPieces;\r\n}\r\nexports.cullByLooseBoundingBox = cullByLooseBoundingBox;\r\n//# sourceMappingURL=cull-by-loose-bounding-box.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/closest-boundary-point/cull-by-loose-bounding-box.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/closest-boundary-point/cull-by-tight-boundary-box.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/closest-boundary-point/cull-by-tight-boundary-box.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst get_closest_squared_distance_to_rotated_rect_1 = __webpack_require__(/*! ../geometry/get-closest-squared-distance-to-rotated-rect */ \"./node_modules/flo-mat/node/mat/geometry/get-closest-squared-distance-to-rotated-rect.js\");\r\n/**\r\n * When checking distances, ignore all those with closest possible distance\r\n * further than 'bestSquaredDistance', i.e. cull them.\r\n * @param bezierPieces\r\n * @param p\r\n * @param bestSquaredDistance\r\n */\r\nfunction cullByTightBoundingBox(bezierPieces, p, bestSquaredDistance) {\r\n    let candidateBezierPieces = [];\r\n    for (let i = 0; i < bezierPieces.length; i++) {\r\n        let bezierPiece = bezierPieces[i];\r\n        let ps = bezierPiece.curve.ps;\r\n        let tightBoundingBox = flo_bezier3_1.getBoundingBoxTight(ps);\r\n        let d = get_closest_squared_distance_to_rotated_rect_1.getClosestSquaredDistanceToRotatedRect(tightBoundingBox, p);\r\n        if (d <= bestSquaredDistance) {\r\n            candidateBezierPieces.push(bezierPiece);\r\n        }\r\n    }\r\n    return candidateBezierPieces;\r\n}\r\nexports.cullByTightBoundingBox = cullByTightBoundingBox;\r\n//# sourceMappingURL=cull-by-tight-boundary-box.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/closest-boundary-point/cull-by-tight-boundary-box.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/closest-boundary-point/get-best-distance-squared.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/closest-boundary-point/get-best-distance-squared.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\n/**\r\n * Finds an initial distance such that the closest point can not be further than\r\n * this distance away.\r\n */\r\nfunction getBestDistanceSquared(bezierPieces, p) {\r\n    let bestSquaredDistance = Number.POSITIVE_INFINITY;\r\n    for (let i = 0; i < bezierPieces.length; i++) {\r\n        let bezierPiece = bezierPieces[i];\r\n        let ps = bezierPiece.curve.ps;\r\n        let evPs = flo_bezier3_1.evaluate(ps);\r\n        let p1 = evPs(bezierPiece.ts[0]);\r\n        let p2 = evPs(bezierPiece.ts[1]);\r\n        let d = Math.min(flo_vector2d_1.squaredDistanceBetween(p, p1), flo_vector2d_1.squaredDistanceBetween(p, p2));\r\n        if (d < bestSquaredDistance) {\r\n            bestSquaredDistance = d;\r\n        }\r\n    }\r\n    // The extra multiplier is to account for floating point precision.\r\n    return bestSquaredDistance * 1.01;\r\n}\r\nexports.getBestDistanceSquared = getBestDistanceSquared;\r\n//# sourceMappingURL=get-best-distance-squared.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/closest-boundary-point/get-best-distance-squared.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/closest-boundary-point/get-close-boundary-points.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/closest-boundary-point/get-close-boundary-points.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nconst cull_bezier_pieces_1 = __webpack_require__(/*! ./cull-bezier-pieces */ \"./node_modules/flo-mat/node/mat/closest-boundary-point/cull-bezier-pieces.js\");\r\nconst closest_points_on_curve_1 = __webpack_require__(/*! ./closest-points-on-curve */ \"./node_modules/flo-mat/node/mat/closest-boundary-point/closest-points-on-curve.js\");\r\n/**\r\n * Returns the closest boundary point to the given point, limited to the given\r\n * bezier pieces, including the beziers actually checked after culling.\r\n * @param bezierPieces\r\n * @param point\r\n * @param touchedCurve\r\n * @param t\r\n * @param extreme\r\n */\r\nfunction getCloseBoundaryPoints(bezierPieces, point, touchedCurve, t, distance) {\r\n    bezierPieces = cull_bezier_pieces_1.cullBezierPieces(bezierPieces, point);\r\n    // TODO - integrate with is-another-cp-closeby - we MUST check angle too!\r\n    let DISTANCE_TOLERANCE = 1e-9;\r\n    let posInfos = [];\r\n    for (let i = 0; i < bezierPieces.length; i++) {\r\n        let bezierPiece = bezierPieces[i];\r\n        // TOOD - important - should be able to return multiple points\r\n        let ps = closest_points_on_curve_1.closestPointsOnCurve(bezierPiece.curve, point, bezierPiece.ts, touchedCurve, t, distance, DISTANCE_TOLERANCE);\r\n        //if (ps === undefined) { continue; }\r\n        for (let j = 0; j < ps.length; j++) {\r\n            let p = ps[j];\r\n            let d = flo_vector2d_1.distanceBetween(p.p, point);\r\n            let curve = bezierPiece.curve;\r\n            let t_ = p.t;\r\n            if (Math.abs(d - distance) < DISTANCE_TOLERANCE) {\r\n                if (t_ === 0) {\r\n                    t_ = 1;\r\n                    curve = bezierPiece.curve.prev;\r\n                }\r\n                posInfos.push({ pos: new point_on_shape_1.PointOnShape(curve, t_), d });\r\n            }\r\n        }\r\n    }\r\n    if (posInfos.length > 1) {\r\n        // Remove ones that are too close together.\r\n        // TODO - in future remove all these checks and join n-prongs when they\r\n        // are being added - much simpler and more symmetric. Remeber order when\r\n        // comparing closeness!\r\n        let indexesToCheck = [];\r\n        for (let i = 0; i < posInfos.length; i++) {\r\n            let pi = posInfos[i];\r\n            // Only check if they are close to the edges.\r\n            if (pi.pos.t < 1e-2 || 1 - pi.pos.t < 1e-2) {\r\n                indexesToCheck.push(i);\r\n            }\r\n        }\r\n        let indexesToRemove = [];\r\n        for (let i = 0; i < indexesToCheck.length; i++) {\r\n            for (let j = i + 1; j < indexesToCheck.length; j++) {\r\n                if (i === j) {\r\n                    continue;\r\n                }\r\n                let p1 = posInfos[indexesToCheck[i]].pos.p;\r\n                let p2 = posInfos[indexesToCheck[j]].pos.p;\r\n                if (Math.abs(p1[0] - p2[0]) < 1e-6 && Math.abs(p1[1] - p2[1]) < 1e-6) {\r\n                    indexesToRemove.push(indexesToCheck[i]);\r\n                }\r\n            }\r\n        }\r\n        for (let i = indexesToRemove.length - 1; i >= 0; i--)\r\n            posInfos.splice(indexesToRemove[i], 1);\r\n    }\r\n    return posInfos;\r\n}\r\nexports.getCloseBoundaryPoints = getCloseBoundaryPoints;\r\n//# sourceMappingURL=get-close-boundary-points.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/closest-boundary-point/get-close-boundary-points.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/closest-boundary-point/get-closest-boundary-point.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/closest-boundary-point/get-closest-boundary-point.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nconst cull_bezier_pieces_1 = __webpack_require__(/*! ./cull-bezier-pieces */ \"./node_modules/flo-mat/node/mat/closest-boundary-point/cull-bezier-pieces.js\");\r\nconst closest_point_on_curve_1 = __webpack_require__(/*! ./closest-point-on-curve */ \"./node_modules/flo-mat/node/mat/closest-boundary-point/closest-point-on-curve.js\");\r\n/**\r\n * Returns the closest boundary point to the given point, limited to the given\r\n * bezier pieces, including the beziers actually checked after culling.\r\n * @param bezierPieces\r\n * @param point\r\n * @param touchedCurve\r\n * @param t\r\n * @param extreme\r\n */\r\nfunction getClosestBoundaryPoint(bezierPieces, point, touchedCurve, t) {\r\n    bezierPieces = cull_bezier_pieces_1.cullBezierPieces(bezierPieces, point);\r\n    let bestDistance = Number.POSITIVE_INFINITY;\r\n    let posInfo;\r\n    for (let i = 0; i < bezierPieces.length; i++) {\r\n        let bezierPiece = bezierPieces[i];\r\n        let p = closest_point_on_curve_1.closestPointOnCurve(bezierPiece.curve, point, bezierPiece.ts, touchedCurve, t);\r\n        if (p === undefined) {\r\n            continue;\r\n        }\r\n        let d = flo_vector2d_1.distanceBetween(p.p, point);\r\n        let curve = bezierPiece.curve;\r\n        let t_ = p.t;\r\n        if (d < bestDistance) {\r\n            if (t_ === 0) {\r\n                t_ = 1;\r\n                curve = bezierPiece.curve.prev;\r\n            }\r\n            posInfo = { pos: new point_on_shape_1.PointOnShape(curve, t_), d };\r\n            bestDistance = d;\r\n        }\r\n    }\r\n    return posInfo;\r\n}\r\nexports.getClosestBoundaryPoint = getClosestBoundaryPoint;\r\n//# sourceMappingURL=get-closest-boundary-point.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/closest-boundary-point/get-closest-boundary-point.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/create-new-cp-tree.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/create-new-cp-tree.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_ll_rb_tree_1 = __webpack_require__(/*! flo-ll-rb-tree */ \"./node_modules/flo-ll-rb-tree/node/index.js\");\r\nconst cp_node_1 = __webpack_require__(/*! ../cp-node */ \"./node_modules/flo-mat/node/cp-node.js\");\r\nfunction createNewCpTree(cpNode) {\r\n    let newCpTrees = new Map();\r\n    let cps = cpNode.getAllOnLoop();\r\n    cps.forEach(f);\r\n    // TODO - (done) This function is broken! We must simply go around the shape with \r\n    // cpNode.next.next... instead of using traverseEdges. \r\n    //traverseEdges(cpNode, f, true);\r\n    function f(cpNode) {\r\n        let loop = cpNode.cp.pointOnShape.curve.loop;\r\n        let cpTree = newCpTrees.get(loop);\r\n        if (!cpTree) {\r\n            cpTree = new flo_ll_rb_tree_1.default(cp_node_1.CpNode.comparator, [], true);\r\n            newCpTrees.set(loop, cpTree);\r\n        }\r\n        cpTree.insert(cpNode);\r\n    }\r\n    return newCpTrees;\r\n}\r\nexports.createNewCpTree = createNewCpTree;\r\n//# sourceMappingURL=create-new-cp-tree.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/create-new-cp-tree.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/add-1-prong.js":
/*!***************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/add-1-prong.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nconst add_to_cp_graph_1 = __webpack_require__(/*! ../add-to-cp-graph */ \"./node_modules/flo-mat/node/mat/add-to-cp-graph.js\");\r\nconst is_another_cp_closeby_1 = __webpack_require__(/*! ../is-another-cp-closeby */ \"./node_modules/flo-mat/node/mat/is-another-cp-closeby.js\");\r\n/**\r\n * Add a 1-prong to the MAT.\r\n * @param cpGraphs\r\n * @param pos\r\n */\r\nfunction add1Prong(maxOsculatingCircleRadius, cpGraphs, pos) {\r\n    if (point_on_shape_1.PointOnShape.isDullCorner(pos)) {\r\n        // This is a 1-prong at a dull corner.\r\n        // TODO IMPORTANT \r\n        // Remove this line, uncomment piece below it and implement the \r\n        // following strategy to find the 3-prongs: if deltas are conjoined due \r\n        // to dull corner, split the conjoinment by inserting successively \r\n        // closer (binary division) 2-prongs. If a 2-prong actually fails, \r\n        // simply remove the 1-prong at the dull corner. In this way **all** \r\n        // terminal points are found, e.g. zoom in on top left leg of ant.\r\n        // Afterthought: there is a better way - split points by two prongs.\r\n        //toRemove.push(posNode); // this!\r\n        if (typeof _debug_ !== 'undefined') {\r\n            _debug_.generated.elems.oneProngAtDullCorner.push(pos);\r\n        }\r\n        return;\r\n    }\r\n    let circle = point_on_shape_1.PointOnShape.getOsculatingCircle(maxOsculatingCircleRadius, pos);\r\n    //console.log(maxOsculatingCircleRadius)\r\n    let order = point_on_shape_1.PointOnShape.calcOrder(circle, pos);\r\n    // Make sure there isn't already a ContactPoint close by - it can cause\r\n    // floating point stability issues.\r\n    if (is_another_cp_closeby_1.isAnotherCpCloseby(cpGraphs, pos, circle, order, 0, 1000, 'magenta')) {\r\n        return;\r\n    }\r\n    add_to_cp_graph_1.addToCpGraph(circle, [-0.5, +0.5], cpGraphs, [pos, pos]);\r\n    if (typeof _debug_ !== 'undefined') {\r\n        _debug_.generated.elems.oneProng.push(pos);\r\n    }\r\n}\r\nexports.add1Prong = add1Prong;\r\n//# sourceMappingURL=add-1-prong.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/add-1-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/add-2-prong.js":
/*!***************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/add-2-prong.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst cp_node_1 = __webpack_require__(/*! ../../cp-node */ \"./node_modules/flo-mat/node/cp-node.js\");\r\nconst contact_point_1 = __webpack_require__(/*! ../../contact-point */ \"./node_modules/flo-mat/node/contact-point.js\");\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nconst is_another_cp_closeby_1 = __webpack_require__(/*! ../is-another-cp-closeby */ \"./node_modules/flo-mat/node/mat/is-another-cp-closeby.js\");\r\nconst get_neighboring_cps_1 = __webpack_require__(/*! ../get-neighboring-cps */ \"./node_modules/flo-mat/node/mat/get-neighboring-cps.js\");\r\n/**\r\n * Adds a 2-prong contact circle to the shape.\r\n * @param cpGraphs\r\n * @param circle Circle containing the 2 contact points\r\n * @param posSource The source point on shape\r\n * @param posAntipode The found antipodal point on shape\r\n * @param holeClosing True if this is a hole-closing 2-prong, false otherwise\r\n * @param extreme The maximum coordinate value used to calculate floating point\r\n * tolerances.\r\n */\r\nfunction add2Prong(cpGraphs, circle, posSource, \r\n//posAntipode   : PointOnShape, \r\nposAntipodes, holeClosing, extreme) {\r\n    let orderSource = point_on_shape_1.PointOnShape.calcOrder(circle, posSource);\r\n    let orderAntipodes = posAntipodes.map(posAntipode => point_on_shape_1.PointOnShape.calcOrder(circle, posAntipode.pos));\r\n    let t_s = posSource.t;\r\n    let curve;\r\n    if (t_s === 0) {\r\n        t_s = 1;\r\n        curve = posSource.curve.prev;\r\n        posSource = new point_on_shape_1.PointOnShape(curve, t_s);\r\n    }\r\n    // Make sure there isn't already a ContactPoint close by - it can cause\r\n    // floating point stability issues.\r\n    // TODO - possibly combine n-prongs in this case\r\n    let isCloseByAntipodes = false;\r\n    for (let i = 0; i < posAntipodes.length; i++) {\r\n        let posAntipode = posAntipodes[i];\r\n        let orderAntipode = orderAntipodes[i];\r\n        if (is_another_cp_closeby_1.isAnotherCpCloseby(cpGraphs, posAntipode.pos, circle, orderAntipode, 0, extreme, 'red')) {\r\n            isCloseByAntipodes = true;\r\n            break;\r\n        }\r\n    }\r\n    if (is_another_cp_closeby_1.isAnotherCpCloseby(cpGraphs, posSource, circle, orderSource, 0, extreme, 'red') ||\r\n        isCloseByAntipodes) {\r\n        if (typeof _debug_ !== 'undefined') {\r\n            if (holeClosing) {\r\n                _debug_.generated.elems['twoProng_holeClosing'].pop();\r\n            }\r\n            else {\r\n                _debug_.generated.elems['twoProng_regular'].pop();\r\n            }\r\n        }\r\n        return;\r\n    }\r\n    // Antipode\r\n    let newCpAntipodes = [];\r\n    let cpAntipodes = [];\r\n    let cpTreeAntipodes = [];\r\n    let deltaAntipodes = [];\r\n    let loopAntipodes = [];\r\n    for (let i = 0; i < posAntipodes.length; i++) {\r\n        let posAntipode = posAntipodes[i];\r\n        let orderAntipode = orderAntipodes[i];\r\n        let cpAntipode = new contact_point_1.ContactPoint(posAntipode.pos, circle, orderAntipode, 0);\r\n        cpAntipodes.push(cpAntipode);\r\n        let loopAntipode = posAntipode.pos.curve.loop;\r\n        loopAntipodes.push(loopAntipode);\r\n        let cpTreeAntipode = cpGraphs.get(loopAntipode);\r\n        cpTreeAntipodes.push(cpTreeAntipode);\r\n        let deltaAntipode = get_neighboring_cps_1.getNeighbouringPoints(cpTreeAntipode, posAntipode.pos, orderAntipode, 0);\r\n        deltaAntipodes.push(deltaAntipode);\r\n        newCpAntipodes.push(cp_node_1.CpNode.insert(holeClosing, false, cpTreeAntipode, cpAntipode, deltaAntipode[0]));\r\n    }\r\n    //console.log(cpAntipode.pointOnShape.t);\r\n    // Source\r\n    let cpSource = new contact_point_1.ContactPoint(posSource, circle, orderSource, 0);\r\n    let loopSource = posSource.curve.loop;\r\n    let cpTreeSource = cpGraphs.get(loopSource);\r\n    let deltaSource = get_neighboring_cps_1.getNeighbouringPoints(cpTreeSource, posSource, orderSource, 0);\r\n    let newCpSource = cp_node_1.CpNode.insert(holeClosing, false, cpTreeSource, cpSource, deltaSource[0]);\r\n    //console.log(cpSource.pointOnShape.t);\r\n    // Connect graph\r\n    if (newCpAntipodes.length === 1) {\r\n        newCpSource.prevOnCircle = newCpAntipodes[0];\r\n        newCpSource.nextOnCircle = newCpAntipodes[0];\r\n        newCpAntipodes[0].prevOnCircle = newCpSource;\r\n        newCpAntipodes[0].nextOnCircle = newCpSource;\r\n    }\r\n    else {\r\n        let cpNodes = newCpAntipodes.slice();\r\n        cpNodes.push(newCpSource);\r\n        cpNodes.sort(cp_node_1.CpNode.comparator);\r\n        for (let i = 0; i < cpNodes.length; i++) {\r\n            let iNext = (i + 1 === cpNodes.length) ? 0 : i + 1;\r\n            let iPrev = (i === 0) ? cpNodes.length - 1 : i - 1;\r\n            let cpNodeCurr = cpNodes[i];\r\n            let cpNodeNext = cpNodes[iNext];\r\n            let cpNodePrev = cpNodes[iPrev];\r\n            cpNodeCurr.nextOnCircle = cpNodeNext;\r\n            cpNodeCurr.prevOnCircle = cpNodePrev;\r\n        }\r\n    }\r\n    if (holeClosing) {\r\n        // TODO - important - take care of case where there are more than 1 antipode\r\n        // Duplicate ContactPoints\r\n        let cpB2 = new contact_point_1.ContactPoint(posAntipodes[0].pos, circle, cpAntipodes[0].order, +1);\r\n        let newCpB2Node = cp_node_1.CpNode.insert(true, false, cpTreeAntipodes[0], cpB2, newCpAntipodes[0]);\r\n        let cpB1 = new contact_point_1.ContactPoint(posSource, circle, cpSource.order, -1);\r\n        let newCpB1Node = cp_node_1.CpNode.insert(true, false, cpTreeSource, cpB1, newCpSource.prev);\r\n        // Connect graph\r\n        newCpB1Node.prevOnCircle = newCpB2Node;\r\n        newCpB1Node.nextOnCircle = newCpB2Node;\r\n        newCpB2Node.prevOnCircle = newCpB1Node;\r\n        newCpB2Node.nextOnCircle = newCpB1Node;\r\n        newCpAntipodes[0].next = newCpSource;\r\n        newCpSource.prev = newCpAntipodes[0];\r\n        newCpB1Node.next = newCpB2Node;\r\n        newCpB2Node.prev = newCpB1Node;\r\n    }\r\n    if (typeof _debug_ !== 'undefined') {\r\n        let elems;\r\n        if (holeClosing) {\r\n            elems = _debug_.generated.elems['twoProng_holeClosing'];\r\n        }\r\n        else {\r\n            elems = _debug_.generated.elems['twoProng_regular'];\r\n        }\r\n        let elem = elems[elems.length - 1];\r\n        if (!newCpSource) {\r\n            console.log('asas');\r\n        }\r\n        elem.cpNode = newCpSource;\r\n    }\r\n    return newCpSource;\r\n}\r\nexports.add2Prong = add2Prong;\r\n//# sourceMappingURL=add-2-prong.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/add-2-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/add-3-prong.js":
/*!***************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/add-3-prong.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst add_to_cp_graph_1 = __webpack_require__(/*! ../add-to-cp-graph */ \"./node_modules/flo-mat/node/mat/add-to-cp-graph.js\");\r\nconst is_another_cp_closeby_1 = __webpack_require__(/*! ../is-another-cp-closeby */ \"./node_modules/flo-mat/node/mat/is-another-cp-closeby.js\");\r\n/**\r\n * Adds a 3-prong MAT circle according to the 3 given (previously calculated)\r\n * points on the shape.\r\n * @param cpTrees\r\n * @param orders\r\n * @param threeProng\r\n */\r\nfunction add3Prong(cpTrees, orders, threeProng) {\r\n    let { circle, ps, δ3s } = threeProng;\r\n    // Keep for possible future debugging.\t\r\n    /*\r\n    if (typeof _debug_ !== 'undefined') {\r\n        for (let i=0; i<3; i++) {\r\n            let cpBef = threeProng.δ3s[i][0].cp;\r\n            let cpAft = threeProng.δ3s[i][1].cp;\r\n            //let cmpBef = PointOnShape.compareInclOrder(cpBef.pointOnShape, ps[i], cpBef.order, orders[i]);\r\n            //let cmpAft = PointOnShape.compareInclOrder(cpAft.pointOnShape, ps[i], cpAft.order, orders[i]);\r\n\r\n            let cmpBef = PointOnShape.compare(cpBef.pointOnShape, ps[i]);\r\n            let cmpAft = PointOnShape.compare(cpAft.pointOnShape, ps[i]);\r\n\r\n            // len is used by debug functions to reference a particular\r\n            // three-prong.\r\n            let len = _debug_.generated.elems.threeProng.length-1;\r\n            if (cmpBef > 0) {\r\n                console.log('----------------------------------------');\r\n                console.log(`3-prong order is wrong (bef) : i: ${i} - cmp: ${cmpBef} - n: ${len}`);\r\n                console.log(threeProng);\r\n                console.log(cpBef);\r\n                console.log(cpAft);\r\n                console.log(ps[i]);\r\n            }\r\n            if (cmpAft < 0) {\r\n                console.log('----------------------------------------');\r\n                console.log(`3-prong order is wrong (aft) : i: ${i} - cmp: ${cmpAft} - n: ${len}`);\r\n                console.log(threeProng);\r\n                console.log(cpBef);\r\n                console.log(cpAft);\r\n                console.log(ps[i]);\r\n            }\r\n        }\r\n    }\r\n    */\r\n    // TODO - replace 1000 below with correct value\r\n    is_another_cp_closeby_1.isAnotherCpCloseby(cpTrees, ps[0], circle, orders[0], 0, 1000, 'blue');\r\n    is_another_cp_closeby_1.isAnotherCpCloseby(cpTrees, ps[1], circle, orders[1], 0, 1000, 'blue');\r\n    is_another_cp_closeby_1.isAnotherCpCloseby(cpTrees, ps[2], circle, orders[2], 0, 1000, 'blue');\r\n    add_to_cp_graph_1.addToCpGraph(circle, orders, cpTrees, ps, δ3s);\r\n    return circle;\r\n}\r\nexports.add3Prong = add3Prong;\r\n//# sourceMappingURL=add-3-prong.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/add-3-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/add-debug-info.js":
/*!******************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/add-debug-info.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nfunction addDebugInfo1(loops) {\r\n    if (typeof _debug_ === 'undefined') {\r\n        return;\r\n    }\r\n    for (let loop of loops) {\r\n        _debug_.fs.nameObj(loop, 'l|');\r\n    }\r\n    let generated = _debug_.generated;\r\n    generated.timing.holeClosers[0] = performance.now();\r\n    generated.elems.loop.push(...loops);\r\n    generated.elems.loops.push(loops);\r\n    for (let loop of loops) {\r\n        let i = 0;\r\n        loop.curves.forEach(function (curve) {\r\n            let ps = curve.ps;\r\n            let hull = flo_bezier3_1.getBoundingHull(ps);\r\n            generated.elems.boundingHull.push(hull);\r\n            let looseBoundingBox = flo_bezier3_1.getBoundingBox(ps);\r\n            generated.elems.looseBoundingBox.push(looseBoundingBox);\r\n            let tightBoundingBox = flo_bezier3_1.getBoundingBoxTight(ps);\r\n            generated.elems.tightBoundingBox.push(tightBoundingBox);\r\n            i++;\r\n        });\r\n    }\r\n}\r\nexports.addDebugInfo1 = addDebugInfo1;\r\nfunction addDebugInfo2(pointOnShapeArrPerLoop) {\r\n    if (typeof _debug_ === 'undefined') {\r\n        return;\r\n    }\r\n    let generated = _debug_.generated;\r\n    let timing = generated.timing;\r\n    let now = performance.now();\r\n    timing.holeClosers[1] += now - timing.holeClosers[0];\r\n    timing.oneAnd2Prongs[0] = now;\r\n    for (let pointsOnShape of pointOnShapeArrPerLoop) {\r\n        for (let pos of pointsOnShape) {\r\n            if (point_on_shape_1.PointOnShape.isSharpCorner(pos)) {\r\n                generated.elems.sharpCorner.push(pos);\r\n            }\r\n            else {\r\n                if (point_on_shape_1.PointOnShape.isDullCorner(pos)) {\r\n                    generated.elems.dullCorner.push(pos);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.addDebugInfo2 = addDebugInfo2;\r\nfunction addDebugInfo3() {\r\n    if (typeof _debug_ === 'undefined') {\r\n        return;\r\n    }\r\n    let generated = _debug_.generated;\r\n    let timing = generated.timing;\r\n    let now = performance.now();\r\n    timing.oneAnd2Prongs[1] += now - timing.oneAnd2Prongs[0];\r\n    timing.threeProngs[0] = now;\r\n}\r\nexports.addDebugInfo3 = addDebugInfo3;\r\nfunction addDebugInfo4(mat) {\r\n    if (typeof _debug_ === 'undefined') {\r\n        return;\r\n    }\r\n    let generated = _debug_.generated;\r\n    let timing = generated.timing;\r\n    generated.elems.mat.push(mat);\r\n    timing.threeProngs[1] += performance.now() - timing.threeProngs[0];\r\n    timing.mats[1] =\r\n        timing.holeClosers[1] +\r\n            timing.oneAnd2Prongs[1] +\r\n            timing.threeProngs[1];\r\n}\r\nexports.addDebugInfo4 = addDebugInfo4;\r\n//# sourceMappingURL=add-debug-info.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/add-debug-info.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/create-get-interesting-points-on-loop.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/create-get-interesting-points-on-loop.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_contact_circles_at_interface_1 = __webpack_require__(/*! ../get-contact-circles-at-interface */ \"./node_modules/flo-mat/node/mat/get-contact-circles-at-interface.js\");\r\nconst get_bezier_curvature_extrema_1 = __webpack_require__(/*! ../get-bezier-curvature-extrema */ \"./node_modules/flo-mat/node/mat/get-bezier-curvature-extrema.js\");\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\n/**\r\n * Get useful points on the shape - these incude points of maximum curvature and\r\n * points at the bezier-bezier interfaces.\r\n * @param loop\r\n * @param additionalPointCount\r\n */\r\nfunction createGetInterestingPointsOnLoop(additionalPointCount = 3) {\r\n    return function (loop) {\r\n        let allPoints = [];\r\n        for (let i = 0; i < loop.curves.length; i++) {\r\n            let curve = loop.curves[i];\r\n            let { maxCurvaturePoss, maxNegativeCurvaturePoss } = get_bezier_curvature_extrema_1.getBezierCurvatureExtrema(curve);\r\n            allPoints.push(...get_contact_circles_at_interface_1.getContactCirclesAtInterface(curve), ...maxCurvaturePoss, ...maxNegativeCurvaturePoss);\r\n            let n = additionalPointCount + 1;\r\n            for (let i = 1; i < n; i++) {\r\n                allPoints.push(new point_on_shape_1.PointOnShape(curve, i / n));\r\n            }\r\n        }\r\n        allPoints.sort(point_on_shape_1.PointOnShape.compare);\r\n        return allPoints;\r\n    };\r\n}\r\nexports.createGetInterestingPointsOnLoop = createGetInterestingPointsOnLoop;\r\n//# sourceMappingURL=create-get-interesting-points-on-loop.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/create-get-interesting-points-on-loop.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/create-initial-cp-graph.js":
/*!***************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/create-initial-cp-graph.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_ll_rb_tree_1 = __webpack_require__(/*! flo-ll-rb-tree */ \"./node_modules/flo-ll-rb-tree/node/index.js\");\r\nconst circle_1 = __webpack_require__(/*! ../../circle */ \"./node_modules/flo-mat/node/circle.js\");\r\nconst cp_node_1 = __webpack_require__(/*! ../../cp-node */ \"./node_modules/flo-mat/node/cp-node.js\");\r\nconst contact_point_1 = __webpack_require__(/*! ../../contact-point */ \"./node_modules/flo-mat/node/contact-point.js\");\r\n/**\r\n * Creates the initial ContactPoint loops from the given sharp corners.\r\n * @param shape\r\n * @param sharpCornerss\r\n */\r\nfunction createInitialCpGraph(loops, cpTrees, sharpCornerss, xMap) {\r\n    let cpNode;\r\n    for (let k = 0; k < sharpCornerss.length; k++) {\r\n        let sharpCorners = sharpCornerss[k];\r\n        let cpTree = new flo_ll_rb_tree_1.default(cp_node_1.CpNode.comparator, [], true);\r\n        let cpNode1 = undefined;\r\n        let cpNode2 = undefined;\r\n        for (let pos of sharpCorners) {\r\n            let ps = pos.curve.next.ps;\r\n            let x = xMap.get(ps);\r\n            let isIntersection = !!x;\r\n            let circle = new circle_1.Circle(pos.p, 0);\r\n            let cp1 = new contact_point_1.ContactPoint(pos, circle, -1, 0);\r\n            let cp2 = new contact_point_1.ContactPoint(pos, circle, +1, 0);\r\n            cpNode1 = cp_node_1.CpNode.insert(false, isIntersection, cpTree, cp1, cpNode2);\r\n            cpNode2 = cp_node_1.CpNode.insert(false, isIntersection, cpTree, cp2, cpNode1);\r\n            cpNode1.prevOnCircle = cpNode2;\r\n            cpNode2.prevOnCircle = cpNode1;\r\n            cpNode1.nextOnCircle = cpNode2;\r\n            cpNode2.nextOnCircle = cpNode1;\r\n        }\r\n        if (!cpNode) {\r\n            cpNode = cpNode1;\r\n        }\r\n        let loop = loops[k];\r\n        cpTrees.set(loop, cpTree);\r\n    }\r\n    return cpNode;\r\n}\r\nexports.createInitialCpGraph = createInitialCpGraph;\r\n//# sourceMappingURL=create-initial-cp-graph.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/create-initial-cp-graph.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/find-2-prong/add-debug-info.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/find-2-prong/add-debug-info.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst two_prong_for_debugging_1 = __webpack_require__(/*! ../../../debug/two-prong-for-debugging */ \"./node_modules/flo-mat/node/debug/two-prong-for-debugging.js\");\r\nconst get_two_prong_type_1 = __webpack_require__(/*! ../../get-two-prong-type */ \"./node_modules/flo-mat/node/mat/get-two-prong-type.js\");\r\nfunction addDebugInfo(bezierPieces, failed, pos, circle, z, δ, xs, holeClosing) {\r\n    let twoProng = new two_prong_for_debugging_1.TwoProngForDebugging(_debug_.generated, bezierPieces, pos, δ, z ? z.p : undefined, circle, xs, failed, holeClosing, false, false);\r\n    let twoProngType = get_two_prong_type_1.getTwoProngType(twoProng);\r\n    _debug_.generated.elems[twoProngType].push(twoProng);\r\n}\r\nexports.addDebugInfo = addDebugInfo;\r\n//# sourceMappingURL=add-debug-info.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/find-2-prong/add-debug-info.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/find-2-prong/cull-bezier-pieces.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/find-2-prong/cull-bezier-pieces.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst get_closest_square_distance_to_rect_1 = __webpack_require__(/*! ../../geometry/get-closest-square-distance-to-rect */ \"./node_modules/flo-mat/node/mat/geometry/get-closest-square-distance-to-rect.js\");\r\n/**\r\n * Cull all bezierPieces not within given radius of a given point.\r\n * @param extreme\r\n * @param bezierPieces\r\n * @param p\r\n * @param rSquared\r\n */\r\nfunction cullBezierPieces(bezierPieces, p, rSquared) {\r\n    const CULL_THRESHOLD = 5;\r\n    const TOLERANCE = 1 + 1e-3;\r\n    if (bezierPieces.length <= CULL_THRESHOLD) {\r\n        return bezierPieces;\r\n    }\r\n    let newPieces = [];\r\n    for (let bezierPiece of bezierPieces) {\r\n        let ps = bezierPiece.curve.ps;\r\n        let rect = flo_bezier3_1.getBoundingBox(ps);\r\n        let bd = get_closest_square_distance_to_rect_1.getClosestSquareDistanceToRect(rect, p);\r\n        if (bd <= rSquared * TOLERANCE) {\r\n            newPieces.push(bezierPiece);\r\n        }\r\n    }\r\n    return newPieces;\r\n}\r\nexports.cullBezierPieces = cullBezierPieces;\r\n//# sourceMappingURL=cull-bezier-pieces.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/find-2-prong/cull-bezier-pieces.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/find-2-prong/find-2-prong.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/find-2-prong/find-2-prong.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst line_line_intersection_1 = __webpack_require__(/*! ../../geometry/line-line-intersection */ \"./node_modules/flo-mat/node/mat/geometry/line-line-intersection.js\");\r\nconst get_closest_boundary_point_1 = __webpack_require__(/*! ../../closest-boundary-point/get-closest-boundary-point */ \"./node_modules/flo-mat/node/mat/closest-boundary-point/get-closest-boundary-point.js\");\r\nconst circle_1 = __webpack_require__(/*! ../../../circle */ \"./node_modules/flo-mat/node/circle.js\");\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nconst add_1_prong_1 = __webpack_require__(/*! ../add-1-prong */ \"./node_modules/flo-mat/node/mat/find-mat/add-1-prong.js\");\r\nconst add_debug_info_1 = __webpack_require__(/*! ./add-debug-info */ \"./node_modules/flo-mat/node/mat/find-mat/find-2-prong/add-debug-info.js\");\r\nconst cull_bezier_pieces_1 = __webpack_require__(/*! ./cull-bezier-pieces */ \"./node_modules/flo-mat/node/mat/find-mat/find-2-prong/cull-bezier-pieces.js\");\r\nconst find_equidistant_point_on_line_1 = __webpack_require__(/*! ./find-equidistant-point-on-line */ \"./node_modules/flo-mat/node/mat/find-mat/find-2-prong/find-equidistant-point-on-line.js\");\r\nconst get_initial_bezier_pieces_1 = __webpack_require__(/*! ./get-initial-bezier-pieces */ \"./node_modules/flo-mat/node/mat/find-mat/find-2-prong/get-initial-bezier-pieces.js\");\r\nconst get_close_boundary_points_1 = __webpack_require__(/*! ../../closest-boundary-point/get-close-boundary-points */ \"./node_modules/flo-mat/node/mat/closest-boundary-point/get-close-boundary-points.js\");\r\n/**\r\n * Adds a 2-prong to the MAT. The first point on the shape boundary is given and\r\n * the second one is found by the algorithm.\r\n *\r\n * A 2-prong is defined as a MAT circle that touches the shape at exactly 2\r\n * points.\r\n *\r\n * Before any 2-prongs are added the entire shape is our δΩ (1-prongs do not\r\n * reduce the boundary).\r\n *\r\n * As per the paper by Choi, Choi, Moon and Wee:\r\n *   \"The starting point of this algorithm is a choice of a circle Br(x)\r\n *    centered at an interior point x which contains two boundary portions c and\r\n *    d of dΩ as in Fig. 19.\"\r\n * In fact, we (and they) start by fixing one point on the boundary beforehand.\r\n * @param loops A shape represented by path loops\r\n * @param extreme The extreme coordinate value of the shape\r\n * @param squaredDiagonalLength The squared diagonal length of the shape\r\n * bounding box.\r\n * @param y The source point of the 2-prong to be found\r\n * @param isHoleClosing True if this is a hole-closing two-prong, false otherwise\r\n * @param k The loop array index\r\n */\r\nfunction find2Prong(loops, extreme, squaredDiagonalLength, cpTrees, y, isHoleClosing, k) {\r\n    const MAX_ITERATIONS = 25;\r\n    const squaredSeperationTolerance = Math.pow((1e-6 * extreme), 2);\r\n    //const oneProngTolerance = 1+1e-4;\r\n    const oneProngTolerance = Math.pow((1e-4), 2);\r\n    const squaredErrorTolerance = 1e-2 * squaredSeperationTolerance;\r\n    const maxOsculatingCircleRadiusSquared = squaredDiagonalLength;\r\n    // The boundary piece that should contain the other point of \r\n    // the 2-prong circle. (Defined by start and end points).\r\n    let { bezierPieces, δ } = get_initial_bezier_pieces_1.getInitialBezierPieces(isHoleClosing, k, loops, cpTrees, y);\r\n    /** The center of the two-prong (successively refined) */\r\n    let x;\r\n    let p;\r\n    let r;\r\n    if (isHoleClosing) {\r\n        p = [y.p[0], y.p[1]];\r\n        x = [p[0], p[1] - Math.sqrt(maxOsculatingCircleRadiusSquared)];\r\n        r = maxOsculatingCircleRadiusSquared;\r\n    }\r\n    else {\r\n        p = y.p;\r\n        x = point_on_shape_1.PointOnShape.getOsculatingCircle(maxOsculatingCircleRadiusSquared, y).center;\r\n        r = flo_vector2d_1.squaredDistanceBetween(p, x);\r\n    }\r\n    // The lines below is an optimization.\r\n    let r_ = reduceRadius(extreme, bezierPieces, p, x);\r\n    if (r > r_) {\r\n        x = flo_vector2d_1.interpolate(p, x, Math.sqrt(r_ / r));\r\n    }\r\n    let xs = []; // Trace the convergence (for debugging).\r\n    let z; // The antipode if the two-prong (successively refined)\r\n    let i = 0;\r\n    let done = 0;\r\n    let failed = false; // The failed flag is set if a 2-prong cannot be found.\r\n    let bezierPieces_ = bezierPieces;\r\n    let prevX = undefined;\r\n    do {\r\n        i++;\r\n        let r = flo_vector2d_1.squaredDistanceBetween(x, y.p);\r\n        bezierPieces_ = cull_bezier_pieces_1.cullBezierPieces(bezierPieces_, x, r);\r\n        //for (let bp of bezierPieces_) { \r\n        //_debug_.fs.draw.bezierPiece(_debug_.generated.g, bp.curve.ps, bp.ts, undefined, 0)\r\n        //console.log(bezierPieces_.length)\r\n        //}\r\n        z = get_closest_boundary_point_1.getClosestBoundaryPoint(bezierPieces_, x, y.curve, y.t);\r\n        if (z === undefined) {\r\n            if (typeof _debug_ !== 'undefined') {\r\n                let elems = _debug_.generated.elems;\r\n                let elem = isHoleClosing\r\n                    ? elems.twoProng_holeClosing\r\n                    : elems.twoProng_regular;\r\n                let elemStr = isHoleClosing\r\n                    ? 'hole-closing: ' + elem.length\r\n                    : 'regular: ' + elem.length;\r\n                console.log('failed: no closest point - ' + elemStr);\r\n            }\r\n            failed = true;\r\n            break;\r\n        }\r\n        if (typeof _debug_ !== 'undefined') {\r\n            xs.push({ x, y, z: z.pos, t: y.t });\r\n        }\r\n        let d = flo_vector2d_1.squaredDistanceBetween(x, z.pos.p);\r\n        //if (i === 1 && d*oneProngTolerance >= r) {\r\n        if (i === 1 && r < d + oneProngTolerance) {\r\n            // It is a 1-prong.\r\n            add_1_prong_1.add1Prong(Math.sqrt(maxOsculatingCircleRadiusSquared), cpTrees, y);\r\n            return undefined;\r\n        }\r\n        // TODO - squaredSeperationTolerance should in future be replaced with\r\n        // a relative error, i.e. distance between y (or z) / length(y (or z)).\r\n        if (!isHoleClosing && flo_vector2d_1.squaredDistanceBetween(y.p, z.pos.p) <= squaredSeperationTolerance) {\r\n            if (typeof _debug_ !== 'undefined') {\r\n                let elems = _debug_.generated.elems;\r\n                let elem = isHoleClosing\r\n                    ? elems.twoProng_holeClosing\r\n                    : elems.twoProng_regular;\r\n                let elemStr = isHoleClosing\r\n                    ? 'hole-closing: ' + elem.length\r\n                    : 'regular: ' + elem.length;\r\n                /*\r\n                console.log(\r\n                    'failed: two-prong radius too small - ' + elemStr\r\n                );\r\n                */\r\n            }\r\n            failed = true;\r\n            break;\r\n        }\r\n        // TODO - Accuracy optimization: tolerance should not be between x and \r\n        // nextX, but rather (distance from x to y) - (distance from x to z)\r\n        // Find the point on the line connecting y with x that is  \r\n        // equidistant from y and z. This will be our next x.\r\n        let nextX = find_equidistant_point_on_line_1.findEquidistantPointOnLine(x, y.p, z.pos.p);\r\n        let squaredError = flo_vector2d_1.squaredDistanceBetween(x, nextX);\r\n        prevX = x;\r\n        x = nextX;\r\n        if (squaredError < squaredErrorTolerance) {\r\n            //console.log(Math.sqrt(squaredError));\r\n            done++; // Do one more iteration\r\n        }\r\n        else if (i === MAX_ITERATIONS) {\r\n            // Convergence was too slow.\r\n            failed = true;\r\n            break; // We're done\r\n        }\r\n    } while (done < 1);\r\n    // TODO - Optimization: only do this if second closest point is within the\r\n    // tolerance which can be checked in getClosestBoundaryPoint algorithm\r\n    let zs = [];\r\n    if (!failed) {\r\n        zs = get_close_boundary_points_1.getCloseBoundaryPoints(bezierPieces_, x, y.curve, y.t, flo_vector2d_1.distanceBetween(x, z.pos.p));\r\n        if (!zs.length) {\r\n            //console.log(zs);\r\n            // Numerical issue\r\n            zs.push(z);\r\n        }\r\n        //zs = [z];\r\n    }\r\n    let circle;\r\n    if (z !== undefined) {\r\n        circle = new circle_1.Circle(x, flo_vector2d_1.distanceBetween(x, z.pos.p));\r\n    }\r\n    if (typeof _debug_ !== 'undefined' && !failed) {\r\n        xs.push({ x, y, z: z.pos, t: y.t });\r\n        add_debug_info_1.addDebugInfo(bezierPieces, failed, y, circle, z.pos, δ, xs, isHoleClosing);\r\n    }\r\n    return failed ? undefined : { circle, zs };\r\n    //return failed ? undefined : { circle, z: z.pos };\r\n}\r\nexports.find2Prong = find2Prong;\r\n/**\r\n * Reduces the circle radius initially as an optimization step.\r\n */\r\nfunction reduceRadius(extreme, bezierPieces, p, x) {\r\n    const TOLERANCE = extreme * 1e-3;\r\n    let prevP = undefined;\r\n    let minRadius = Number.POSITIVE_INFINITY;\r\n    for (let i = 0; i < bezierPieces.length; i++) {\r\n        let bezierPiece = bezierPieces[i];\r\n        let ps = bezierPiece.curve.ps;\r\n        let ev = flo_bezier3_1.evaluate(ps);\r\n        let p1 = ev(bezierPiece.ts[0]);\r\n        let r1 = Number.POSITIVE_INFINITY;\r\n        // Prevent evaluating the same points twice\r\n        if (!prevP || prevP[0] !== p1[0] || prevP[1] !== p1[1]) {\r\n            let cc1 = getCircleCenterFrom2PointsAndNormal(extreme, p, x, p1);\r\n            if (cc1) {\r\n                r1 = flo_vector2d_1.squaredDistanceBetween(p, cc1);\r\n            }\r\n        }\r\n        let r2 = Number.POSITIVE_INFINITY;\r\n        let p2 = ev(bezierPiece.ts[1]);\r\n        let cc2 = getCircleCenterFrom2PointsAndNormal(extreme, p, x, p2);\r\n        if (cc2) {\r\n            r2 = flo_vector2d_1.squaredDistanceBetween(p, cc2);\r\n        }\r\n        prevP = p2;\r\n        let d = Math.min(r1, r2);\r\n        if (d < minRadius) {\r\n            minRadius = d;\r\n        }\r\n    }\r\n    // The extra bit is to account for floating point precision.\r\n    return minRadius + TOLERANCE;\r\n}\r\n/**\r\n *\r\n * @param p A point on the circle with normal pointing to x towards the center\r\n * of the circle.\r\n * @param x\r\n * @param p1 Another point on the circle.\r\n */\r\nfunction getCircleCenterFrom2PointsAndNormal(extreme, p, x, p1) {\r\n    let TOLERANCE = Math.pow((1e-4 * extreme), 2);\r\n    // Ignore if p and p1 are too close together\r\n    if (flo_vector2d_1.squaredDistanceBetween(p, p1) < TOLERANCE) {\r\n        return undefined;\r\n    }\r\n    /** The perpindicular bisector between the two given points on the circle */\r\n    let pb = [\r\n        (p[0] + p1[0]) / 2,\r\n        (p[1] + p1[1]) / 2,\r\n    ];\r\n    let tangent = [p1[0] - p[0], p1[1] - p[1]];\r\n    let normal = [-tangent[1], tangent[0]]; // Rotate by 90 degrees\r\n    let pb2 = [pb[0] + normal[0], pb[1] + normal[1]];\r\n    let res = line_line_intersection_1.lineLineIntersection([p, x], [pb, pb2]);\r\n    if (!res) {\r\n        return undefined;\r\n    }\r\n    let resO = [res[0] - p[0], res[1] - p[1]];\r\n    let xO = [x[0] - p[0], x[1] - p[1]];\r\n    if (flo_vector2d_1.dot(resO, xO) < 0) {\r\n        return undefined;\r\n    }\r\n    return res;\r\n}\r\n//# sourceMappingURL=find-2-prong.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/find-2-prong/find-2-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/find-2-prong/find-equidistant-point-on-line.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/find-2-prong/find-equidistant-point-on-line.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n *\r\n * @param x\r\n * @param y\r\n * @param z\r\n * @returns The point on the line from y to x that is equidistant from y and z.\r\n */\r\nfunction findEquidistantPointOnLine(x, y, z) {\r\n    // Some basic algebra (not shown) finds the required point.\r\n    // Swap axes if x and y are more aligned to y-axis than to x-axis.\r\n    let swapAxes = Math.abs((x[1] - y[1]) / (x[0] - y[0])) > 1;\r\n    // Cache\r\n    let x1, x2, y1, y2, z1, z2;\r\n    if (swapAxes) {\r\n        x1 = x[1];\r\n        x2 = x[0];\r\n        y1 = y[1];\r\n        y2 = y[0];\r\n        z1 = z[1];\r\n        z2 = z[0];\r\n    }\r\n    else {\r\n        x1 = x[0];\r\n        x2 = x[1];\r\n        y1 = y[0];\r\n        y2 = y[1];\r\n        z1 = z[0];\r\n        z2 = z[1];\r\n    }\r\n    // a <= 1 (due to swapped axes)\r\n    let a = (x2 - y2) / (x1 - y1);\r\n    let b = y2 - a * y1;\r\n    let c = (y1 * y1 + y2 * y2 - z1 * z1 - z2 * z2) + 2 * b * (z2 - y2);\r\n    let d = y1 - z1 + a * (y2 - z2);\r\n    let t1 = c / (2 * d);\r\n    let t2 = a * t1 + b;\r\n    return swapAxes ? [t2, t1] : [t1, t2];\r\n}\r\nexports.findEquidistantPointOnLine = findEquidistantPointOnLine;\r\n//# sourceMappingURL=find-equidistant-point-on-line.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/find-2-prong/find-equidistant-point-on-line.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/find-2-prong/get-initial-bezier-pieces.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/find-2-prong/get-initial-bezier-pieces.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_neighboring_cps_1 = __webpack_require__(/*! ../../get-neighboring-cps */ \"./node_modules/flo-mat/node/mat/get-neighboring-cps.js\");\r\nconst get_boundary_piece_beziers_1 = __webpack_require__(/*! ../../get-boundary-piece-beziers */ \"./node_modules/flo-mat/node/mat/get-boundary-piece-beziers.js\");\r\nconst bezier_piece_1 = __webpack_require__(/*! ../../../bezier-piece */ \"./node_modules/flo-mat/node/bezier-piece.js\");\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nfunction getInitialBezierPieces(isHoleClosing, k, loops, cpTrees, y) {\r\n    let bezierPieces;\r\n    let δ;\r\n    if (isHoleClosing) {\r\n        bezierPieces = [];\r\n        for (let k2 = 0; k2 < k; k2++) {\r\n            //let pieces = getBoundaryBeziers(loops[k2]);\r\n            let pieces = loops[k2].curves\r\n                .map(curve => new bezier_piece_1.BezierPiece(curve, [0, 1]));\r\n            bezierPieces.push(...pieces);\r\n        }\r\n    }\r\n    else {\r\n        let order = point_on_shape_1.PointOnShape.isDullCorner(y)\r\n            ? y.t === 1 ? -1 : +1\r\n            : 0;\r\n        let loop = loops[k];\r\n        let cpNode = get_neighboring_cps_1.getNeighbouringPoints(cpTrees.get(loop), y, order, 0)[0];\r\n        δ = [cpNode, cpNode];\r\n        if (!cpNode ||\r\n            // The special case if there is only a single sharp corner or \r\n            // terminating 2-prong currently in the MAT. Don't remove!\r\n            (cpNode === cpNode.next.next)) {\r\n            bezierPieces = loop.curves\r\n                .map(curve => new bezier_piece_1.BezierPiece(curve, [0, 1]));\r\n        }\r\n        else {\r\n            bezierPieces = get_boundary_piece_beziers_1.getBoundaryPieceBeziers(δ);\r\n        }\r\n    }\r\n    return { bezierPieces, δ };\r\n}\r\nexports.getInitialBezierPieces = getInitialBezierPieces;\r\n//# sourceMappingURL=get-initial-bezier-pieces.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/find-2-prong/get-initial-bezier-pieces.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/find-3-prong/calc-better-x.js":
/*!******************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/find-3-prong/calc-better-x.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst get_closest_points_1 = __webpack_require__(/*! ./get-closest-points */ \"./node_modules/flo-mat/node/mat/find-mat/find-3-prong/get-closest-points.js\");\r\n/**\r\n * Find new x and ps that are a better estimate of the 3-prong circle.\r\n * The potential function, V, is defined as the distance to the actual 3 prong\r\n * circle center.\r\n * @param bezierPiece3s The three boundary pieces, each of which should contain\r\n * a point of the 3-prong to be found.\r\n * @param x The currently best guess at the center of the 3-prong circle.\r\n * @param vectorToZeroV\r\n * @param extreme\r\n */\r\nfunction calcBetterX(bezierPiece3s, x, vectorToZeroV) {\r\n    let V = flo_vector2d_1.len(vectorToZeroV);\r\n    let nu = 1;\r\n    let better;\r\n    let newX;\r\n    let newPs;\r\n    let newV;\r\n    let i = 0; // Safeguard\r\n    do {\r\n        let shift = flo_vector2d_1.scale(vectorToZeroV, nu);\r\n        newX = flo_vector2d_1.translate(shift, x);\r\n        newPs = get_closest_points_1.getClosestPoints(newX, bezierPiece3s);\r\n        //console.log(newPs.map(pos => '' + pos.p[0] + ' ' + pos.p[1]))\r\n        // Point of zero V\r\n        let newCircleCenter = flo_vector2d_1.circumCenter(newPs.map(pos => pos.p));\r\n        let newVectorToZeroV = flo_vector2d_1.fromTo(newX, newCircleCenter);\r\n        newV = flo_vector2d_1.len(newVectorToZeroV);\r\n        better = newV < V;\r\n        nu = nu / 2;\r\n        i++;\r\n    } while (!better && i < 3);\r\n    return { newX, newV, newPs };\r\n}\r\nexports.calcBetterX = calcBetterX;\r\n//# sourceMappingURL=calc-better-x.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/find-3-prong/calc-better-x.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/find-3-prong/calc-initial-3-prong-center.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/find-3-prong/calc-initial-3-prong-center.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst get_closest_boundary_point_1 = __webpack_require__(/*! ../../closest-boundary-point/get-closest-boundary-point */ \"./node_modules/flo-mat/node/mat/closest-boundary-point/get-closest-boundary-point.js\");\r\n/**\r\n * Finds an initial 3-prong circle center point from which to iterate. The point\r\n * must be within the shape.\r\n * @param δ3s - The three boundary pieces of which we need to find the three\r\n * 3-prong points.\r\n * @param bezierPiece3s\r\n * @param extreme\r\n */\r\nfunction calcInitial3ProngCenter(δ3s, bezierPiece3s) {\r\n    let twoProngCircleCenter = δ3s[0][0].cp.circle.center;\r\n    /*\r\n    let twoProngCircleCenter =\r\n        mean([\r\n            δ3s[0][0].cp.pointOnShape.p,\r\n            δ3s[2][1].cp.pointOnShape.p\r\n        ]);\r\n        */\r\n    //_debug_.fs.draw.dot(_debug_.generated.g, twoProngCircleCenter, 0.05, 'blue');\r\n    let posInfo = get_closest_boundary_point_1.getClosestBoundaryPoint(bezierPiece3s[1], twoProngCircleCenter, undefined, // curve\r\n    undefined // t\r\n    );\r\n    let meanPoints = [\r\n        δ3s[0][0].cp.pointOnShape.p,\r\n        posInfo.pos.p,\r\n        δ3s[2][1].cp.pointOnShape.p,\r\n    ];\r\n    return flo_vector2d_1.circumCenter(meanPoints);\r\n}\r\nexports.calcInitial3ProngCenter = calcInitial3ProngCenter;\r\n//# sourceMappingURL=calc-initial-3-prong-center.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/find-3-prong/calc-initial-3-prong-center.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/find-3-prong/find-3-prong-for-delta3s.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/find-3-prong/find-3-prong-for-delta3s.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst circle_1 = __webpack_require__(/*! ../../../circle */ \"./node_modules/flo-mat/node/circle.js\");\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nconst get_closest_boundary_point_1 = __webpack_require__(/*! ../../closest-boundary-point/get-closest-boundary-point */ \"./node_modules/flo-mat/node/mat/closest-boundary-point/get-closest-boundary-point.js\");\r\nconst calc_initial_3_prong_center_1 = __webpack_require__(/*! ./calc-initial-3-prong-center */ \"./node_modules/flo-mat/node/mat/find-mat/find-3-prong/calc-initial-3-prong-center.js\");\r\nconst get_closest_points_1 = __webpack_require__(/*! ./get-closest-points */ \"./node_modules/flo-mat/node/mat/find-mat/find-3-prong/get-closest-points.js\");\r\nconst calc_better_x_1 = __webpack_require__(/*! ./calc-better-x */ \"./node_modules/flo-mat/node/mat/find-mat/find-3-prong/calc-better-x.js\");\r\nconst curve_1 = __webpack_require__(/*! ../../../curve */ \"./node_modules/flo-mat/node/curve.js\");\r\nconst calcVectorToZeroV_StraightToIt = flo_vector2d_1.fromTo;\r\n/**\r\n * Finds a 3-prong using only the 3 given δs.\r\n * @param δs The boundary pieces\r\n * @param idx δ identifier\r\n * @param bezierPiecess\r\n * @param extreme The maximum coordinate value used to calculate floating point\r\n * tolerances.\r\n */\r\nfunction find3ProngForDelta3s(δs, idx, k, bezierPiecess, extreme) {\r\n    const TOLERANCE = extreme * 1e-10;\r\n    const MAX_ITERATIONS = 10;\r\n    //k = 0;\r\n    /*\r\n    let δ3s = [\r\n        δs[0],\r\n        δs[idx],\r\n        δs[δs.length-1]\r\n    ];\r\n    */\r\n    let δs_ = [\r\n        δs[0],\r\n        δs[idx],\r\n        δs[δs.length - 1]\r\n    ];\r\n    /*\r\n    let bezierPiece3s = [\r\n        bezierPiecess[0],\r\n        bezierPiecess[idx],\r\n        bezierPiecess[δs.length-1]\r\n    ];\r\n    */\r\n    let bezierPieces_ = [\r\n        bezierPiecess[0],\r\n        bezierPiecess[idx],\r\n        bezierPiecess[δs.length - 1]\r\n    ];\r\n    let δ3ss = [\r\n        [δs_[0], δs_[1], δs_[2]],\r\n        [δs_[1], δs_[2], δs_[0]],\r\n        [δs_[2], δs_[0], δs_[1]],\r\n    ];\r\n    let bezierPiecess_ = [\r\n        [bezierPieces_[0], bezierPieces_[1], bezierPieces_[2]],\r\n        [bezierPieces_[1], bezierPieces_[2], bezierPieces_[0]],\r\n        [bezierPieces_[2], bezierPieces_[0], bezierPieces_[1]],\r\n    ];\r\n    let δ3s = δ3ss[k];\r\n    let bezierPiece3s = bezierPiecess_[k];\r\n    if (δ3s[0][0].isSharp()) {\r\n        return undefined;\r\n    }\r\n    let ps;\r\n    let circumCenter_;\r\n    let j = 0; // Safeguard for slow convergence\r\n    let x = calc_initial_3_prong_center_1.calcInitial3ProngCenter(δ3s, bezierPiece3s);\r\n    if (typeof _debug_ !== 'undefined') {\r\n        let threeProngs = _debug_.generated.elems.threeProng;\r\n        let d = threeProngs[threeProngs.length - 1];\r\n        let trace = d.traces[d.traces.length - 1];\r\n        trace.push(x);\r\n    }\r\n    let tolerance = Number.POSITIVE_INFINITY;\r\n    while (tolerance > TOLERANCE && j < MAX_ITERATIONS) {\r\n        j++;\r\n        ps = get_closest_points_1.getClosestPoints(x, bezierPiece3s);\r\n        if (!Number.isFinite(x[0]) || !Number.isFinite(x[1])) {\r\n            // TODO - the code can be cleaned up and sped up a lot if we don't\r\n            // use this function as is but instead use δs[0] and δs[2] as is\r\n            // and make δs[1] include all the rest of the beziers around the \r\n            // loop. This check, for instance, would be eliminated completely.\r\n            return undefined;\r\n        }\r\n        circumCenter_ = flo_vector2d_1.circumCenter(ps.map(x => x.p));\r\n        let vectorToZeroV = calcVectorToZeroV_StraightToIt(x, circumCenter_);\r\n        //console.log('' + x[0] + ' ' + x[1])\r\n        //console.log('' + vectorToZeroV[0] + ' ' + vectorToZeroV[1]);\r\n        if (!Number.isFinite(vectorToZeroV[0]) || !Number.isFinite(vectorToZeroV[1])) {\r\n            // TODO - the code can be cleaned up and sped up a lot if we don't\r\n            // use this function as is but instead use δs[0] and δs[2] as is\r\n            // and make δs[1] include all the rest of the beziers around the \r\n            // loop. This check, for instance, would be eliminated completely.\r\n            return undefined;\r\n        }\r\n        let upds = calc_better_x_1.calcBetterX(bezierPiece3s, x, vectorToZeroV);\r\n        x = upds.newX;\r\n        ps = upds.newPs;\r\n        if (typeof _debug_ !== 'undefined') {\r\n            let threeProngs = _debug_.generated.elems.threeProng;\r\n            let d = threeProngs[threeProngs.length - 1];\r\n            let trace = d.traces[d.traces.length - 1];\r\n            trace.push(x);\r\n        }\r\n        let V = flo_vector2d_1.len(vectorToZeroV); // The 'potential'\r\n        tolerance = Math.abs(V - upds.newV);\r\n    }\r\n    //_debug_.fs.draw.dot(_debug_.generated.g, x, 0.05);\r\n    let radius = (flo_vector2d_1.distanceBetween(x, ps[0].p) +\r\n        flo_vector2d_1.distanceBetween(x, ps[1].p) +\r\n        flo_vector2d_1.distanceBetween(x, ps[2].p)) / 3;\r\n    let circle = new circle_1.Circle(x, radius);\r\n    //-------------------------------------------------------------------------\r\n    // Calculate the unit tangent vector at 3-prong circle points - they should \r\n    // be very close to tangent to the boundary piece tangents at those points \r\n    // (up to sign). Sharp corners are a common special case.\r\n    //-------------------------------------------------------------------------\r\n    let totalAngleError = 0;\r\n    for (let i = 0; i < 3; i++) {\r\n        let p = ps[i];\r\n        //----------------------------\r\n        // Tangent of circle at point\r\n        //----------------------------\r\n        let v = flo_vector2d_1.toUnitVector(flo_vector2d_1.fromTo(p.p, x));\r\n        let v1 = flo_vector2d_1.rotate90Degrees(v);\r\n        //-----------------------------------\r\n        // Check if point is on dull crorner\r\n        //-----------------------------------\r\n        if (point_on_shape_1.PointOnShape.isDullCorner(p)) {\r\n            let corner = curve_1.Curve.getCornerAtEnd(p.curve);\r\n            let tans = corner.tangents;\r\n            let perps = tans.map(flo_vector2d_1.rotate90Degrees);\r\n            let angleError1 = Math.asin(flo_vector2d_1.cross(perps[0], v));\r\n            let angleError2 = Math.asin(flo_vector2d_1.cross(v, perps[1]));\r\n            let angleError = 0;\r\n            if (angleError1 > 0) {\r\n                angleError += angleError1;\r\n            }\r\n            if (angleError2 > 0) {\r\n                angleError += angleError2;\r\n            }\r\n            totalAngleError += angleError;\r\n        }\r\n        else {\r\n            //---------------------------\r\n            // Tangent of curve at point\r\n            //---------------------------\r\n            let v2 = flo_vector2d_1.toUnitVector(flo_bezier3_1.tangent(p.curve.ps, p.t));\r\n            // Cross is more numerically stable than Vector.dot at angles a\r\n            // multiple of Math.PI **and** is close to the actual angle value\r\n            // and can thus just be added to cone method of looking at \r\n            // tolerance.\r\n            // Should be close to zero and is close to the actual angle.\r\n            let cross_ = Math.abs(Math.asin(flo_vector2d_1.cross(v1, v2)));\r\n            totalAngleError += cross_;\r\n        }\r\n    }\r\n    //-------------------------------------------------------------------------\r\n    // Calculate radiusDelta, the difference between the radius and the closest\r\n    // point to the 3-prong. It should be around 0. If not, this is not a good \r\n    // candidate for the 3-prong.\r\n    //-------------------------------------------------------------------------\r\n    let closestDs = [];\r\n    for (let i = 0; i < bezierPiecess.length; i++) {\r\n        let p = get_closest_boundary_point_1.getClosestBoundaryPoint(bezierPiecess[i], x, undefined, undefined);\r\n        closestDs.push(flo_vector2d_1.distanceBetween(p.pos.p, x));\r\n    }\r\n    let closestD = Math.min(...closestDs);\r\n    let radiusDelta = Math.abs(radius - closestD);\r\n    // Weights below still need to be optimized.\r\n    let W1 = 1;\r\n    let W2 = 1;\r\n    let error = W1 * radiusDelta + W2 * totalAngleError;\r\n    return { ps, circle, error, δ3s };\r\n}\r\nexports.find3ProngForDelta3s = find3ProngForDelta3s;\r\n//# sourceMappingURL=find-3-prong-for-delta3s.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/find-3-prong/find-3-prong-for-delta3s.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/find-3-prong/find-3-prong.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/find-3-prong/find-3-prong.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst three_prong_for_debugging_1 = __webpack_require__(/*! ../../../debug/three-prong-for-debugging */ \"./node_modules/flo-mat/node/debug/three-prong-for-debugging.js\");\r\nconst find_3_prong_for_delta3s_1 = __webpack_require__(/*! ./find-3-prong-for-delta3s */ \"./node_modules/flo-mat/node/mat/find-mat/find-3-prong/find-3-prong-for-delta3s.js\");\r\nconst get_boundary_piece_beziers_1 = __webpack_require__(/*! ../../get-boundary-piece-beziers */ \"./node_modules/flo-mat/node/mat/get-boundary-piece-beziers.js\");\r\n/**\r\n * Find and return a 3-prong from the given boundary piece.\r\n * @param δs A boundary piece\r\n * @param extreme The maximum coordinate value used to calculate floating point\r\n * tolerances.\r\n */\r\nfunction find3Prong(δs, extreme) {\r\n    let bezierPiecess = δs.map(get_boundary_piece_beziers_1.getBoundaryPieceBeziers);\r\n    if (typeof _debug_ !== 'undefined') {\r\n        let threeProngs = _debug_.generated.elems.threeProng;\r\n        threeProngs.push(new three_prong_for_debugging_1.ThreeProngForDebugging());\r\n        let d = threeProngs[threeProngs.length - 1];\r\n        d.boundaries = [];\r\n        for (let bezierPieces of bezierPiecess) {\r\n            let boundary = [];\r\n            d.boundaries.push(boundary);\r\n            for (let bezierPiece of bezierPieces) {\r\n                let bezier = flo_bezier3_1.fromTo(bezierPiece.curve.ps)(bezierPiece.ts[0], bezierPiece.ts[1]);\r\n                boundary.push(bezier);\r\n            }\r\n        }\r\n        d.traces = [];\r\n    }\r\n    let candidateThreeProngs = [];\r\n    // The best candidate amongst the different 'permutations' of the given δs.\r\n    let threeProng;\r\n    let bestIndx = undefined;\r\n    let smallestError = Number.POSITIVE_INFINITY;\r\n    for (let i = 1; i < δs.length - 1; i++) {\r\n        for (let k = 0; k < 3; k++) {\r\n            //let k = 0;\r\n            if (typeof _debug_ !== 'undefined') {\r\n                let threeProngs = _debug_.generated.elems.threeProng;\r\n                let d = threeProngs[threeProngs.length - 1];\r\n                let trace = [];\r\n                d.traces.push(trace);\r\n            }\r\n            let threeProngInfo = find_3_prong_for_delta3s_1.find3ProngForDelta3s(δs, i, k, bezierPiecess, extreme);\r\n            if (!threeProngInfo) {\r\n                continue;\r\n            }\r\n            let { circle, ps, error, δ3s } = threeProngInfo;\r\n            if (typeof _debug_ !== 'undefined') {\r\n                candidateThreeProngs.push({ circle, ps });\r\n            }\r\n            if (error < smallestError) {\r\n                smallestError = error;\r\n                bestIndx = i - 1;\r\n                threeProng = { circle, ps, δ3s };\r\n            }\r\n        }\r\n    }\r\n    //threeProng.δ3s = [δs[0], δs[bestIndx+1], δs[δs.length-1]];\r\n    if (typeof _debug_ !== 'undefined') {\r\n        let threeProngs = _debug_.generated.elems.threeProng;\r\n        let d = threeProngs[threeProngs.length - 1];\r\n        d.generated = _debug_.generated;\r\n        d.circle = threeProng.circle,\r\n            d.poss = threeProng.ps;\r\n        d.cp3ss = threeProng.δ3s;\r\n        d.cpss = δs;\r\n        d.bestIndx = bestIndx;\r\n        d.candidateThreeProngs = candidateThreeProngs;\r\n    }\r\n    return threeProng;\r\n}\r\nexports.find3Prong = find3Prong;\r\n//# sourceMappingURL=find-3-prong.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/find-3-prong/find-3-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/find-3-prong/get-closest-points.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/find-3-prong/get-closest-points.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_closest_boundary_point_1 = __webpack_require__(/*! ../../closest-boundary-point/get-closest-boundary-point */ \"./node_modules/flo-mat/node/mat/closest-boundary-point/get-closest-boundary-point.js\");\r\n/**\r\n *\r\n * @param x\r\n * @param bezierPiece3s\r\n * @param extreme\r\n */\r\nfunction getClosestPoints(x, bezierPiece3s) {\r\n    return bezierPiece3s.map(bezierPieces => {\r\n        let posInfo = get_closest_boundary_point_1.getClosestBoundaryPoint(bezierPieces, x, undefined, // curve\r\n        undefined // t\r\n        );\r\n        return posInfo ? posInfo.pos : undefined;\r\n    });\r\n}\r\nexports.getClosestPoints = getClosestPoints;\r\n//# sourceMappingURL=get-closest-points.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/find-3-prong/get-closest-points.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/find-and-add-2-prongs-on-all-paths.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/find-and-add-2-prongs-on-all-paths.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst find_and_add_2_prongs_1 = __webpack_require__(/*! ./find-and-add-2-prongs */ \"./node_modules/flo-mat/node/mat/find-mat/find-and-add-2-prongs.js\");\r\n/**\r\n * Add 2 prongs. See comments on the add2Prong function.\r\n * @param loops\r\n * @param cpGraphs\r\n * @param for2Prongss\r\n * @param extreme The maximum coordinate value used to calculate floating point\r\n * tolerances.\r\n */\r\nfunction findAndAdd2ProngsOnAllPaths(loops, cpGraphs, for2Prongss, extreme) {\r\n    let cpNode;\r\n    for (let k = 0; k < for2Prongss.length; k++) {\r\n        let for2Prongs = for2Prongss[k];\r\n        cpNode = find_and_add_2_prongs_1.findAndAdd2Prongs(loops, cpGraphs, k, for2Prongs, extreme);\r\n    }\r\n    return cpNode;\r\n}\r\nexports.findAndAdd2ProngsOnAllPaths = findAndAdd2ProngsOnAllPaths;\r\n//# sourceMappingURL=find-and-add-2-prongs-on-all-paths.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/find-and-add-2-prongs-on-all-paths.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/find-and-add-2-prongs.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/find-and-add-2-prongs.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_shape_bounds_1 = __webpack_require__(/*! ../../svg/fs/get-shape-bounds */ \"./node_modules/flo-mat/node/svg/fs/get-shape-bounds.js\");\r\nconst find_2_prong_1 = __webpack_require__(/*! ./find-2-prong/find-2-prong */ \"./node_modules/flo-mat/node/mat/find-mat/find-2-prong/find-2-prong.js\");\r\nconst add_2_prong_1 = __webpack_require__(/*! ./add-2-prong */ \"./node_modules/flo-mat/node/mat/find-mat/add-2-prong.js\");\r\n/**\r\n * Find and add two-prongs.\r\n * @param loops\r\n * @param cpGraphs\r\n * @param k\r\n * @param for2Prongs\r\n * @param extreme The maximum coordinate value used to calculate floating point\r\n * tolerances.\r\n */\r\nfunction findAndAdd2Prongs(loops, cpGraphs, k, for2Prongs, extreme) {\r\n    let len = for2Prongs.length;\r\n    let index = indexLinear(len); // Keep for possible future use.\r\n    //let index = indexInterlaced(len);\r\n    let cpNode_;\r\n    let bounds = get_shape_bounds_1.getShapeBounds(loops);\r\n    let squaredDiagonalLength = Math.pow((bounds.maxX.p[0] - bounds.minX.p[0]), 2) +\r\n        Math.pow((bounds.maxY.p[1] - bounds.minY.p[1]), 2);\r\n    //console.log(Math.sqrt(squaredDiagonalLength));\r\n    for (let i = 0; i < len; i++) {\r\n        let pos = for2Prongs[index[i]];\r\n        //let twoProngInfo: { circle: Circle,\tz: PointOnShape };\r\n        /*if (i === 15) {\r\n            console.log('stop')\r\n        }*/\r\n        let twoProngInfo;\r\n        twoProngInfo = find_2_prong_1.find2Prong(loops, extreme, squaredDiagonalLength, cpGraphs, pos, false, k);\r\n        if (twoProngInfo) {\r\n            let { circle, zs } = twoProngInfo;\r\n            let cpNode = add_2_prong_1.add2Prong(cpGraphs, circle, pos, zs, false, extreme);\r\n            // TODO - below should certainly be explained\r\n            if (!cpNode_ && cpNode) {\r\n                cpNode_ = cpNode;\r\n            }\r\n        } /* else {\r\n            console.log('aaaaaaaaa')\r\n        }*/\r\n        if (typeof _debug_ !== 'undefined') {\r\n            if (i + 1 === _debug_.directives.stopAfterTwoProngsNum) {\r\n                return undefined;\r\n            }\r\n        }\r\n    }\r\n    return cpNode_;\r\n}\r\nexports.findAndAdd2Prongs = findAndAdd2Prongs;\r\n/**\r\n * Simple linear array indexing.\r\n * @param n\r\n */\r\nfunction indexLinear(n) {\r\n    let arr = [];\r\n    for (let i = 0; i < n; i++) {\r\n        arr.push(i);\r\n    }\r\n    return arr;\r\n}\r\n/**\r\n * Creates a kind of interlaced index vector.\r\n * @param n\r\n*/\r\nfunction indexInterlaced(n) {\r\n    let source = {};\r\n    let arr = [];\r\n    // l is the lowest power of 2 so that 2^l > n\r\n    let l = Math.pow(2, Math.floor(Math.log2(n)));\r\n    while (l >= 1) {\r\n        let k = 0;\r\n        while (k < n) {\r\n            if (!source[k]) {\r\n                arr.push(k);\r\n                source[k] = true;\r\n            }\r\n            k = k + l;\r\n        }\r\n        l = l / 2;\r\n    }\r\n    return arr;\r\n}\r\n//# sourceMappingURL=find-and-add-2-prongs.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/find-and-add-2-prongs.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/find-and-add-3-prongs.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/find-and-add-3-prongs.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nconst find_3_prong_1 = __webpack_require__(/*! ./find-3-prong/find-3-prong */ \"./node_modules/flo-mat/node/mat/find-mat/find-3-prong/find-3-prong.js\");\r\nconst add_3_prong_1 = __webpack_require__(/*! ../find-mat/add-3-prong */ \"./node_modules/flo-mat/node/mat/find-mat/add-3-prong.js\");\r\n/**\r\n * Finds and adds all 3-prongs.\r\n * @param cpGraphs\r\n * @param cpStart The CpNode to start traversing from.\r\n * @param extreme The maximum coordinate value used to calculate floating point\r\n * tolerances.\r\n */\r\nfunction findAndAddAll3Prongs(cpGraphs, cpStart, extreme) {\r\n    // Don't change this function to be recursive, the call stack may overflow \r\n    // if there are too many two-prongs.\r\n    let visitedEdges = new Map();\r\n    let edgesToCheck = [{ fromCpNode: undefined, cpStart }];\r\n    while (edgesToCheck.length) {\r\n        let { fromCpNode, cpStart } = edgesToCheck.shift();\r\n        markEdgeAsTaken(visitedEdges, fromCpNode, cpStart);\r\n        for (let cpNode of cpStart.getCpNodesOnCircle()) {\r\n            if (!point_on_shape_1.PointOnShape.isSharpCorner(cpNode.cp.pointOnShape)) {\r\n                findAndAdd3Prongs(cpGraphs, cpNode, extreme);\r\n            }\r\n            if (hasEdgeBeenTaken(visitedEdges, cpNode, cpNode.next)) {\r\n                continue; // We already visited this edge\r\n            }\r\n            edgesToCheck.push({ fromCpNode: cpStart, cpStart: cpNode.next });\r\n        }\r\n    }\r\n}\r\nexports.findAndAddAll3Prongs = findAndAddAll3Prongs;\r\n/**\r\n * Marks the given edge as already taken.\r\n */\r\nfunction markEdgeAsTaken(visitedEdges, cp1, cp2) {\r\n    if (cp1 === undefined) {\r\n        return;\r\n    }\r\n    f(cp1, cp2);\r\n    f(cp2, cp1);\r\n    function f(cp1, cp2) {\r\n        let visited = visitedEdges.get(cp1);\r\n        if (!visited) {\r\n            visited = new Set();\r\n            visitedEdges.set(cp1, visited);\r\n        }\r\n        visited.add(cp2);\r\n    }\r\n}\r\nfunction hasEdgeBeenTaken(visitedEdges, cp1, cp2) {\r\n    let cps;\r\n    cps = visitedEdges.get(cp1);\r\n    let takenForward = cps && cps.has(cp2);\r\n    cps = visitedEdges.get(cp2);\r\n    let takenBackwards = cps && cps.has(cp1);\r\n    return takenForward || takenBackwards;\r\n}\r\n/**\r\n * Traverses the shape from the given ContactPoint going around contact circles\r\n * so that only a piece of the shape is traversed and returns the visited\r\n * CpNodes (starting from the given CpNode).\r\n * @param cpStart The ContactPoint from where to start the traversal.\r\n */\r\nfunction traverseShape(cpStart) {\r\n    let cpNode = cpStart;\r\n    if (cpNode === cpNode.next.prevOnCircle) {\r\n        return [cpNode];\r\n    }\r\n    let visitedCps = [];\r\n    do {\r\n        visitedCps.push(cpNode);\r\n        let next = cpNode.next.prevOnCircle;\r\n        cpNode = cpNode === next\r\n            ? cpNode = cpNode.next.next // Terminal vertex\r\n            : cpNode = next; // Take last exit\r\n    } while (cpNode !== cpStart);\r\n    return visitedCps;\r\n}\r\n/**\r\n * Starting from some ContactPoint, traverses the shape going around Vertices\r\n * and if more than two Vertices have been visited in total then recursively\r\n * adds 3-prongs until only one or two Vertices have been visited.\r\n *\r\n * This process further subdivides the shape.\r\n * @param cpGraphs\r\n * @param cpStart The ContactPoint from where to start the process.\r\n * @param extreme The maximum coordinate value used to calculate floating point\r\n * tolerances.\r\n */\r\nfunction findAndAdd3Prongs(cpGraphs, cpStart, extreme) {\r\n    let visitedCps;\r\n    do {\r\n        visitedCps = traverseShape(cpStart);\r\n        if (visitedCps.length > 2) {\r\n            findAndAdd3Prong(cpGraphs, visitedCps, extreme);\r\n        }\r\n    } while (visitedCps.length > 2);\r\n    return visitedCps;\r\n}\r\n/**\r\n * Finds and add a 3-prong MAT circle to the given shape.\r\n * @param cpGraphs\r\n * @param visitedCps\r\n * @param extreme The maximum coordinate value used to calculate floating point\r\n * tolerances.\r\n */\r\nfunction findAndAdd3Prong(cpGraphs, visitedCps, extreme) {\r\n    let δs = [];\r\n    for (let visitedCp of visitedCps) {\r\n        δs.push([visitedCp, visitedCp.next]);\r\n    }\r\n    let threeProng = find_3_prong_1.find3Prong(δs, extreme);\r\n    let orders = [];\r\n    for (let i = 0; i < 3; i++) {\r\n        orders.push(point_on_shape_1.PointOnShape.calcOrder(threeProng.circle, threeProng.ps[i]));\r\n    }\r\n    let circle = add_3_prong_1.add3Prong(cpGraphs, orders, threeProng);\r\n    if (typeof _debug_ !== 'undefined') {\r\n        add3ProngDebugInfo(circle, visitedCps);\r\n    }\r\n}\r\nfunction add3ProngDebugInfo(circle, visitedCps) {\r\n    let threeProngs = _debug_.generated.elems.threeProng;\r\n    let len = threeProngs.length;\r\n    let data = threeProngs[len - 1];\r\n    data.visitedCps = visitedCps;\r\n    data.circle = circle;\r\n}\r\n//# sourceMappingURL=find-and-add-3-prongs.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/find-and-add-3-prongs.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/find-and-add-hole-closing-2-prongs.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/find-and-add-hole-closing-2-prongs.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_shape_bounds_1 = __webpack_require__(/*! ../../svg/fs/get-shape-bounds */ \"./node_modules/flo-mat/node/svg/fs/get-shape-bounds.js\");\r\nconst get_min_y_pos_1 = __webpack_require__(/*! ../../svg/fs/get-min-y-pos */ \"./node_modules/flo-mat/node/svg/fs/get-min-y-pos.js\");\r\nconst find_2_prong_1 = __webpack_require__(/*! ./find-2-prong/find-2-prong */ \"./node_modules/flo-mat/node/mat/find-mat/find-2-prong/find-2-prong.js\");\r\nconst add_2_prong_1 = __webpack_require__(/*! ./add-2-prong */ \"./node_modules/flo-mat/node/mat/find-mat/add-2-prong.js\");\r\n/**\r\n * Find and add two-prongs that remove any holes in the shape.\r\n * @param loops\r\n * @param cpTrees\r\n * @param extreme The maximum coordinate value used to calculate floating point\r\n * tolerances.\r\n */\r\nfunction findAndAddHoleClosing2Prongs(loops, cpTrees, extreme) {\r\n    let bounds = get_shape_bounds_1.getShapeBounds(loops);\r\n    let squaredDiagonalLength = Math.pow((bounds.maxX.p[0] - bounds.minX.p[0]), 2) +\r\n        Math.pow((bounds.maxY.p[1] - bounds.minY.p[1]), 2);\r\n    // Find the topmost points on each loop.\r\n    let minYs = loops.map(get_min_y_pos_1.getMinYPos);\r\n    for (let k = 1; k < minYs.length; k++) {\r\n        let posSource = minYs[k];\r\n        //console.log(posSource.t);\r\n        //console.log(posSource.p[1]);\r\n        let holeClosingTwoProng = find_2_prong_1.find2Prong(loops, extreme, squaredDiagonalLength, cpTrees, posSource, true, k);\r\n        if (!holeClosingTwoProng) {\r\n            throw 'unable to find hole-closing 2-prong';\r\n        }\r\n        if (holeClosingTwoProng) {\r\n            // TODO important - handle case of n-prong, i.e. more than one antipode\r\n            let { circle, zs: posAntipodes } = holeClosingTwoProng;\r\n            add_2_prong_1.add2Prong(cpTrees, circle, posSource, posAntipodes, true, extreme);\r\n        }\r\n    }\r\n}\r\nexports.findAndAddHoleClosing2Prongs = findAndAddHoleClosing2Prongs;\r\n//# sourceMappingURL=find-and-add-hole-closing-2-prongs.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/find-and-add-hole-closing-2-prongs.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/get-potential-2-prongs.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/get-potential-2-prongs.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nfunction getPotential2Prongs(possPerLoop) {\r\n    let for2ProngsArray = [];\r\n    for (let poss of possPerLoop) {\r\n        let for2Prongs = [];\r\n        for (let pos of poss) {\r\n            if (!point_on_shape_1.PointOnShape.isQuiteSharpCorner(pos)) {\r\n                for2Prongs.push(pos);\r\n            }\r\n        }\r\n        for2ProngsArray.push(for2Prongs);\r\n    }\r\n    return for2ProngsArray;\r\n}\r\nexports.getPotential2Prongs = getPotential2Prongs;\r\n//# sourceMappingURL=get-potential-2-prongs.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/get-potential-2-prongs.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/get-sharp-corners.js":
/*!*********************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/get-sharp-corners.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nfunction getSharpCorners(possPerLoop) {\r\n    let sharpCornersPerLoop = [];\r\n    for (let poss of possPerLoop) {\r\n        let sharpCorners = [];\r\n        for (let pos of poss) {\r\n            if (point_on_shape_1.PointOnShape.isQuiteSharpCorner(pos)) {\r\n                sharpCorners.push(pos);\r\n            }\r\n        }\r\n        sharpCornersPerLoop.push(sharpCorners);\r\n    }\r\n    return sharpCornersPerLoop;\r\n}\r\nexports.getSharpCorners = getSharpCorners;\r\n//# sourceMappingURL=get-sharp-corners.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/get-sharp-corners.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/geometry/get-closest-square-distance-to-rect.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/geometry/get-closest-square-distance-to-rect.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\n/**\r\n *\r\n */\r\nfunction getClosestSquareDistanceToRect(box, p) {\r\n    let [[x0, y0], [x1, y1]] = box;\r\n    let [xp, yp] = p;\r\n    if (xp < x0) {\r\n        if (yp < y0) {\r\n            return flo_vector2d_1.squaredDistanceBetween(box[0], p);\r\n        }\r\n        else if (yp > y1) {\r\n            return flo_vector2d_1.squaredDistanceBetween([x0, y1], p);\r\n        }\r\n        else {\r\n            let d = x0 - xp;\r\n            return d * d;\r\n        }\r\n    }\r\n    else if (xp > x1) {\r\n        if (yp < y0) {\r\n            return flo_vector2d_1.squaredDistanceBetween([x1, y0], p);\r\n        }\r\n        else if (yp > y1) {\r\n            return flo_vector2d_1.squaredDistanceBetween(box[1], p);\r\n        }\r\n        else {\r\n            let d = xp - x1;\r\n            return d * d;\r\n        }\r\n    }\r\n    else {\r\n        if (yp < y0) {\r\n            let d = y0 - yp;\r\n            return d * d;\r\n        }\r\n        else if (yp > y1) {\r\n            let d = yp - y1;\r\n            return d * d;\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n}\r\nexports.getClosestSquareDistanceToRect = getClosestSquareDistanceToRect;\r\n//# sourceMappingURL=get-closest-square-distance-to-rect.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/geometry/get-closest-square-distance-to-rect.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/geometry/get-closest-squared-distance-to-rotated-rect.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/geometry/get-closest-squared-distance-to-rotated-rect.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\n/**\r\n *\r\n */\r\nfunction getClosestSquaredDistanceToRotatedRect(ps, p) {\r\n    let ds = [0, 1, 2, 3].map(i => flo_vector2d_1.squaredDistanceBetweenPointAndLineSegment(p, [ps[i], ps[(i + 1) % 4]]));\r\n    let width = flo_vector2d_1.squaredDistanceBetween(ps[0], ps[1]);\r\n    let height = flo_vector2d_1.squaredDistanceBetween(ps[0], ps[3]);\r\n    if (ds[0] <= height && ds[2] <= height &&\r\n        ds[1] <= width && ds[3] <= width) {\r\n        return 0; // Inside rotated rect\r\n    }\r\n    return Math.min(...ds);\r\n}\r\nexports.getClosestSquaredDistanceToRotatedRect = getClosestSquaredDistanceToRotatedRect;\r\n//# sourceMappingURL=get-closest-squared-distance-to-rotated-rect.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/geometry/get-closest-squared-distance-to-rotated-rect.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/geometry/line-line-intersection.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/geometry/line-line-intersection.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Find point where two lines intersect. Returns he point where the two lines\r\n * intersect or undefined if they don't intersect or are the same line.\r\n * @param l1 - A line\r\n * @param l2 - Another line\r\n */\r\nfunction lineLineIntersection(l1, l2) {\r\n    let [[p1x, p1y], [p2x, p2y]] = l1;\r\n    let [[p3x, p3y], [p4x, p4y]] = l2;\r\n    let v1x = p2x - p1x;\r\n    let v1y = p2y - p1y;\r\n    let v2x = p4x - p3x;\r\n    let v2y = p4y - p3y;\r\n    let cross = v2x * v1y - v2y * v1x;\r\n    if (cross === 0) {\r\n        // parallel\r\n        return undefined;\r\n    }\r\n    let b = ((p3y - p1y) * v1x - (p3x - p1x) * v1y) / cross;\r\n    return [p3x + b * v2x, p3y + b * v2y];\r\n}\r\nexports.lineLineIntersection = lineLineIntersection;\r\n//# sourceMappingURL=line-line-intersection.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/geometry/line-line-intersection.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/get-bezier-curvature-extrema-brackets.js":
/*!********************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/get-bezier-curvature-extrema-brackets.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst DELTA = 1e-6;\r\n/**\r\n * Calculates the curvature extrema brackets of the given cubic bezier.\r\n * See the paper at http://ac.els-cdn.com/S037704270000529X/1-s2.0-S037704270000529X-main.pdf?_tid=0b25a2cc-ad35-11e5-a728-00000aacb362&acdnat=1451288083_86359fc83af9dec3232c90a6d2e71031\r\n * Note that naming conventions is roughly as in the paper above.\r\n * @param ps\r\n */\r\nfunction calcBezierCurvatureExtremaBrackets(ps) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    let brackets = [];\r\n    // Bezier points translated to origin;\r\n    let P_1x = x1 - x0;\r\n    let P_1y = y1 - y0;\r\n    let P_2x = x2 - x0;\r\n    let P_2y = y2 - y0;\r\n    let P_3x = x3 - x0;\r\n    let P_3y = y3 - y0;\r\n    // Distance to consecutive points\r\n    let W_0x = P_1x;\r\n    let W_1x = P_2x - P_1x;\r\n    let W_2x = P_3x - P_2x;\r\n    let W_0y = P_1y;\r\n    let W_1y = P_2y - P_1y;\r\n    let W_2y = P_3y - P_2y;\r\n    // Check for degenerate case in which cubic curve becomes quadratic. \r\n    if ((Math.abs(W_0x - 2 * W_1x + W_2x) < DELTA) &&\r\n        (Math.abs(W_0y - 2 * W_1y + W_2y) < DELTA)) {\r\n        // TODO - This case is simpler due to being quadratic - still needs to\r\n        // be implemented!. \r\n    }\r\n    // See http://ac.els-cdn.com/S037704270000529X/1-s2.0-S037704270000529X-main.pdf?_tid=0b25a2cc-ad35-11e5-a728-00000aacb362&acdnat=1451288083_86359fc83af9dec3232c90a6d2e71031\r\n    // Rotate curve so that W0 - 2W1 + W2 = (0, (1/3)a), a != 0\r\n    let atan_numer = P_3x - 3 * P_2x + 3 * P_1x;\r\n    let atan_denom = P_3y - 3 * P_2y + 3 * P_1y;\r\n    let atan_numer_squared = atan_numer * atan_numer;\r\n    let atan_denom_squared = atan_denom * atan_denom;\r\n    let rad = Math.sqrt((atan_numer_squared / atan_denom_squared) + 1);\r\n    let cos_theta = 1 / rad;\r\n    let sin_theta;\r\n    if (cos_theta === 0) { // edge case\r\n        sin_theta = 1;\r\n    }\r\n    else {\r\n        sin_theta = atan_numer / (atan_denom * rad);\r\n    }\r\n    // Here we skip expensive trig evaluations\r\n    let R_1x = P_1x * cos_theta - P_1y * sin_theta;\r\n    let R_1y = P_1x * sin_theta + P_1y * cos_theta;\r\n    let R_2x = P_2x * cos_theta - P_2y * sin_theta;\r\n    let R_2y = P_2x * sin_theta + P_2y * cos_theta;\r\n    let R_3x = P_3x * cos_theta - P_3y * sin_theta;\r\n    let R_3y = P_3x * sin_theta + P_3y * cos_theta;\r\n    // Modify W_0x, etc. to be correct for new rotated curve \r\n    W_0x = R_1x;\r\n    W_1x = R_2x - R_1x;\r\n    W_2x = R_3x - R_2x;\r\n    W_0y = R_1y;\r\n    W_1y = R_2y - R_1y;\r\n    W_2y = R_3y - R_2y;\r\n    let a = 3 * (W_0y - 2 * W_1y + W_2y);\r\n    let dif = R_2x - 2 * R_1x; // which = W_1x - W_0x;\r\n    if (dif === 0) {\r\n        // Case 1 (special) - W_1x - W_0x === 0\r\n        // Degenerate to cubic function\t\r\n        if (W_0x !== 0) {\r\n            // TODO - finish!\r\n            // TODO - we also still need to check for degenerate cubic (see \r\n            // beginning of paper)\r\n        }\r\n        else {\r\n            // We have a straight line x=0!\r\n            return [];\r\n        }\r\n    }\r\n    else {\r\n        // Case 2 (usual) - W_1x - W_0x !== 0\r\n        if (dif < 0) {\r\n            // Reflect curve accross y-axis to make dif > 0\r\n            R_1x = -R_1x;\r\n            R_2x = -R_2x;\r\n            R_3x = -R_3x;\r\n            // Modify W_0x, etc. to be correct for new reflected \r\n            W_0x = -W_0x;\r\n            W_1x = -W_1x;\r\n            W_2x = -W_2x;\r\n            dif = -dif;\r\n        }\r\n        // From the paper:\r\n        // ---------------\r\n        // All curves has exactly one of 4 cases:\r\n        //\r\n        // 1. It has a single inflection point and exactly 2 curvature maxima \r\n        //    (symmetrically positioned about inflection point). This is the \r\n        //    case if dif === 0 in above code.\r\n        // 2. TODO - It has a single cusp - ignored for now!\r\n        // 3. It has a point of self-intersection - occurs if d < 0 in paper.\r\n        // 4. It has 2 inflection points, no cusps, no self-intersections.\r\n        //    It can have either 3 or 5 curvature extrema\r\n        //    a. The case of 5 curvature extrema is ignored for now - in the \r\n        //       paper it is mentioned to even find such a curve is difficult \r\n        //       and it seems such curves have very sharp curvature at one point \r\n        //       which does not usually occur in an SVG shape. But this case \r\n        //       should later be included or we'll miss some points.\r\n        //    b. There are 3 curvature extrema:\r\n        //       Extrema occur in the range (-inf, -sqrt(d)), \r\n        //       (-sqrt(d), sqrt(d)), (sqrt(d), inf). \r\n        //       Since we dont know how to select -inf and inf we will just \r\n        //       choose them to be -10 and 11 (remember bezier runs from t=0 to \r\n        //       t=1). If Brent's method runs out of the (0,1) interval we stop \r\n        //       and use 0 or 1 as the extremum? Remember extrema can also occur \r\n        //       at t=0 and t=1!\r\n        //\r\n        // TODO - At the moment we only test for case 1 and 4b, but in future \r\n        // we must test and eliminate the other cases.\r\n        let μ = 6 * dif;\r\n        let λ = (3 * a * W_0x) / (μ * μ);\r\n        let γ1 = (3 * a * W_0y) / (μ * μ);\r\n        let γ2 = (3 * (W_1y - W_0y)) / (μ);\r\n        let d = λ * λ - 2 * γ2 * λ + γ1;\r\n        let b = 2 * (γ2 - λ);\r\n        let deParamBoundary = deParameterizeBoundary(λ, μ, a);\r\n        if (d > 0) {\r\n            let ssigd_ = Math.sqrt(d);\r\n            // de-reparametize\r\n            // Note: the sda and sdb here are the inflection points forcase iv! \r\n            // there are easier ways to calculate these\r\n            let sda = -ssigd_;\r\n            let sdb = ssigd_;\r\n            brackets =\r\n                [\r\n                    [Number.NEGATIVE_INFINITY, sda],\r\n                    [sda, sdb],\r\n                    [sdb, Number.POSITIVE_INFINITY]\r\n                ]\r\n                    .map(deParamBoundary)\r\n                    .map(clipBoundary);\r\n        }\r\n        else if (d < 0) {\r\n            // It is a loop \r\n            // Note: The loop intersection may be outside t=[0,1] but curvature \r\n            // maxima may still occur inside t=[0,1] of course.\r\n            // There can be 1 or 3 maxima of curvature.\r\n            let ξ1_ = 2 * b * b - 8 * d - 3;\r\n            if (ξ1_ < 0) {\r\n                brackets = [[0, Math.sqrt(-3 * d)]]\r\n                    .map(deParamBoundary)\r\n                    .map(clipBoundary);\r\n            }\r\n            else {\r\n                let ξ2_ = Math.sqrt(5 * ξ1_);\r\n                let ξ1 = (-5 * b - ξ2_) / 10;\r\n                let ξ2 = (-5 * b + ξ2_) / 10;\r\n                brackets = [\r\n                    [Number.NEGATIVE_INFINITY, ξ1],\r\n                    [ξ1, Math.min(0, ξ2)],\r\n                    [Math.max(0, ξ2), Math.sqrt(-3 * d)]\r\n                ]\r\n                    .map(deParamBoundary)\r\n                    .map(clipBoundary);\r\n            }\r\n        }\r\n        else if (d === 0) {\r\n            // TODO - It is a cusp - still to implement!\r\n        }\r\n    }\r\n    return brackets;\r\n}\r\nexports.calcBezierCurvatureExtremaBrackets = calcBezierCurvatureExtremaBrackets;\r\n/**\r\n * Clips to [0,1] or returns undefined if not within [0,1].\r\n * @param range\r\n */\r\nfunction clipBoundary(range) {\r\n    let [a, b] = range;\r\n    if ((a < 0 && b < 0) || (a > 1 && b > 1)) {\r\n        return undefined;\r\n    }\r\n    if (a < 0) {\r\n        a = 0;\r\n    }\r\n    if (a > 1) {\r\n        a = 1;\r\n    }\r\n    if (b < 0) {\r\n        b = 0;\r\n    }\r\n    if (b > 1) {\r\n        b = 1;\r\n    }\r\n    return [a, b];\r\n}\r\n/**\r\n *\r\n * @param λ\r\n * @param μ\r\n * @param a\r\n */\r\nfunction deParameterize(λ, μ, a) {\r\n    return (σ) => (σ - λ) * (μ / a);\r\n}\r\n/**\r\n *\r\n * @param λ\r\n * @param μ\r\n * @param a\r\n */\r\nfunction deParameterizeBoundary(λ, μ, a) {\r\n    return (boundary) => boundary.map(deParameterize(λ, μ, a));\r\n}\r\n;\r\n//# sourceMappingURL=get-bezier-curvature-extrema-brackets.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/get-bezier-curvature-extrema-brackets.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/get-bezier-curvature-extrema.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/get-bezier-curvature-extrema.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst point_on_shape_1 = __webpack_require__(/*! ../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nconst get_bezier_curvature_extrema_brackets_1 = __webpack_require__(/*! ./get-bezier-curvature-extrema-brackets */ \"./node_modules/flo-mat/node/mat/get-bezier-curvature-extrema-brackets.js\");\r\n/**\r\n * Finds the osculating circles and inflection points for the given bezier.\r\n * @param curve\r\n */\r\nfunction getBezierCurvatureExtrema(curve) {\r\n    let maxCurvaturePoss = [];\r\n    let maxNegativeCurvaturePoss = [];\r\n    let ps = curve.ps;\r\n    let brackets = get_bezier_curvature_extrema_brackets_1.calcBezierCurvatureExtremaBrackets(ps);\r\n    let κPs = flo_bezier3_1.κ(ps); // The curvature function\r\n    let lenb = brackets.length;\r\n    for (let k = 0; k < lenb; k++) {\r\n        let bracket = brackets[k];\r\n        if (!bracket) {\r\n            continue;\r\n        }\r\n        let root = lookForRoot(ps, bracket);\r\n        if (!root) {\r\n            continue;\r\n        }\r\n        let κ_ = -κPs(root);\r\n        // Check if local extrema is a maximum or minimum.\r\n        let κAtMinsd = -κPs(bracket[0]);\r\n        let κAtMaxsd = -κPs(bracket[1]);\r\n        if (κ_ > κAtMinsd && κ_ > κAtMaxsd) {\r\n            // maximum\r\n            if (κ_ > 0) {\r\n                maxCurvaturePoss.push(new point_on_shape_1.PointOnShape(curve, root));\r\n            }\r\n            //_debug_.fs.draw.crossHair((new PointOnShape(curve, root).p), 'blue thin2 nofill')\r\n        }\r\n        else if (κ_ <= κAtMinsd && κ_ <= κAtMaxsd) {\r\n            // minimum\r\n            if (κ_ < 0) {\r\n                maxNegativeCurvaturePoss.push(new point_on_shape_1.PointOnShape(curve, root));\r\n                //_debug_.fs.draw.crossHair((new PointOnShape(curve, root).p), 'red thin2 nofill')\r\n            }\r\n        }\r\n    }\r\n    return { maxCurvaturePoss, maxNegativeCurvaturePoss };\r\n}\r\nexports.getBezierCurvatureExtrema = getBezierCurvatureExtrema;\r\nfunction lookForRoot(ps, [minsd, maxsd]) {\r\n    // At this point there can be exactly 0 or 1 roots within \r\n    // [minsd, maxsd]\r\n    let dκMod_ = flo_bezier3_1.dκMod(ps);\r\n    let c0 = dκMod_(minsd);\r\n    let c1 = dκMod_(maxsd);\r\n    if (c0 * c1 >= 0) {\r\n        return;\r\n    }\r\n    // There is exactly one root in the interval.\r\n    let root = flo_poly_1.default.brent(dκMod_, minsd, maxsd);\r\n    return root;\r\n}\r\n//# sourceMappingURL=get-bezier-curvature-extrema.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/get-bezier-curvature-extrema.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/get-boundary-piece-beziers.js":
/*!*********************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/get-boundary-piece-beziers.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst bezier_piece_1 = __webpack_require__(/*! ../bezier-piece */ \"./node_modules/flo-mat/node/bezier-piece.js\");\r\nconst point_on_shape_1 = __webpack_require__(/*! ../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nconst contact_point_1 = __webpack_require__(/*! ../contact-point */ \"./node_modules/flo-mat/node/contact-point.js\");\r\n/**\r\n* Returns the ordered cubic bezier pieces (i.e a bezier with a t range)\r\n* from the given boundary piece.\r\n* @param cpNode - An ordered pair that represents the start and end points of\r\n* the boundary piece\r\n*/\r\nfunction getBoundaryPieceBeziers(cpNode) {\r\n    let cpThis = cpNode[0];\r\n    let cpEnd = cpNode[1];\r\n    let bezierPieces = [];\r\n    // As opposed to going around the circle and taking the last exit\r\n    let goStraight = true;\r\n    do {\r\n        if (!goStraight) {\r\n            goStraight = true;\r\n            cpThis = cpThis.prevOnCircle; // take last exit\r\n            continue;\r\n        }\r\n        goStraight = false;\r\n        let posThis = cpThis.cp.pointOnShape;\r\n        let posNext = cpThis.next.cp.pointOnShape;\r\n        if (posNext.curve === posThis.curve &&\r\n            point_on_shape_1.PointOnShape.isQuiteSharpCorner(posThis) &&\r\n            point_on_shape_1.PointOnShape.isQuiteSharpCorner(posNext)) {\r\n            // Do nothing\r\n        }\r\n        else if (posNext.curve === posThis.curve &&\r\n            contact_point_1.ContactPoint.compare(cpThis.next.cp, cpThis.cp) > 0) {\r\n            bezierPieces.push(new bezier_piece_1.BezierPiece(posThis.curve, [posThis.t, posNext.t]));\r\n        }\r\n        else {\r\n            bezierPieces.push(new bezier_piece_1.BezierPiece(posThis.curve, [posThis.t, 1]));\r\n            addSkippedBeziers(bezierPieces, posThis.curve, posNext.curve, posNext.t);\r\n        }\r\n        cpThis = cpThis.next;\r\n    } while (cpThis !== cpEnd);\r\n    return bezierPieces;\r\n}\r\nexports.getBoundaryPieceBeziers = getBoundaryPieceBeziers;\r\n/**\r\n * Adds pieces of skipped beziers\r\n */\r\nfunction addSkippedBeziers(bezierPieces, curveStart, curveEnd, t1) {\r\n    let curveThis = curveStart;\r\n    do {\r\n        curveThis = curveThis.next;\r\n        let tEnd = curveThis === curveEnd ? t1 : 1;\r\n        bezierPieces.push(new bezier_piece_1.BezierPiece(curveThis, [0, tEnd]));\r\n    } while (curveThis !== curveEnd);\r\n}\r\n//# sourceMappingURL=get-boundary-piece-beziers.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/get-boundary-piece-beziers.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/get-contact-circles-at-interface.js":
/*!***************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/get-contact-circles-at-interface.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst curve_1 = __webpack_require__(/*! ../curve */ \"./node_modules/flo-mat/node/curve.js\");\r\nconst point_on_shape_1 = __webpack_require__(/*! ../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nfunction getContactCirclesAtInterface(curve) {\r\n    let { isQuiteSharp, isDull, isQuiteDull } = curve_1.Curve.getCornerAtEnd(curve);\r\n    if (isQuiteSharp) {\r\n        return [new point_on_shape_1.PointOnShape(curve, 1)];\r\n    }\r\n    else if (isQuiteDull) {\r\n        return [\r\n            new point_on_shape_1.PointOnShape(curve, 1),\r\n            new point_on_shape_1.PointOnShape(curve.next, 0)\r\n        ];\r\n    }\r\n    else if (isDull) {\r\n    }\r\n    return [];\r\n}\r\nexports.getContactCirclesAtInterface = getContactCirclesAtInterface;\r\n//# sourceMappingURL=get-contact-circles-at-interface.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/get-contact-circles-at-interface.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/get-largest-vertex.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/get-largest-vertex.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction getLargestVertex(cpNodes) {\r\n    return cpNodes.reduce(function (maxCpNode, cpNode) {\r\n        return maxCpNode.cp.circle.radius >= cpNode.cp.circle.radius\r\n            ? maxCpNode\r\n            : cpNode;\r\n    }, cpNodes[0]);\r\n}\r\nexports.getLargestVertex = getLargestVertex;\r\n//# sourceMappingURL=get-largest-vertex.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/get-largest-vertex.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/get-leaves.js":
/*!*****************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/get-leaves.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction getLeaves(cpNode) {\r\n    let leaves = [];\r\n    let cps = cpNode.getAllOnLoop();\r\n    cps.forEach(function (cp) {\r\n        if (cp.isTerminating()) {\r\n            leaves.push(cp);\r\n        }\r\n    });\r\n    /*\r\n    traverseEdges(cpNode, f, true);\r\n\r\n    function f(cp: CpNode, isLeaf: boolean) {\r\n        if (isLeaf) {\r\n            leaves.push(cp);\r\n        }\r\n    }\r\n    */\r\n    return leaves;\r\n}\r\nexports.getLeaves = getLeaves;\r\n//# sourceMappingURL=get-leaves.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/get-leaves.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/get-neighboring-cps.js":
/*!**************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/get-neighboring-cps.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst cp_node_1 = __webpack_require__(/*! ../cp-node */ \"./node_modules/flo-mat/node/cp-node.js\");\r\nconst contact_point_1 = __webpack_require__(/*! ../contact-point */ \"./node_modules/flo-mat/node/contact-point.js\");\r\n/**\r\n * Returns the boundary piece that starts at the immediate previous point on the\r\n * shape and ends at the immediate next point.\r\n * @param cpTree\r\n * @param pos\r\n * @param order\r\n * @param order2\r\n */\r\nfunction getNeighbouringPoints(cpTree, pos, order, order2) {\r\n    let cps = cpTree.findBounds(new cp_node_1.CpNode(new contact_point_1.ContactPoint(pos, undefined, order, order2), false, false));\r\n    if (!cps[0] && !cps[1]) {\r\n        // The tree is still empty\r\n        return [undefined, undefined];\r\n    }\r\n    if (!cps[0] || !cps[1]) {\r\n        // Smaller than all -> cptree.min() === cps[1].data OR\r\n        // Larger  than all -> cptree.max() === cps[0].data\r\n        return [\r\n            cpTree.max(cpTree.root),\r\n            cpTree.min(cpTree.root)\r\n        ];\r\n    }\r\n    return [\r\n        cps[0].data,\r\n        cps[1].data\r\n    ];\r\n}\r\nexports.getNeighbouringPoints = getNeighbouringPoints;\r\n//# sourceMappingURL=get-neighboring-cps.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/get-neighboring-cps.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/get-two-prong-type.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/get-two-prong-type.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction getTwoProngType(e) {\r\n    if (e.holeClosing) {\r\n        return 'twoProng_holeClosing';\r\n    }\r\n    return 'twoProng_regular';\r\n}\r\nexports.getTwoProngType = getTwoProngType;\r\n//# sourceMappingURL=get-two-prong-type.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/get-two-prong-type.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/is-another-cp-closeby.js":
/*!****************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/is-another-cp-closeby.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst get_neighboring_cps_1 = __webpack_require__(/*! ./get-neighboring-cps */ \"./node_modules/flo-mat/node/mat/get-neighboring-cps.js\");\r\n//const ANGLE_THRESHOLD = Math.cos(3 * (Math.PI / 180)); // 3 degrees\r\nconst ANGLE_THRESHOLD = 0.9986295347545738; // === Math.cos(3  degrees)\r\n//const ANGLE_THRESHOLD = 0.9848077530122080; // === Math.cos(10 degrees)\r\n//const ANGLE_THRESHOLD = 0.9998476951563913; // === Math.cos(1 degrees)\r\n//const ANGLE_THRESHOLD = 0.9999984769132877; // === Math.cos(0.1 degrees)   \r\n//const ANGLE_THRESHOLD = 0.9999999847691291  // === Math.cos(0.01 degrees)   \r\n/**\r\n * Returns true if another CpNode is close to the given implied (via pos, order\r\n * and order2) CpNode.\r\n * @param cpTrees\r\n * @param pos\r\n * @param circle\r\n * @param order\r\n * @param order2\r\n * @param extreme The maximum coordinate value used to calculate floating point\r\n * tolerances.\r\n * @param color Used for debugging only\r\n */\r\nfunction isAnotherCpCloseby(cpTrees, pos, circle, order, order2, extreme, color) {\r\n    //const DISTANCE_THRESHOLD = extreme * 1e-3; \r\n    //const DISTANCE_THRESHOLD = extreme * 1e-1;             \r\n    //const DISTANCE_THRESHOLD = extreme * 1e-4; - was this\r\n    const DISTANCE_THRESHOLD = extreme * 1e-12;\r\n    // It seems this can be zero else the ordering should be correct\r\n    //const DISTANCE_THRESHOLD = 0;\r\n    let cpTree = cpTrees.get(pos.curve.loop);\r\n    let cpNodes = get_neighboring_cps_1.getNeighbouringPoints(cpTree, pos, order, order2);\r\n    if (!cpNodes[0]) {\r\n        return false;\r\n    }\r\n    for (let cpNode of cpNodes) {\r\n        let pos2 = cpNode.cp.pointOnShape;\r\n        let p1 = pos.p;\r\n        let p2 = pos2.p;\r\n        if (flo_vector2d_1.distanceBetween(p1, p2) > DISTANCE_THRESHOLD) {\r\n            continue;\r\n        }\r\n        let v1 = flo_vector2d_1.toUnitVector(flo_vector2d_1.fromTo(cpNode.cp.pointOnShape.p, cpNode.cp.circle.center));\r\n        let v2 = flo_vector2d_1.toUnitVector(flo_vector2d_1.fromTo(p1, circle.center));\r\n        let cosTheta = flo_vector2d_1.dot(v1, v2);\r\n        if (cosTheta > ANGLE_THRESHOLD) {\r\n            //console.log(`%c${cosTheta} - ${distanceBetween(p1,p2)}`, `color: ${color}`);\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nexports.isAnotherCpCloseby = isAnotherCpCloseby;\r\n//# sourceMappingURL=is-another-cp-closeby.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/is-another-cp-closeby.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/smoothen/get-edge-direction.js":
/*!**********************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/smoothen/get-edge-direction.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\n/**\r\n * Returns a line segment of unit length starting in the given Vertex center and\r\n * pointing in the direction of the medial axis (viewed as a rooted tree).\r\n * @param cpNode\r\n */\r\nfunction getEdgeDirection(cpNode) {\r\n    let circleCenter = cpNode.cp.circle.center;\r\n    let cp1 = cpNode;\r\n    let cp2 = cpNode.nextOnCircle;\r\n    let pos1 = cp1.cp.pointOnShape;\r\n    let pos2 = cp2.cp.pointOnShape;\r\n    let p1 = pos1.p;\r\n    let p2 = pos2.p;\r\n    let vDir;\r\n    if (!point_on_shape_1.PointOnShape.isSharpCorner(pos1)) {\r\n        if (p1[0] === p2[0] && p1[1] === p2[1]) {\r\n            vDir = flo_vector2d_1.fromTo(p1, circleCenter); // A 1-prong\r\n        }\r\n        else {\r\n            vDir = flo_vector2d_1.rotate90Degrees(flo_vector2d_1.fromTo(p1, p2)); // not a 1-prong.\r\n        }\r\n    }\r\n    else {\r\n        let curve1;\r\n        let curve2;\r\n        // TODO - test if pos1.t can ever be 0 - it is terminating\r\n        if (pos1.t === 0) {\r\n            curve1 = pos1.curve;\r\n            curve2 = pos1.curve.prev;\r\n        }\r\n        else if (pos1.t === 1) {\r\n            curve1 = pos1.curve.next;\r\n            curve2 = pos1.curve;\r\n        }\r\n        let tan1 = flo_bezier3_1.tangent(curve1.ps)(0);\r\n        let tan2 = flo_vector2d_1.reverse(flo_bezier3_1.tangent(curve2.ps)(1));\r\n        let x = flo_vector2d_1.dot(tan1, tan2);\r\n        // Recall the identities sin(acos(x)) = sqrt(1-x^2), etc. Also \r\n        // recall the half angle formulas. Then the rotation matrix, R, can \r\n        // be calculated.\r\n        let cosθ = Math.sqrt((1 + x) / 2);\r\n        let sinθ = Math.sqrt((1 - x) / 2);\r\n        vDir = flo_vector2d_1.rotate(sinθ, cosθ, tan2);\r\n    }\r\n    let v = flo_vector2d_1.translate(flo_vector2d_1.toUnitVector(vDir), circleCenter);\r\n    return [circleCenter, v];\r\n}\r\nexports.getEdgeDirection = getEdgeDirection;\r\n//# sourceMappingURL=get-edge-direction.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/smoothen/get-edge-direction.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/smoothen/smoothen.js":
/*!************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/smoothen/smoothen.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst line_line_intersection_1 = __webpack_require__(/*! ../geometry/line-line-intersection */ \"./node_modules/flo-mat/node/mat/geometry/line-line-intersection.js\");\r\nconst traverse_edges_1 = __webpack_require__(/*! ../../traverse-edges */ \"./node_modules/flo-mat/node/traverse-edges.js\");\r\nconst get_edge_direction_1 = __webpack_require__(/*! ./get-edge-direction */ \"./node_modules/flo-mat/node/mat/smoothen/get-edge-direction.js\");\r\nconst TOLERANCE_ADD_2PRONG = 0.01;\r\nconst TOLERANCE_USE_LINE = 0.0001; // else cubic\r\n/**\r\n * Smoothens the given MAT by fitting consecutive mat lines with either lines or\r\n * quadratic or cubic beziers.\r\n */\r\nfunction smoothen(cpNode) {\r\n    traverse_edges_1.traverseEdges(cpNode, f);\r\n    function f(cpNode) {\r\n        let fromCc = cpNode.cp.circle.center;\r\n        let fromL = get_edge_direction_1.getEdgeDirection(cpNode);\r\n        let toCc = cpNode.next.cp.circle.center;\r\n        let toL = get_edge_direction_1.getEdgeDirection(cpNode.next.prevOnCircle);\r\n        let mid = line_line_intersection_1.lineLineIntersection(fromL, toL);\r\n        let c = flo_vector2d_1.fromTo(fromCc, toCc);\r\n        let twisted;\r\n        if (!mid) {\r\n            twisted = true;\r\n        }\r\n        else {\r\n            let a = flo_vector2d_1.fromTo(fromCc, mid);\r\n            let b = flo_vector2d_1.fromTo(toCc, mid);\r\n            twisted = flo_vector2d_1.dot(a, c) < 0 || flo_vector2d_1.dot(b, c) > 0;\r\n        }\r\n        if (!twisted) {\r\n            cpNode.matCurveToNextVertex = [fromCc, mid, toCc];\r\n            cpNode.next.prevOnCircle.matCurveToNextVertex = [toCc, mid, fromCc];\r\n            return;\r\n        }\r\n        let r = flo_vector2d_1.rotate90Degrees(c);\r\n        let w1 = flo_vector2d_1.fromTo(fromL[0], fromL[1]); // This is a unit vector\r\n        let w2 = flo_vector2d_1.fromTo(toL[0], toL[1]); // This is a unit vector\r\n        let d1 = Math.abs(flo_vector2d_1.cross(c, w1)) / (3 * 3);\r\n        let d2 = Math.abs(flo_vector2d_1.cross(c, w2)) / (3 * 3);\r\n        if (d1 > TOLERANCE_ADD_2PRONG || d2 > TOLERANCE_ADD_2PRONG) {\r\n            // TODO - not within tolerance - must add additional 2-prong\r\n            cpNode.matCurveToNextVertex = [fromCc, toCc];\r\n            cpNode.next.prevOnCircle.matCurveToNextVertex = [toCc, fromCc];\r\n            return;\r\n        }\r\n        if (d1 > TOLERANCE_USE_LINE || d2 > TOLERANCE_USE_LINE) {\r\n            // approximate with cubic bezier\r\n            let m1 = flo_vector2d_1.interpolate(fromCc, toCc, 1 / 3);\r\n            let m2 = flo_vector2d_1.interpolate(fromCc, toCc, 2 / 3);\r\n            let v1 = flo_vector2d_1.translate(r, m1);\r\n            let v2 = flo_vector2d_1.translate(r, m2);\r\n            let l1 = [m1, v1];\r\n            let l2 = [m2, v2];\r\n            let mid1 = line_line_intersection_1.lineLineIntersection(fromL, l1);\r\n            let mid2 = line_line_intersection_1.lineLineIntersection(toL, l2);\r\n            cpNode.matCurveToNextVertex = [fromCc, mid1, mid2, toCc];\r\n            cpNode.next.prevOnCircle.matCurveToNextVertex = [toCc, mid2, mid1, fromCc];\r\n            return;\r\n        }\r\n        // Within tolerance - approximate with a straight line.\r\n        cpNode.matCurveToNextVertex = [fromCc, toCc];\r\n        cpNode.next.prevOnCircle.matCurveToNextVertex = [toCc, fromCc];\r\n    }\r\n}\r\nexports.smoothen = smoothen;\r\n//# sourceMappingURL=smoothen.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/smoothen/smoothen.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/to-scale-axis/add-debug-info.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/to-scale-axis/add-debug-info.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction addDebugInfo(sat) {\r\n    if (typeof _debug_ === 'undefined') {\r\n        return;\r\n    }\r\n    let generated = _debug_.generated;\r\n    generated.elems.sat.push(sat);\r\n    let timing = generated.timing;\r\n    timing.sats[1] += performance.now() - timing.sats[0];\r\n}\r\nexports.addDebugInfo = addDebugInfo;\r\n//# sourceMappingURL=add-debug-info.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/to-scale-axis/add-debug-info.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/to-scale-axis/cull-non-cycles.js":
/*!************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/to-scale-axis/cull-non-cycles.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_leaves_1 = __webpack_require__(/*! ../get-leaves */ \"./node_modules/flo-mat/node/mat/get-leaves.js\");\r\nconst cp_node_1 = __webpack_require__(/*! ../../cp-node */ \"./node_modules/flo-mat/node/cp-node.js\");\r\n/**\r\n * Cull all edges not part of a cycle in the MAT planar graph.\r\n * @param cpStart The start CpNode which must reprsesent the maximal 3-prong\r\n * vertex.\r\n */\r\nfunction cullNonCycles(cpStart) {\r\n    let cpNodeKept = cpStart;\r\n    let leaves = get_leaves_1.getLeaves(cpStart);\r\n    while (leaves.length) {\r\n        let leaf = leaves.pop();\r\n        // Preserve topology - keep cycles.\r\n        if (leaf.isHoleClosing || leaf.isIntersection) {\r\n            continue;\r\n        }\r\n        let cpNode = leaf.next; // Turn around\r\n        while (true) {\r\n            cpNode = cpNode.next;\r\n            let cut = false;\r\n            let cp1 = cpNode.prevOnCircle;\r\n            if (cpNode.getProngCount() > 2) {\r\n                //let cp2 = cp1.prevOnCircle;\r\n                let cp2 = cpNode.nextOnCircle;\r\n                //if (cpStart === cpNode || cpStart === cp1 || cpStart === cp2) {\r\n                if (cp_node_1.CpNode.isOnSameCircle(cpNode, cpStart)) {\r\n                    cut = true; // We are at the max disk - cut whole edge\r\n                }\r\n                else if (cpNode.next === cp2) {\r\n                    cpNode = cp2;\r\n                }\r\n                else if (cp2.next !== cp1) {\r\n                    cut = true; // Cut whole edge\r\n                }\r\n            }\r\n            else if (cpNode.isTerminating() && !cpNode.isIntersection) {\r\n                cpNodeKept = cpNode;\r\n                return undefined;\r\n            }\r\n            if (cut) {\r\n                cp1.next = cpNode;\r\n                cpNode.prev = cp1;\r\n                cpNodeKept = cpNode;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return cpNodeKept;\r\n}\r\nexports.cullNonCycles = cullNonCycles;\r\n//# sourceMappingURL=cull-non-cycles.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/to-scale-axis/cull-non-cycles.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/to-scale-axis/cull.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/to-scale-axis/cull.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_leaves_1 = __webpack_require__(/*! ../get-leaves */ \"./node_modules/flo-mat/node/mat/get-leaves.js\");\r\nconst cp_node_1 = __webpack_require__(/*! ../../cp-node */ \"./node_modules/flo-mat/node/cp-node.js\");\r\n/**\r\n * Returns the set of Vertices passing the following test: walk the MAT tree and\r\n * keep all Vertices not in the current cull set and any Vertices that have a\r\n * non-culled node further down the line toward the tree leaves.\r\n * @param culls The CpNodes (referred to by circles) that should be culled.\r\n * @param maxCpNode The start CpNode which must reprsesent the maximal vertex.\r\n */\r\nfunction cull(culls, maxCpNode) {\r\n    let leaves = get_leaves_1.getLeaves(maxCpNode);\r\n    function getNonTrivialEdges(cpStart) {\r\n        let cp = cpStart;\r\n        let cps = [];\r\n        do {\r\n            if (cp.next !== cp.nextOnCircle) {\r\n                cps.push(cp);\r\n            }\r\n            cp = cp.nextOnCircle;\r\n        } while (cp !== cpStart.prevOnCircle);\r\n        return cps;\r\n    }\r\n    while (leaves.length) {\r\n        let leaf = leaves.pop();\r\n        // Preserve topology.\r\n        if (leaf.isHoleClosing || leaf.isIntersection) {\r\n            continue;\r\n        }\r\n        if (!culls.has(leaf.cp.circle)) {\r\n            continue;\r\n        }\r\n        let cpNode = leaf.next; // Turn around\r\n        while (true) {\r\n            cpNode = cpNode.next;\r\n            let cut = false;\r\n            let cp1 = cpNode.prevOnCircle;\r\n            if (!culls.has(cpNode.cp.circle)) {\r\n                // Cut off the edge once a non-cull has been reached.\r\n                cut = true;\r\n            }\r\n            else if (cp_node_1.CpNode.isOnSameCircle(cpNode, maxCpNode)) {\r\n                cut = true; // We are at the max disk - cut whole edge\r\n            }\r\n            else {\r\n                let cps = getNonTrivialEdges(cpNode);\r\n                if (cps.length === 1) {\r\n                    cpNode = cps[0];\r\n                }\r\n                else {\r\n                    cut = true;\r\n                }\r\n            }\r\n            if (cut) {\r\n                cp1.next = cpNode;\r\n                cpNode.prev = cp1;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.cull = cull;\r\n//# sourceMappingURL=cull.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/to-scale-axis/cull.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/trim-mat.js":
/*!***************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/trim-mat.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst mat_1 = __webpack_require__(/*! ../mat */ \"./node_modules/flo-mat/node/mat.js\");\r\nconst smoothen_1 = __webpack_require__(/*! ./smoothen/smoothen */ \"./node_modules/flo-mat/node/mat/smoothen/smoothen.js\");\r\nconst create_new_cp_tree_1 = __webpack_require__(/*! ./create-new-cp-tree */ \"./node_modules/flo-mat/node/mat/create-new-cp-tree.js\");\r\nconst cull_non_cycles_1 = __webpack_require__(/*! ./to-scale-axis/cull-non-cycles */ \"./node_modules/flo-mat/node/mat/to-scale-axis/cull-non-cycles.js\");\r\n/**\r\n * Trims the given Medial Axis Transform so that only cycles remain. Similar to\r\n * toScaleAxis(mat, Number.POSITIVE_INFINITY).\r\n * @param mat The MAT to trim.\r\n */\r\nfunction trimMat(mat) {\r\n    let cpNode = cull_non_cycles_1.cullNonCycles(mat.cpNode.clone());\r\n    if (!cpNode) {\r\n        return undefined;\r\n    }\r\n    smoothen_1.smoothen(cpNode);\r\n    let mat_ = new mat_1.Mat(cpNode, create_new_cp_tree_1.createNewCpTree(cpNode));\r\n    /*\r\n    if (typeof _debug_ !== 'undefined') {\r\n        let generated = _debug_.generated;\r\n        generated.elems.sat.push(mat_);\r\n    }\r\n    */\r\n    return mat_;\r\n}\r\nexports.trimMat = trimMat;\r\n//# sourceMappingURL=trim-mat.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/trim-mat.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/point-on-shape.js":
/*!*****************************************************!*\
  !*** ./node_modules/flo-mat/node/point-on-shape.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst curve_1 = __webpack_require__(/*! ./curve */ \"./node_modules/flo-mat/node/curve.js\");\r\nconst circle_1 = __webpack_require__(/*! ./circle */ \"./node_modules/flo-mat/node/circle.js\");\r\n/**\r\n * Represents a point on the shape boundary for which MAT vertex information\r\n * has not *necessarily* been calculated.\r\n */\r\nclass PointOnShape {\r\n    /**\r\n     * @param curve\tThe [[Curve]] on the shape boundary this points belong to.\r\n     * @param t The bezier parameter value on the curve to identify the point\r\n     * coordinates.\r\n     */\r\n    constructor(curve, t) {\r\n        this.curve = curve;\r\n        this.t = t;\r\n        // Cache\r\n        this.p_ = undefined;\r\n    }\r\n    /**\r\n     * The planar point coordinates of this [[PointOnShape]].\r\n     */\r\n    get p() {\r\n        return this.p_ === undefined\r\n            ? this.p_ = flo_bezier3_1.evaluate(this.curve.ps, this.t)\r\n            : this.p_;\r\n    }\r\n    /**\r\n     * Returns the osculating circle at this point of the curve.\r\n     * @param maxOsculatingCircleRadius If not Number.POSITIVE_INFINITY then the\r\n     * circle radius will be limited to this value.\r\n     * @param pos The [[PointOnShape]] identifying the point.\r\n     */\r\n    static getOsculatingCircle(maxOsculatingCircleRadius, pos) {\r\n        if (PointOnShape.isSharpCorner(pos)) {\r\n            return new circle_1.Circle(pos.p, 0);\r\n        }\r\n        let radius = PointOnShape.calcOsculatingCircleRadius(pos);\r\n        if (radius < 0) {\r\n            radius = Number.POSITIVE_INFINITY;\r\n        }\r\n        radius = Math.min(radius, maxOsculatingCircleRadius);\r\n        let ps = pos.curve.ps;\r\n        let t = pos.t;\r\n        let normal_ = flo_bezier3_1.normal(ps, t);\r\n        let p = flo_bezier3_1.evaluate(ps, t);\r\n        let circleCenter = [\r\n            p[0] + normal_[0] * radius,\r\n            p[1] + normal_[1] * radius\r\n        ];\r\n        return new circle_1.Circle(circleCenter, radius);\r\n    }\r\n    /**\r\n     * Calculates the order (to distinguish between points lying on top of each\r\n     * other) of the contact point if it is a dull corner.\r\n     * @param pos\r\n     * @private\r\n     */\r\n    static calcOrder(circle, pos) {\r\n        if (!PointOnShape.isDullCorner(pos)) {\r\n            return 0;\r\n        }\r\n        let corner = PointOnShape.getCorner(pos);\r\n        let n = flo_vector2d_1.rotateNeg90Degrees(corner.tangents[0]);\r\n        let v = flo_vector2d_1.toUnitVector(flo_vector2d_1.fromTo(pos.p, circle.center));\r\n        return -flo_vector2d_1.dot(n, v);\r\n    }\r\n}\r\n/**\r\n * Calculates and returns the osculating circle radius of the bezier at a\r\n * specific t. If it is found to have negative or nearly zero radius\r\n * it is clipped to have positive radius so it can point into the shape.\r\n * @param ps\r\n * @param t\r\n * @private\r\n */\r\nPointOnShape.calcOsculatingCircleRadius = flo_memoize_1.memoize(function (pos) {\r\n    let ps = pos.curve.ps;\r\n    let t = pos.t;\r\n    let κ = -flo_bezier3_1.κ(ps, t);\r\n    // κ > 0 => bending inwards\r\n    return 1 / κ;\r\n});\r\n/**\r\n * Compares two [[PointOnShape]]s according to their cyclic ordering imposed\r\n * by their relative positions on the shape boundary.\r\n * @param a The first [[PointOnShape]].\r\n * @param b The second [[PointOnShape]].\r\n * @private\r\n */\r\nPointOnShape.compare = function (a, b) {\r\n    if (a === undefined || b === undefined) {\r\n        return undefined;\r\n    }\r\n    let res;\r\n    res = a.curve.idx - b.curve.idx;\r\n    if (res !== 0) {\r\n        return res;\r\n    }\r\n    res = a.t - b.t;\r\n    return res;\r\n};\r\n/**\r\n * Ignores order2 (used in hole-closing two-prongs only)\r\n * @private\r\n */\r\nPointOnShape.compareInclOrder = function (a, b, aOrder, bOrder) {\r\n    let res = PointOnShape.compare(a, b);\r\n    if (res === undefined) {\r\n        return undefined;\r\n    }\r\n    if (res !== 0) {\r\n        return res;\r\n    }\r\n    res = aOrder - bOrder;\r\n    return res;\r\n};\r\n/**\r\n * @private\r\n */\r\nPointOnShape.getCorner = flo_memoize_1.memoize(function (pos) {\r\n    if (pos.t !== 0 && pos.t !== 1) {\r\n        return undefined;\r\n    }\r\n    return curve_1.Curve.getCornerAtEnd(pos.t === 1 ? pos.curve : pos.curve.prev);\r\n});\r\n/**\r\n * @private\r\n */\r\nPointOnShape.isSharpCorner = flo_memoize_1.memoize(function (pos) {\r\n    let corner = PointOnShape.getCorner(pos);\r\n    return corner && corner.isSharp;\r\n});\r\n/**\r\n * @private\r\n */\r\nPointOnShape.isDullCorner = flo_memoize_1.memoize(function (pos) {\r\n    let corner = PointOnShape.getCorner(pos);\r\n    return corner && corner.isDull;\r\n});\r\n/**\r\n * @private\r\n */\r\nPointOnShape.isQuiteSharpCorner = flo_memoize_1.memoize(function (pos) {\r\n    let corner = PointOnShape.getCorner(pos);\r\n    return corner && corner.isQuiteSharp;\r\n});\r\n/**\r\n * @private\r\n */\r\nPointOnShape.isQuiteDullCorner = flo_memoize_1.memoize(function (pos) {\r\n    let corner = PointOnShape.getCorner(pos);\r\n    return corner && corner.isQuiteDull;\r\n});\r\n/**\r\n * Returns a human-readable string of the given [[PointOnShape]].\r\n * For debugging only.\r\n * @private\r\n */\r\nPointOnShape.toHumanString = function (pos) {\r\n    return '' + pos.p[0] + ', ' + pos.p[1] +\r\n        ' | bz: ' + pos.curve.idx +\r\n        ' | t: ' + pos.t;\r\n};\r\nexports.PointOnShape = PointOnShape;\r\n//# sourceMappingURL=point-on-shape.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/point-on-shape.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/fs/beziers-to-svg-path-str.js":
/*!*********************************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/fs/beziers-to-svg-path-str.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns an SVG path string representation of the given cubic bezier loop.\r\n * @param beziers An array of cubic bezier curves each given as an array of\r\n * control points.\r\n * @param decimalPlaces The number of decimal places in the returned path\r\n * string.\r\n * @doc _\r\n */\r\nfunction beziersToSvgPathStr(beziers, decimalPlaces = 10) {\r\n    const D = decimalPlaces;\r\n    let str = '';\r\n    for (let i = 0; i < beziers.length; i++) {\r\n        let ps = beziers[i];\r\n        if (i === 0) {\r\n            str = 'M ' +\r\n                ps[0][0].toFixed(D) + ' ' +\r\n                ps[0][1].toFixed(D) + '\\n';\r\n        }\r\n        str += 'C ' +\r\n            ps[1][0].toFixed(D) + ' ' +\r\n            ps[1][1].toFixed(D) + ' ' +\r\n            ps[2][0].toFixed(D) + ' ' +\r\n            ps[2][1].toFixed(D) + ' ' +\r\n            ps[3][0].toFixed(D) + ' ' +\r\n            ps[3][1].toFixed(D) + ' ' + '\\n';\r\n    }\r\n    return str + ' z' + '\\n';\r\n}\r\nexports.beziersToSvgPathStr = beziersToSvgPathStr;\r\n//# sourceMappingURL=beziers-to-svg-path-str.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/fs/beziers-to-svg-path-str.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/fs/de-pathologify.js":
/*!************************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/fs/de-pathologify.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\n/**\r\n * Possibly changes the curve into one that is as close to the original as\r\n * possible but does not have pathological properties (i.e. does not have near\r\n * infinitely sharp corners, etc) or if that is not possible remove the curve in\r\n * some circumstances (e.g. if it is of extreme short length, etc.).\r\n * @param ps Cubic bezier curve points.\r\n */\r\nfunction dePathologify(ps_, max) {\r\n    // TODO \r\n    // We check if any of the ps are coincident and thus\r\n    // that the bezier is degenerate in some sense. If that is the\r\n    // case we apply a heuristic to get a new similar bezier by \r\n    // respacing the points. This entire function is very \r\n    // convoluted.\r\n    // We should investigate a better mathematical solution.\r\n    // Currently if the bezier degenerates more or less into a point\r\n    // we make the next bezier start at the previous bezier's end\r\n    // point else we adjust the bezier to be less pathological.\r\n    let delta = max / 1e4;\r\n    let ds = [\r\n        [\r\n            0,\r\n            flo_vector2d_1.manhattanDistanceBetween(ps_[0], ps_[1]),\r\n            flo_vector2d_1.manhattanDistanceBetween(ps_[0], ps_[2]),\r\n            flo_vector2d_1.manhattanDistanceBetween(ps_[0], ps_[3])\r\n        ],\r\n        [\r\n            flo_vector2d_1.manhattanDistanceBetween(ps_[1], ps_[0]),\r\n            0,\r\n            flo_vector2d_1.manhattanDistanceBetween(ps_[1], ps_[2]),\r\n            flo_vector2d_1.manhattanDistanceBetween(ps_[1], ps_[3]),\r\n        ],\r\n        [\r\n            flo_vector2d_1.manhattanDistanceBetween(ps_[2], ps_[0]),\r\n            flo_vector2d_1.manhattanDistanceBetween(ps_[2], ps_[1]),\r\n            0,\r\n            flo_vector2d_1.manhattanDistanceBetween(ps_[2], ps_[3]),\r\n        ],\r\n        [\r\n            flo_vector2d_1.manhattanDistanceBetween(ps_[3], ps_[0]),\r\n            flo_vector2d_1.manhattanDistanceBetween(ps_[3], ps_[1]),\r\n            flo_vector2d_1.manhattanDistanceBetween(ps_[3], ps_[2]),\r\n            0,\r\n        ]\r\n    ];\r\n    let ps = ps_;\r\n    const SHIFT = 0.02;\r\n    // Check if first or last 3 points are coincident\r\n    if (ds[0][1] < delta && ds[1][2] < delta ||\r\n        ds[1][2] < delta && ds[2][3] < delta) {\r\n        ps = [\r\n            ps_[0],\r\n            flo_vector2d_1.interpolate(ps_[0], ps_[3], 1 / 3),\r\n            flo_vector2d_1.interpolate(ps_[0], ps_[3], 2 / 3),\r\n            ps_[3]\r\n        ];\r\n    }\r\n    // Check if first 2 points are coincident\r\n    if (ds[0][1] < delta) {\r\n        ps[1] = flo_vector2d_1.interpolate(ps_[0], ps_[2], SHIFT);\r\n    }\r\n    // Check if last 2 points are coincident\r\n    if (ds[2][3] < delta) {\r\n        ps[2] = flo_vector2d_1.interpolate(ps_[1], ps_[3], 1 - SHIFT);\r\n    }\r\n    // Check if middle 2 points are coincident\r\n    if (ds[1][2] < delta) {\r\n        ps[1] = flo_vector2d_1.interpolate(ps_[0], ps_[1], 1 - SHIFT);\r\n        ps[2] = flo_vector2d_1.interpolate(ps_[2], ps_[3], SHIFT);\r\n    }\r\n    return ps;\r\n}\r\nexports.dePathologify = dePathologify;\r\n//# sourceMappingURL=de-pathologify.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/fs/de-pathologify.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/fs/get-beziers-from-raw-paths.js":
/*!************************************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/fs/get-beziers-from-raw-paths.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst push_bezier_1 = __webpack_require__(/*! ../fs/push-bezier */ \"./node_modules/flo-mat/node/svg/fs/push-bezier.js\");\r\nconst path_state_1 = __webpack_require__(/*! ../path-state */ \"./node_modules/flo-mat/node/svg/path-state.js\");\r\nconst z_1 = __webpack_require__(/*! ../path-segment/z */ \"./node_modules/flo-mat/node/svg/path-segment/z.js\");\r\nconst c_1 = __webpack_require__(/*! ../path-segment/c */ \"./node_modules/flo-mat/node/svg/path-segment/c.js\");\r\nconst s_1 = __webpack_require__(/*! ../path-segment/s */ \"./node_modules/flo-mat/node/svg/path-segment/s.js\");\r\nconst l_1 = __webpack_require__(/*! ../path-segment/l */ \"./node_modules/flo-mat/node/svg/path-segment/l.js\");\r\nconst h_1 = __webpack_require__(/*! ../path-segment/h */ \"./node_modules/flo-mat/node/svg/path-segment/h.js\");\r\nconst v_1 = __webpack_require__(/*! ../path-segment/v */ \"./node_modules/flo-mat/node/svg/path-segment/v.js\");\r\nconst q_1 = __webpack_require__(/*! ../path-segment/q */ \"./node_modules/flo-mat/node/svg/path-segment/q.js\");\r\nconst t_1 = __webpack_require__(/*! ../path-segment/t */ \"./node_modules/flo-mat/node/svg/path-segment/t.js\");\r\nconst a_1 = __webpack_require__(/*! ../path-segment/a */ \"./node_modules/flo-mat/node/svg/path-segment/a.js\");\r\nconst pathFs = { a: a_1.a, c: c_1.c, h: h_1.h, l: l_1.l, q: q_1.q, s: s_1.s, t: t_1.t, v: v_1.v, z: z_1.z };\r\n/**\r\n * Get the cubic beziers from the given SVG DOM element. If a path\r\n * data tag is not \"C\", i.e. if it is not an absolute cubic bezier\r\n * coordinate then it is converted into one.\r\n * @param elem - An SVG element\r\n * @returns aaa\r\n */\r\nfunction getBeziersFromRawPaths(paths) {\r\n    if (paths.length === 0) {\r\n        return []; // A shape is not described   \r\n    }\r\n    if (paths[0].type.toLowerCase() !== 'm') {\r\n        throw new Error('Invalid SVG - every new path must start with an M or m.');\r\n    }\r\n    let s = new path_state_1.PathState();\r\n    let beziersArrays = [];\r\n    let beziers = [];\r\n    let max = Number.NEGATIVE_INFINITY;\r\n    for (let i = 0; i < paths.length; i++) {\r\n        let path = paths[i];\r\n        for (let j = 0; j < path.values.length; j++) {\r\n            let v = path.values[j];\r\n            if (max < v) {\r\n                max = v;\r\n            }\r\n        }\r\n    }\r\n    let type = undefined;\r\n    let prevType;\r\n    for (let i = 0; i < paths.length; i++) {\r\n        prevType = type;\r\n        let pathSeg = paths[i];\r\n        type = pathSeg.type.toLowerCase();\r\n        s.vals = pathSeg.values;\r\n        /*\r\n        if (pathSeg.values[0] === 109.637) {\r\n            console.log('109')\r\n        }\r\n        */\r\n        if (pathSeg.type === pathSeg.type.toLowerCase()) {\r\n            if (type === 'v') {\r\n                s.vals[0] += s.p[1];\r\n            }\r\n            else if (type === 'a') {\r\n                s.vals[5] += s.p[0];\r\n                s.vals[6] += s.p[1];\r\n            }\r\n            else {\r\n                for (let i = 0; i < s.vals.length; i++) {\r\n                    s.vals[i] += s.p[i % 2];\r\n                }\r\n            }\r\n        }\r\n        if (type === 'm') {\r\n            if (beziers.length) {\r\n                // This is a subpath, close as if the previous command was a \r\n                // Z or z.\r\n                if (prevType !== 'z') {\r\n                    push_bezier_1.pushBezier(beziers, z_1.z(s), s, max);\r\n                }\r\n                // Start new path\r\n                beziersArrays.push(beziers);\r\n                beziers = [];\r\n            }\r\n            s.initialPoint = s.p = s.vals;\r\n            continue;\r\n        }\r\n        let f = pathFs[type];\r\n        if (!f) {\r\n            throw new Error('Invalid SVG - command not recognized.');\r\n        }\r\n        let ps = f(s);\r\n        s.p = ps[3]; // Update current point\r\n        push_bezier_1.pushBezier(beziers, ps, s, max);\r\n    }\r\n    if (beziers.length) {\r\n        //beziersArrays.push(beziers);\r\n        // This is a subpath, close as if the previous command was a \r\n        // Z or z.\r\n        if (prevType !== 'z') {\r\n            push_bezier_1.pushBezier(beziers, z_1.z(s), s, max);\r\n        }\r\n        // Start new path\r\n        beziersArrays.push(beziers);\r\n    }\r\n    return beziersArrays;\r\n}\r\nexports.getBeziersFromRawPaths = getBeziersFromRawPaths;\r\n//# sourceMappingURL=get-beziers-from-raw-paths.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/fs/get-beziers-from-raw-paths.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/fs/get-extreme.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/fs/get-extreme.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_shape_bounds_1 = __webpack_require__(/*! ./get-shape-bounds */ \"./node_modules/flo-mat/node/svg/fs/get-shape-bounds.js\");\r\n/**\r\n * Returns the max extreme point coordinate value for the given shape. This is\r\n * used for floating point tolerance calculations.\r\n * @param loops\r\n */\r\nfunction getExtreme(loops) {\r\n    let bounds = get_shape_bounds_1.getShapeBounds(loops);\r\n    return Math.max(Math.abs(bounds.minX.p[0]), Math.abs(bounds.minY.p[1]), Math.abs(bounds.maxX.p[0]), Math.abs(bounds.maxY.p[1]));\r\n}\r\nexports.getExtreme = getExtreme;\r\n//# sourceMappingURL=get-extreme.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/fs/get-extreme.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/fs/get-loop-bounds.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/fs/get-loop-bounds.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nconst INF = Number.POSITIVE_INFINITY;\r\nlet getLoopBounds = flo_memoize_1.memoize(function (loop) {\r\n    let extremes = [\r\n        [\r\n            { bezier: undefined, t: undefined, val: INF },\r\n            { bezier: undefined, t: undefined, val: INF }\r\n        ],\r\n        [\r\n            { bezier: undefined, t: undefined, val: -INF },\r\n            { bezier: undefined, t: undefined, val: -INF }\r\n        ]\r\n    ];\r\n    loop.curves.forEach(function (curve) {\r\n        let ps = curve.ps;\r\n        let bounds = flo_bezier3_1.getBounds(ps);\r\n        for (let i = 0; i < 2; i++) {\r\n            for (let j = 0; j < 2; j++) {\r\n                let v = bounds.box[i][j];\r\n                let m = i === 0 ? -1 : 1; // min or max?\r\n                let x = extremes[i][j].val;\r\n                if (m * v > m * x || (v === x && bounds.ts[i][j] > extremes[i][j].t)) {\r\n                    extremes[i][j] = {\r\n                        bezier: curve,\r\n                        t: bounds.ts[i][j],\r\n                        val: v\r\n                    };\r\n                }\r\n            }\r\n        }\r\n    });\r\n    return {\r\n        minX: new point_on_shape_1.PointOnShape(extremes[0][0].bezier, extremes[0][0].t),\r\n        minY: new point_on_shape_1.PointOnShape(extremes[0][1].bezier, extremes[0][1].t),\r\n        maxX: new point_on_shape_1.PointOnShape(extremes[1][0].bezier, extremes[1][0].t),\r\n        maxY: new point_on_shape_1.PointOnShape(extremes[1][1].bezier, extremes[1][1].t)\r\n    };\r\n});\r\nexports.getLoopBounds = getLoopBounds;\r\n//# sourceMappingURL=get-loop-bounds.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/fs/get-loop-bounds.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/fs/get-min-y-pos.js":
/*!***********************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/fs/get-min-y-pos.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_loop_bounds_1 = __webpack_require__(/*! ./get-loop-bounds */ \"./node_modules/flo-mat/node/svg/fs/get-loop-bounds.js\");\r\n/**\r\n * Get topmost PointOnShape the given loop.\r\n */\r\nfunction getMinYPos(loop) {\r\n    let pos = get_loop_bounds_1.getLoopBounds(loop).minY;\r\n    if (typeof _debug_ !== 'undefined') {\r\n        _debug_.generated.elems.minY.push(pos);\r\n    }\r\n    return pos;\r\n}\r\nexports.getMinYPos = getMinYPos;\r\n//# sourceMappingURL=get-min-y-pos.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/fs/get-min-y-pos.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/fs/get-paths-from-str.js":
/*!****************************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/fs/get-paths-from-str.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_beziers_from_raw_paths_1 = __webpack_require__(/*! ./get-beziers-from-raw-paths */ \"./node_modules/flo-mat/node/svg/fs/get-beziers-from-raw-paths.js\");\r\nconst parse_path_data_string_1 = __webpack_require__(/*! ../path-data-polyfill/parse-path-data-string */ \"./node_modules/flo-mat/node/svg/path-data-polyfill/parse-path-data-string.js\");\r\n/**\r\n * Returns an array of loops with each loop consisting of an array of beziers\r\n * and each bezier in turn consisting of an array of control points from the\r\n * given SVG path string. An array of loops are returned (as opposed to a single\r\n * loop) since an SVG path may have sub-paths.\r\n * @param str The SVG path string, e.g. 'M1 1 C 5 1 5 2 4 2 C 3 3 1 3 1 1 z'\r\n * @doc _\r\n */\r\nfunction getPathsFromStr(str) {\r\n    return get_beziers_from_raw_paths_1.getBeziersFromRawPaths(parse_path_data_string_1.parsePathDataString(str));\r\n}\r\nexports.getPathsFromStr = getPathsFromStr;\r\n//# sourceMappingURL=get-paths-from-str.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/fs/get-paths-from-str.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/fs/get-shape-bounds.js":
/*!**************************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/fs/get-shape-bounds.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\r\nconst get_loop_bounds_1 = __webpack_require__(/*! ./get-loop-bounds */ \"./node_modules/flo-mat/node/svg/fs/get-loop-bounds.js\");\r\nlet getShapeBounds = flo_memoize_1.memoize(function (loops) {\r\n    let minX_ = Number.POSITIVE_INFINITY;\r\n    let maxX_ = Number.NEGATIVE_INFINITY;\r\n    let minY_ = Number.POSITIVE_INFINITY;\r\n    let maxY_ = Number.NEGATIVE_INFINITY;\r\n    let minX;\r\n    let maxX;\r\n    let minY;\r\n    let maxY;\r\n    for (let loop of loops) {\r\n        let bounds = get_loop_bounds_1.getLoopBounds(loop);\r\n        if (bounds.minX.p[0] < minX_) {\r\n            minX = bounds.minX;\r\n            minX_ = bounds.minX.p[0];\r\n        }\r\n        if (bounds.maxX.p[0] > maxX_) {\r\n            maxX = bounds.maxX;\r\n            maxX_ = bounds.maxX.p[0];\r\n        }\r\n        if (bounds.minY.p[1] < minY_) {\r\n            minY = bounds.minY;\r\n            minY_ = bounds.minY.p[1];\r\n        }\r\n        if (bounds.maxY.p[1] > maxY_) {\r\n            maxY = bounds.maxY;\r\n            maxY_ = bounds.maxY.p[1];\r\n        }\r\n    }\r\n    return { minX, minY, maxX, maxY };\r\n});\r\nexports.getShapeBounds = getShapeBounds;\r\nlet getShapesBounds = flo_memoize_1.memoize(function (loopss) {\r\n    let minX_ = Number.POSITIVE_INFINITY;\r\n    let maxX_ = Number.NEGATIVE_INFINITY;\r\n    let minY_ = Number.POSITIVE_INFINITY;\r\n    let maxY_ = Number.NEGATIVE_INFINITY;\r\n    let minX;\r\n    let maxX;\r\n    let minY;\r\n    let maxY;\r\n    for (let loops of loopss) {\r\n        let bounds = getShapeBounds(loops);\r\n        if (bounds.minX.p[0] < minX_) {\r\n            minX = bounds.minX;\r\n            minX_ = bounds.minX.p[0];\r\n        }\r\n        if (bounds.maxX.p[0] > maxX_) {\r\n            maxX = bounds.maxX;\r\n            maxX_ = bounds.maxX.p[0];\r\n        }\r\n        if (bounds.minY.p[1] < minY_) {\r\n            minY = bounds.minY;\r\n            minY_ = bounds.minY.p[1];\r\n        }\r\n        if (bounds.maxY.p[1] > maxY_) {\r\n            maxY = bounds.maxY;\r\n            maxY_ = bounds.maxY.p[1];\r\n        }\r\n    }\r\n    return { minX, minY, maxX, maxY };\r\n});\r\nexports.getShapesBounds = getShapesBounds;\r\n//# sourceMappingURL=get-shape-bounds.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/fs/get-shape-bounds.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/fs/is-almost-zero-length.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/fs/is-almost-zero-length.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst DELTA = 1e-6;\r\n/**\r\n * Returns true if distance between consecutive points are all less than\r\n * some delta, false otherwise.\r\n * @private\r\n * @param ps - an array of points\r\n * @param delta - a tolerance - defaults to 1e-6;\r\n */\r\nfunction isAlmostZeroLength(ps, delta = DELTA) {\r\n    for (let i = 1; i < ps.length; i++) {\r\n        let p1 = ps[i - 1];\r\n        let p2 = ps[i];\r\n        if (flo_vector2d_1.manhattanDistanceBetween(p1, p2) > delta) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexports.isAlmostZeroLength = isAlmostZeroLength;\r\n//# sourceMappingURL=is-almost-zero-length.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/fs/is-almost-zero-length.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/fs/is-path-positively-oriented.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/fs/is-path-positively-oriented.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\r\nconst get_loop_bounds_1 = __webpack_require__(/*! ./get-loop-bounds */ \"./node_modules/flo-mat/node/svg/fs/get-loop-bounds.js\");\r\n/**\r\n * Returns true if the given beizer loop is positively orientated, false\r\n * otherwise. Careful! Checks leftmost part of loop so twisted complex paths\r\n * may give an ambiguous orientation.\r\n */\r\nlet isPathPositivelyOrientated = flo_memoize_1.memoize(function (bezierLoop) {\r\n    let extreme = get_loop_bounds_1.getLoopBounds(bezierLoop).minX;\r\n    let t = extreme.t;\r\n    let curve;\r\n    if (t === 0) {\r\n        curve = extreme.curve.prev;\r\n        t = 1;\r\n    }\r\n    else {\r\n        curve = extreme.curve;\r\n    }\r\n    let ps = curve.ps;\r\n    let tan = flo_bezier3_1.tangent(ps)(t);\r\n    if (t !== 1) {\r\n        // Not a sharp corner\r\n        return tan[1] < 0;\r\n    }\r\n    let psNext = curve.next.ps;\r\n    let tanNext = flo_bezier3_1.tangent(psNext)(0);\r\n    if (tan[1] * tanNext[1] > 0) {\r\n        // Both tangents points up or both points down.\r\n        return tan[1] < 0;\r\n    }\r\n    // One tangent points up and the other down.\r\n    let c = flo_vector2d_1.cross(tan, tanNext);\r\n    return c > 0;\r\n    // We don't check for the very special case where the cross === 0. \r\n});\r\nexports.isPathPositivelyOrientated = isPathPositivelyOrientated;\r\n//# sourceMappingURL=is-path-positively-oriented.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/fs/is-path-positively-oriented.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/fs/linear-to-cubic.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/fs/linear-to-cubic.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction linearToCubic(l) {\r\n    let [p0, p1] = l;\r\n    let xInterval = (p1[0] - p0[0]) / 3;\r\n    let yInterval = (p1[1] - p0[1]) / 3;\r\n    let ps = [\r\n        p0,\r\n        [p0[0] + xInterval, p0[1] + yInterval],\r\n        [p0[0] + xInterval * 2, p0[1] + yInterval * 2],\r\n        p1\r\n    ];\r\n    return ps;\r\n}\r\nexports.linearToCubic = linearToCubic;\r\n//# sourceMappingURL=linear-to-cubic.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/fs/linear-to-cubic.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/fs/push-bezier.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/fs/push-bezier.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst de_pathologify_1 = __webpack_require__(/*! ./de-pathologify */ \"./node_modules/flo-mat/node/svg/fs/de-pathologify.js\");\r\nconst is_almost_zero_length_1 = __webpack_require__(/*! ./is-almost-zero-length */ \"./node_modules/flo-mat/node/svg/fs/is-almost-zero-length.js\");\r\n// TODO - 1e4 is arbitrary\r\nconst RESOLUTION = 1e4;\r\n/**\r\n *\r\n * @param beziers The array of path curves\r\n * @param ps_ The bezier\r\n * @param state The current path state\r\n */\r\nfunction pushBezier(beziers, ps_, s, max) {\r\n    /*\r\nif ( isAlmostZeroLength(ps_, max/RESOLUTION) ) {\r\nif ( isAlmostZeroLength(ps_, 0) ) {\r\n    return;\r\n}\r\n//console.log(ps_);\r\n}\r\n\r\nbeziers.push(ps_);\r\n*/\r\n    if (is_almost_zero_length_1.isAlmostZeroLength(ps_, max / RESOLUTION)) {\r\n        let len = beziers.length;\r\n        if (len === 0) {\r\n            s.initialPoint = ps_[3];\r\n        }\r\n        else {\r\n            let prevPs = beziers[len - 1];\r\n            prevPs[3] = ps_[3];\r\n        }\r\n        return;\r\n    }\r\n    let ps = de_pathologify_1.dePathologify(ps_, max);\r\n    beziers.push(ps);\r\n}\r\nexports.pushBezier = pushBezier;\r\n//# sourceMappingURL=push-bezier.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/fs/push-bezier.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/fs/quadratic-to-cubic.js":
/*!****************************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/fs/quadratic-to-cubic.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction quadraticToCubic(ps) {\r\n    let [p0, p1, p2] = ps;\r\n    return [\r\n        p0,\r\n        [\r\n            p0[0] + (2 / 3) * (p1[0] - p0[0]),\r\n            p0[1] + (2 / 3) * (p1[1] - p0[1])\r\n        ],\r\n        [\r\n            p2[0] + (2 / 3) * (p1[0] - p2[0]),\r\n            p2[1] + (2 / 3) * (p1[1] - p2[1])\r\n        ],\r\n        p2\r\n    ];\r\n}\r\nexports.quadraticToCubic = quadraticToCubic;\r\n//# sourceMappingURL=quadratic-to-cubic.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/fs/quadratic-to-cubic.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/fs/simplify-paths/complete-loop.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/fs/simplify-paths/complete-loop.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst get_next_x_1 = __webpack_require__(/*! ./get-next-x */ \"./node_modules/flo-mat/node/svg/fs/simplify-paths/get-next-x.js\");\r\nfunction completeLoop(intersections, takenXs, xStack, loopTree, x) {\r\n    let beziers = [];\r\n    let reversed = (loopTree.windingNum === 0 && loopTree.orientation === -1) ||\r\n        (loopTree.windingNum !== 0 && loopTree.orientation === +1);\r\n    let pos = reversed ? x.pos : x.opposite.pos;\r\n    let startBez = pos.curve;\r\n    let startT = pos.t;\r\n    let curBez = startBez;\r\n    let curT = startT;\r\n    let fromX = x.isDummy\r\n        ? undefined\r\n        : reversed ? x.opposite : x;\r\n    let wasOnX = true;\r\n    while (true) {\r\n        let xs = intersections.get(curBez);\r\n        let x_ = xs ? get_next_x_1.getNextX(xs, curT, !reversed, wasOnX) : undefined;\r\n        // Add a bezier to the component loop.\r\n        if (x_) {\r\n            // We are at an intersection\r\n            wasOnX = true;\r\n            if (curT !== x_.pos.t) {\r\n                let ps = reversed\r\n                    ? flo_bezier3_1.reverse(flo_bezier3_1.fromTo(curBez.ps)(x_.pos.t, curT))\r\n                    : flo_bezier3_1.fromTo(curBez.ps)(curT, x_.pos.t);\r\n                beziers.push(ps);\r\n                addXOutPs(reversed, fromX, ps);\r\n                fromX = x_;\r\n            }\r\n            // Move onto next bezier\r\n            curBez = x_.opposite.pos.curve; // Switch to other path's bezier\r\n            curT = x_.opposite.pos.t; // ...\r\n            let _x_ = reversed ? x_.opposite : x_;\r\n            _x_.loopTree = loopTree;\r\n            if (!takenXs.has(_x_.opposite)) {\r\n                xStack.push(_x_.opposite);\r\n            }\r\n            takenXs.add(_x_); // Mark this intersection as taken\r\n        }\r\n        else {\r\n            wasOnX = false;\r\n            let t = reversed ? 0 : 1;\r\n            if (curT !== t) {\r\n                let ps = reversed\r\n                    ? flo_bezier3_1.reverse(flo_bezier3_1.fromTo(curBez.ps)(0, curT))\r\n                    : flo_bezier3_1.fromTo(curBez.ps)(curT, 1);\r\n                beziers.push(ps);\r\n                addXOutPs(reversed, fromX, ps);\r\n                fromX = undefined;\r\n            }\r\n            // Move onto next bezier on current path\r\n            curBez = reversed ? curBez.prev : curBez.next;\r\n            curT = reversed ? 1 : 0;\r\n        }\r\n        if (curBez === startBez && curT === startT) {\r\n            break;\r\n        }\r\n    }\r\n    return beziers;\r\n}\r\nexports.completeLoop = completeLoop;\r\nfunction addXOutPs(reversed, fromX, ps) {\r\n    if (fromX && !fromX.isDummy) {\r\n        let x = reversed ? fromX : fromX.opposite;\r\n        x.outPs = ps;\r\n        fromX = undefined;\r\n        //_debug_.fs.draw.bezier(_debug_.generated.g, ps, 'red thin10 nofill');\r\n    }\r\n}\r\n//# sourceMappingURL=complete-loop.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/fs/simplify-paths/complete-loop.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/fs/simplify-paths/complete-path.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/fs/simplify-paths/complete-path.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst loop_1 = __webpack_require__(/*! ../../../loop */ \"./node_modules/flo-mat/node/loop.js\");\r\nconst complete_loop_1 = __webpack_require__(/*! ./complete-loop */ \"./node_modules/flo-mat/node/svg/fs/simplify-paths/complete-loop.js\");\r\nconst get_initial_x_1 = __webpack_require__(/*! ./get-initial-x */ \"./node_modules/flo-mat/node/svg/fs/simplify-paths/get-initial-x.js\");\r\nconst get_loop_metrics_1 = __webpack_require__(/*! ./get-loop-metrics */ \"./node_modules/flo-mat/node/svg/fs/simplify-paths/get-loop-metrics.js\");\r\n/**\r\n *\r\n * @param intersections\r\n * @param loopsTaken\r\n * @param loop\r\n * @param parent\r\n */\r\nfunction completePath(intersections, loopsTaken, parent, loop) {\r\n    // Each loop generated by xs in xStack will give rise to one componentLoop. \r\n    // The initial intersection in the stack is a dummy.\r\n    /** Intersection stack */\r\n    let initialX = get_initial_x_1.getInitialX(intersections, parent, loop);\r\n    let curve = initialX.pos.curve;\r\n    let xs = intersections.get(curve) || [];\r\n    if (xs.length === 0) {\r\n        intersections.set(curve, xs);\r\n    }\r\n    xs.push(initialX);\r\n    let xStack = [initialX];\r\n    let takenXs = new Set(); // Taken intersections\r\n    while (xStack.length) {\r\n        let x = xStack.pop();\r\n        loopsTaken.add(x.pos.curve.loop);\r\n        if (takenXs.has(x)) {\r\n            continue;\r\n        }\r\n        let loopTree = get_loop_metrics_1.getLoopMetrics(x);\r\n        loopTree.beziers = complete_loop_1.completeLoop(intersections, takenXs, xStack, loopTree, x);\r\n        loopTree.loop = loop_1.Loop.fromCubicBeziers(loopTree.beziers);\r\n    }\r\n}\r\nexports.completePath = completePath;\r\n//# sourceMappingURL=complete-path.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/fs/simplify-paths/complete-path.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/fs/simplify-paths/get-initial-x.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/fs/simplify-paths/get-initial-x.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nconst is_path_positively_oriented_1 = __webpack_require__(/*! ../../fs/is-path-positively-oriented */ \"./node_modules/flo-mat/node/svg/fs/is-path-positively-oriented.js\");\r\nconst get_loop_bounds_1 = __webpack_require__(/*! ../get-loop-bounds */ \"./node_modules/flo-mat/node/svg/fs/get-loop-bounds.js\");\r\nconst x_1 = __webpack_require__(/*! ../../../x/x */ \"./node_modules/flo-mat/node/x/x.js\");\r\n/**\r\n * Get initial intersection which is really a dummy intersection.\r\n * @param loop\r\n * @param parent\r\n */\r\nfunction getInitialX(intersections, parent, loop) {\r\n    let dummyLoop = {\r\n        parent,\r\n        children: new Set(),\r\n        beziers: [],\r\n        loop: undefined,\r\n        orientation: is_path_positively_oriented_1.isPathPositivelyOrientated(loop) ? -1 : +1,\r\n        windingNum: parent.windingNum\r\n    };\r\n    let pos = get_loop_bounds_1.getLoopBounds(loop).minX;\r\n    let xs = intersections.get(pos.curve);\r\n    // If no intersections on this curve, just start at 0\r\n    if (!xs) {\r\n        pos = new point_on_shape_1.PointOnShape(pos.curve, 0);\r\n    }\r\n    let x = new x_1.X(pos, true, undefined, // will be set just below\r\n    dummyLoop);\r\n    x.opposite = x;\r\n    return x;\r\n}\r\nexports.getInitialX = getInitialX;\r\n//# sourceMappingURL=get-initial-x.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/fs/simplify-paths/get-initial-x.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/fs/simplify-paths/get-intersections.js":
/*!******************************************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/fs/simplify-paths/get-intersections.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst x_1 = __webpack_require__(/*! ../../../x/x */ \"./node_modules/flo-mat/node/x/x.js\");\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nconst pair_set_1 = __webpack_require__(/*! ./pair-set */ \"./node_modules/flo-mat/node/svg/fs/simplify-paths/pair-set.js\");\r\nconst find_bb_intersections_1 = __webpack_require__(/*! ../../../bounding-box/find-bb-intersections */ \"./node_modules/flo-mat/node/bounding-box/find-bb-intersections.js\");\r\n// TODO - DELTA is somewhat arbitrary\r\nconst DELTA = 1e-10;\r\n/**\r\n * Find and return all intersections on all given loops.\r\n * @param loops\r\n */\r\nfunction getIntersections(loops) {\r\n    // intersection <=> X\r\n    let { boxes, boxInfoMap } = getBoxInfos(loops);\r\n    let boxIntersections = find_bb_intersections_1.findBbIntersections(boxes);\r\n    // Check curve intersection amongst possibilities\r\n    /** A map from each curve to its intersectings */\r\n    let xMap = new Map();\r\n    let checkedPairs = new Map();\r\n    for (let i = 0; i < boxIntersections.length; i++) {\r\n        let { box1, box2 } = boxIntersections[i];\r\n        let curves = [\r\n            boxInfoMap.get(box1).curve,\r\n            boxInfoMap.get(box2).curve,\r\n        ];\r\n        if (pair_set_1.pairSet_has(checkedPairs, curves)) {\r\n            continue;\r\n        }\r\n        pair_set_1.pairSet_add(checkedPairs, curves);\r\n        let pss = curves.map(curve => curve.ps);\r\n        let tPairs = flo_bezier3_1.bezier3Intersection(pss[0], pss[1]);\r\n        if (!tPairs.length) {\r\n            continue;\r\n        }\r\n        for (let tPair of tPairs) {\r\n            let curves_ = confirmIntersection(checkedPairs, curves, tPair);\r\n            if (curves_ === undefined) {\r\n                continue;\r\n            }\r\n            let xs = [];\r\n            for (let j of [0, 1]) {\r\n                let curve = curves_[j];\r\n                let x = new x_1.X(new point_on_shape_1.PointOnShape(curve, tPair[j]));\r\n                // Get intersections stored at this curve\r\n                let curveXs = xMap.get(curve) || [];\r\n                if (!curveXs.length) {\r\n                    xMap.set(curve, curveXs);\r\n                }\r\n                // Add an intersection to this curve\r\n                curveXs.push(x);\r\n                xs.push(x);\r\n            }\r\n            xs[0].opposite = xs[1];\r\n            xs[1].opposite = xs[0];\r\n        }\r\n    }\r\n    return xMap;\r\n}\r\nexports.getIntersections = getIntersections;\r\n/**\r\n *\r\n */\r\nfunction confirmIntersection(checkedPairs, curves, tPair) {\r\n    let curves_ = curves.slice();\r\n    // TODO - the below check is temporary - there is a better way\r\n    // TODO - eliminate the fact that intersections are found twice\r\n    if (((Math.abs(tPair[0]) < DELTA && Math.abs(tPair[1] - 1) < DELTA) ||\r\n        (Math.abs(tPair[0] - 1) < DELTA && Math.abs(tPair[1]) < DELTA) ||\r\n        (Math.abs(tPair[0]) < DELTA && Math.abs(tPair[1]) < DELTA) ||\r\n        (Math.abs(tPair[0] - 1) < DELTA && Math.abs(tPair[1] - 1) < DELTA)) &&\r\n        (curves_[0].next === curves_[1] || curves_[1].next === curves_[0])) {\r\n        return undefined;\r\n    }\r\n    if (Math.abs(tPair[0] - 1) < DELTA) {\r\n        // If the intersection occurs at the end, move it to the start\r\n        // so we don't have a very small bezier piece left.\r\n        curves_[0] = curves_[0].next;\r\n        tPair[0] = 0;\r\n        // Recheck\r\n        if (pair_set_1.pairSet_has(checkedPairs, [curves_[0], curves_[1]])) {\r\n            return undefined;\r\n        }\r\n    }\r\n    if (Math.abs(tPair[1] - 1) < DELTA) {\r\n        // If the intersection occurs at the end, move it to the start\r\n        // so we don't have a very small bezier piece left.\r\n        curves_[1] = curves_[1].next;\r\n        tPair[1] = 0;\r\n        // Recheck\r\n        if (pair_set_1.pairSet_has(checkedPairs, [curves_[0], curves_[1]])) {\r\n            return undefined;\r\n        }\r\n    }\r\n    return curves_;\r\n}\r\n/**\r\n * Returns an array of lines of the bounding hulls of the Loop beziers' control\r\n * points including a map that maps each line to its hull, path and curve.\r\n * @param loops An array of Loops\r\n */\r\nfunction getBoxInfos(loops) {\r\n    /** Map that maps a line segment to some info. */\r\n    let boxInfoMap = new Map();\r\n    let boxes = [];\r\n    // Get lines making up the hulls of the paths\r\n    for (let loop of loops) {\r\n        loop.curves.forEach(function (curve) {\r\n            let box = flo_bezier3_1.getBoundingBox(curve.ps);\r\n            boxes.push(box);\r\n            boxInfoMap.set(box, { box, loop, curve });\r\n        });\r\n    }\r\n    return { boxes, boxInfoMap };\r\n}\r\n//# sourceMappingURL=get-intersections.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/fs/simplify-paths/get-intersections.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/fs/simplify-paths/get-loop-metrics.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/fs/simplify-paths/get-loop-metrics.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\n/**\r\n *\r\n * @param x The intersection\r\n */\r\nfunction getLoopMetrics(x) {\r\n    let oppositeLoopTree = x.opposite.loopTree;\r\n    let oppositeOrientation = oppositeLoopTree.orientation;\r\n    let oppositeWindingNum = oppositeLoopTree.windingNum;\r\n    // Left or right turning? - The current X\r\n    let oldInBez = x.opposite.pos.curve.ps;\r\n    let oldOutBez = x.pos.curve.ps;\r\n    let orientation;\r\n    let windingNum;\r\n    let parent;\r\n    if (oldInBez !== oldOutBez) {\r\n        let tanIn = flo_bezier3_1.tangent(oldInBez, x.opposite.pos.t);\r\n        let tanOut = flo_bezier3_1.tangent(oldOutBez, x.pos.t);\r\n        // TODO - if cross product is close to 0 check second derivatives (the \r\n        // same can be done at cusps in the mat code). E.g. a figure eight with \r\n        // coinciding bezier stretches may cause floating point instability.\r\n        let isLeft = flo_vector2d_1.cross(tanIn, tanOut) > 0;\r\n        let isTwist = (isLeft && oppositeOrientation === +1) ||\r\n            (!isLeft && oppositeOrientation === -1);\r\n        let windingNumberInc = isTwist\r\n            ? -2 * oppositeOrientation\r\n            : oppositeOrientation;\r\n        orientation = isTwist\r\n            ? -1 * oppositeOrientation\r\n            : +1 * oppositeOrientation;\r\n        windingNum = oppositeWindingNum + windingNumberInc;\r\n        parent = isTwist ? oppositeLoopTree.parent : oppositeLoopTree;\r\n    }\r\n    else {\r\n        // This is the first loop's start - it's a special case\r\n        orientation = oppositeOrientation === +1 ? -1 : +1;\r\n        windingNum = oppositeWindingNum + orientation;\r\n        parent = oppositeLoopTree.parent;\r\n    }\r\n    let iLoopTree = {\r\n        parent,\r\n        children: new Set(),\r\n        beziers: undefined,\r\n        loop: undefined,\r\n        orientation,\r\n        windingNum\r\n    };\r\n    parent.children.add(iLoopTree);\r\n    return iLoopTree;\r\n}\r\nexports.getLoopMetrics = getLoopMetrics;\r\n//# sourceMappingURL=get-loop-metrics.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/fs/simplify-paths/get-loop-metrics.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/fs/simplify-paths/get-next-x.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/fs/simplify-paths/get-next-x.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n *\r\n * @param xs An array of intersections on the curve\r\n * @param curT The current t value\r\n * @param forwards If true go forwards else go backwards\r\n */\r\nfunction getNextX(xs, curT, forwards, wasOnX) {\r\n    let bestX = undefined;\r\n    let bestT = Number.POSITIVE_INFINITY;\r\n    for (let i = 0; i < xs.length; i++) {\r\n        let x = xs[i];\r\n        let t = x.pos.t;\r\n        let deltaT = forwards\r\n            ? t - curT\r\n            : curT - t;\r\n        if ((deltaT > 0 || (deltaT === 0 && !wasOnX)) && deltaT < bestT) {\r\n            bestX = x;\r\n            bestT = deltaT;\r\n        }\r\n    }\r\n    return bestX;\r\n}\r\nexports.getNextX = getNextX;\r\n/**\r\n *\r\n * @param xs An array of intersections on the curve\r\n * @param t The current t value\r\n */\r\nfunction getThisX(xs, t) {\r\n    for (let i = 0; i < xs.length; i++) {\r\n        let x = xs[i];\r\n        if (x.pos.t - t === 0) {\r\n            return x;\r\n        }\r\n    }\r\n}\r\nexports.getThisX = getThisX;\r\n//# sourceMappingURL=get-next-x.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/fs/simplify-paths/get-next-x.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/fs/simplify-paths/get-tightest-containing-loop.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/fs/simplify-paths/get-tightest-containing-loop.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst is_loop_in_loop_1 = __webpack_require__(/*! ./is-loop-in-loop */ \"./node_modules/flo-mat/node/svg/fs/simplify-paths/is-loop-in-loop.js\");\r\n/**\r\n *\r\n * @param root\r\n * @param loop\r\n */\r\nfunction getTightestContainingLoop(root, loop) {\r\n    let containingLoop = undefined;\r\n    let stack = [root];\r\n    while (stack.length) {\r\n        let loopTree = stack.pop();\r\n        f(loopTree);\r\n    }\r\n    //console.log(containingLoop)\r\n    return containingLoop;\r\n    function f(parent) {\r\n        if (parent === root || is_loop_in_loop_1.isLoopInLoop([loop, parent.loop])) {\r\n            containingLoop = parent;\r\n            for (let child of parent.children) {\r\n                stack.push(child);\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.getTightestContainingLoop = getTightestContainingLoop;\r\n//# sourceMappingURL=get-tightest-containing-loop.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/fs/simplify-paths/get-tightest-containing-loop.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/fs/simplify-paths/is-loop-in-loop.js":
/*!****************************************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/fs/simplify-paths/is-loop-in-loop.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nconst get_loop_bounds_1 = __webpack_require__(/*! ../get-loop-bounds */ \"./node_modules/flo-mat/node/svg/fs/get-loop-bounds.js\");\r\nconst DELTA = 1e-6;\r\n/**\r\n * Returns true if the first loop is contained wholly within the second. At this\r\n * stage we already know the loop is either wholly contained inside the loop\r\n * or is wholly outside.\r\n * @param loops\r\n */\r\nfunction isLoopInLoop(loops) {\r\n    let i = 0;\r\n    let seed = 1231; // Just some value\r\n    do {\r\n        i++;\r\n        // This gets us a predictable random number between 0 and 1;\r\n        let rand1 = flo_poly_1.default.random.flatCoefficients(1, 0, 1, seed);\r\n        let t = rand1.p[0];\r\n        seed = rand1.seed; // Get next seed.\r\n        // This gets us a predictable random number roughly between 0 and the \r\n        // number of curves in the loop.\r\n        let curveCount = loops[0].curves.length;\r\n        let rand2 = flo_poly_1.default.random.flatCoefficients(1, 0, curveCount, seed);\r\n        let idx = Math.floor(rand2.p[0]);\r\n        seed = rand2.seed; // Get next seed.\r\n        let ps = loops[0].curves[idx].ps;\r\n        let p = flo_bezier3_1.evaluate(ps, t);\r\n        let res = f(loops, p);\r\n        if (res !== undefined) {\r\n            return res;\r\n        }\r\n    } while (i < 10);\r\n    return undefined; // There's no chance we'll get up to this point.\r\n    function f(loops, p) {\r\n        if (isLoopNotInLoop(loops)) {\r\n            return false;\r\n        }\r\n        //let g = _debug_.generated.g;\r\n        //let bounds = getShapeBounds(loops);\r\n        //_debug_.fs.draw.dot(g, p, (bounds.maxX.p[0] - bounds.minX.p[0]) * 0.002, 'blue');\r\n        let intersections = getAxisAlignedRayLoopIntersections(loops[1], p, 'left');\r\n        //console.log(intersections, intersections.length % 2 !== 0);\r\n        if (intersections) {\r\n            return intersections.length % 2 !== 0;\r\n        }\r\n    }\r\n}\r\nexports.isLoopInLoop = isLoopInLoop;\r\n/**\r\n * Returns true if the first loop is not wholly within the second. The converse\r\n * is not necessarily true. It is assumed the loops don't intersect.\r\n * @param loops\r\n */\r\nfunction isLoopNotInLoop(loops) {\r\n    let loopBoundss = loops.map(get_loop_bounds_1.getLoopBounds);\r\n    let boundss = loopBoundss.map(loopBound => {\r\n        return {\r\n            minX: loopBound.minX.p[0],\r\n            maxX: loopBound.maxX.p[0],\r\n            minY: loopBound.minY.p[1],\r\n            maxY: loopBound.maxY.p[1]\r\n        };\r\n    });\r\n    return (boundss[0].minX < boundss[1].minX ||\r\n        boundss[0].maxX > boundss[1].maxX ||\r\n        boundss[0].minY < boundss[1].minY ||\r\n        boundss[0].maxY > boundss[1].maxY);\r\n}\r\n//enum Dir { LEFT, RIGHT, UP, DOWN }\r\n/**\r\n *\r\n * @param p The point where the horizontal ray starts\r\n * @param toLeft The ray to the left of this point (else right)\r\n * @param loop A loop of curves\r\n */\r\nfunction getAxisAlignedRayLoopIntersections(loop, p, dir) {\r\n    let [x, y] = p;\r\n    let curves = loop.curves;\r\n    let possAll = [];\r\n    for (let i = 0; i < curves.length; i++) {\r\n        let curve = curves[i];\r\n        let ps = curve.ps;\r\n        //------------------------------------------------------/\r\n        //---- Check if ray intersects bezier bounding box -----/\r\n        //------------------------------------------------------/\r\n        let [[minX, minY], [maxX, maxY]] = flo_bezier3_1.getBoundingBox(ps);\r\n        let notIntersecting = ((dir === 'left' || dir === 'right') && (minY > y || maxY < y)) ||\r\n            ((dir === 'up' || dir === 'down') && (minX > x || maxX < x));\r\n        notIntersecting = notIntersecting ||\r\n            (dir === 'left' && minX > x) || (dir === 'right' && maxX < x) ||\r\n            (dir === 'down' && minY > y) || (dir === 'up' && maxY < y);\r\n        if (notIntersecting) {\r\n            continue;\r\n        } // No intersection with bezier\r\n        //------------------------------------------------------/\r\n        //----------- Get intersection ts on bezier ------------/\r\n        //------------------------------------------------------/\r\n        // Get the bezier's x-coordinate power representation.\r\n        let ts = [];\r\n        let f;\r\n        let offset;\r\n        let axis;\r\n        let dirIsDecreasing = (dir === 'left' || dir === 'up');\r\n        if (dir === 'left' || dir === 'right') {\r\n            f = flo_bezier3_1.getY;\r\n            offset = [0, -y];\r\n            axis = 0;\r\n        }\r\n        else {\r\n            f = flo_bezier3_1.getX;\r\n            offset = [-x, 0];\r\n            axis = 1;\r\n        }\r\n        let translatedPs = flo_bezier3_1.translate(offset, ps);\r\n        let poly = f(translatedPs);\r\n        let ev = flo_bezier3_1.evaluate(translatedPs);\r\n        let ts_ = flo_poly_1.default.allRoots(poly, 0 - DELTA, 1 + DELTA);\r\n        for (let i = 0; i < ts_.length; i++) {\r\n            let t = ts_[i];\r\n            if (Math.abs(t) < DELTA || Math.abs(t - 1) < DELTA) {\r\n                // We don't know the exact number of intersections due to\r\n                // floating point arithmetic. \r\n                return undefined;\r\n            }\r\n            let p_ = ev(t);\r\n            if ((dirIsDecreasing && p[axis] >= p_[axis]) ||\r\n                (!dirIsDecreasing && p[axis] <= p_[axis])) {\r\n                ts.push(t);\r\n            }\r\n        }\r\n        //------------------------------------------------------/\r\n        //----- Check if line is tangent to intersections ------/\r\n        //------------------------------------------------------/\r\n        // We only care if there were 1 or 3 intersections.\r\n        if (ts.length === 1 || ts.length === 3) {\r\n            for (let t of ts) {\r\n                let tan = flo_bezier3_1.tangent(ps, t);\r\n                if (((dir === 'left' || dir === 'right') && Math.abs(tan[1]) < DELTA) ||\r\n                    ((dir === 'down' || dir === 'up') && Math.abs(tan[0]) < DELTA)) {\r\n                    // We don't know the exact number of intersections due to\r\n                    // floating point arithmetic\r\n                    return undefined;\r\n                }\r\n            }\r\n        }\r\n        possAll.push(...ts.map(t => new point_on_shape_1.PointOnShape(curve, t)));\r\n    }\r\n    return possAll;\r\n}\r\n//# sourceMappingURL=is-loop-in-loop.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/fs/simplify-paths/is-loop-in-loop.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/fs/simplify-paths/pair-set.js":
/*!*********************************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/fs/simplify-paths/pair-set.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Adds an unordered pair of values to the set (given as a special map)\r\n * @param map The map representing the pairs.\r\n * @param vs The pair to add.\r\n */\r\nfunction pairSet_add(map, vs) {\r\n    if (pairSet_has(map, vs)) {\r\n        return;\r\n    }\r\n    f(vs[0], vs[1]);\r\n    f(vs[1], vs[0]);\r\n    function f(v1, v2) {\r\n        let set = map.get(v1);\r\n        if (!set) {\r\n            set = new Set();\r\n            map.set(v1, set);\r\n        }\r\n        set.add(v2);\r\n    }\r\n}\r\nexports.pairSet_add = pairSet_add;\r\n/**\r\n * Returns true if the unordered pair is in the set of pairs (represented by a\r\n * map).\r\n * @param map The map representing the pairs.\r\n * @param vs The pair to check.\r\n */\r\nfunction pairSet_has(map, vs) {\r\n    let set;\r\n    set = map.get(vs[0]);\r\n    let has1 = set && set.has(vs[1]);\r\n    set = map.get(vs[1]);\r\n    let has2 = set && set.has(vs[0]);\r\n    return has1 || has2;\r\n}\r\nexports.pairSet_has = pairSet_has;\r\n/**\r\n * Returns the unordered pairs as an array.\r\n * @param map The map representing the pairs.\r\n */\r\nfunction pairSet_asArray(map) {\r\n    let items = [];\r\n    let map_ = new Map();\r\n    for (let m of map) {\r\n        for (let s of m[1]) {\r\n            let vs = [m[0], s];\r\n            if (!pairSet_has(map_, vs)) {\r\n                items.push(vs);\r\n                pairSet_add(map_, vs);\r\n            }\r\n        }\r\n    }\r\n    return items;\r\n}\r\nexports.pairSet_asArray = pairSet_asArray;\r\n//# sourceMappingURL=pair-set.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/fs/simplify-paths/pair-set.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/fs/simplify-paths/simplify-paths.js":
/*!***************************************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/fs/simplify-paths/simplify-paths.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst loop_1 = __webpack_require__(/*! ../../../loop */ \"./node_modules/flo-mat/node/loop.js\");\r\nconst get_loop_bounds_1 = __webpack_require__(/*! ../get-loop-bounds */ \"./node_modules/flo-mat/node/svg/fs/get-loop-bounds.js\");\r\nconst get_intersections_1 = __webpack_require__(/*! ./get-intersections */ \"./node_modules/flo-mat/node/svg/fs/simplify-paths/get-intersections.js\");\r\nconst complete_path_1 = __webpack_require__(/*! ./complete-path */ \"./node_modules/flo-mat/node/svg/fs/simplify-paths/complete-path.js\");\r\nconst get_tightest_containing_loop_1 = __webpack_require__(/*! ./get-tightest-containing-loop */ \"./node_modules/flo-mat/node/svg/fs/simplify-paths/get-tightest-containing-loop.js\");\r\n/**\r\n * Uses the algorithm of Lavanya Subramaniam (PARTITION OF A NON-SIMPLE POLYGON\r\n * INTO SIMPLE POLYGONS) but modified to use cubic bezier curves (as opposed to\r\n * polygons) and to additionally take care of paths with multiple subpaths, i.e.\r\n * such as disjoint nested paths.\r\n * @param loops An array of possibly intersecting paths\r\n */\r\nfunction simplifyPaths(loops) {\r\n    /** A map from each curve to an array of intersections on that curve. */\r\n    let intersections = get_intersections_1.getIntersections(loops);\r\n    let loopsTaken = new Set();\r\n    let root = {\r\n        parent: undefined,\r\n        children: new Set(),\r\n        beziers: undefined,\r\n        loop: undefined,\r\n        orientation: undefined,\r\n        windingNum: 0\r\n    };\r\n    loops.sort(ascendingByTopmostPoint);\r\n    if (typeof _debug_ !== 'undefined') {\r\n        for (let loop of loops) {\r\n            _debug_.fs.nameObj(loop);\r\n        }\r\n    }\r\n    for (let loop of loops) {\r\n        // TODO - handle special case of 1 curve - mayve just delete lines below\r\n        if (loop.curves.length <= 1) {\r\n            continue;\r\n        }\r\n        if (loopsTaken.has(loop)) {\r\n            continue;\r\n        }\r\n        loopsTaken.add(loop);\r\n        let parent = get_tightest_containing_loop_1.getTightestContainingLoop(root, loop);\r\n        complete_path_1.completePath(intersections, loopsTaken, parent, loop);\r\n    }\r\n    // Take the forest of trees, create a new root making it a tree and snip\r\n    // branches such that each branch determines a new set of loops each \r\n    // representing an individual independent shape that possess its own Medial\r\n    // Axis Transform (still to be determined).\r\n    let loopTrees = splitLoopTrees(root);\r\n    let iLoopSets = loopTrees.map(getLoopsFromTree);\r\n    let loopss = iLoopSets.map(loopSet => loopSet.map(iLoop => loop_1.Loop.fromCubicBeziers(iLoop.beziers)));\r\n    /*\r\n    let str = '';\r\n    for (let simplePaths of loopss) {\r\n        //console.log(str)\r\n        for (let loop of simplePaths) {\r\n            str = str + '\\n\\n' + beziersToSvgPathStr(\r\n                loop.curves.map(c => c.ps),\r\n                5\r\n            )\r\n        }\r\n        //console.log(str)\r\n        //console.log('-----------------');\r\n    }\r\n    console.log(str)\r\n    */\r\n    let xMap = new Map();\r\n    for (let intersection of intersections) {\r\n        for (let x of intersection[1]) {\r\n            if (x.isDummy) {\r\n                continue;\r\n            }\r\n            xMap.set(x.outPs, { ps: x.opposite.outPs });\r\n            if (typeof _debug_ !== 'undefined') {\r\n                _debug_.generated.elems.intersection.push(x);\r\n            }\r\n        }\r\n    }\r\n    return { loopss, xMap };\r\n}\r\nexports.simplifyPaths = simplifyPaths;\r\nfunction splitLoopTrees(root) {\r\n    let iLoopTrees = [];\r\n    let nodeStack = [root];\r\n    while (nodeStack.length) {\r\n        let parent = nodeStack.pop();\r\n        for (let child of parent.children) {\r\n            if (parent.windingNum === 0) {\r\n                iLoopTrees.push(child);\r\n            }\r\n            nodeStack.push(child);\r\n        }\r\n        if (parent.windingNum === 0) {\r\n            parent.children = new Set(); // Make it a leaf\r\n        }\r\n    }\r\n    return iLoopTrees;\r\n}\r\n/**\r\n * Returns an array of LoopTrees from the given LoopTree where each returned\r\n * LoopTree is one of the nodes of the tree. Nodes with winding number > 1 are\r\n * not returned.\r\n * @param root\r\n */\r\nfunction getLoopsFromTree(root) {\r\n    let loopTrees = [];\r\n    let stack = [root];\r\n    while (stack.length) {\r\n        let node = stack.pop();\r\n        f(node);\r\n    }\r\n    return loopTrees;\r\n    function f(parent) {\r\n        if (Math.abs(parent.windingNum) <= 1) {\r\n            loopTrees.push(parent);\r\n        }\r\n        for (let child of parent.children) {\r\n            stack.push(child);\r\n        }\r\n    }\r\n}\r\n/**\r\n *\r\n * @param loopA\r\n * @param loopB\r\n */\r\nfunction ascendingByTopmostPoint(loopA, loopB) {\r\n    let boundsA = get_loop_bounds_1.getLoopBounds(loopA);\r\n    let boundsB = get_loop_bounds_1.getLoopBounds(loopB);\r\n    let a = boundsA.minY.p[1];\r\n    let b = boundsB.minY.p[1];\r\n    return a - b;\r\n}\r\n//# sourceMappingURL=simplify-paths.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/fs/simplify-paths/simplify-paths.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/path-data-polyfill/parse-number.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/path-data-polyfill/parse-number.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// Parse a number from an SVG path. This very closely follows genericParseNumber(...) from\r\n// Source/core/svg/SVGParserUtilities.cpp.\r\n// Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-PathDataBNF\r\nfunction parseNumber(source) {\r\n    var exponent = 0;\r\n    var integer = 0;\r\n    var frac = 1;\r\n    var decimal = 0;\r\n    var sign = 1;\r\n    var expsign = 1;\r\n    var startIndex = source._currentIndex;\r\n    source._skipOptionalSpaces();\r\n    // Read the sign.\r\n    if (source._currentIndex < source._endIndex && source._string[source._currentIndex] === \"+\") {\r\n        source._currentIndex += 1;\r\n    }\r\n    else if (source._currentIndex < source._endIndex && source._string[source._currentIndex] === \"-\") {\r\n        source._currentIndex += 1;\r\n        sign = -1;\r\n    }\r\n    if (source._currentIndex === source._endIndex ||\r\n        ((source._string[source._currentIndex] < \"0\" || source._string[source._currentIndex] > \"9\") &&\r\n            source._string[source._currentIndex] !== \".\")) {\r\n        // The first character of a number must be one of [0-9+-.].\r\n        return null;\r\n    }\r\n    // Read the integer part, build right-to-left.\r\n    var startIntPartIndex = source._currentIndex;\r\n    while (source._currentIndex < source._endIndex &&\r\n        source._string[source._currentIndex] >= \"0\" &&\r\n        source._string[source._currentIndex] <= \"9\") {\r\n        source._currentIndex += 1; // Advance to first non-digit.\r\n    }\r\n    if (source._currentIndex !== startIntPartIndex) {\r\n        var scanIntPartIndex = source._currentIndex - 1;\r\n        var multiplier = 1;\r\n        while (scanIntPartIndex >= startIntPartIndex) {\r\n            integer += multiplier * (Number(source._string[scanIntPartIndex]) - 0);\r\n            scanIntPartIndex -= 1;\r\n            multiplier *= 10;\r\n        }\r\n    }\r\n    // Read the decimals.\r\n    if (source._currentIndex < source._endIndex && source._string[source._currentIndex] === \".\") {\r\n        source._currentIndex += 1;\r\n        // There must be a least one digit following the .\r\n        if (source._currentIndex >= source._endIndex ||\r\n            source._string[source._currentIndex] < \"0\" ||\r\n            source._string[source._currentIndex] > \"9\") {\r\n            return null;\r\n        }\r\n        while (source._currentIndex < source._endIndex &&\r\n            source._string[source._currentIndex] >= \"0\" &&\r\n            source._string[source._currentIndex] <= \"9\") {\r\n            frac *= 10;\r\n            decimal += (Number(source._string.charAt(source._currentIndex))) / frac;\r\n            source._currentIndex += 1;\r\n        }\r\n    }\r\n    // Read the exponent part.\r\n    if (source._currentIndex !== startIndex &&\r\n        source._currentIndex + 1 < source._endIndex &&\r\n        (source._string[source._currentIndex] === \"e\" || source._string[source._currentIndex] === \"E\") &&\r\n        (source._string[source._currentIndex + 1] !== \"x\" && source._string[source._currentIndex + 1] !== \"m\")) {\r\n        source._currentIndex += 1;\r\n        // Read the sign of the exponent.\r\n        if (source._string[source._currentIndex] === \"+\") {\r\n            source._currentIndex += 1;\r\n        }\r\n        else if (source._string[source._currentIndex] === \"-\") {\r\n            source._currentIndex += 1;\r\n            expsign = -1;\r\n        }\r\n        // There must be an exponent.\r\n        if (source._currentIndex >= source._endIndex ||\r\n            source._string[source._currentIndex] < \"0\" ||\r\n            source._string[source._currentIndex] > \"9\") {\r\n            return null;\r\n        }\r\n        while (source._currentIndex < source._endIndex &&\r\n            source._string[source._currentIndex] >= \"0\" &&\r\n            source._string[source._currentIndex] <= \"9\") {\r\n            exponent *= 10;\r\n            exponent += (Number(source._string[source._currentIndex]));\r\n            source._currentIndex += 1;\r\n        }\r\n    }\r\n    var number = integer + decimal;\r\n    number *= sign;\r\n    if (exponent) {\r\n        number *= Math.pow(10, expsign * exponent);\r\n    }\r\n    if (startIndex === source._currentIndex) {\r\n        return null;\r\n    }\r\n    source._skipOptionalSpacesOrDelimiter();\r\n    return number;\r\n}\r\nexports.parseNumber = parseNumber;\r\n//# sourceMappingURL=parse-number.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/path-data-polyfill/parse-number.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/path-data-polyfill/parse-path-data-string.js":
/*!************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/path-data-polyfill/parse-path-data-string.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst source_1 = __webpack_require__(/*! ./source */ \"./node_modules/flo-mat/node/svg/path-data-polyfill/source.js\");\r\nfunction parsePathDataString(string) {\r\n    if (!string.length)\r\n        return [];\r\n    let source = new source_1.Source(string);\r\n    let pathData = [];\r\n    if (!source.initialCommandIsMoveTo()) {\r\n        return [];\r\n    }\r\n    while (source.hasMoreData()) {\r\n        let pathSeg = source.parseSegment();\r\n        if (pathSeg === null) {\r\n            break;\r\n        }\r\n        else {\r\n            pathData.push(pathSeg);\r\n        }\r\n    }\r\n    return pathData;\r\n}\r\nexports.parsePathDataString = parsePathDataString;\r\n//# sourceMappingURL=parse-path-data-string.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/path-data-polyfill/parse-path-data-string.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/path-data-polyfill/source.js":
/*!********************************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/path-data-polyfill/source.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst parse_number_1 = __webpack_require__(/*! ./parse-number */ \"./node_modules/flo-mat/node/svg/path-data-polyfill/parse-number.js\");\r\nconst COMMAND_MAP = {\r\n    \"Z\": \"Z\", \"M\": \"M\", \"L\": \"L\", \"C\": \"C\", \"Q\": \"Q\", \"A\": \"A\", \"H\": \"H\", \"V\": \"V\", \"S\": \"S\", \"T\": \"T\",\r\n    \"z\": \"Z\", \"m\": \"m\", \"l\": \"l\", \"c\": \"c\", \"q\": \"q\", \"a\": \"a\", \"h\": \"h\", \"v\": \"v\", \"s\": \"s\", \"t\": \"t\"\r\n};\r\nclass Source {\r\n    constructor(string) {\r\n        this._string = string;\r\n        this._currentIndex = 0;\r\n        this._endIndex = this._string.length;\r\n        this._prevCommand = null;\r\n        this._skipOptionalSpaces();\r\n    }\r\n    parseSegment() {\r\n        var char = this._string[this._currentIndex];\r\n        var command = COMMAND_MAP[char] ? COMMAND_MAP[char] : null;\r\n        if (command === null) {\r\n            // Possibly an implicit command. Not allowed if this is the first command.\r\n            if (this._prevCommand === null) {\r\n                return null;\r\n            }\r\n            // Check for remaining coordinates in the current command.\r\n            if ((char === \"+\" || char === \"-\" || char === \".\" || (char >= \"0\" && char <= \"9\")) && this._prevCommand !== \"Z\") {\r\n                if (this._prevCommand === \"M\") {\r\n                    command = \"L\";\r\n                }\r\n                else if (this._prevCommand === \"m\") {\r\n                    command = \"l\";\r\n                }\r\n                else {\r\n                    command = this._prevCommand;\r\n                }\r\n            }\r\n            else {\r\n                command = null;\r\n            }\r\n            if (command === null) {\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            this._currentIndex += 1;\r\n        }\r\n        this._prevCommand = command;\r\n        var values = null;\r\n        var cmd = command.toUpperCase();\r\n        if (cmd === \"H\" || cmd === \"V\") {\r\n            values = [parse_number_1.parseNumber(this)];\r\n        }\r\n        else if (cmd === \"M\" || cmd === \"L\" || cmd === \"T\") {\r\n            values = [parse_number_1.parseNumber(this), parse_number_1.parseNumber(this)];\r\n        }\r\n        else if (cmd === \"S\" || cmd === \"Q\") {\r\n            values = [parse_number_1.parseNumber(this), parse_number_1.parseNumber(this), parse_number_1.parseNumber(this), parse_number_1.parseNumber(this)];\r\n        }\r\n        else if (cmd === \"C\") {\r\n            values = [\r\n                parse_number_1.parseNumber(this),\r\n                parse_number_1.parseNumber(this),\r\n                parse_number_1.parseNumber(this),\r\n                parse_number_1.parseNumber(this),\r\n                parse_number_1.parseNumber(this),\r\n                parse_number_1.parseNumber(this)\r\n            ];\r\n        }\r\n        else if (cmd === \"A\") {\r\n            values = [\r\n                parse_number_1.parseNumber(this),\r\n                parse_number_1.parseNumber(this),\r\n                parse_number_1.parseNumber(this),\r\n                this._parseArcFlag(),\r\n                this._parseArcFlag(),\r\n                parse_number_1.parseNumber(this),\r\n                parse_number_1.parseNumber(this)\r\n            ];\r\n        }\r\n        else if (cmd === \"Z\") {\r\n            this._skipOptionalSpaces();\r\n            values = [];\r\n        }\r\n        if (values === null || values.indexOf(null) >= 0) {\r\n            // Unknown command or known command with invalid values\r\n            return null;\r\n        }\r\n        else {\r\n            return { type: command, values: values };\r\n        }\r\n    }\r\n    hasMoreData() {\r\n        return this._currentIndex < this._endIndex;\r\n    }\r\n    peekSegmentType() {\r\n        var char = this._string[this._currentIndex];\r\n        return COMMAND_MAP[char] ? COMMAND_MAP[char] : null;\r\n    }\r\n    initialCommandIsMoveTo() {\r\n        // If the path is empty it is still valid, so return true.\r\n        if (!this.hasMoreData()) {\r\n            return true;\r\n        }\r\n        var command = this.peekSegmentType();\r\n        // Path must start with moveTo.\r\n        return command === \"M\" || command === \"m\";\r\n    }\r\n    _isCurrentSpace() {\r\n        var char = this._string[this._currentIndex];\r\n        return char <= \" \" && (char === \" \" || char === \"\\n\" || char === \"\\t\" || char === \"\\r\" || char === \"\\f\");\r\n    }\r\n    _skipOptionalSpaces() {\r\n        while (this._currentIndex < this._endIndex && this._isCurrentSpace()) {\r\n            this._currentIndex += 1;\r\n        }\r\n        return this._currentIndex < this._endIndex;\r\n    }\r\n    _skipOptionalSpacesOrDelimiter() {\r\n        if (this._currentIndex < this._endIndex &&\r\n            !this._isCurrentSpace() &&\r\n            this._string[this._currentIndex] !== \",\") {\r\n            return false;\r\n        }\r\n        if (this._skipOptionalSpaces()) {\r\n            if (this._currentIndex < this._endIndex && this._string[this._currentIndex] === \",\") {\r\n                this._currentIndex += 1;\r\n                this._skipOptionalSpaces();\r\n            }\r\n        }\r\n        return this._currentIndex < this._endIndex;\r\n    }\r\n    _parseArcFlag() {\r\n        if (this._currentIndex >= this._endIndex) {\r\n            return null;\r\n        }\r\n        var flag = null;\r\n        var flagChar = this._string[this._currentIndex];\r\n        this._currentIndex += 1;\r\n        if (flagChar === \"0\") {\r\n            flag = 0;\r\n        }\r\n        else if (flagChar === \"1\") {\r\n            flag = 1;\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n        this._skipOptionalSpacesOrDelimiter();\r\n        return flag;\r\n    }\r\n}\r\nexports.Source = Source;\r\n//# sourceMappingURL=source.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/path-data-polyfill/source.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/path-segment/a.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/path-segment/a.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/*\r\n * A and a: (from www.w3.org)\r\n *\r\n * params: rx ry x-axis-rotation large-arc-flag sweep-flag x y\r\n *\r\n * Draws an elliptical arc from the current point to (x, y). The size and\r\n * orientation of the ellipse are defined by two radii (rx, ry) and an\r\n * x-axis-rotation, which indicates how the ellipse as a whole is rotated\r\n * relative to the current coordinate system. The center (cx, cy) of the ellipse\r\n * is calculated automatically to satisfy the constraints imposed by the other\r\n * parameters. large-arc-flag and sweep-flag contribute to the automatic\r\n * calculations and help determine how the arc is drawn.\r\n */\r\nfunction a(s) {\r\n    // TODO - not implemented yet (or not necessary)\r\n    s.prev2ndCubicControlPoint = undefined;\r\n    s.prev2ndQuadraticControlPoint = undefined;\r\n    // Update current point\r\n    //x0 = ? ps[3][0]; \r\n    //y0 = ? ps[3][1];\r\n    return undefined;\r\n}\r\nexports.a = a;\r\n//# sourceMappingURL=a.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/path-segment/a.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/path-segment/c.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/path-segment/c.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * C and c: (from www.w3.org)\r\n *\r\n * params: x1 y1 x2 y2 x y\r\n *\r\n * Draws a cubic Bézier curve from the current point to (x,y)\r\n * using (x1,y1) as the control point at the beginning of the\r\n * curve and (x2,y2) as the control point at the end of the\r\n * curve. C (uppercase) indicates that absolute coordinates\r\n * will follow; c (lowercase) indicates that relative\r\n * coordinates will follow. Multiple sets of coordinates may\r\n * be specified to draw a polybézier. At the end of the\r\n * command, the new current point becomes the final (x,y)\r\n * coordinate pair used in the polybézier.\r\n */\r\nfunction c(s) {\r\n    let ps = [\r\n        s.p,\r\n        [s.vals[0], s.vals[1]],\r\n        [s.vals[2], s.vals[3]],\r\n        [s.vals[4], s.vals[5]]\r\n    ];\r\n    s.prev2ndCubicControlPoint = ps[2];\r\n    s.prev2ndQuadraticControlPoint = undefined;\r\n    return ps;\r\n}\r\nexports.c = c;\r\n//# sourceMappingURL=c.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/path-segment/c.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/path-segment/h.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/path-segment/h.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * H and h: (from www.w3.org)\r\n *\r\n * params: x\r\n *\r\n * Draws a horizontal line from the current point (cpx, cpy) to (x, cpy). H\r\n * (uppercase) indicates that absolute coordinates will follow; h (lowercase)\r\n * indicates that relative coordinates will follow. Multiple x values can be\r\n * provided (although usually this doesn't make sense). At the end of the\r\n * command, the new current point becomes (x, cpy) for the final value of x.\r\n */\r\nfunction h(s) {\r\n    let xInterval = (s.vals[0] - s.p[0]) / 3;\r\n    let ps = [\r\n        s.p,\r\n        [s.p[0] + xInterval * 1, s.p[1]],\r\n        [s.p[0] + xInterval * 2, s.p[1]],\r\n        [s.p[0] + xInterval * 3, s.p[1]]\r\n    ];\r\n    s.prev2ndCubicControlPoint = undefined;\r\n    s.prev2ndQuadraticControlPoint = undefined;\r\n    return ps;\r\n}\r\nexports.h = h;\r\n//# sourceMappingURL=h.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/path-segment/h.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/path-segment/l.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/path-segment/l.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * L and l: (from www.w3.org)\r\n *\r\n * params: x y\r\n *\r\n * Draw a line from the current point to the given (x,y) coordinate which\r\n * becomes the new current point. L (uppercase) indicates that absolute\r\n * coordinates will follow; l (lowercase) indicates that relative coordinates\r\n * will follow. A number of coordinates pairs may be specified to draw a\r\n * polyline. At the end of the command, the new current point is set to the\r\n * final set of coordinates provided.\r\n */\r\nfunction l(s) {\r\n    let xInterval = (s.vals[0] - s.p[0]) / 3;\r\n    let yInterval = (s.vals[1] - s.p[1]) / 3;\r\n    let ps = [\r\n        s.p,\r\n        [s.p[0] + xInterval * 1, s.p[1] + yInterval * 1],\r\n        [s.p[0] + xInterval * 2, s.p[1] + yInterval * 2],\r\n        [s.p[0] + xInterval * 3, s.p[1] + yInterval * 3]\r\n    ];\r\n    s.prev2ndCubicControlPoint = undefined;\r\n    s.prev2ndQuadraticControlPoint = undefined;\r\n    return ps;\r\n}\r\nexports.l = l;\r\n//# sourceMappingURL=l.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/path-segment/l.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/path-segment/q.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/path-segment/q.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Q and q: (from www.w3.org)\r\n *\r\n * params: x1 y1 x y\r\n *\r\n * Draws a quadratic Bézier curve from the current point to (x,y) using (x1,y1)\r\n * as the control point. Q (uppercase) indicates that absolute coordinates will\r\n * follow; q (lowercase) indicates that relative coordinates will follow.\r\n * Multiple sets of coordinates may be specified to draw a polybézier. At the\r\n * end of the command, the new current point becomes the final (x,y) coordinate\r\n * pair used in the polybézier.\r\n */\r\nfunction q(s) {\r\n    //---------------------------------------------------\r\n    // Convert quadratic to cubic\r\n    // see https://stackoverflow.com/questions/3162645/convert-a-quadratic-bezier-to-a-cubic/3162732#3162732\r\n    //---------------------------------------------------\r\n    let QP0 = s.p;\r\n    let QP1 = [s.vals[0], s.vals[1]];\r\n    let QP2 = [s.vals[2], s.vals[3]];\r\n    // Endpoints stay the same\r\n    let CP0 = QP0;\r\n    let CP3 = QP2;\r\n    // CP1 = QP0 + 2/3 *(QP1-QP0)\r\n    let CP1 = [\r\n        QP0[0] + (2 / 3) * (QP1[0] - QP0[0]),\r\n        QP0[1] + (2 / 3) * (QP1[1] - QP0[1])\r\n    ];\r\n    // CP2 = QP2 + 2/3 *(QP1-QP2)\r\n    let CP2 = [\r\n        QP2[0] + (2 / 3) * (QP1[0] - QP2[0]),\r\n        QP2[1] + (2 / 3) * (QP1[1] - QP2[1])\r\n    ];\r\n    let ps = [CP0, CP1, CP2, CP3];\r\n    s.prev2ndCubicControlPoint = undefined;\r\n    s.prev2ndQuadraticControlPoint = QP1;\r\n    return ps;\r\n}\r\nexports.q = q;\r\n//# sourceMappingURL=q.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/path-segment/q.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/path-segment/s.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/path-segment/s.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * S and s: (from www.w3.org)\r\n *\r\n * params: x2 y2 x y\r\n *\r\n * Draws a cubic Bézier curve from the current point to (x,y). The first control\r\n * point is assumed to be the reflection of the second control point on the\r\n * previous command relative to the current point. (If there is no previous\r\n * command or if the previous command was not an C, c, S or s, assume the first\r\n * control point is coincident with the current point.) (x2,y2) is the second\r\n * control point (i.e., the control point at the end of the curve). S\r\n * (uppercase) indicates that absolute coordinates will follow; s (lowercase)\r\n * indicates that relative coordinates will follow. Multiple sets of coordinates\r\n * may be specified to draw a polybézier. At the end of the command, the new\r\n * current point becomes the final (x,y) coordinate pair used in the polybézier.\r\n */\r\nfunction s(s) {\r\n    let p = [undefined, undefined];\r\n    if (s.prev2ndCubicControlPoint) {\r\n        p[0] = (s.p[0] - s.prev2ndCubicControlPoint[0]) + s.p[0];\r\n        p[1] = (s.p[1] - s.prev2ndCubicControlPoint[1]) + s.p[1];\r\n    }\r\n    else {\r\n        p = s.p;\r\n    }\r\n    let ps = [\r\n        s.p,\r\n        p,\r\n        [s.vals[0], s.vals[1]],\r\n        [s.vals[2], s.vals[3]]\r\n    ];\r\n    s.prev2ndCubicControlPoint = ps[2];\r\n    s.prev2ndQuadraticControlPoint = undefined;\r\n    return ps;\r\n}\r\nexports.s = s;\r\n//# sourceMappingURL=s.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/path-segment/s.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/path-segment/t.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/path-segment/t.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * T and t: (from www.w3.org)\r\n *\r\n * params: x y\r\n *\r\n * Draws a quadratic Bézier curve from the current point to (x,y). The control\r\n * point is assumed to be the reflection of the control point on the previous\r\n * command relative to the current point. (If there is no previous command or if\r\n * the previous command was not a Q, q, T or t, assume the control point is\r\n * coincident with the current point.) T (uppercase) indicates that absolute\r\n * coordinates will follow; t (lowercase) indicates that relative coordinates\r\n * will follow. At the end of the command, the new current point becomes the\r\n * final (x,y) coordinate pair used in the polybézier.\r\n */\r\nfunction t(s) {\r\n    let p = [undefined, undefined];\r\n    if (s.prev2ndQuadraticControlPoint) {\r\n        p[0] = (s.p[0] - s.prev2ndQuadraticControlPoint[0]) + s.p[0];\r\n        p[1] = (s.p[1] - s.prev2ndQuadraticControlPoint[1]) + s.p[1];\r\n    }\r\n    else {\r\n        p = s.p;\r\n    }\r\n    //---------------------------------------------------\r\n    // Convert quadratic to cubic\r\n    // see https://stackoverflow.com/questions/3162645/convert-a-quadratic-bezier-to-a-cubic/3162732#3162732\r\n    //---------------------------------------------------\r\n    let QP0 = s.p;\r\n    let QP1 = p;\r\n    let QP2 = [s.vals[0], s.vals[1]];\r\n    // CP1 = QP0 + 2/3 *(QP1-QP0)\r\n    let CP1 = [\r\n        QP0[0] + (2 / 3) * (QP1[0] - QP0[0]),\r\n        QP0[1] + (2 / 3) * (QP1[1] - QP0[1])\r\n    ];\r\n    // CP2 = QP2 + 2/3 *(QP1-QP2)\r\n    let CP2 = [\r\n        QP2[0] + (2 / 3) * (QP1[0] - QP2[0]),\r\n        QP2[1] + (2 / 3) * (QP1[1] - QP2[1])\r\n    ];\r\n    let ps = [QP0, CP1, CP2, QP2];\r\n    s.prev2ndCubicControlPoint = undefined;\r\n    s.prev2ndQuadraticControlPoint = QP1;\r\n    return ps;\r\n}\r\nexports.t = t;\r\n//# sourceMappingURL=t.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/path-segment/t.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/path-segment/v.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/path-segment/v.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/*\r\n * V and v: (from www.w3.org)\r\n *\r\n * params: y\r\n *\r\n * Draws a vertical line from the current point (cpx, cpy) to (cpx, y). V\r\n * (uppercase) indicates that absolute coordinates will follow; v (lowercase)\r\n * indicates that relative coordinates will follow. Multiple y values can be\r\n * provided (although usually this doesn't make sense). At the end of the\r\n * command, the new current point becomes (cpx, y) for the final value of y.\r\n */\r\nfunction v(s) {\r\n    let yInterval = (s.vals[0] - s.p[1]) / 3;\r\n    let ps = [\r\n        s.p,\r\n        [s.p[0], s.p[1] + yInterval * 1],\r\n        [s.p[0], s.p[1] + yInterval * 2],\r\n        [s.p[0], s.p[1] + yInterval * 3]\r\n    ];\r\n    s.prev2ndCubicControlPoint = undefined;\r\n    s.prev2ndQuadraticControlPoint = undefined;\r\n    return ps;\r\n}\r\nexports.v = v;\r\n//# sourceMappingURL=v.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/path-segment/v.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/path-segment/z.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/path-segment/z.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Z and z: (from www.w3.org)\r\n *\r\n * params: (none)\r\n *\r\n * Close the current subpath by drawing a straight line from the current point\r\n * to current subpath's initial point. Since the Z and z commands take no\r\n * parameters, they have an identical effect.\r\n */\r\nfunction z(s) {\r\n    let xInterval = (s.initialPoint[0] - s.p[0]) / 3;\r\n    let yInterval = (s.initialPoint[1] - s.p[1]) / 3;\r\n    let ps = [\r\n        s.p,\r\n        [s.p[0] + xInterval, s.p[1] + yInterval],\r\n        [s.p[0] + xInterval * 2, s.p[1] + yInterval * 2],\r\n        [s.p[0] + xInterval * 3, s.p[1] + yInterval * 3]\r\n    ];\r\n    s.prev2ndCubicControlPoint = undefined;\r\n    s.prev2ndQuadraticControlPoint = undefined;\r\n    return ps;\r\n}\r\nexports.z = z;\r\n//# sourceMappingURL=z.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/path-segment/z.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/path-state.js":
/*!*****************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/path-state.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass PathState {\r\n    constructor() {\r\n        this.initialPoint = undefined;\r\n        // Used in conjunction with \"S\" and \"s\"\r\n        this.prev2ndCubicControlPoint = undefined;\r\n        this.prev2ndQuadraticControlPoint = undefined;\r\n        this.p = [0, 0];\r\n    }\r\n}\r\nexports.PathState = PathState;\r\n//# sourceMappingURL=path-state.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/path-state.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/to-scale-axis.js":
/*!****************************************************!*\
  !*** ./node_modules/flo-mat/node/to-scale-axis.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst mat_1 = __webpack_require__(/*! ./mat */ \"./node_modules/flo-mat/node/mat.js\");\r\nconst traverse_edges_1 = __webpack_require__(/*! ./traverse-edges */ \"./node_modules/flo-mat/node/traverse-edges.js\");\r\nconst traverse_vertices_1 = __webpack_require__(/*! ./traverse-vertices */ \"./node_modules/flo-mat/node/traverse-vertices.js\");\r\nconst smoothen_1 = __webpack_require__(/*! ./mat/smoothen/smoothen */ \"./node_modules/flo-mat/node/mat/smoothen/smoothen.js\");\r\nconst get_largest_vertex_1 = __webpack_require__(/*! ./mat/get-largest-vertex */ \"./node_modules/flo-mat/node/mat/get-largest-vertex.js\");\r\nconst create_new_cp_tree_1 = __webpack_require__(/*! ./mat/create-new-cp-tree */ \"./node_modules/flo-mat/node/mat/create-new-cp-tree.js\");\r\nconst get_leaves_1 = __webpack_require__(/*! ./mat/get-leaves */ \"./node_modules/flo-mat/node/mat/get-leaves.js\");\r\nconst cull_1 = __webpack_require__(/*! ./mat/to-scale-axis/cull */ \"./node_modules/flo-mat/node/mat/to-scale-axis/cull.js\");\r\nconst add_debug_info_1 = __webpack_require__(/*! ./mat/to-scale-axis/add-debug-info */ \"./node_modules/flo-mat/node/mat/to-scale-axis/add-debug-info.js\");\r\n/**\r\n * Apply and returns an enhanced version of the Scale Axis Transform (SAT) to\r\n * the given MAT. The returned SAT is guaranteed to be a subset of the MAT and\r\n * preserves topology at any scale.\r\n *\r\n * Typically the MAT contains too many branches caused by minute details on the\r\n * boundary of the shape. The SAT is a simplification of the MAT that preserves\r\n * less detail the higher the applied scale factor. The severity at which noise\r\n * are removed depends on the local scale of the shape.\r\n * @param mat The Medial Axis Transform ([[Mat]]) on which to apply the SAT.\r\n * @param s The scale factor >= 1 (e.g. 1.3)\r\n */\r\nfunction toScaleAxis(mat, s) {\r\n    if (typeof _debug_ !== 'undefined') {\r\n        _debug_.generated.timing.sats[0] = performance.now();\r\n        let leaves = get_leaves_1.getLeaves(mat.cpNode);\r\n        _debug_.generated.elems.leaves.push(leaves);\r\n    }\r\n    /** The largest vertex (as measured by its inscribed disk) */\r\n    let cpNodes = [];\r\n    traverse_vertices_1.traverseVertices(mat.cpNode.clone(), cpNode => {\r\n        cpNodes.push(cpNode);\r\n        //_debug_.fs.draw.crossHair(_debug_.generated.g, cpNode.cp.circle.center)\r\n    });\r\n    let cpNode = get_largest_vertex_1.getLargestVertex(cpNodes);\r\n    if (typeof _debug_ !== 'undefined') {\r\n        _debug_.generated.elems.maxVertex.push(cpNode);\r\n    }\r\n    /**\r\n     * All vertices that are set to be culled initially. This may change later\r\n     * in order to preserve topology.\r\n     */\r\n    let culls = new Set();\r\n    let rMap = new Map();\r\n    traverse_edges_1.traverseEdges(cpNode, function (cpNode) {\r\n        /** The occulating radius stored with this vertex. */\r\n        let R = rMap.get(cpNode) || s * cpNode.cp.circle.radius;\r\n        let cpNode_ = cpNode.next;\r\n        //let c  = cpNode .cp.circle.center;\r\n        //let c_ = cpNode_.cp.circle.center;\r\n        /** Distance between this vertex and the next. */\r\n        //let l = distanceBetween(c, c_); // Almost always precise enough\r\n        let l = flo_bezier3_1.len([0, 1], cpNode.matCurveToNextVertex);\r\n        let r_ = s * cpNode_.cp.circle.radius;\r\n        if (R - l > r_) {\r\n            for (let cpNode of cpNode_.getCpNodesOnCircle()) {\r\n                rMap.set(cpNode, R - l); // Update occulating radii\r\n            }\r\n            culls.add(cpNode_.cp.circle);\r\n        }\r\n    });\r\n    cull_1.cull(culls, cpNode);\r\n    if (typeof _debug_ !== 'undefined') {\r\n        _debug_.generated.elems.culls.push(Array.from(culls));\r\n    }\r\n    smoothen_1.smoothen(cpNode);\r\n    let sat = new mat_1.Mat(cpNode, create_new_cp_tree_1.createNewCpTree(cpNode));\r\n    add_debug_info_1.addDebugInfo(sat);\r\n    return sat;\r\n}\r\nexports.toScaleAxis = toScaleAxis;\r\n//# sourceMappingURL=to-scale-axis.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/to-scale-axis.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/traverse-edges.js":
/*!*****************************************************!*\
  !*** ./node_modules/flo-mat/node/traverse-edges.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Traverses all edges (depth first) of the given MAT tree starting at the given\r\n * vertex (represented by a [[CpNode]]).\r\n * @param cpNode Any [[CpNode]] representing the start vertex.\r\n * @param f A callback function for each CpNode representing the vertex at the\r\n * start of an edge.\r\n  */\r\nfunction traverseEdges(cpNode, f) {\r\n    // Since the tree is unrooted we must iterate in all directions from the\r\n    // given vertex.\r\n    let cps = cpNode.getCpNodesOnCircle();\r\n    while (cps.length) {\r\n        let cp = cps.pop();\r\n        f(cp);\r\n        cps.push(...cp.children);\r\n    }\r\n}\r\nexports.traverseEdges = traverseEdges;\r\n//# sourceMappingURL=traverse-edges.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/traverse-edges.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/traverse-vertices.js":
/*!********************************************************!*\
  !*** ./node_modules/flo-mat/node/traverse-vertices.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Traverses the MAT tree and calls the given callback function for each vertex\r\n * (represented by a [[CpNode]]) on the MAT.\r\n *\r\n * It is usually preferable to use [[traverseEdges]] as it allows for the\r\n * traversal of all the smooth curves representing the MAT.\r\n * @param cpNode Any [[CpNode]] representing the start vertex.\r\n * @param f A callback function taking a single [[CpNode]] as parameter.\r\n */\r\nfunction traverseVertices(cpNode, f) {\r\n    f(cpNode);\r\n    // Since the tree is unrooted we must iterate in all directions from the\r\n    // given cpNode.\t\r\n    cpNode.getCpNodesOnCircle()\r\n        .filter(cpNode => !cpNode.isTerminating())\r\n        .map(cpNode => cpNode.next)\r\n        .forEach(f_);\r\n    function f_(cpNode) {\r\n        let cps = [cpNode];\r\n        while (cps.length) {\r\n            let cp = cps.pop();\r\n            f(cp);\r\n            cps.push(...cp.vertexChildren);\r\n        }\r\n    }\r\n}\r\nexports.traverseVertices = traverseVertices;\r\n//# sourceMappingURL=traverse-vertices.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/traverse-vertices.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/x/x.js":
/*!******************************************!*\
  !*** ./node_modules/flo-mat/node/x/x.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Representation of one side of an intersection. The opposite side is at\r\n * X.opposite.\r\n */\r\nclass X {\r\n    constructor(\r\n    /**\r\n     * The PointOnShape on the curve of the intersection. This side of the\r\n     * intersection is represented by the incoming part of this curve.\r\n     */\r\n    pos, isDummy = false, \r\n    /** The opposite side of the intersection */\r\n    opposite, loopTree, \r\n    //public inPs?     : number[][],\r\n    outPs) {\r\n        this.pos = pos;\r\n        this.isDummy = isDummy;\r\n        this.opposite = opposite;\r\n        this.loopTree = loopTree;\r\n        this.outPs = outPs;\r\n    }\r\n}\r\nexports.X = X;\r\n//# sourceMappingURL=x.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/x/x.js?");

/***/ }),

/***/ "./node_modules/flo-memoize/node/index.js":
/*!************************************************!*\
  !*** ./node_modules/flo-memoize/node/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst SUPPORTED = typeof WeakMap === 'function';\r\n/**\r\n * Memoize the given arity 1 function.\r\n */\r\nfunction memoize(f) {\r\n    if (!SUPPORTED) {\r\n        return f;\r\n    }\r\n    let results = new WeakMap();\r\n    return function (a) {\r\n        let result = results.get(a);\r\n        if (result !== undefined) {\r\n            //console.log('cache hit');\r\n            return result;\r\n        }\r\n        //console.log('cache miss');\r\n        result = f(a);\r\n        results.set(a, result);\r\n        return result;\r\n    };\r\n}\r\nexports.memoize = memoize;\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-memoize/node/index.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/index.js":
/*!*********************************************!*\
  !*** ./node_modules/flo-poly/node/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst core_operators_1 = __webpack_require__(/*! ./src/core-operators */ \"./node_modules/flo-poly/node/src/core-operators.js\");\nconst root_operators_1 = __webpack_require__(/*! ./src/root-operators */ \"./node_modules/flo-poly/node/src/root-operators.js\");\nconst root_bounds_1 = __webpack_require__(/*! ./src/root-bounds */ \"./node_modules/flo-poly/node/src/root-bounds.js\");\nconst all_roots_recursive_1 = __webpack_require__(/*! ./src/all-roots-recursive */ \"./node_modules/flo-poly/node/src/all-roots-recursive.js\");\nconst random_1 = __webpack_require__(/*! ./src/random */ \"./node_modules/flo-poly/node/src/random.js\");\nconst error_analysis_1 = __webpack_require__(/*! ./src/error-analysis */ \"./node_modules/flo-poly/node/src/error-analysis.js\");\nconst from_roots_1 = __webpack_require__(/*! ./src/from-roots */ \"./node_modules/flo-poly/node/src/from-roots.js\");\nconst multiply = core_operators_1.default.multiply;\n/**\n* Simple & fast practical library functions for functional univariate\n* polynomials over the reals (actually ECMAScript numbers, i.e. double\n* floats).\n*\n* All polinomials are represented as a simple array starting with the\n* highest non-zero power, e.g.\n*   3x^3 + 5x^2 + 7x + 2 -> [3,5,7,2]\n*\n* @ignore\n*/\nconst FloPoly = Object.assign({}, core_operators_1.default, root_operators_1.default, root_bounds_1.default, error_analysis_1.default, { random: random_1.default,\n    fromRoots: from_roots_1.default,\n    allRoots: all_roots_recursive_1.default });\nexports.default = FloPoly;\n\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/index.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/src/all-roots-recursive.js":
/*!***************************************************************!*\
  !*** ./node_modules/flo-poly/node/src/all-roots-recursive.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst core_operators_1 = __webpack_require__(/*! ./core-operators */ \"./node_modules/flo-poly/node/src/core-operators.js\");\nconst root_operators_1 = __webpack_require__(/*! ./root-operators */ \"./node_modules/flo-poly/node/src/root-operators.js\");\nconst root_bounds_1 = __webpack_require__(/*! ./root-bounds */ \"./node_modules/flo-poly/node/src/root-bounds.js\");\nconst { clip0, evaluate, differentiate, toCasStr } = core_operators_1.default;\nconst { brent, quadraticRoots } = root_operators_1.default;\nconst { rootMagnitudeUpperBound_fujiwara, positiveRootUpperBound_LMQ, positiveRootLowerBound_LMQ, negativeRootUpperBound_LMQ, negativeRootLowerBound_LMQ, } = root_bounds_1.default;\nconst INF = Number.POSITIVE_INFINITY;\n/**\n * <p>Finds a near optimal approximation to the real roots (or those\n * within a range) of the input polynomial.\n * </p>\n * <p>\n * Only multiple roots of even order that is very close together may be\n * missed. (This is rarely a problem in practice - in a geometrical\n * application, for instance, this may mean two objects are barely\n * touching and returning either, all, or none of the repeated even\n * roots should not break the algorithm).\n * </p>\n * @param p - The polynomial\n * @param a - Lower limit of root values that should be returned -\n * defaults to -∞\n * @param b - Upper limit of root values that should be returned -\n * defaults to +∞\n * @example\n * FloPoly.allRoots([1, -10, 35, -50, 24]); //=> [1, 2.0000000000000036, 3.0000000000000067, 4]\n */\nfunction allRoots(p, a = -INF, b = +INF) {\n    p = clip0(p);\n    let d = p.length - 1;\n    let rangeFilter = inRange(a, b);\n    if (d === 2) {\n        return quadraticRoots(p)\n            .filter(rangeFilter);\n        // Investigate if any numerically stable algorithm could be as fast\n        // as this algorithm (i.e by finding cubic roots within quadratic\n        // root demarcated intervals via Brent's method. The cubicRoots \n        // algoritm below has been removed since it was numerically \n        // unstable.\n        /*} else if (d === 3) {\n            return cubicRoots(p)\n                .filter(rangeFilter)\n                .sort((a,b) => a-b)\n        } else if (d > 3) {*/\n    }\n    else if (d > 2) {\n        // TODO The root bounding function below might have an impact on \n        // performance - it would probably be better to use \n        // positiveRootUpperBound_LMQ or (possibly) even better, the \n        // linear version of it (see paper of Viglas, Akritas and \n        // Strzebonski) and re-calculate bounds on every iteration.\n        let lowerBound;\n        let upperBound;\n        if (a === -INF || b === +INF) {\n            //let magnitudeBound = rootMagnitudeUpperBound_fujiwara(p);\n            //lowerBound = a === -INF ? -magnitudeBound : a;\n            //upperBound = b === +INF ? +magnitudeBound : b;\n            if (a === -INF) {\n                lowerBound = negativeRootLowerBound_LMQ(p);\n            }\n            else {\n                lowerBound = a;\n            }\n            if (b === +INF) {\n                upperBound = positiveRootUpperBound_LMQ(p);\n            }\n            else {\n                upperBound = b;\n            }\n        }\n        else {\n            lowerBound = a;\n            upperBound = b;\n        }\n        // If the roots of the differentiated polynomial is out of range \n        // then the roots of the polynomial itself will also be out of \n        // range.\n        let dp = differentiate(p);\n        let roots = allRoots(dp, lowerBound, upperBound)\n            .filter(rangeFilter);\n        if (roots[0] !== lowerBound) {\n            // For code coverage to cover the 'else' case we would need\n            // to find a case where the lower bound actually matches the\n            // root which would be very rare - needs further \n            // investigation.\n            // Not an actual root.\n            roots.unshift(lowerBound);\n        }\n        if (roots[roots.length - 1] !== upperBound) {\n            // Not an actual root.\n            roots.push(upperBound);\n        }\n        return rootsWithin(p, roots);\n    }\n    else if (d === 1) {\n        // Less likely so put near bottom (micro optimization)\n        return [-p[1] / p[0]]\n            .filter(rangeFilter);\n    }\n    else if (d === 0) {\n        return []; // y = c -> no roots\t\n    }\n    // Least likely so put at bottom (micro optimization)\n    // d === -1\n    // y = 0 -> infinite number of roots\n    return [];\n}\n/**\n * Returns a function that returns true if x is in the range [a,b].\n * @param a\n * @param b\n * @private\n */\nfunction inRange(a, b) {\n    return x => x >= a && x <= b;\n}\n/**\n * Finds all roots of the given polynomial within the given intervals.\n * @private\n * @param p\n * @param intervals\n */\nfunction rootsWithin(p, intervals) {\n    let roots = [];\n    let peval = evaluate(p);\n    let prevRoot;\n    let a = intervals[0];\n    for (let i = 1; i < intervals.length; i++) {\n        let root;\n        let b = intervals[i];\n        let evA = peval(a);\n        let evB = peval(b);\n        let k = evA * evB;\n        if (k === 0) {\n            if (evA === 0) {\n                root = a;\n            }\n            else if (evB === 0 && i === intervals.length - 1) {\n                root = b;\n            }\n        }\n        else if (evA * evB < 0) {\n            root = brent(peval, a, b);\n        }\n        // Add root if it exists and suppress exact duplicates\n        if (root !== undefined && root !== prevRoot) {\n            roots.push(root);\n            prevRoot = root;\n        }\n        a = b;\n    }\n    return roots;\n}\nexports.default = allRoots;\n\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/src/all-roots-recursive.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/src/core-operators.js":
/*!**********************************************************!*\
  !*** ./node_modules/flo-poly/node/src/core-operators.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Returns true if two polynomials are exactly equal by comparing\n * coefficients.\n * @param p1 - A polynomial\n * @param p2 - Another polynomial\n * @example\n * FloPoly.equal([1,2,3,4], [1,2,3,4]);   //=> true\n * FloPoly.equal([1,2,3,4], [1,2,3,4,5]); //=> false\n */\nfunction equal(p1, p2) {\n    if (p1.length !== p2.length) {\n        return false;\n    }\n    for (let i = 0; i < p1.length; i++) {\n        if (p1[i] !== p2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Adds two polynomials.\n * @param p1 - The first polynomial\n * @param p2 - The second polynomial\n * @example\n * FloPoly.add([1,2,3],[3,4]); //=> [1,5,7]\n */\nfunction add(p1, p2) {\n    // Initialize result array  \n    let d1 = p1.length - 1;\n    let d2 = p2.length - 1;\n    let Δd = d1 - d2;\n    let Δd1 = 0;\n    let Δd2 = 0;\n    if (Δd > 0) {\n        Δd2 = -Δd;\n    }\n    else if (Δd < 0) {\n        Δd1 = +Δd;\n    }\n    let d = Math.max(d1, d2);\n    // Add coefficients\n    let result = [];\n    for (let i = 0; i < d + 1; i++) {\n        let c1 = p1[i + Δd1];\n        let c2 = p2[i + Δd2];\n        result.push((c1 || 0) + (c2 || 0));\n    }\n    // Ensure the result is a valid polynomial representation\n    return clip0(result);\n}\n/**\n * Subtracts the second polynomial from first (p1 - p2).\n * @param p1 - The polynomial from which will be subtracted\n * @param p2 - The polynomial that will be subtracted\n * @example\n * FloPoly.subtract([2,3],[4,4]); //=> [-2, -1]\n */\nfunction subtract(p1, p2) {\n    // Initialize result array  \n    let d1 = p1.length - 1;\n    let d2 = p2.length - 1;\n    let Δd = d1 - d2;\n    let Δd1 = 0;\n    let Δd2 = 0;\n    if (Δd > 0) {\n        Δd2 = -Δd;\n    }\n    else if (Δd < 0) {\n        Δd1 = +Δd;\n    }\n    let d = Math.max(d1, d2);\n    // Add coefficients\n    let result = [];\n    for (let i = 0; i < d + 1; i++) {\n        let c1 = p1[i + Δd1];\n        let c2 = p2[i + Δd2];\n        result.push((c1 || 0) - (c2 || 0));\n    }\n    // Ensure the result is a valid polynomial representation\n    return clip0(result);\n}\n/**\n * Negate the given polynomial (p -> -p).\n * @param p - The polynomial\n * @example\n * FloPoly.negate([0.1, -0.2]); //=> [-0.1, 0.2]\n */\nfunction negate(p) {\n    return multiplyByConst(-1, p);\n}\n/**\n * Differentiates the given polynomial.\n * @param p - The polynomial\n * @example\n * FloPoly.differentiate([5, 4, 3, 2, 1]); //=> [20, 12, 6, 2]\n */\nfunction differentiate(p) {\n    let result = [];\n    let d = p.length - 1;\n    for (let i = 0; i < d; i++) {\n        result.push((d - i) * p[i]);\n    }\n    return result;\n}\n/**\n * <p>\n * Multiplies the two given polynomials and returns the result.\n * </p>\n * <p>\n * See <a href=\"https://en.wikipedia.org/wiki/Polynomial_arithmetic\">polynomial arithmetic</a>\n * </p>\n * <p>\n * See <a href=\"https://en.wikipedia.org/wiki/Discrete_Fourier_transform#Polynomial_multiplication\">polynomial multiplication</a>\n * </p>\n * <p>\n * See <a herf=\"http://web.cs.iastate.edu/~cs577/handouts/polymultiply.pdf\">polynomial multiplication (pdf)</a>\n * </p>\n * @param p1 - The one polynomial.\n * @param p2 - The other polynomial.\n * @example\n * FloPoly.multiply([1,2,3], [2,5,3,5]); //=> [2, 9, 19, 26, 19, 15]\n */\nfunction multiply(p1, p2) {\n    let d1 = p1.length - 1;\n    let d2 = p2.length - 1;\n    let d = d1 + d2;\n    let result = new Array(d + 1).fill(0);\n    for (let i = 0; i < d1 + 1; i++) {\n        for (let j = 0; j < d2 + 1; j++) {\n            result[d - (i + j)] += (p1[d1 - i] * p2[d2 - j]);\n        }\n    }\n    return clip0(result);\n}\n/**\n * Multiplies 2 polynomials by a constant.\n * @param c - The constant\n * @param p - The polynomial\n * @example\n * FloPoly.multiplyByConst(0.25, [3,2,1]); //=> [0.75, 0.5, 0.25]\n */\nfunction multiplyByConst(c, p) {\n    if (c === 0) {\n        return [];\n    }\n    let d = p.length - 1;\n    let result = [];\n    for (let i = 0; i < d + 1; i++) {\n        result.push(c * p[i]);\n    }\n    // We have to clip due to possible floating point underflow\n    return clip0(result);\n}\n/**\n * Returns the degree of the polynomial.\n * @param p - The polynomial\n * @example\n * FloPoly.degree([9,8,7,6,5,4,3,2,1]); //=> 9\n */\nfunction degree(p) {\n    return p.length - 1;\n}\nfunction evaluate(p, a) {\n    function f(a) {\n        //if p.length === 0 { return 0; }\n        let result = p[0];\n        for (let i = 1; i < p.length; i++) {\n            result = p[i] + result * a;\n        }\n        return result;\n    }\n    // Curry the function\n    return a === undefined ? f : f(a);\n}\n/**\n * Evaluates the given polynomial at 0 - it is much faster than at an\n * arbitrary point.\n * @param p - The polynomial\n * @example\n * FloPoly.evaluateAt0([3,2,99]); //=> 99\n */\nfunction evaluateAt0(p) {\n    return p[p.length - 1];\n}\n;\n/**\n * <p>\n * Returns the number of sign changes in the polynomial coefficents\n * when ordered in descending order; zeros are ignored.\n * </p>\n * <p>\n * Descartes' rule of signs states (quoted from Wikipedia):\n * \"if the terms of a polynomial are ordered by descending variable\n * exponent, then the number of positive roots of the polynomial is\n * either equal to the number of sign differences between consecutive\n * nonzero coefficients, or is less than it by an even number. Multiple\n * roots of the same value are counted separately.\"\n * </p>\n * See https://en.wikipedia.org/wiki/Descartes%27_rule_of_signs\n * @param p - The polynomial\n * @example\n * FloPoly.signChanges([1,2,-3,0,0,3,-1]); //=> 3\n */\nfunction signChanges(p) {\n    let d = p.length - 1;\n    let result = 0;\n    let prevSign = Math.sign(p[0]);\n    for (let i = 1; i < d + 1; i++) {\n        let sign = Math.sign(p[i]);\n        if (sign !== prevSign && sign !== 0) {\n            result++;\n            prevSign = sign;\n        }\n    }\n    return result;\n}\n/**\n * Deflates the given polynomial by removing a factor (x - r), where\n * r is a root of the polynomial.\n * @param p - The polynomial\n * @param root - A pre-calculated root of the polynomial.\n * @example\n * // The polynomial x^3 - 5x^2 + 8x - 4 has a root at 1 and a double root at 2\n * FloPoly.deflate([1, -5, 8, -4], 2); //=> [1, -3, 2]\n * FloPoly.deflate([1, -3, 2], 2);     //=> [1,-1]\n * FloPoly.deflate([1, -1], 1);        //=> [1]\n */\nfunction deflate(p, root) {\n    let d = p.length - 1;\n    let bs = [p[0]];\n    for (let i = 1; i < d; i++) {\n        bs.push(p[i] + root * bs[i - 1]);\n    }\n    return bs;\n}\n/**\n * Inverts the given polynomial by reversing the order of the\n * coefficients, i.e. p(x) -> x^deg(p) * p(1/x)\n * @param p - The polynomial\n * @example\n * FloPoly.invert([1,2,3,4]); // => [4,3,2,1]\n * FloPoly.invert([3,2,-5]);  // => [-5,2,3]\n */\nfunction invert(p) {\n    return p.slice().reverse();\n}\n/**\n * <p>\n * Performs a change of variables of the form: p(x) <- p(ax + b).\n * </p>\n * <p>\n * See <a href=\"http://stackoverflow.com/questions/141422/how-can-a-transform-a-polynomial-to-another-coordinate-system\">this stackoverflow question</a>\n * </p>\n * @param p - The polynomial\n * @param a\n * @param b\n * @example\n * FloPoly.changeVariables([1,2,7], 3, 4); //=> [9, 30, 31]\n */\nfunction changeVariables(p, a, b) {\n    // We let the coefficients of p(ax + b) be denoted by d_i in the \n    // code below. \n    // d_i is calculated as d = T*c, where c are the original \n    // coefficients.\n    let d = p.length - 1;\n    // Initialize a zero matrix\n    let t = [];\n    for (let i = 0; i < d + 1; i++) {\n        t.push(new Array(d + 1).fill(0));\n    }\n    // Calculate the triangular matrix T\n    t[0][0] = 1;\n    for (let j = 1; j <= d; j++) {\n        t[0][j] = b * t[0][j - 1];\n        for (let i = 1; i <= j; i++) {\n            t[i][j] = b * t[i][j - 1] + a * t[i - 1][j - 1];\n        }\n    }\n    // Multiply\n    let res = new Array(d + 1).fill(0);\n    for (let i = 0; i <= d; i++) {\n        res[d - i] = 0;\n        for (let j = i; j <= d; j++) {\n            let acc = t[i][j] * p[d - j];\n            res[d - i] += acc;\n        }\n    }\n    return res;\n}\n/**\n * Reflects the given polynomial about the Y-axis, i.e. perform the\n * change of variables: p(x) <- p(-x).\n * @param p - The polynomial to reflect\n * @example\n * FloPoly.reflectAboutYAxis([5,4,3,2,1]); //=> [5, -4, 3, -2, 1]\n */\nfunction reflectAboutYAxis(p) {\n    let d = p.length - 1;\n    let result = p.slice();\n    for (let i = 0; i < d + 1; i++) {\n        if (i % 2) {\n            result[i] = -result[i];\n        }\n    }\n    return result;\n}\n/**\n * Generates a sturm chain for the given polynomial.\n * See https://en.wikipedia.org/wiki/Sturm%27s_theorem\n * @param p - The polynomial\n * @example\n * FloPoly.sturmChain([-3,4,2,-2]); //=> [[-3, 4, 2, -2], [-9, 8, 2], [-2.5185185185185186, 1.7037037037037037], [-3.2932525951557086]]\n */\nfunction sturmChain(p) {\n    /**\n     * Returns the negative of the remainder when dividing the first\n     * polynomial (the dividend) by the second (the divisor) provided\n     * that deg(p1) - deg(p2) === 1.\n     * @private\n     * @param p1 - The first polynomial (dividend)\n     * @param p2 - The second polynomial (divisor)\n     * See https://en.wikipedia.org/wiki/Sturm%27s_theorem\n     */\n    function negRemainder(p1, p2) {\n        let d1 = p1.length - 1;\n        let d2 = p2.length - 1;\n        let d = d1 - d2;\n        let a = p1[1] / p1[0] - p2[1] / p2[0];\n        let b = p1[0] / p2[0];\n        let p3 = multiply(multiplyByConst(b, p2), [1, a]);\n        return subtract(p3, p1);\n    }\n    let m = []; // Sturm chain\n    m.push(p);\n    m.push(differentiate(p));\n    //const δ = 10 * Number.EPSILON;\n    let i = 1;\n    while (m[i].length - 1 > 0) {\n        let pnext = negRemainder(m[i - 1], m[i]);\n        //pnext = clip(pnext, δ);\n        // If the polynomial degree was not reduced due to roundoff\n        // such that the first 1 or more terms are very small.\n        while (m[i].length - pnext.length < 1) {\n            pnext.shift();\n        }\n        /*\n        if (pnext.length === 0) {\n            break;\n        }\n        */\n        m.push(pnext);\n        i++;\n    }\n    return m;\n}\n/**\n * If the highest power coefficient is small in the sense that the\n * highest power term has a negligible contribution (compared to the\n * other terms) at x = 1 then clip() can be called to remove all such\n * highest terms. A contribution of less than Number.EPSILON of the\n * highest coefficient will be considered negligible by default.\n * @param p - The polynomial to be clipped.\n * @param δ - The optional contribution tolerence else\n *        Number.EPSILON will be used by default.\n * @example\n * FloPoly.clip([1e-18, 1e-10, 1e-5]); //=> [1e-18, 1e-10, 1e-5]\n * FloPoly.clip([1e-18, 1e-10, 1e-1]); //=> [1e-10, 1e-1]\n */\nfunction clip(p, δ) {\n    δ = (δ === undefined) ? Number.EPSILON : δ;\n    let c = maxCoefficient(p);\n    if (c === 0) {\n        return [];\n    }\n    if (Math.abs(p[0]) > δ * c) {\n        return p;\n    }\n    let p_ = p.slice(1);\n    while (Math.abs(p_[0]) < δ * c) {\n        p_ = p_.slice(1);\n    }\n    return clip(p_, δ);\n}\n/**\n * If the highest power coefficient is 0 then clip() can be called to\n * remove all such highest terms so that the array is a valid\n * presentation of a polynomial.\n * @param p - The polynomial to be clipped.\n * @example\n * FloPoly.clip0([1e-18, 1e-10, 1e-1]); //=> [1e-18, 1e-10, 1e-1]\n * FloPoly.clip0([0, 1e-10, 1e-1]); //=> [1e-10, 1e-1]\n */\nfunction clip0(p) {\n    return p[0] !== 0 ? p : clip0(p.slice(1));\n}\n/**\n * Returns the absolute value of the highest coefficient of the polynomial.\n * @param p - The polynomial.\n * @example\n * FloPoly.maxCoefficient([-2, 0.1, 0.2]); //=> 2\n */\nfunction maxCoefficient(p) {\n    let max = 0;\n    for (let i = 0; i < p.length; i++) {\n        let c = Math.abs(p[i]);\n        if (c > max) {\n            max = c;\n        }\n    }\n    return max;\n}\n/**\n * Returns a string representing the given polynomial that is readable\n * by a human or a CAS (Computer Algebra System).\n * @param p - The polynomial\n * @example\n * FloPoly.toCasStr([5,4,3,2,1]); //=> \"x^4*5 + x^3*4 + x^2*3 + x*2 + 1\"\n */\nfunction toCasStr(p) {\n    let d = p.length - 1;\n    let str = '';\n    for (let i = 0; i < d + 1; i++) {\n        let cStr = p[i].toString();\n        if (i === d) {\n            str += cStr;\n        }\n        else if (i === d - 1) {\n            str += 'x*' + cStr + ' + ';\n        }\n        else {\n            str += 'x^' + (d - i).toString() + '*' + cStr + ' + ';\n        }\n    }\n    return str;\n}\nlet coreOperators = {\n    equal,\n    add,\n    subtract,\n    multiplyByConst,\n    negate,\n    differentiate,\n    multiply,\n    degree,\n    evaluate,\n    evaluateAt0,\n    signChanges,\n    invert,\n    changeVariables,\n    reflectAboutYAxis,\n    sturmChain,\n    clip,\n    clip0,\n    deflate,\n    maxCoefficient,\n    toCasStr,\n};\nexports.default = coreOperators;\n\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/src/core-operators.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/src/error-analysis.js":
/*!**********************************************************!*\
  !*** ./node_modules/flo-poly/node/src/error-analysis.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst core_operators_1 = __webpack_require__(/*! ./core-operators */ \"./node_modules/flo-poly/node/src/core-operators.js\");\nconst { evaluate } = core_operators_1.default;\n/**\n * <p>\n * Approximate condition number for polynomial evaluation multiplied by the\n * exact value of the polynomial evaluation.\n * </p>\n * <p>\n * See <a href=\"http://www-pequan.lip6.fr/~jmc/polycopies/Compensation-horner.pdf\">Compensated Horner Scheme - paragraph 1.1</a>\n * </p>\n * @ignore\n * @param p - The polynomial\n * @param x - The evaluation point\n */\nfunction conditionNumber(p, x) {\n    let d = p.length - 1;\n    let res = 0;\n    for (let i = 0; i < d; i++) {\n        res += Math.abs(p[i] * Math.pow(x, d - i));\n    }\n    return res;\n}\n/**\n * <p>\n * Classic rule of thumb approximate error bound when using Horner's\n * method to evaluate polynomials.\n * </p>\n * <p>\n * See for instance <a href=\"http://www-pequan.lip6.fr/~jmc/polycopies/Compensation-horner.pdf\">compensated horner evaluation</a>\n * </p>\n * @param p - The polynomial\n * @param x - Value at which polynomial is evaluated.\n  * @example\n * hornerErrorBound([1.1,2.2,-3.3], 1.5); //=> 5.1292303737682235e-15\n */\nfunction hornerErrorBound(p, x) {\n    const δ = Number.EPSILON;\n    let d = p.length - 1;\n    return 2 * d * δ * conditionNumber(p, x);\n}\nlet errorAnalysis = {\n    hornerErrorBound\n};\nexports.default = errorAnalysis;\n\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/src/error-analysis.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/src/from-roots.js":
/*!******************************************************!*\
  !*** ./node_modules/flo-poly/node/src/from-roots.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst core_operators_1 = __webpack_require__(/*! ./core-operators */ \"./node_modules/flo-poly/node/src/core-operators.js\");\nconst { multiply } = core_operators_1.default;\n/**\n * <p>\n * Constructs a polynomial from the given roots by multiplying out the\n * factors (x - root1)(x - root2)... Note that the resulting polynomial\n * will not have any complex roots.\n * </p>\n * <p>\n * Mostly provided for testing purposes. Note that the real roots of the\n * constructed polynomial may not be exactly the same as the roots that\n * the polynomial has been constructed from due to floating-point\n * round-off.\n * </p>\n *\n * @param roots - The roots\n * @example\n * FloPoly.fromRoots([1,2,3,3]); //=> [1, -9, 29, -39, 18]\n * FloPoly.allRoots([1, -9, 29, -39, 18]); //=> [1.0000000000000007, 2.000000000000004]\n * // In the above note the rounding error. Also note the multiple root of 3 that has been missed but as stated previously this does not generally pose a problem for even multiple roots. See the examples below.\n * FloPoly.allRoots([1, -9, 29, -39, 17.99999999999999]); //=> [0.9999999999999973, 2.00000000000002, 2.9999999999999982]\n * FloPoly.allRoots([1, -9, 29, -39, 17.9999999999999]); //=> [0.999999999999975, 2.0000000000000986, 2.9999997898930832, 3.0000002095475775]\n */\nfunction fromRoots(roots) {\n    let p = [1];\n    for (let i = 0; i < roots.length; i++) {\n        p = multiply(p, [1, -roots[i]]);\n    }\n    return p;\n}\nexports.default = fromRoots;\n\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/src/from-roots.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/src/random.js":
/*!**************************************************!*\
  !*** ./node_modules/flo-poly/node/src/random.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst from_roots_1 = __webpack_require__(/*! ./from-roots */ \"./node_modules/flo-poly/node/src/from-roots.js\");\n/**\n * Some seed value for the simple random number generator.\n * @ignore\n */\nconst SEED = 123456789;\n/**\n * The range for the simple random number generator, i.e. the generated\n * numbers will be in [0,RANGE].\n * @ignore\n */\nconst RANGE = 4294967296;\n/**\n * Creates a function from the given function with parameters similar\n * to flatRoots but with an extra parameter in the beginning indicating\n * the length of the array generated by the original function.\n * @private\n * @param {function} f\n * @returns {function}\n */\nfunction createArrFunction(f) {\n    return function (n, d, a, b, seed = SEED, odds = 0) {\n        let res = [];\n        for (let i = 0; i < n; i++) {\n            let v = f(d, a, b, seed, odds);\n            let p = v.p;\n            seed = v.seed;\n            res.push(p);\n        }\n        return res;\n    };\n}\n/**\n * Generates an array of random polynomials with parameters as specified\n * by flatRoots. The exact same polynomials will be created on each\n * call to this function if the same seed is used - this is by design to\n * improve testability.\n * @memberof Random\n * @param n - The number of polynomials to generate.\n * @param d - The degree of the polynomials\n * @param a - The lower bound of the distribution - defaults\n * to 0\n * @param b - The upper bound of the distribution - defaults\n * to 1\n * @param seed - A seed value for generating random values (so\n * that the results are reproducable)\n * @param odds - The odds that a root will be doubled (applied\n * recursively so that some roots will be tripled, etc. - defaults to 0\n * @example\n * FloPoly.Random.flatRootsArr(2,3,0,10); //=> [[1, -17.27247918024659, 97.33487287168995, -179.34094494147305], [1, -14.934967160224915, 57.624514485645406, -14.513933300587215]]\n * FloPoly.Random.flatRootsArr(2,3,0,10); //=> [[1, -17.27247918024659, 97.33487287168995, -179.34094494147305], [1, -14.934967160224915, 57.624514485645406, -14.513933300587215]]\n */\nlet flatRootsArr = createArrFunction(flatRoots);\n/**\n * Generates an array of random polynomials as specified by\n * flatCoefficients. The exact same polynomials will be created on each\n * call to this function if the same seed is used - this is by design to\n * improve testability.\n *\n * @memberof Random\n * @param n - The number of polynomials to generate.\n * @param d - The degree of the polynomials\n * @param a - The lower bound of the distribution - defaults\n * to 0\n * @param b - The upper bound of the distribution - defaults\n * to 1\n * @param seed - A seed value for generating random values (so\n * that the results are reproducable)\n * @returns {number[][]} The array of random polynomials.\n * @example\n * FloPoly.Random.flatCoefficientsArr(2,3,-2,2); //=> [[0.1749166026711464, -0.20349335670471191, 0.9375684261322021], [1.0617692470550537, -1.8918039798736572, 0.8040215969085693]]\n * FloPoly.Random.flatCoefficientsArr(2,3,-2,2); //=> [[0.1749166026711464, -0.20349335670471191, 0.9375684261322021], [1.0617692470550537, -1.8918039798736572, 0.8040215969085693]]\n */\nlet flatCoefficientsArr = createArrFunction(flatCoefficients);\n/**\n * Returns a quasi-random number to be used as the next input to this function.\n * See https://stackoverflow.com/questions/3062746/special-simple-random-number-generator\n * @private\n * @param seed\n */\nfunction predictiveRandom(seed) {\n    const a = 134775813;\n    return (a * seed + 1) % RANGE;\n}\n/**\n * Generates a random array of numbers picked from a bounded flat\n * distribution (i.e. a rectangular distribution) with specified odds of\n * duplication of consecutive values.\n *\n * @ignore\n * @param n - The number of values to generate.\n * @param a - The lower bound of the distribution - defaults\n * to 0\n * @param b - The upper bound of the distribution - defaults\n * to 1\n * @param seed - A seed value for generating random values (so\n * that the results are reproducable)\n * @param odds - The odds that a root will be doubled (applied\n * recursively so that some roots will be tripled, etc. - defaults to 0\n */\nfunction randomArray(n, a, b, seed = SEED, odds = 0) {\n    let vs = [];\n    for (let i = 0; i < n; i++) {\n        seed = predictiveRandom(seed);\n        let v = ((seed / RANGE) * (b - a)) + a;\n        seed = push(seed, vs, v, odds);\n    }\n    vs = vs.slice(0, n);\n    return { vs, seed };\n}\n/**\n * Helper function that will add more numbers to the passed array - modifies the\n * values parameter.\n * @private\n * @param seed\n * @param values - An existing array of values - will be modified!\n * @param x - The number that will be added (possibly multiple times)\n * @param odds - The odds that the number will be added again (recursively).\n */\nfunction push(seed, values, x, odds) {\n    seed = predictiveRandom(seed);\n    values.push(x);\n    if ((seed / RANGE) < odds) {\n        seed = push(seed, values, x, odds);\n    }\n    return seed;\n}\n/**\n * Generates a random polynomial with roots picked from a bounded flat\n * distribution (i.e. a rectangular distribution) with specified odds of\n * duplication of consecutive values. Note that the resulting polynomial\n * won't have any complex roots.\n * @memberof Random\n * @param d - The degree of the polynomials\n * @param a - The lower bound of the distribution - defaults\n * to 0\n * @param b - The upper bound of the distribution - defaults\n * to 1\n * @param seed - A seed value for generating random values (so\n * that the results are reproducable)\n * @param odds - The odds that a root will be doubled (applied\n * recursively so that some roots will be tripled, etc. - defaults to 0\n * @example\n * FloPoly.Random.flatRoots(3,0,10); //=> { p: [1, -17.27247918024659, 97.33487287168995, -179.34094494147305], seed: 939629312 }\n */\nfunction flatRoots(d, a = 0, b = 1, seed = SEED, odds = 0) {\n    let randArr = randomArray(d, a, b, seed, odds);\n    seed = randArr.seed;\n    let p = from_roots_1.default(randArr.vs);\n    return { p, seed };\n}\n/**\n * Generates a random polynomial with coefficients picked from a bounded\n * flat distribution (i.e. a rectangular distribution).\n * @memberof Random\n * @param d - The degree of the polynomials\n * @param a - The lower bound of the distribution - defaults to -1\n * @param b - The upper bound of the distribution - defaults to 1\n * @param seed - A seed value for generating random values (so that the results\n * are reproducable)\n * @example\n * FloPoly.Random.flatCoefficients(3,-5,5); //=> { p: [0.437291506677866, -0.5087333917617798, 2.3439210653305054], seed: 939629312 }\n */\nfunction flatCoefficients(d, a = -1, b = +1, seed = SEED) {\n    a = (a === undefined) ? -1 : a;\n    b = (b === undefined) ? +1 : b;\n    seed = (seed === undefined) ? SEED : seed;\n    let randArr = randomArray(d, a, b, seed);\n    seed = randArr.seed;\n    let p = randArr.vs;\n    return { p, seed };\n}\nlet random = {\n    flatRoots,\n    flatRootsArr,\n    flatCoefficients,\n    flatCoefficientsArr,\n};\nexports.default = random;\n\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/src/random.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/src/root-bounds.js":
/*!*******************************************************!*\
  !*** ./node_modules/flo-poly/node/src/root-bounds.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst core_operators_1 = __webpack_require__(/*! ./core-operators */ \"./node_modules/flo-poly/node/src/core-operators.js\");\nconst { invert, negate, reflectAboutYAxis } = core_operators_1.default;\n/**\n * Returns the maximum magnitude value within the supplied array of numbers.\n * @private\n */\nfunction maxAbs(ns) {\n    return Math.max(...ns.map(n => Math.abs(n)));\n}\n/**\n * Finds an upper bound on the magnitude (absolute value) of the roots\n * (including complex roots) of the given polynomial using Rouche's\n * Theorem with k = n. This function is fast but the bound is not tight.\n * @param p - The polynomial.\n */\nfunction rootMagnitudeUpperBound_rouche(p) {\n    let d = p.length - 1;\n    let R = 1 + (1 / p[0]) * maxAbs(p.slice(1));\n    return R;\n}\n/**\n * Finds an upper bound on the magnitude (absolute value) of the roots\n * of the given polynomial using the near-optimal Fujiwara bound. Note\n * that the bound includes complex roots. The bound is tight but slow\n * due to usage of Math.pow().\n * See https://en.wikipedia.org/wiki/Properties_of_polynomial_roots#cite_note-Fujiwara1916-4\n * @param p - The polynomial.\n * @example\n * FloPoly.rootMagnitudeUpperBound_fujiwara([2,-3,6,5,-130]); //=> 6.753296750770361\n * FloPoly.allRoots([2,-3,6,5,-130]); //=> [-2.397918624065303, 2.8793785310848383]\n */\nfunction rootMagnitudeUpperBound_fujiwara(p) {\n    let d = p.length - 1;\n    let an = p[0];\n    let bs = [];\n    for (let i = 1; i < d; i++) {\n        let b = Math.pow(Math.abs(p[i] / an), 1 / i);\n        bs.push(b);\n    }\n    bs.push(Math.pow(Math.abs(p[d] / 2 * an), 1 / d));\n    return 2 * Math.max.apply(undefined, bs);\n}\nconst POWERS = [\n    1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768,\n    65536, 131072, 262144, 524288, 1048576, 2097152\n];\n/**\n * <p>\n * Returns an upper bound for the positive real roots of the given\n * polynomial.\n * </p>\n * <p>\n * See algoritm 6 of the paper by Vigklas, Akritas and Strzeboński,\n * specifically the LocalMaxQuadratic algorithm hence LMQ.\n * </p>\n * @param p - The polynomial\n * @example\n * FloPoly.positiveRootUpperBound_LMQ([2,-3,6,5,-130]); //=> 4.015534272870436\n * FloPoly.positiveRootUpperBound_LMQ([2,3]);           //=> 0\n * FloPoly.positiveRootUpperBound_LMQ([-2,-3,-4]);      //=> 0\n */\nfunction positiveRootUpperBound_LMQ(p) {\n    let deg = p.length - 1;\n    if (deg < 1) {\n        return 0;\n    }\n    if (p[0] < 0) {\n        p = negate(p);\n    }\n    let timesUsed = [];\n    for (let i = 0; i < deg; i++) {\n        timesUsed.push(1);\n    }\n    let ub = 0;\n    for (let m = 0; m <= deg; m++) {\n        if (p[m] >= 0)\n            continue;\n        let tempub = Number.POSITIVE_INFINITY;\n        let any = false;\n        for (let k = 0; k < m; k++) {\n            if (p[k] <= 0) {\n                continue;\n            }\n            // Table lookup is about 70% faster but both are\n            // extemely fast anyway. \n            // Result is at https://www.measurethat.net/Benchmarks/ShowResult/6610\n            let pow = timesUsed[k];\n            let powres;\n            if (pow > 20) {\n                powres = Math.pow(2, pow);\n            }\n            else {\n                powres = POWERS[pow];\n            }\n            let temp = Math.pow(-p[m] / (p[k] / powres), 1 / (m - k));\n            timesUsed[k]++;\n            if (tempub > temp) {\n                tempub = temp;\n            }\n            any = true;\n        }\n        if (any && ub < tempub)\n            ub = tempub;\n    }\n    return ub;\n}\n/**\n * <p>\n * Calculates a lower bound for the positive roots of the given\n * polynomial.\n * </p>\n * <p>\n * See algoritm 6 of the paper by Vigklas, Akritas and Strzeboński,\n * specifically the LocalMaxQuadratic algorithm hence LMQ.\n * </p>\n * @param p - The polynomial\n * @example\n * FloPoly.positiveRootLowerBound_LMQ([2,-3,6,5,-130]); //=> 1.6883241876925903\n * FloPoly.positiveRootLowerBound_LMQ([2,3]);           //=> 0\n * FloPoly.positiveRootLowerBound_LMQ([-2,-3,-4]);      //=> 0\n */\nfunction positiveRootLowerBound_LMQ(p) {\n    let ub = positiveRootUpperBound_LMQ(invert(p));\n    if (ub === 0) {\n        return 0;\n    }\n    return 1 / ub;\n}\n/**\n * See positiveRootUpperBound_LMQ\n *\n * @param p - The polynomial\n * @returns {number} An upper bound.\n */\nfunction negativeRootUpperBound_LMQ(p) {\n    return -positiveRootLowerBound_LMQ(reflectAboutYAxis(p));\n}\n/**\n * See positiveRootLowerBound_LMQ\n *\n * @param p - The polynomial\n * @returns {number} A lower bound.\n */\nfunction negativeRootLowerBound_LMQ(p) {\n    return -positiveRootUpperBound_LMQ(reflectAboutYAxis(p));\n}\nlet rootBounds = {\n    rootMagnitudeUpperBound_fujiwara,\n    positiveRootUpperBound_LMQ,\n    positiveRootLowerBound_LMQ,\n    negativeRootUpperBound_LMQ,\n    negativeRootLowerBound_LMQ,\n    rootMagnitudeUpperBound_rouche\n};\nexports.default = rootBounds;\n\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/src/root-bounds.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/src/root-operators.js":
/*!**********************************************************!*\
  !*** ./node_modules/flo-poly/node/src/root-operators.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst core_operators_1 = __webpack_require__(/*! ./core-operators */ \"./node_modules/flo-poly/node/src/core-operators.js\");\nconst { sturmChain, evaluate, signChanges } = core_operators_1.default;\n/**\n * <p>\n * Floating-point-stably calculates and returns the ordered quadratic\n * roots of the given quadratic polynomial.\n * </p>\n * <p>\n * This function is included only because it might be slightly faster\n * than calling allRoots due to allRoots first checking if the\n * polynomial is quadratic and checking if the roots are within the\n * given range.\n * </p>\n * @param p - The 2nd order polynomial\n * @example\n * FloPoly.quadraticRoots([1, -3, 2]); //=> [1,2]\n */\nfunction quadraticRoots(p) {\n    let [a, b, c] = p;\n    let delta = b * b - 4 * a * c;\n    if (delta < 0) {\n        // No real roots;\n        return [];\n    }\n    if (delta === 0) {\n        return [-b / (2 * a)];\n    }\n    delta = Math.sqrt(delta);\n    let root1;\n    let root2;\n    if (b >= 0) {\n        root1 = (-b - delta) / (2 * a);\n        root2 = (2 * c) / (-b - delta);\n    }\n    else {\n        root1 = (2 * c) / (-b + delta);\n        root2 = (-b + delta) / (2 * a);\n    }\n    if (root1 < root2) {\n        return [root1, root2];\n    }\n    return [root2, root1];\n}\n/**\n * Calculates the roots of the given cubic polynomial.\n *\n * This code is mostly from the Pomax guide found at\n * https://pomax.github.io/bezierinfo/#extremities\n *\n * @param p - A cubic polynomial.\n */\n// TODO - This function as it currently stands is very sensitive to\n// the first coefficient if it is very small, e.g. compare:\n// cubicRoots([1e-5, 1560,-1740,96]) = [1.1903631761670113, -156000001.1153846, -0.07497859001159668] \n// vs\n// quadraticRoots([1560,-1740,96]) = [0.05821032751613551, 1.0571742878684798]\n// It is completely useless in some ranges of its input domain:\n// the part of the function 'if (discriminant < 0) {}'\n// is highly problematic for numerical stability.\n// Simply use allRoots / allRootsRecursive instead.\n/*\nfunction cubicRoots(p) {\n\r\n    function cuberoot(v) {\n        return v < 0\n            ? -Math.pow(-v, 1/3)\n            : +Math.pow(v, 1/3);\n    }\n    \r\n    let cbrt = Math.cbrt || cuberoot;\n    \r\n    let d = p[0];\n    let a = p[1] / d;\n    let b = p[2] / d;\n    let c = p[3] / d;\n    \r\n    let s  = (3*b - a*a) / 9;\n    let q  = (2*a*a*a - 9*a*b + 27*c) / 54;\n    \r\n    let s3 = s*s*s;\n    let q2 = q*q;\n    \r\n    let discriminant = q2 + s3;\n\r\n    if (!Number.isFinite(discriminant)) {\n        \r\n        // Overflow occured - in which case one root will be very large.\n        // We might want to report such large roots as positive or\n        // negative infinity but since they are rarely of interest we\n        // report only the smaller roots.\n        \r\n        // Here q*q   === (729*c^2 - 486*a*b*c + 108*a^3*c + 81*a^2*b^2 - 36*a^4*b + 4*a^6) / (729*4)\n        // and  s*s*s === (27*b^3 - 27*a^2*b^2 + 9*a^4*b - a^6) / (729*1)\n        \r\n        return quadraticRoots(p.slice(1));\n    }\n    \r\n    if (discriminant < 0) {\n        // three real roots\n        \r\n        let r = Math.sqrt(-s3);\n        let t = -q / r;\n        \r\n        let cosphi = t < -1 ? -1 : t > 1 ? 1 : t;\n        let phi    = Math.acos(cosphi);\n        let\tt1     = 2*cbrt(r);\n        \r\n        let ao3 = a/3;\n        \r\n        return [\n            t1*Math.cos((phi            )/3) - ao3,\n            t1*Math.cos((phi + 2*Math.PI)/3) - ao3,\n            t1*Math.cos((phi + 4*Math.PI)/3) - ao3\n        ]\n    } else if (discriminant === 0) {\n        // three real roots, but two of them are equal\n        \r\n        let u1 = q < 0 ? cbrt(-q) : -cbrt(q);\n        let ao3 = a/3;\n        \r\n        return [\n            2*u1 - ao3,\n            -u1 - ao3\n        ];\n    } else {\n        // one real root, two complex roots\n        \r\n        let sd = Math.sqrt(discriminant);\n        let u1 = cbrt(sd - q);\n        let v1 = cbrt(sd + q);\n        \r\n        return [u1 - v1 - a/3];\n    }\n}\n*/\n/**\n * Returns the number of real roots in the interval (a,b) of the given\n * polynomial.\n * @param p - The polynomial\n * @param a - The lower bound\n * @param b - The upper bound\n * @example\n * let p = [1, 1, -64, 236, -240];\n * FloPoly.numRootsWithin(p,-20,-11); //=> 0\n * FloPoly.numRootsWithin(p,-11,-9);  //=> 1\n * FloPoly.numRootsWithin(p,-11,3.5); //=> 3\n * FloPoly.numRootsWithin(p,-11,5);   //=> 4\n */\nfunction numRootsWithin(p, a, b) {\n    let ps = sturmChain(p);\n    let ev = evaluate(p);\n    let as = ps.map(p => evaluate(p)(a));\n    let bs = ps.map(p => evaluate(p)(b));\n    return signChanges(as) - signChanges(bs);\n}\n/**\n * <p>\n * Searches an interval (a,b) for a root (i.e. zero) of the\n * given function with respect to its first argument using the Bisection\n * Method root-finding algorithm. Any function can be supplied (it does\n * not even have to be continuous) as long as the root is bracketed.\n * </p>\n * <p>\n * Note: This function has no advantages above the Brent method except\n * for its simpler implementation and can be much slower. Use brent\n * instead.\n * </p>\n * @param f - The function for which the root is sought.\n * @param a - The lower limit of the search interval.\n * @param b - The upper limit of the search interval.\n * @example\n * let p = FloPoly.fromRoots([-10,2,3,4]);  //=> [1, 1, -64, 236, -240]\n * let f = FloPoly.evaluate(p);\n * FloPoly.bisection(f,2.2,3.8); //=> 3\n * FloPoly.bisection(f,2.2,3.1); //=> 3.0000000000000044\n */\nfunction bisection(f, a, b) {\n    if (a === b) {\n        // Presumably the root is already found.\n        return a;\n    }\n    else if (b < a) {\n        [a, b] = [b, a]; // Swap a and b \n    }\n    let fa = f(a);\n    let fb = f(b);\n    if (fa === 0) {\n        return a;\n    }\n    if (fb === 0) {\n        return b;\n    }\n    if (fa * fb > 0) {\n        // Root is not bracketed - this is a precondition.\n        throw new Error('Root not bracketed');\n    }\n    while (true) {\n        let c = a + (b - a) / 2; // Take midpoint\n        let fc = f(c);\n        if (fc === 0) {\n            return c;\n        }\n        if (fa * fc < 0) {\n            b = c;\n        }\n        else {\n            a = c;\n        }\n        // We don't add Number.EPSILON in the line below because we want\n        // accuracy to improve even below 1.\n        let δ = 2 * Number.EPSILON * Math.abs(b) /*+ Number.EPSILON*/;\n        if (Math.abs(a - b) <= δ) {\n            return b;\n        }\n    }\n}\n/**\n * <p>\n * Searches an interval (a,b) for a root (i.e. zero) of the\n * given function with respect to its first argument using the Brent's\n * Method root-finding algorithm. Any function can be supplied (it does\n * not even have to be continuous) as long as the root is bracketed.\n * </p>\n * <p>\n * Brent's Method is an excellent root-finding choice since it is\n * (1) guaranteed to converge (unlike the Newton and other so-called\n * single-point methods), (2) converges in a reasonable number of\n * iterations even for highly contrived functions (unlike Dekker's\n * Method) and (3) nearly always converges extremely fast, i.e. super-\n * linearly (unlike the Secant and Regula-Falsi methods).\n * </p>\n * <p>\n * The max error, δ, is set equal to 2*Number.EPSILON*Math.abs(b)\n * after each iteration where b is the max of the current 2 best\n * guesses.\n * </p>\n * <p>\n * See <a href=\"https://en.wikipedia.org/wiki/Brent%27s_method\">Wikipedia</a>\n * </p>\n * <p>\n * See <a href=\"https://maths-people.anu.edu.au/~brent/pd/rpb011i.pdf\">Brent (page 47)</a>\n * </p>\n * @param f - The function for which the root is sought.\n * @param a - The lower limit of the search interval.\n * @param b - The upper limit of the search interval.\n * about 1e-15 multiplied by the root magnitued).\n * @example\n * let p = FloPoly.fromRoots([-10,2,3,4]);  //=> [1, 1, -64, 236, -240]\n * let f = FloPoly.evaluate(p);\n * FloPoly.brent(f,2.2,3.8); //=> 3.000000000000003\n * FloPoly.brent(f,2.2,3.1); //=> 3.000000000000001\n */\nfunction brent(f, a, b) {\n    if (a === b) {\n        // Presumably the root is already found.\n        return a;\n    }\n    // We assume on the first iteration f(a) !== 0 && f(b) !== 0. \n    let fa = f(a);\n    let fb = f(b);\n    if (fa * fb > 0) {\n        // Root is not bracketed - this is a precondition.\n        throw new Error('Root not bracketed');\n    }\n    let c; // Value of previous guess - set to a initially \n    if (Math.abs(fa) < Math.abs(fb)) {\n        // Swap a,b\n        c = a;\n        a = b;\n        b = c;\n        // Swap fa,fb\n        let temp = fa;\n        fa = fb;\n        fb = temp;\n    }\n    c = a;\n    let mflag = true;\n    let d; // Value of guess before previous guess\n    while (true) {\n        let δ = 2 * Number.EPSILON * Math.abs(b); // + Number.EPSILON;\n        let fc = f(c);\n        // Calculate provisional interpolation value\n        let s;\n        if (fa !== fc && fb !== fc) {\n            // 3 points available - inverse quadratic interpolation\n            let fac = fa - fc;\n            let fab = fa - fb;\n            let fbc = fb - fc;\n            // The below has been multiplied out to speed up the algorithm.\n            /*s = ((a * fb * fc) / ( fab * fac)) +\n                  ((b * fa * fc) / (-fab * fbc)) +\n                  ((c * fa * fb) / ( fac * fbc));*/\n            s = ((a * fb * fbc - b * fa * fac) * fc + c * fa * fab * fb) / (fab * fac * fbc);\n        }\n        else {\n            // only 2 points available - secant method\n            s = b - (fb * ((b - a) / (fb - fa)));\n        }\n        let t1 = (3 * a + b) / 4;\n        let b_c = Math.abs(b - c);\n        let s_b = Math.abs(s - b);\n        let c_d = Math.abs(c - d);\n        if ((!((s > t1 && s < b) ||\n            (s < t1 && s > b))) ||\n            (mflag && (\n            // condition 2\n            (s_b >= b_c / 2) ||\n                // condition 4\n                (b_c < δ))) ||\n            (!mflag && (\n            // condition 3\n            (s_b >= c_d / 2) ||\n                // condition 5\n                (c_d < δ)))) {\n            // Bisection\n            s = (a + b) / 2;\n            mflag = true;\n        }\n        else {\n            mflag = false;\n        }\n        let fs = f(s);\n        d = c;\n        c = b;\n        if (fa * fs < 0) {\n            b = s;\n        }\n        else {\n            a = s;\n        }\n        if (Math.abs(fa) < Math.abs(fb)) {\n            // Swap a,b\n            let temp = a;\n            a = b;\n            b = temp;\n        }\n        if (fb === 0) {\n            return b;\n        }\n        if (fs === 0) {\n            return s;\n        }\n        if (Math.abs(a - b) <= δ) {\n            return b;\n        }\n        fa = f(a);\n        fb = f(b);\n    }\n}\nlet rootOperators = {\n    quadraticRoots,\n    numRootsWithin,\n    brent,\n    bisection,\n};\nexports.default = rootOperators;\n\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/src/root-operators.js?");

/***/ }),

/***/ "./node_modules/flo-vector2d/node/index.js":
/*!*************************************************!*\
  !*** ./node_modules/flo-vector2d/node/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst DELTA = 1e-10;\n/**\n * Curry the given arity two function.\n * @param f - A function\n */\nfunction curry2(f) {\n    function g(t, u) {\n        return u === undefined\n            ? (u) => f(t, u)\n            : f(t, u);\n    }\n    return g;\n}\n/**\n* Creates a transformation function that operates on multiple points from the\n* given arity two function.\n* @private\n*/\nfunction mapCurry2(f) {\n    function g(t, us) {\n        let h = f(t);\n        let hUs = (us) => us.map(h);\n        // Curry the function\n        return us === undefined ? hUs : hUs(us);\n    }\n    return g;\n}\n/**\n* Creates a transformation function that operates on multiple points from the\n* given arity 3 curried function (keeping the first two parameters uncurried).\n* @private\n*/\nfunction specialMapCurry(f) {\n    function g(s, t, us) {\n        let h = f(s, t);\n        let hUs = (us) => us.map(h);\n        // Curry the function\n        return us === undefined ? hUs : hUs(us);\n    }\n    return g;\n}\n/**\n * Returns the dot (inner) product between two 2-vectors.\n * @param a - The first vector\n * @param b - The second vector\n */\nfunction dot(a, b) {\n    return a[0] * b[0] + a[1] * b[1];\n}\nexports.dot = dot;\n/**\n * Returns the cross product signed magnitude between two 2-vectors.\n * @param a - The first vector\n * @param b - The second vector\n */\nfunction cross(a, b) {\n    return a[0] * b[1] - a[1] * b[0];\n}\nexports.cross = cross;\n/**\n * Three 2d points are a counter-clockwise turn if ccw > 0, clockwise if\n * ccw < 0, and colinear if ccw = 0 because ccw is a determinant that gives\n * twice the signed area of the triangle formed by p1, p2 and p3.\n * @param p1 - The first point\n * @param p2 - The second point\n * @param p3 - The third point\n * @param delta - The tolerance at which the three points are considered\n * collinear - defaults to 1e-10.\n */\nfunction ccw(p1, p2, p3, delta = DELTA) {\n    let res = (p2[0] - p1[0]) * (p3[1] - p1[1]) -\n        (p2[1] - p1[1]) * (p3[0] - p1[0]);\n    return Math.abs(res) <= delta ? 0 : res;\n}\nexports.ccw = ccw;\n/**\n* <p>\n* Returns the point where two line segments intersect or undefined if they\n* don't intersect or a line if they intersect at infinitely many points.\n* </p>\n* <p>\n* See <a href=\"http://algs4.cs.princeton.edu/91primitives\">Geometric primitves</a>\n* </p>\n* @param ab - The first line\n* @param cd - The second line\n* @param delta - The tolerance at which the lines are considered parallel -\n* defaults to 1e-10.\n*/\nfunction segSegIntersection(ab, cd, delta = DELTA) {\n    let [a, b] = ab;\n    let [c, d] = cd;\n    let denom = (b[0] - a[0]) * (d[1] - c[1]) - (b[1] - a[1]) * (d[0] - c[0]);\n    let rNumer = (a[1] - c[1]) * (d[0] - c[0]) - (a[0] - c[0]) * (d[1] - c[1]);\n    let sNumer = (a[1] - c[1]) * (b[0] - a[0]) - (a[0] - c[0]) * (b[1] - a[1]);\n    if (Math.abs(denom) <= delta) {\n        // parallel\n        if (Math.abs(rNumer) <= delta) {\n            // colinear\n            // TODO Check if x-projections and y-projections intersect\n            // and return the line of intersection if they do.\n            return undefined;\n        }\n        return undefined;\n    }\n    let r = rNumer / denom;\n    let s = sNumer / denom;\n    if (0 <= r && r <= 1 && 0 <= s && s <= 1) {\n        return [a[0] + r * (b[0] - a[0]), a[1] + r * (b[1] - a[1])];\n    }\n    return undefined;\n}\nexports.segSegIntersection = segSegIntersection;\n/**\n* Returns true if the two given 2d line segments intersect, false otherwise.\n* @param a - A line segment\n* @param b - Another line segment\n*/\nfunction doesSegSegIntersect(a, b) {\n    if ((ccw(a[0], a[1], b[0]) * ccw(a[0], a[1], b[1])) > 0) {\n        return false;\n    }\n    else if ((ccw(b[0], b[1], a[0]) * ccw(b[0], b[1], a[1])) > 0) {\n        return false;\n    }\n    return true;\n}\nexports.doesSegSegIntersect = doesSegSegIntersect;\n/**\n* Returns the squared distance between two 2d points.\n* @param p1 - A point\n* @param p2 - Another point\n*/\nfunction squaredDistanceBetween(p1, p2) {\n    let x = p2[0] - p1[0];\n    let y = p2[1] - p1[1];\n    return x * x + y * y;\n}\nexports.squaredDistanceBetween = squaredDistanceBetween;\n/**\n* Returns a scaled version of the given 2-vector.\n* @param p - A vector\n* @param factor - A scale factor\n*/\nfunction scale(p, factor) {\n    return [p[0] * factor, p[1] * factor];\n}\nexports.scale = scale;\n/**\n* Returns the given 2-vector reversed.\n* @param p - A vector\n*/\nfunction reverse(p) {\n    return [-p[0], -p[1]];\n}\nexports.reverse = reverse;\n/**\n* Returns the given 2-vector scaled to a length of one.\n* @param p - A vector\n*/\nfunction toUnitVector(p) {\n    let scaleFactor = 1 / len(p);\n    return [p[0] * scaleFactor, p[1] * scaleFactor];\n}\nexports.toUnitVector = toUnitVector;\n/**\n* Returns the given 2-vector scaled to the given length.\n* @param p - A vector\n* @param length - The length to scale to\n*/\nfunction toLength(p, length) {\n    let scaleFactor = length / len(p);\n    return [p[0] * scaleFactor, p[1] * scaleFactor];\n}\nexports.toLength = toLength;\n/**\n* Returns the second 2-vector minus the first.\n* @param p1 - The first vector\n* @param p2 - The second vector\n*/\nfunction fromTo(p1, p2) {\n    return [p2[0] - p1[0], p2[1] - p1[1]];\n}\nexports.fromTo = fromTo;\n/**\n* Performs linear interpolation between two 2d points and returns the resultant point.\n* @param p1 - The first point.\n* @param p2 - The second point.\n* @param t - The interpolation fraction (often in [0,1]).\n*/\nfunction interpolate(p1, p2, t) {\n    return [\n        p1[0] + (p2[0] - p1[0]) * t,\n        p1[1] + (p2[1] - p1[1]) * t\n    ];\n}\nexports.interpolate = interpolate;\n/**\n* Returns the mean of two 2d points.\n* @param ps - The two points\n*/\nfunction mean(ps) {\n    let p1 = ps[0];\n    let p2 = ps[1];\n    return [(p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2];\n}\nexports.mean = mean;\n/**\n* Returns the distance between two 2d points.\n* @param p1 - A point.\n* @param p2 - Another point.\n*/\nfunction distanceBetween(p1, p2) {\n    return Math.sqrt(squaredDistanceBetween(p1, p2));\n}\nexports.distanceBetween = distanceBetween;\n/**\n* Returns the length of the given 2-vector.\n* @param p - A vector\n*/\nfunction len(p) {\n    return Math.sqrt((p[0] * p[0]) + (p[1] * p[1]));\n}\nexports.len = len;\n/**\n* Returns the squared length of the given 2-vector.\n* @param p - A vector\n*/\nfunction lengthSquared(v) {\n    return v[0] * v[0] + v[1] * v[1];\n}\nexports.lengthSquared = lengthSquared;\n/**\n* Returns the Manhattan distance between two 2d points.\n* @param p1 - A point.\n* @param p2 - Another point.\n*/\nfunction manhattanDistanceBetween(p1, p2) {\n    return Math.abs(p1[0] - p2[0]) + Math.abs(p1[1] - p2[1]);\n}\nexports.manhattanDistanceBetween = manhattanDistanceBetween;\n/**\n* Returns the Manhattan length of the given 2-vector.\n* @param p - A vector\n*/\nfunction manhattanLength(p) {\n    return Math.abs(p[0]) + Math.abs(p[1]);\n}\nexports.manhattanLength = manhattanLength;\n/**\n* <p>\n* Returns the distance between the given point and line.\n* </p>\n* <p>\n* See <a href=\"https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Line_defined_by_two_points\">\n* this Wikipedia article</a>\n* </p>\n* @param p - A point\n* @param l - A line\n*/\nfunction distanceBetweenPointAndLine(p, l) {\n    let [x0, y0] = p;\n    let [[x1, y1], [x2, y2]] = l;\n    let y = y2 - y1;\n    let x = x2 - x1;\n    let a = (y * x0 - x * y0 + x2 * y1 - y2 * x1);\n    let b = Math.sqrt(x * x + y * y);\n    return Math.abs(a / b);\n}\nexports.distanceBetweenPointAndLine = distanceBetweenPointAndLine;\n/**\n* Returns the squared distance between the given point and line segment.\n* @param p - A point\n* @param l - A line\n*/\nfunction squaredDistanceBetweenPointAndLineSegment(p, l) {\n    const sqDst = squaredDistanceBetween;\n    let v = l[0];\n    let w = l[1];\n    let l2 = sqDst(v, w);\n    if (l2 == 0) {\n        return sqDst(p, v);\n    }\n    let t = ((p[0] - v[0]) * (w[0] - v[0]) + (p[1] - v[1]) * (w[1] - v[1])) / l2;\n    t = Math.max(0, Math.min(1, t));\n    let d2 = sqDst(p, [v[0] + t * (w[0] - v[0]), v[1] + t * (w[1] - v[1])]);\n    return d2;\n}\nexports.squaredDistanceBetweenPointAndLineSegment = squaredDistanceBetweenPointAndLineSegment;\n/**\n* Returns the circumcenter of the given 2d triangle.\n* @param triangle\n*/\nfunction circumCenter(triangle) {\n    // See wikipedia\n    let p1 = triangle[0];\n    let p2 = triangle[1];\n    let p3 = triangle[2];\n    const sqLen = lengthSquared;\n    let Sx = 0.5 * det3([sqLen(p1), p1[1], 1], [sqLen(p2), p2[1], 1], [sqLen(p3), p3[1], 1]);\n    let Sy = 0.5 * det3([p1[0], sqLen(p1), 1], [p2[0], sqLen(p2), 1], [p3[0], sqLen(p3), 1]);\n    let a = det3([p1[0], p1[1], 1], [p2[0], p2[1], 1], [p3[0], p3[1], 1]);\n    let b = det3([p1[0], p1[1], sqLen(p1)], [p2[0], p2[1], sqLen(p2)], [p3[0], p3[1], sqLen(p3)]);\n    return [Sx / a, Sy / a];\n}\nexports.circumCenter = circumCenter;\n/**\n* <p>\n* Returns the incenter of the given triangle.\n* </p>\n* <p>\n* See Wikipedia - https://en.wikipedia.org/wiki/Incenter\n* </p>\n* @param triangle\n*/\nfunction inCenter(triangle) {\n    const dst = distanceBetween;\n    let p1 = triangle[0];\n    let p2 = triangle[1];\n    let p3 = triangle[2];\n    let l1 = dst(p2, p3);\n    let l2 = dst(p1, p3);\n    let l3 = dst(p1, p2);\n    let lengthSum = l1 + l2 + l3;\n    return [\n        (l1 * p1[0] + l2 * p2[0] + l3 * p3[0]) / lengthSum,\n        (l1 * p1[1] + l2 * p2[1] + l3 * p3[1]) / lengthSum\n    ];\n}\nexports.inCenter = inCenter;\n/**\n* Returns the centroid of the given polygon, e.g. triangle. The polygon\n* must be simple, i.e. not self-intersecting.\n* @param polygon\n*/\nfunction centroid(polygon) {\n    if (polygon.length === 3) {\n        let p1 = polygon[0];\n        let p2 = polygon[1];\n        let p3 = polygon[2];\n        let x = p1[0] + p2[0] + p3[0];\n        let y = p1[1] + p2[1] + p3[1];\n        return [x / 3, y / 3];\n    }\n    // polygon.length assumed > 3 and assumed to be non-self-intersecting\n    // See wikipedia\n    // First calculate the area, A, of the polygon\n    let A = 0;\n    for (let i = 0; i < polygon.length; i++) {\n        let p0 = polygon[i];\n        let p1 = (i === polygon.length - 1)\n            ? polygon[0]\n            : polygon[i + 1];\n        A = A + (p0[0] * p1[1] - p1[0] * p0[1]);\n    }\n    A = A / 2;\n    let C = [0, 0];\n    for (let i = 0; i < polygon.length; i++) {\n        let p0 = polygon[i];\n        let p1 = (i === polygon.length - 1)\n            ? polygon[0]\n            : polygon[i + 1];\n        C[0] = C[0] + (p0[0] + p1[0]) * (p0[0] * p1[1] - p1[0] * p0[1]);\n        C[1] = C[1] + (p0[1] + p1[1]) * (p0[0] * p1[1] - p1[0] * p0[1]);\n    }\n    return [C[0] / (6 * A), C[1] / (6 * A)];\n}\nexports.centroid = centroid;\n/**\n* Calculate the determinant of three 3d vectors, i.e. 3x3 matrix\n* @ignore\n* @param x - A 2d vector\n* @param y - Another 2d vector\n* @param z - Another 2d vector\n*/\nfunction det3(x, y, z) {\n    return (x[0] * (y[1] * z[2] - y[2] * z[1])) -\n        (x[1] * (y[0] * z[2] - y[2] * z[0])) +\n        (x[2] * (y[0] * z[1] - y[1] * z[0]));\n}\nexports.det3 = det3;\nfunction translate(a, b) {\n    function f(b) {\n        return [a[0] + b[0], a[1] + b[1]];\n    }\n    // Curry the function\n    return b === undefined ? f : f(b);\n}\nexports.translate = translate;\n/**\n* Return the given 2d points translated by the given 2d vector. This\n* function is curried.\n* @param v\n* @param ps\n*/\nlet translatePs = mapCurry2(translate);\nexports.translatePs = translatePs;\n/**\n* Return the given 2d points translated by the given 2d vector. This function\n* is curried.\n* @param sinθ\n* @param cosθ\n* @param ps\n*/\nlet rotatePs = specialMapCurry(rotate);\nexports.rotatePs = rotatePs;\nfunction rotate(sinθ, cosθ, p) {\n    let a = translatePs([1, 2]);\n    function rotateByθ(p) {\n        return [\n            p[0] * cosθ - p[1] * sinθ,\n            p[0] * sinθ + p[1] * cosθ\n        ];\n    }\n    // Curry the function\n    return p === undefined ? rotateByθ : rotateByθ(p);\n}\nexports.rotate = rotate;\n/**\n* Returns true if two 2-vectors are identical (by value), false otherwise.\n* @param a - A 2d vector\n* @param b - Another 2d vector\n*/\nfunction equal(a, b) {\n    return (a[0] === b[0] && a[1] === b[1]);\n}\nexports.equal = equal;\n/**\n* Returns a anti-clockwise rotated version of the given 2-vector given the\n* sine and cosine of the angle.\n* @param p - A 2d vector\n* @param sinθ\n* @param cosθ\n*/\nfunction reverseRotate(sinθ, cosθ, p) {\n    return [\n        +p[0] * cosθ + p[1] * sinθ,\n        -p[0] * sinθ + p[1] * cosθ\n    ];\n}\nexports.reverseRotate = reverseRotate;\n/**\n* Returns a 90 degrees rotated version of the given 2-vector.\n* @param p - A 2d vector\n*/\nfunction rotate90Degrees(p) {\n    return [-p[1], p[0]];\n}\nexports.rotate90Degrees = rotate90Degrees;\n/**\n* Returns a negative 90 degrees rotated version of the given 2-vector.\n* @param p - A 2d vector\n*/\nfunction rotateNeg90Degrees(p) {\n    return [p[1], -p[0]];\n}\nexports.rotateNeg90Degrees = rotateNeg90Degrees;\n/**\n* Transforms the given 2-vector by applying the given function to each\n* coordinate.\n* @param p - A 2d vector\n* @param f - A transformation function\n*/\nfunction transform(p, f) {\n    return [f(p[0]), f(p[1])];\n}\nexports.transform = transform;\n/**\n* Returns the closest point to the array of 2d points, optionally providing\n* a distance function.\n* @param p\n* @param ps\n* @param f - Optional distance function - defaults to\n* squaredDistanceBetween.\n*/\nfunction getClosestTo(p, ps) {\n    let closestPoint = undefined;\n    let closestDistance = Number.POSITIVE_INFINITY;\n    for (let i = 0; i < ps.length; i++) {\n        let q = ps[i];\n        let d = squaredDistanceBetween(p, q);\n        if (d < closestDistance) {\n            closestPoint = q;\n            closestDistance = d;\n        }\n    }\n    return closestPoint;\n}\nexports.getClosestTo = getClosestTo;\n/**\n* Returns the closest point to the array of 2d points, optionally providing\n* a distance function.\n* @param p\n* @param ps\n* @param f - Optional distance function - defaults to\n* squaredDistanceBetween.\n*/\nfunction getObjClosestTo(p, ps, f) {\n    let closestObj = undefined; // Closest Point\n    let closestDistance = Number.POSITIVE_INFINITY;\n    for (let i = 0; i < ps.length; i++) {\n        let o = ps[i];\n        let d = squaredDistanceBetween(p, f(o));\n        if (d < closestDistance) {\n            closestObj = o;\n            closestDistance = d;\n        }\n    }\n    return closestObj;\n}\nexports.getObjClosestTo = getObjClosestTo;\n/**\n* Returns an array of points by applying a translation and then rotation to\n* the given points.\n* @param v - The translation vector\n* @param sinθ\n* @param cosθ\n* @param ps - The input points\n**/\nfunction translateThenRotatePs(v, sinθ, cosθ, ps) {\n    const f = translate(v);\n    return ps.map(p => rotate(sinθ, cosθ, f(p)));\n}\nexports.translateThenRotatePs = translateThenRotatePs;\n/**\n* Returns an array of points by applying a rotation and then translation to\n* the given points.\n* @param sinθ\n* @param cosθ\n* @param v - The translation vector\n* @param ps - The input points\n**/\nfunction rotateThenTranslatePs(sinθ, cosθ, v, ps) {\n    return ps.map(p => translate(v, rotate(sinθ, cosθ, p)));\n}\nexports.rotateThenTranslatePs = rotateThenTranslatePs;\n;\n//export  Vector2d;\n\n\n//# sourceURL=webpack:///./node_modules/flo-vector2d/node/index.js?");

/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target, parent) {\n  if (parent){\n    return parent.querySelector(target);\n  }\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target, parent) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target, parent);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(/*! ./urls */ \"./node_modules/style-loader/lib/urls.js\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertAt.before, target);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\tif(options.attrs.nonce === undefined) {\n\t\tvar nonce = getNonce();\n\t\tif (nonce) {\n\t\t\toptions.attrs.nonce = nonce;\n\t\t}\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction getNonce() {\n\tif (false) {}\n\n\treturn __webpack_require__.nc;\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = typeof options.transform === 'function'\n\t\t ? options.transform(obj.css) \n\t\t : options.transform.default(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n\n\n//# sourceURL=webpack:///./node_modules/style-loader/lib/addStyles.js?");

/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n\n\n//# sourceURL=webpack:///./node_modules/style-loader/lib/urls.js?");

/***/ }),

/***/ "./style.css":
/*!*******************!*\
  !*** ./style.css ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !./node_modules/css-loader!./style.css */ \"./node_modules/css-loader/index.js!./style.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ./node_modules/style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}\n\n//# sourceURL=webpack:///./style.css?");

/***/ })

/******/ });